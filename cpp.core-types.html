<!DOCTYPE html>
<html>
  <head>
    <title>C++ Core Types</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="C++ Core Types: Integers, Characters, Floats..."/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel="prev" href="cpp.html">The C++ Programming Language</a></p>
        <p><a href="cpp.RTTI.html">Run-Time Type Information (RTTI) in C++</a></p>
        <p><a href="cpp.type-aliases.html">Type Aliases in C++</a></p>
        <p><a href="cpp.type_traits.html">Handling Type with <code>&lt;type_traits&gt;</code></a></p>
        <p><a href="cpp.casts.html">C++ Casts</a></p>
        <p><a href="byte-order.html#cpp">Handling Byte Order in C++</a></p>
      </div>
      <div>
        <p><a href="cpp.functions.html">Functions in C++</a></p>
        <p><a href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a href="cpp.constexpr-and-consteval.html"><code>constexpr</code> and <code>consteval</code></a></p>
      </div>
      <div>
        <p><a href="cpp.linking-c-object-files-in.html">Linking C++ and C Object Files Together</a></p>
        <p><a href="c-and-cpp.html">C and C++</a></p>
      </div>
    </nav>

    <main>
      <h1>C++ Core Types</h1>

      <section id="void">
        <h2><code>void</code></h2>
        <p><strong>void</strong>: type with an empty set of values. It is an incomplete type that cannot be completed (consequently, objects of type void are disallowed). There are no arrays of void, nor references to void. However, pointers to void and functions returning type void (procedures in other languages) are permitted.</p>
      </section>
      <section id="nullptr_t">
        <h2><code>std::nullptr_t</code></h2>
        <p>(Defined in header <code>&lt;cstddef&gt;</code>)</p>
        <blockquote>
          <pre>typedef decltype(nullptr) nullptr_t;</pre>
          <p>(since C++11)</p>
        </blockquote>
        <p><code>std::nullptr_t</code> is the type of the null pointer literal, <code>nullptr</code>. It is a distinct type that is not itself a pointer type or a pointer to member type. All Its prvalues are null pointer constants.</p>
        <blockquote><code>sizeof(std::nullptr_t)</code> is equal to <code>sizeof(void*)</code>.</blockquote>
      </section>

      <section id="int">
        <h2>C++ Built-in Integer Types</h2>
        <section>
          <h3>Standard integer types</h3>
          <p><strong>int</strong>: basic integer type. The keyword <code>int</code> may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it&apos;s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (<i>see below</i>).</p>
        </section>
        <section>
          <h3>Modifiers</h3>
          <p>They modify the basic integer type. Can be mixed in any order. Only one of each group can be present in type name.</p>
          <dl>
            <dt>Signedness:</dt>
            <dd>
              <p><strong>signed</strong>: target type will have signed representation (this is the default if omitted)</p>
              <p><strong>unsigned</strong>: target type will have unsigned representation</p>
            </dd>
            <dt>Size:</dt>
            <dd>
              <p><strong>short</strong>: target type will be optimized for space and will have width of at least 16 bits.</p>
              <p><strong>long</strong>: target type will have width of at least 32 bits.</p>
              <p><strong>long long</strong>: (since C++11) target type will have width of at least 64 bits.</p>
            </dd>
          </dl>
          <p><strong>Note:</strong> as with all type specifiers, any order is permitted: unsigned long long int and long int unsigned long name the same type.</p>
          <p><strong>std::size_t</strong> is the unsigned integer type of the result of the sizeof operator as well as the sizeof... operator and the alignof operator(since C++11).</p>
        </section>
        <section>
          <h3> Extended integer types</h3>
          <p>The extended integer types are implementation-defined. Note that fixed width integer types are typically aliases of the standard integer types.</p>
          <p>(<i>See</i> <code><a terget="_blank" href="https://en.cppreference.com/w/cpp/types/integer.html">https://en.cppreference.com/w/cpp/types/integer.html</a></code>)</p>
        </section>
      </section>

      <section id="bool">
        <h2>Boolean Type</h2>
        <p><strong>bool</strong>: integer type, capable of holding one of the two values: true or false. The value of sizeof(bool) is implementation defined and might differ from 1.</p>
      </section>

      <section id="char">
        <h2>C++ Built-in Character Types</h2>
        <p>Character types are integer types used for a character representation.</p>
        <ul>
          <li><strong>signed char</strong>: type for signed character representation. </li>
          <li><strong>unsigned char</strong>: type for unsigned character representation. Also used to inspect object representations (raw memory).</li>
          <li><strong>char</strong>: type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either signed char or unsigned char, but is always a distinct type). Multibyte characters strings use this type to represent code units. For every value of type unsigned char in range [​0​, 255], converting the value to char and then back to unsigned char produces the original value.(since C++11) The signedness of char depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed.</li>
          <li><strong>wchar_t</strong>: type for wide character representation (<i>see</i> wide strings). It has the same size, signedness, and alignment as one of the integer types, but is a distinct type. In practice, it is 32 bits and holds UTF-32 on Linux and many other non-Windows systems, but 16 bits and holds UTF-16 code units on Windows. The standard used to require wchar_t to be large enough to represent any supported character code point. However, such requirement cannot be fulfilled on Windows, and thus it is considered as a defect and removed.</li>
        </ul>
        <p>Types added in C++11:</p>
        <ul>
          <li><strong>char16_t</strong>: type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as std::uint_least16_t, but is a distinct type.</li>
          <li><strong>char32_t</strong>: type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as std::uint_least32_t, but is a distinct type.</li>
        </ul>
        <p>Type added in C++20:</p>
        <ul>
          <li><strong>char8_t</strong> type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as unsigned char (and therefore, the same size and alignment as char and signed char), but is a distinct type.</li>
        </ul>
        <hr/>
        <p>Besides the minimal bit counts, the C++ Standard guarantees that</p>
        <blockquote>1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long).</blockquote>
        <p><strong>Note</strong>: this allows the extreme case in which bytes are sized 64 bits, all types (including char) are 64 bits wide, and sizeof returns 1 for every type.</p>
      </section>

      <section id="float">
        <h2>C++ Built-in Floating Point Types</h2>
        <section>
          <h3>Standard floating-point types</h3>
          <p>The following three types and their cv-qualified versions are collectively called standard floating-point types.</p>
          <ul>
            <li><strong>float</strong>: single precision floating-point type. Usually IEEE-754 binary32 format.</li>
            <li><strong>double</strong>: double precision floating-point type. Usually IEEE-754 binary64 format.</li>
            <li><strong>long double</strong>: extended precision floating-point type. Does not necessarily map to types mandated by IEEE-754.</li>
          </ul>
        </section>
        <section>
          <h3> Extended floating-point types</h3>
          <p>The extended floating-point types are implementation-defined. They may include fixed width floating-point types.</p>
        </section>
      </section>

      <section>
        <h2>Removing Constantness, Reference-ness, Pointer-ness from Types</h2>
        <p>Constantness, Reference-ness, Pointer-ness can be removed from a type through:</p>
        <ul>
          <li><code>std::remove_const</code></li>
          <li><code><a href="#remove_reference">std::remove_reference</a></code></li>
          <li><code>std::remove_pointer</code>: obtains the type pointed by <var>T</var> (if <var>T</var> is a pointer)</li>
          <li><code><a href="#decay">std::decay</a></code></li>
        </ul>
        <p>The stripped type is available as a member alias named <code>value</code>.</p>
        <p>For each of these struct&apos;s there is a reverse one that adds a feature instead of removing it.</p>
        <ul>
          <li><code>add_const</code></li>
          <li><code>add_pointer</code></li>
          <li><code>add_lvalue_reference</code></li>
          <li><code>add_rvalue_reference</code></li>
          <li><code>add_volatile</code></li>
          <li><code>add_cv</code>: obtains the type T with both const and volatile qualification</li>
        </ul>
        <section id="remove_reference">
          <h3>Removing Reference-ness with <code>std::remove_reference</code></h3>
          <p>Obtains the non-reference type to which <var>T</var> refers. The transformed type is aliased as member type <code>remove_reference::type</code>.</p>
          <p>If <var>T</var> is a reference type (either lvalue reference or rvalue reference), this is the type to which it refers. Otherwise, it is the same as <var>T</var>, unchanged.</p>
          <p>Notice that this class merely obtains a type using another type as model, but it does not transform values or objects between those types.</p>
          <hr/>
          <p>An example:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main() {
  typedef int&amp;&amp; rval_int;
  typedef std::remove_reference&lt;int&gt;::type A;
  typedef std::remove_reference&lt;int&amp;&gt;::type B;
  typedef std::remove_reference&lt;int&amp;&amp;&gt;::type C;
  typedef std::remove_reference&lt;rval_int&gt;::type D;

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "typedefs of int:" &lt;&lt; std::endl;
  std::cout &lt;&lt; "A: " &lt;&lt; std::is_same&lt;int,A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "B: " &lt;&lt; std::is_same&lt;int,B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "C: " &lt;&lt; std::is_same&lt;int,C&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "D: " &lt;&lt; std::is_same&lt;int,D&gt;::value &lt;&lt; std::endl;

  return 0;
}</pre>
          <p>Its output:</p>
          <pre>typedefs of int:
A: true
B: true
C: true
D: true</pre>

        </section>
        <section id="decay">
          <h3>Decay Types and <code>std::decay</code> in <cite>&lt;type_traits&gt;</cite></h3>
          <p>Struct <code>decay</code>:</p>
          <pre>template &lt;class T&gt;
struct decay;</pre>
          <p>is used to obtain the decay type of <var>T</var>, which is aliased as member type <code>decay::type</code>.</p>
          <p>The decay type of <var>T</var> is the same type that results from the standard conversions that happen when an lvalue expression is used as an rvalue, with its cv-qualifier stripped. This resembles the implicit conversions happening when an argument is passed by value to a function.</p>

          <p>Put more simply, if <var>T</var> is a reference type (say <code>const int&amp;</code>), then member <code>value</code> is the type referred to by <var>T</var> with its const-ness removed (<code>int</code> in this case).</p>

          <p>Cases:</p>
          <ul>
            <li>If <var>T</var> is a function type, a function-to-pointer conversion is applied and the decay type is the same as: <code>add_pointer&lt;T&gt;::type</code></li>
            <li>If <var>T</var> is an array type, an array-to-pointer conversion is applied and the decay type is the same as: <code>add_pointer&lt;remove_extent&lt;remove_reference&lt;T&gt;::type&gt;::type&gt;::type</code>. (This very much resembles <a target="_blank" href="c.decay.html">C decay</a>)</li>
            <li>Otherwise, a regular lvalue-to-rvalue conversion is applied and the decay type is the same as: <code>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</code>.</li>
          </ul>

          <p>Notice that this class merely obtains a type using another type as model, but it does not transform values or objects between those types.</p>

          <p>An example:</p>
          <pre>#include &lt;type_traits&gt;

typedef std::decay&lt;int&gt;::type A;           // int
typedef std::decay&lt;int&amp;&gt;::type B;          // int
typedef std::decay&lt;int&amp;&amp;&gt;::type C;         // int
typedef std::decay&lt;const int&amp;&gt;::type D;    // int
typedef std::decay&lt;int[2]&gt;::type E;        // int*
typedef std::decay&lt;int(int)&gt;::type F;      // int(*)(int)

typedef int X[3];</pre>
          <p>These typedef&apos;s could be tested with:</p>
          <pre>#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "typedefs of int:" &lt;&lt; std::endl;
  std::cout &lt;&lt; "A: " &lt;&lt; std::is_same&lt;int,A&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "B: " &lt;&lt; std::is_same&lt;int,B&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "C: " &lt;&lt; std::is_same&lt;int,C&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "D: " &lt;&lt; std::is_same&lt;int,D&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "E: " &lt;&lt; std::is_same&lt;int,E&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; "F: " &lt;&lt; std::is_same&lt;int,F&gt;::value &lt;&lt; std::endl;

  return 0;
}</pre>
          <p>Output:</p>
          <pre>typedefs of int:
A: true
B: true
C: true
D: true
E: false
F: false</pre>
        </section>
      </section>

    </main>

  </body>

</html>
