<!DOCTYPE html>
<html>
  <head>
    <title>C++ Core Types</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="C++ Core Types: Integers, Characters, Floats..."/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel="prev" href="cpp.html">The C++ Programming Language</a></p>
        <p><a href="cpp.RTTI.html">Run-Time Type Information (RTTI) in C++</a></p>
        <p><a href="cpp.type-aliases.html">Type Aliases in C++</a></p>
        <p><a href="cpp.type_traits.html">Handling Type with <code>&lt;type_traits&gt;</code></a></p>
        <p><a href="cpp.casts.html">C++ Casts</a></p>
        <p><a href="byte-order.html#cpp">Handling Byte Order in C++</a></p>
      </div>
      <div>
        <p><a href="cpp.functions.html">Functions in C++</a></p>
        <p><a href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a href="cpp.constexpr-and-consteval.html"><code>constexpr</code> and <code>consteval</code></a></p>
      </div>
      <div>
        <p><a href="cpp.linking-c-object-files-in.html">Linking C++ and C Object Files Together</a></p>
        <p><a href="c-and-cpp.html">C and C++</a></p>
      </div>
    </nav>

    <main>
      <h1>C++ Core Types</h1>

      <section id="void">
        <h2><code>void</code></h2>
        <p><strong>void</strong>: type with an empty set of values. It is an incomplete type that cannot be completed (consequently, objects of type void are disallowed). There are no arrays of void, nor references to void. However, pointers to void and functions returning type void (procedures in other languages) are permitted.</p>
      </section>
      <section id="nullptr_t">
        <h2><code>std::nullptr_t</code></h2>
        <p>(Defined in header <code>&lt;cstddef&gt;</code>)</p>
        <blockquote>
          <pre>typedef decltype(nullptr) nullptr_t;</pre>
          <p>(since C++11)</p>
        </blockquote>
        <p><code>std::nullptr_t</code> is the type of the null pointer literal, <code>nullptr</code>. It is a distinct type that is not itself a pointer type or a pointer to member type. All Its prvalues are null pointer constants.</p>
        <blockquote><code>sizeof(std::nullptr_t)</code> is equal to <code>sizeof(void*)</code>.</blockquote>
      </section>

      <section id="int">
        <h2>C++ Built-in Integer Types</h2>
        <section>
          <h3>Standard integer types</h3>
          <p><strong>int</strong>: basic integer type. The keyword <code>int</code> may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it&apos;s guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (<i>see below</i>).</p>
        </section>
        <section>
          <h3>Modifiers</h3>
          <p>They modify the basic integer type. Can be mixed in any order. Only one of each group can be present in type name.</p>
          <dl>
            <dt>Signedness:</dt>
            <dd>
              <p><strong>signed</strong>: target type will have signed representation (this is the default if omitted)</p>
              <p><strong>unsigned</strong>: target type will have unsigned representation</p>
            </dd>
            <dt>Size:</dt>
            <dd>
              <p><strong>short</strong>: target type will be optimized for space and will have width of at least 16 bits.</p>
              <p><strong>long</strong>: target type will have width of at least 32 bits.</p>
              <p><strong>long long</strong>: (since C++11) target type will have width of at least 64 bits.</p>
            </dd>
          </dl>
          <p><strong>Note:</strong> as with all type specifiers, any order is permitted: unsigned long long int and long int unsigned long name the same type.</p>
          <p><strong>std::size_t</strong> is the unsigned integer type of the result of the sizeof operator as well as the sizeof... operator and the alignof operator(since C++11).</p>
        </section>
        <section>
          <h3> Extended integer types</h3>
          <p>The extended integer types are implementation-defined. Note that fixed width integer types are typically aliases of the standard integer types.</p>
          <p>(<i>See</i> <code><a terget="_blank" href="https://en.cppreference.com/w/cpp/types/integer.html">https://en.cppreference.com/w/cpp/types/integer.html</a></code>)</p>
        </section>
      </section>

      <section id="bool">
        <h2>Boolean Type</h2>
        <p><strong>bool</strong>: integer type, capable of holding one of the two values: true or false. The value of sizeof(bool) is implementation defined and might differ from 1.</p>
      </section>

      <section id="char">
        <h2>C++ Built-in Character Types</h2>
        <p>Character types are integer types used for a character representation.</p>
        <ul>
          <li><strong>signed char</strong>: type for signed character representation. </li>
          <li><strong>unsigned char</strong>: type for unsigned character representation. Also used to inspect object representations (raw memory).</li>
          <li><strong>char</strong>: type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either signed char or unsigned char, but is always a distinct type). Multibyte characters strings use this type to represent code units. For every value of type unsigned char in range [​0​, 255], converting the value to char and then back to unsigned char produces the original value.(since C++11) The signedness of char depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed.</li>
          <li><strong>wchar_t</strong>: type for wide character representation (<i>see</i> wide strings). It has the same size, signedness, and alignment as one of the integer types, but is a distinct type. In practice, it is 32 bits and holds UTF-32 on Linux and many other non-Windows systems, but 16 bits and holds UTF-16 code units on Windows. The standard used to require wchar_t to be large enough to represent any supported character code point. However, such requirement cannot be fulfilled on Windows, and thus it is considered as a defect and removed.</li>
        </ul>
        <p>Types added in C++11:</p>
        <ul>
          <li><strong>char16_t</strong>: type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as std::uint_least16_t, but is a distinct type.</li>
          <li><strong>char32_t</strong>: type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as std::uint_least32_t, but is a distinct type.</li>
        </ul>
        <p>Type added in C++20:</p>
        <ul>
          <li><strong>char8_t</strong> type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as unsigned char (and therefore, the same size and alignment as char and signed char), but is a distinct type.</li>
        </ul>
        <hr/>
        <p>Besides the minimal bit counts, the C++ Standard guarantees that</p>
        <blockquote>1 == sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long).</blockquote>
        <p><strong>Note</strong>: this allows the extreme case in which bytes are sized 64 bits, all types (including char) are 64 bits wide, and sizeof returns 1 for every type.</p>
      </section>

      <section id="float">
        <h2>C++ Built-in Floating Point Types</h2>
        <section>
          <h3>Standard floating-point types</h3>
          <p>The following three types and their cv-qualified versions are collectively called standard floating-point types.</p>
          <ul>
            <li><strong>float</strong>: single precision floating-point type. Usually IEEE-754 binary32 format.</li>
            <li><strong>double</strong>: double precision floating-point type. Usually IEEE-754 binary64 format.</li>
            <li><strong>long double</strong>: extended precision floating-point type. Does not necessarily map to types mandated by IEEE-754.</li>
          </ul>
        </section>
        <section>
          <h3> Extended floating-point types</h3>
          <p>The extended floating-point types are implementation-defined. They may include fixed width floating-point types.</p>
        </section>
      </section>

    </main>

  </body>

</html>
