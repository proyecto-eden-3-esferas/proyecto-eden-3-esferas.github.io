<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>BGL Algorithms and Visitors</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Algorithms and Visitors in the Boost Graph Library (BGL)"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>
    <meta name="author" content="AUTHOR"/>

    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p><a            href="cpp.boost.graph.adjacency_list.html"><code>boost::adjacency_list</code></a></p>
        <p><a rel="next" href="cpp.boost.graph.algorithms-and-visitors.html">Algorithms and Visitors in the Boost Graph Library (BGL)</a></p>
        <p><a            href="cpp.boost.graph.examples.html">Boost Graph Library (BGL) Examples</a></p>
      </div>
      <div>
        <p><a rel="prev" href="graphs.html">Graphs</a></p>
        <p><a            href="cpp.graphs.html">C++ Graph Implementations</a></p>
        <p><a            href="cpp.boost.graph.old.html">(Former version of this page)</a></p>
      </div>
      <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a href="ANOTHER_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="prev" href="PREVIOUS_PAGE.html">LINK_TEXT</a></p>

      -->
    </nav>
    <main>
      <h1>Algorithms and Visitors in the Boost Graph Library (BGL)</h1>

      <section id="algorithms">
        <h2>Algorithms in the Boost Graph Library</h2>

        <section id="extending">
          <h3>Extending Algorithms with Visitors</h3>
          <p>Often times an algorithm in a library <em>almost</em> does what you need, but not quite. For example, in the previous section we used Dijkstra's algorithm to calculate the shortest distances to each vertex, but perhaps we also wanted to record the tree of shortest paths. One way to do this is to record the predecessor (parent) for each node in the shortest-paths tree.</p>
          <p>It would be nice if we could avoid rewriting Dijkstra's algorithm, and just add that little bit extra needed to record the predecessors. In the STL, this kind of extensibility is provided by <a target="_blank" href="cpp.function-object.html">functors</a>, which are optional parameters to each algorithm. In the BGL this role is fulfilled by visitors.</p>
          <p>A <dfn>visitor</dfn> is like a functor, but instead of having just one <q>apply</q> method, it has several. Each of these methods get invoked at certain well-defined points within the algorithm. The visitor methods are explained in detail in <cite class="section" href="#visitors">Visitor Concepts</cite>. The BGL provides a number of visitors for some common tasks including a predecessor recording visitor. The user is encouraged to write his or her own visitors as a way of extending the BGL. Here we will take a quick look at the implementation and use of the predecessor recorder. Since we will be using the <code class="function">dijkstra_shortest_paths()</code> algorithm, the visitor we create must be a Dijkstra Visitor.</p>
          <p>The functionality of the <code>record_predecessors</code> visitor is separated into two parts. For the storage and access of the predecessor property, we will use a <code><a target="_blank" href="cpp.boost.graph.html#property-maps">property_map</a></code>. The predecessor visitor will then only be responsible for what parent to record. To implement this, we create a <code>record_predecessors</code> class and template it on the predecessor property map <code>PredecessorMap</code>. Since this visitor will only be filling in one of the visitor methods, we will inherit from <code>dijkstra_visitor</code>, which will provide empty methods for the rest. The constructor of the predecessor_recorder will take the property map object and save it away in a data member.</p>

          <pre>template &lt;class PredecessorMap&gt;
  class record_predecessors : public dijkstra_visitor&lt;&gt;
  {
  public:
    record_predecessors(PredecessorMap p)
      : m_predecessor(p) { }

    template &lt;class Edge, class Graph&gt;
    void edge_relaxed(Edge e, Graph&amp; g) {
      // set the parent of the target(e) to source(e)
      put(m_predecessor, target(e, g), source(e, g));
    }
  protected:
    PredecessorMap m_predecessor;
  };</pre>
          <p>The job of recording the predecessors is quite simple. When Dijkstra's algorithm relaxes an edge (potentially adding it to the shortest-paths tree) we record the source vertex as the predecessor of the target vertex. Later, if the edge is relaxed again the predecessor property will be overwritten by the new predecessor. Here we use the <code class="function">put()</code> function associated with the property map to record the predecessor. The edge_filter of the visitor tells the algorithm when to invoke the <code class="function">explore()</code> method. In this case we only want to be notified about edges in the shortest-paths tree so we specify tree_edge_tag.</p>
          <p>As a finishing touch, we create a helper function to make it more convenient to create predecessor visitors. All BGL visitors have a helper function like this.</p>
          <pre>template &lt;class PredecessorMap&gt;
  record_predecessors&lt;PredecessorMap&gt;
  make_predecessor_recorder(PredecessorMap p) {
    return record_predecessors&lt;PredecessorMap&gt;(p);
  }</pre>
          <p>We are now ready to use the record_predecessors in Dijkstra's algorithm. Luckily, BGL's Dijkstra's algorithm is already equipped to handle visitors, so we just pass in our new visitor. In this example we only need to use one visitor, but the BGL is also equipped to handle the use of multiple visitors in the same algorithm (<i>see</i> <cite><a href="#visitors">Visitor Concepts</a></cite>).</p>
          <pre>  using std::vector;
  using std::cout;
  using std::endl;
  vector&lt;Vertex&gt; p(num_vertices(G), graph_traits&lt;G&gt;::null_vertex()); //the predecessor array
  dijkstra_shortest_paths(G, s, distance_map(&amp;d[0]).
                          visitor(make_predecessor_recorder(&amp;p[0])));

  cout &lt;&lt; "parents in the tree of shortest paths:" &lt;&lt; endl;
  for(vi = vertices(G).first; vi != vertices(G).second; ++vi) {
    cout &lt;&lt; "parent(" &lt;&lt; *vi;
    if (p[*vi] == graph_traits&lt;G&gt;::null_vertex())
      cout &lt;&lt; ") = no parent" &lt;&lt; endl;
    else
      cout &lt;&lt; ") = " &lt;&lt; p[*vi] &lt;&lt; endl;
  }</pre>
          <p>The output is:</p>
          <pre>parents in the tree of shortest paths:
  parent(0) = no parent
  parent(1) = 4
  parent(2) = 0
  parent(3) = 2
  parent(4) = 3</pre>
        </section>

      </section>

      <section id="visitors">
        <h2>Visitors in the Boost Graph Library</h2>
        <!-- from  1685 to 1858 -->
        <p>The <dfn>visitor</dfn> concept plays the same role in BGL as functors play in the STL. Functors provide a mechanism for extending an algorithm; for customizing what is done at each step of the algorithm. Visitors allow the user to insert their own operations at various steps within a graph algorithm. Unlike the STL algorithms, graph algorithms typically have multiple <dfn>event points</dfn> where one may want to insert a call-back via a functor. Therefore visitors do not have a single <code class="function">operator()</code> method like a functor, but instead have several methods that correspond to the various event points. Each algorithm has a different set of event points, which are described by the following visitor concepts:</p>
        <ul>
          <li>
            <a href="#bfs_visitor">BFS Visitor</a>
          </li>
          <li>
            <a href="#dfs_visitor">DFS Visitor</a>
          </li>
          <li>
            <a href="#dijkstra_visitor">Dijkstra Visitor</a>
          </li>
          <li>
            <a href="#bellman_ford_visitor">Bellman Ford Visitor</a>
          </li>
          <li>
            <a href="#a_star_visitor">A* Visitor</a>
          </li>
          <li>
            <a href="#event_visitor">Event Visitor</a>
          </li>
          <li>
            <a href="#planar_face_visitor">Planar Face Visitor</a>
          </li>
          <li>
            <a href="#tsp_tour_visitor">TSP Tour Visitor</a>
          </li>
        </ul>
        <p>In the following example we print out the Internet routers in breadth-first order by extending the <code class="function">breadth_first_search()</code> function with a visitor. The visitor prints the vertex name on the discover vertex event. The visitor class is defined according to the interface described by the <a href="#bfs_visitor">BFSVisitor</a> concept.</p>
        <pre>template &lt;var class='type'name VertexNameMap&gt;
class bfs_name_printer : public default_bfs_visitor {
// inherit default (empty) event point actions
public:
  bfs_name_printer(VertexNameMap n map) : m_name_map(n_map) { }
  template &lt;var class='type'name Vertex, typename Graph&gt;
  void discover_vertex(Vertex u, const Graph&amp; ) const {
    std::cout &lt;&lt; get(m_name_map, u) &lt;&lt; ' ';
  }
private:
  VertexNameMap m_name_map;
};</pre>
        <p>We then create a visitor object of type <code>bfs_name_printer</code> and pass it to <code class="function">breadth_first_search()</code>.</p>
        <pre>bfs_name_printer&lt;VertexNameMap&gt; vis(name map);
std::cout &lt;&lt; "BFS vertex discover order: ";
breadth first search(g, a, visitor(vis));
std::cout &lt;&lt; std::endl;</pre>
        <section id="bfs_visitor">
          <h4>BFS Visitor</h4>
          <p>This concept defines the visitor interface for <code class="function">breadth_first_search()</code>. Users can define a class with the BFS Visitor interface and pass and object of the class to <code class="function">breadth_first_search()</code>, thereby augmenting the actions taken during the graph search.</p>
          <h4>Refinement of</h4>
          <p>Copy Constructible (copying a visitor should be a lightweight operation).</p>
          <h4>Notation</h4>
          <ul>
            <li><var>V</var>: 	A type that is a model of BFS Visitor.</li>
            <li><var>vis</var>: 	An object of type V.</li>
            <li><var>G</var>: 	A type that is a model of Graph.</li>
            <li><var>g</var>: 	An object of type G.</li>
            <li><var>e</var>: 	An object of type <code>boost::graph_traits&lt;G&gt;::edge_descriptor</code>.</li>
            <li><var>s,u</var>: 	An object of type <code>boost::graph_traits&lt;G&gt;::vertex_descriptor</code>.</li>
          </ul>
          <h4>Valid Expressions</h4>
          <dl>
            <dt>Initialize Vertex</dt>
            <dd>
              <p>
                <code class="function">vis.initialize_vertex(s, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on every vertex of the graph before the start of the graph search.</p>
            </dd>
            <dt>Discover Vertex</dt>
            <dd>
              <p>
                <code class="function">	vis.discover_vertex(u, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked when a vertex is encountered for the first time.</p>
            </dd>
            <dt>Examine Vertex</dt>
            <dd>
              <p>
                <code class="function">	vis.examine_vertex(u, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on a vertex as it is popped from the queue. This happens immediately before examine_edge() is invoked on each of the out-edges of vertex u.</p>
            </dd>
            <dt>Examine Edge</dt>
            <dd>
              <p>
                <code class="function">	vis.examine_edge(e, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on every out-edge of each vertex after it is discovered.</p>
            </dd>
            <dt>Tree Edge</dt>
            <dd>
              <p>
                <code class="function">	vis.tree_edge(e, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on each edge as it becomes a member of the edges that form the search tree.</p>
            </dd>
            <dt>Non-Tree Edge</dt>
            <dd>
              <p>
                <code class="function">	vis.non_tree_edge(e, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on back or cross edges for directed graphs and cross edges for undirected graphs.</p>
            </dd>
            <dt>Gray Target</dt>
            <dd>
              <p>
                <code class="function">	vis.gray_target(e, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on the subset of non-tree edges whose target vertex is colored gray at the time of examination. The color gray indicates that the vertex is currently in the queue.</p>
            </dd>
            <dt>Black Target</dt>
            <dd>
              <p>
                <code class="function">	vis.black_target(e, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This is invoked on the subset of non-tree edges whose target vertex is colored black at the time of examination. The color black indicates that the vertex has been removed from the queue.</p>
            </dd>
            <dt>Finish Vertex</dt>
            <dd>
              <p>
                <code class="function">	vis.finish_vertex(u, g)</code>
              </p>
              <p><em>return type:</em> void</p>
              <p>This invoked on a vertex after all of its out edges have been added to the search tree and all of the adjacent vertices have been discovered (but before the out-edges of the adjacent vertices have been examined).</p>
            </dd>
          </dl>
        </section>
        <section id="dfs_visitor">
          <h3>DFS Visitor*</h3>
        </section>
        <section id="dijkstra_visitor">
          <h3>Dijkstra Visitor*</h3>
        </section>
        <section id="bellman_ford_visitor">
          <h3>Bellman Ford Visitor*</h3>
        </section>
        <section id="a_star_visitor">
          <h3>A* Visitor*</h3>
        </section>
        <section id="event_visitor">
          <h3>Event Visitor*</h3>
        </section>
        <section id="planar_face_visitor">
          <h3>Planar Face Visitor*</h3>
        </section>
        <section id="tsp_tour_visitor">
          <h3>TSP Tour Visitor*</h3>
        </section>
      </section>

    </main>
  </body>
</html>
