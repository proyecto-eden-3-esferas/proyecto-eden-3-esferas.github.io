<!DOCTYPE html>
<html>
  <head>
    <title>Move Semantics</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Move Semantics: on l- and r-values, moving and forwarding"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a            href="cpp.references.html">C++ References</a></p>
        <p><a rel="next" href="cpp.rule-of-five.html">Rule of Five in C++</a></p>
      </div>
      <div>
        <p><a rel="prev" href="cpp.html">The C++ Programming Language</a></p>
        <p><a            href="computing.html">Computing</a></p>
      </div>
    </nav>

    <main>
      <h1>Move Semantics in C++</h1>
      <p>In C++, to <dfn>move</dfn> means to move the contents (of an object) from one place in memory to another. You typically move something pointed to or some acquired resource such as a file handle or a connection (to a database, or a socket, or...).</p>

      <section id="l-and-r-values">
        <h2>L- and R-Values</h2>
        <p>The term lvalue originally referred to an expression that could be the left hand side of an assignment. Correspondingly, an rvalue (although as I recall that term was not used by the C89 standard), was originally just the opposite: an expression that could not be the left hand side of an assignment, but that could only be the right hand side.</p>
        <p>C++11 complicated this by adding several more nuanced terms, but let&apos;s concentrate on the C++03 meanings. For example, if you have</p>
        <pre>int x;</pre>
        <p>then the assignment <code>x = 42</code> is OK, so x is an lvalue expression.</p>
        <p>As a counter-example, the assigment <code>x+0 = 42</code> is not OK, so <var>x+0</var> is an rvalue expression.</p>
        <p>And so is the expression <code>2+2</code>, it&apos;s an rvalue expression.</p>
        <p>So, if the requirement is that your program should include an rvalue, then just write 2+2 or something analogous.</p>
        <p>Original <a target="_blank" href="c.html">C</a> didn&apos;t have <code>const</code>. In C++, with <code>const</code>, you have to cannot rely on <code>const</code> for the purpose of making an expression an lvalue or an rvalue. The critical point is then whether the expression guaranteed refers to an object in memory, an object with an address: if so, then the expression is an lvalue.</p>
        <p>Thus, a reference type implies an lvalue, because an expression of reference type is necessarily referring to an object with a memory address, i.e. that expression is an lvalue. However, other than references there&apos;s no connection between type and lvalue/rvalue. For example, both <var>x</var> and <var>x+0</var> are expressions of type <code>int</code>, and they do indeed yield the same <code>int</code> value. But the former is an lvalue expression, while the latter is an rvalue expression.</p>
        <p>As a general rule, if you can apply the built-in address operator, then it&apos;s an lvalue expression, and otherwise it&apos;s an rvalue expression.</p>
        <hr/>
        <p>In C++, an rvalue is an unnamed object or a member of such an object which is not a reference.</p>
      </section>

      <section id="std_move">
        <h2>Causing Move Semantics with <code>std::move()</code></h2>
        <p>...</p>
        <pre>// Creating an object using Move constructor
Object obj2 = std::move(obj1);

// Creating an object using Move assignment operator
Object obj3;
obj3 = std::move(obj2);</pre>
        <p>...</p>
      </section>

      <section id="forwarding">
        <h2>Forwarding</h2>
        <p><dfn>Forwarding</dfn> is the process where one function forwards its parameter to another function.</p>
        <section id="perfect-forwarding">
          <h3>Perfect Forwarding</h3>
          <p>With <dfn>perfect forwarding</dfn>, the function should receive the same object passed from the function that does the forwarding. In other words, <dfn>perfect forwarding</dfn> means we do not just forward objects, we also forward their salient properties, whether they are lvalues or rvalues, const or volatile.</p>
          <aside>
            <p><dfn>Perfect Forwarding</dfn> means that a function template can pass its arguments through to another function whilst retaining the lvalue/rvalue nature of the function arguments by using <code><a href="#forward">std::forward</a></code>. This avoids excessive copying as well as the template author having to write multiple overloads for lvalue and rvalue references.</p>
            <p>Common examples include constructors and setter functions that forward arguments they receive to the data members of the class they are initializing or setting, as well as standard library functions like <code>std::make_shared</code>, which <q>perfect-forwards</q> its arguments to the class constructor of whatever object the to-be-created <code>std::shared_ptr</code> is to point to.</p>
          </aside>
        </section>
        <section id="forward">
          <h3><code>std::forward</code> in Header <cite>&lt;utility&gt;</cite></h3>
          <p>Function <code>std::forward(<var>arg</var>)</code> returns an rvalue reference to <var>arg</var> if <var>arg</var> is not an lvalue reference. If <var>arg</var> is an lvalue reference, the function returns <var>arg</var> without modifying its type.</p>
          <p>The need for this function stems from the fact that all named values (such as function parameters) always evaluate as lvalues (even those declared as rvalue references), and this poses difficulties in preserving potential move semantics on template functions that forward arguments to other functions.</p>
          <p>These are their twin <strong>prototypes</strong>:</p>
          <pre>template &lt;class T&gt; T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp; arg) noexcept;
template &lt;class T&gt; T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp;&amp; arg) noexcept;</pre>
          <p><strong>Example:</strong></p>
          <pre>#include &lt;utility&gt;      // std::forward
#include &lt;iostream&gt;     // std::cout

// function with lvalue and rvalue reference overloads:
void overloaded (const int&amp; x) {std::cout &lt;&lt; "[lvalue]";}
void overloaded (int&amp;&amp; x) {std::cout &lt;&lt; "[rvalue]";}

// function template taking rvalue reference to deduced type:
template &lt;class T&gt; void fn (T&amp;&amp; x) {
  overloaded (x);                   // always an lvalue
  overloaded (std::forward&lt;T&gt;(x));  // rvalue if argument is rvalue
}

int main () {
  int a;

  std::cout &lt;&lt; "calling fn with lvalue: ";
  fn (a); // [lvalue][lvalue]
  std::cout &lt;&lt; '\n';

  std::cout &lt;&lt; "calling fn with rvalue: ";
  fn (0); // [lvalue][rvalue]
  std::cout &lt;&lt; '\n';

  return 0;
}</pre>
          <!--
          <p></p>
          <pre></pre>
          -->
        </section>
      </section>


    </main>

  </body>

</html>
