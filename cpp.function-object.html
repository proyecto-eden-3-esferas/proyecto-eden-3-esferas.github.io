<!DOCTYPE html>
<html>
  <head>
    <title>c++ function objects</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a href="cpp.preprocessor.html">The C/C++ Preprocessor</a></p>
        <p><a href="cpp.stl.html">C++ Standad Template Library (STL)</a></p>
      </div>
      <div>
        <p><a href="cpp.core-guidelines.html">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup (<em>local</em>)</p>
        <p><a href="http://isocpp.github.io/CppCoreGuidelines/">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup, much like the C++ language itself (<em>online</em>)</p>
      </div>
    </nav>

    <main>
      <h1>Function Objects in C++</h1>
      <p style="text-align: right">(Heavily from <a target="_blank" href="https://cplusplus.com/reference/functional/">https://cplusplus.com/reference/functional/</a>)</p>
      <p>Function objects are objects that work as functions. On an implementation level, however, function objects are objects of a class that implement <code>operator()</code>, with zero to any number of arguments. Although functions and function-pointers can also be classified as function objects, it is the capability of an object of a class that implements operator() to carry state (that is, values in member attributes of the class) that makes it so useful.</p>
      <p>Function objects that return a boolean type (<dfn>predicates</dfn>) naturally are used in algorithms that need decision-making.</p>
      <p>They are typically used as arguments to functions, such as predicates or comparison functions passed to <a target="_blank" href="algorithms.html">standard algorithms</a>.</p>
      <section id="header">
        <h2>Header <code>&lt;functional&gt;</code></h2>
        <p>This header defines some functions, wrapper classes and namespace <code><a href="#placeholders">placeholders</a></code>.</p>
        <section id="functions">
          <h3>Functions</h3>
          <p>These functions create objects of wrapper classes based on its arguments:</p>
          <dl>
            <dt><code><a href="#bind">bind</a></code></dt>
            <dd>Bind function arguments<!--  (function template) --></dd>

            <dt><code><a href="#ref-cref">cref</a></code></dt>
            <dd>Construct reference_wrapper to const<!--  (function template) --></dd>

            <dt><code>mem_fn</code></dt>
            <dd>Convert member function to function object<!--  (function template) --></dd>

            <dt><code>not1</code></dt>
            <dd>Return negation of unary function object<!--  (function template) --></dd>

            <dt><code>not2</code></dt>
            <dd>Return negation of binary function object<!--  (function template) --></dd>

            <dt><code><a href="#ref-cref">ref</a></code></dt>
            <dd>Construct reference_wrapper<!--  (function template) --></dd>

          </dl>
        </section>
        <section id="classes">
          <h3>Classes*</h3>
          <section>
            <h4>Wrapper classes</h4>
            <p><dfn>Wrapper classes</dfn> are classes that hold an object and have an interface similar to that object, but adding or changing some of its features:</p>
            <dl>

              <dt><code>binary_negate</code></dt>
              <dd>Negate binary function object class<!-- (class template) --></dd>

              <dt><code>function</code></dt>
              <dd>Function wrapper<!-- (class template) --></dd>

              <dt><code>reference_wrapper</code></dt>
              <dd>Reference wrapper<!-- (class template) --></dd>

              <dt><code>unary_negate</code></dt>
              <dd>Negate unary function object class<!-- (class template) --></dd>

            </dl>
          </section>
          <section>
            <h4>Operator classes</h4>
            <p>Operator classes are classes that define functional objects that call operators:</p>
            <dl>

              <dt><code>bit_and</code></dt>
              <dd>Bitwise AND function object class<!-- (class template) --></dd>

              <dt><code>bit_or</code></dt>
              <dd>Bitwise OR function object class<!-- (class template) --></dd>

              <dt><code>bit_xor</code></dt>
              <dd>Bitwise XOR function object class<!-- (class template) --></dd>

              <dt><code>divides</code></dt>
              <dd>Division function object class<!-- (class template) --></dd>

              <dt><code>equal_to</code></dt>
              <dd>Function object class for equality comparison<!-- (class template) --></dd>

              <dt><code>greater</code></dt>
              <dd>Function object class for greater-than inequality comparison<!-- (class template) --></dd>

              <dt><code>greater_equal</code></dt>
              <dd>Function object class for greater-than-or-equal-to comparison<!-- (class template) --></dd>

              <dt><code>less</code></dt>
              <dd>Function object class for less-than inequality comparison<!-- (class template) --></dd>

              <dt><code>less_equal</code></dt>
              <dd>Function object class for less-than-or-equal-to comparison<!-- (class template) --></dd>

              <dt><code>logical_and</code></dt>
              <dd>Logical AND function object class<!-- (class template) --></dd>

              <dt><code>logical_not</code></dt>
              <dd>Logical NOT function object class<!-- (class template) --></dd>

              <dt><code>logical_or</code></dt>
              <dd>Logical OR function object class<!-- (class template) --></dd>

              <dt><code>minus</code></dt>
              <dd>Subtraction function object class<!-- (class template) --></dd>

              <dt><code>modulus</code></dt>
              <dd>Modulus function object class<!-- (class template) --></dd>

              <dt><code>multiplies</code></dt>
              <dd>Multiplication function object class<!-- (class template) --></dd>

              <dt><code>negate</code></dt>
              <dd>Negative function object class<!-- (class template) --></dd>

              <dt><code>not_equal_to</code></dt>
              <dd>Function object class for non-equality comparison<!-- (class template) --></dd>

              <dt><code>plus</code></dt>
              <dd>Addition function object class<!-- (class template) --></dd>

            </dl>
          </section>
          <section>
            <h4>Other classes</h4>
            <dl>

              <dt><code>bad_function_call</code></dt>
              <dd>Exception thrown on bad call (class)</dd>

              <dt><code>hash</code></dt>
              <dd>Default hash function object class<!-- (class template) --></dd>

              <dt><code>is_bind_expression</code></dt>
              <dd>Is bind expression<!-- (class template) --></dd>

              <dt><code>is_placeholder</code></dt>
              <dd>Is placeholder<!-- (class template) --></dd>

            </dl>
          </section>
        </section>
        <section id="placeholders">
          <h3>Namespace <code>placeholders</code></h3>
          <p></p>
        </section>
      </section>

      <section id="bind">
        <h2>Function <code>std::bind</code> in Depth (<code>&lt;functional&gt;</code>)</h2>
        <p><strong>Prototypes:</strong></p>
        <pre>template &lt;class Fn, class... Args&gt;
bind (Fn&amp;&amp; fn, Args&amp;&amp;... args);
template &lt;class Ret, class Fn, class... Args&gt;
bind (Fn&amp;&amp; fn, Args&amp;&amp;... args);</pre>
        <p><code>bind()</code> returns a function object based on <var>fn</var>, but with its arguments bound to <var>args</var>. Each argument may either be bound to a value or be a placeholder:</p>
        <ul>
          <li>If bound to a value, calling the returned function object will always use that value as argument.</li>
          <li>If a placeholder, calling the returned function object forwards an argument passed to the call (the one whose order number is specified by the placeholder).</li>
        </ul>
        <p>Calling the returned object returns the same type as <var>fn</var>, unless a specific return type is specified as <var>Ret</var> (second prototype). (Note that <var>Ret</var> is the only template parameter that cannot be implicitly deduced by the arguments passed to this function).</p>
        <hr/>
        <p>The type of the returned object has the following properties:</p>
        <ul>
          <li>Its functional call returns the same as <var>fn</var> with its arguments bound to <var>args...</var> (or forwarded, for placeholders).</li>
          <li>For the first prototype, it may have a member <code>result_type</code>: if <var>Fn</var> is a pointer to function or member function type, it is defined as an alias of its return type. Otherwise, it is defined as <code>Fn::result_type</code>, if there should be such a member type.</li>
        </ul>
        <p>>An <strong>example</strong>:</p>
        <p>[...]</p>
        <pre>// bind example
#include &lt;iostream&gt;     // std::cout
#include &lt;functional&gt;   // std::bind

// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)
double my_divide (double x, double y) {return x/y;}

struct MyPair {
  double a,b;
  double multiply() {return a*b;}
};

int main () {
  using namespace std::placeholders;    // adds visibility of _1, _2, _3,...

  // binding functions:
  auto fn_five = std::bind (my_divide,10,2);               // returns 10/2
  std::cout &lt;&lt; fn_five() &lt;&lt; '\n';                          // 5

  auto fn_half = std::bind (my_divide,_1,2);               // returns x/2
  std::cout &lt;&lt; fn_half(10) &lt;&lt; '\n';                        // 5

  auto fn_invert = std::bind (my_divide,_2,_1);            // returns y/x
  std::cout &lt;&lt; fn_invert(10,2) &lt;&lt; '\n';                    // 0.2

  auto fn_rounding = std::bind&lt;int&gt; (my_divide,_1,_2);     // returns int(x/y)
  std::cout &lt;&lt; fn_rounding(10,3) &lt;&lt; '\n';                  // 3

  MyPair ten_two {10,2};

  // binding members:
  auto bound_member_fn = std::bind (&amp;MyPair::multiply,_1); // returns x.multiply()
  std::cout &lt;&lt; bound_member_fn(ten_two) &lt;&lt; '\n';           // 20
  auto bound_member_data = std::bind (&amp;MyPair::a,ten_two); // returns ten_two.a
  std::cout &lt;&lt; bound_member_data() &lt;&lt; '\n';                // 10

  return 0;
}</pre>
        <p>[...]</p>
      </section>

      <section id="ref-cref">
        <h2>Functions <code>std::ref</code> and <code>std::cref</code> in Depth (<code>&lt;functional&gt;</code>)</h2>
        <p>...</p>
        <p><strong>Prototypes:</strong></p>
        <pre>template &lt;class T&gt; reference_wrapper&lt;T&gt; ref (T&amp; elem) noexcept;
template &lt;class T&gt; reference_wrapper&lt;T&gt; ref (reference_wrapper&lt;T&gt;&amp; x) noexcept;
template &lt;class T&gt; void ref (const T&amp;&amp;) = delete;

template &lt;class T&gt;  reference_wrapper&lt;const T&gt; cref (const T&amp; elem) noexcept;
template &lt;class T&gt;  reference_wrapper&lt;const T&gt; cref (reference_wrapper&lt;T&gt;&amp; x) noexcept;
template &lt;class T&gt;  void cref (const T&amp;&amp;) = delete;</pre>
        <p>These functions return a <code><a target="_blank" ref="">reference_wrapper</a></code> object of the appropriate type to hold an element of type <code>T</code> or <code>const T</code> respectively.</p>
        <p>An <strong>example</strong>:</p>
        <pre>// ref example
#include &lt;iostream&gt;     // std::cout
#include &lt;functional&gt;   // std::ref

int main () {
  int foo (10);

  auto bar = std::ref(foo);

  ++bar;
  std::cout &lt;&lt; foo &lt;&lt; '\n';

  return 0;
}</pre>
        <p>(Note that should we have invoked <code>std::cref</code> instead, the returned object, <var>bar</var>, would not be incrementable, but the source object, <var>foo</var>, would.)</p>
      </section>

      <section id="mem_fn">
        <h2>Function <code>std::mem_fn</code> (<code>&lt;functional&gt;</code>)</h2>
        <pre>template &lt;class Ret, class T&gt;
/* unspecified */ mem_fn (Ret T::* pm);</pre>
        <p><code>std::mem_fn</code> converts member function <var>pm</var> to a function object. It returns a function object whose functional call invokes the member function pointed by <var>pm</var>.</p>
        <hr/>
        <p>The type of the returned object has the following properties:</p>
        <ul>
          <li>Its functional call takes as first argument an object of type <var>T</var> (or a reference or a pointer to it) and, as additional arguments, the arguments taken by <var>pm</var> (if any). The effect of such a call with <var>fn</var> as first argument are the same as calling <code><var>fn</var></code>.*<var>pm</var> (or <code>(*<var>fn</var>).*<var>pm</var></code> if <var>fn</var> is a pointer), forwarding any additional arguments.</li>
          <li>It has a member <code>result_type</code>, defined as an alias of <var>Ret</var> (which is the return type of <var>pm</var>).</li>
          <li>If the member pointed by <var>pm</var> takes no arguments, it has a member argument_type, defined as an alias of <code>T*</code>.</li>
          <li>If the member pointed by <var>pm</var> takes one argument, it has a member <code>first_argument_type</code>, defined as an alias of <code>T*</code>, and a member <code>second_argument_type</code>, defined as an alias of the argument taken by <var>pm</var>.</li>
          <li>It is nothrow move-constructible, nothrow copy-constructible and nothrow copy-assignable.</li>
          <hr/>
          <p>An <strong>example</strong>:</p>
          <pre>// mem_fn example
#include &lt;iostream&gt;     // std::cout
#include &lt;functional&gt;   // std::mem_fn

struct int_holder {
  int value;
  int triple() {return value*3;}
};

int main () {
  int_holder five {5};

  // call member directly:
  std::cout &lt;&lt; five.triple() &lt;&lt; '\n'; // 15

  // same as above using a mem_fn:
  auto triple = std::mem_fn (&amp;int_holder::triple);
  std::cout &lt;&lt; triple(five) &lt;&lt; '\n'; // 15

  return 0;
}</pre>
          <p>[...]</p>
        </ul>
      </section>

    </main>

  </body>

</html>
