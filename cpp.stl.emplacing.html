<!DOCTYPE html>
<html>
  <head>
    <title>the c++ programming language</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel= "prev" href="cpp.containers.html">C++ STL Containers</a></p>
        <p><a             href="cpp.html">The C++ Programming Language</a> </p>
      </div>
    </nav>

    <main>
      <h1>C++ Emplacing</h1>
      <p>Emplace operations are provided to make C++ code faster. They should be used when you want to add an object by constructing at the point of calling the emplace operation. For example, you may want to construct the object using its default constructor and then push it into the container. Or you may want to construct it using some parameters on the spot. Formerly, this involved the construction of a temporary object and then copying it into the container.</p>
      <p>Many of the STL containers support emplacing. For example, <clode class="classname">vector</clode> now has <code class="function">emplace_back</code> operation along with the old <code class="function">push_back</code> operation, as well as <code class="function">emplace</code> along with <code class="function">insert</code>.</p>
      <p>The good news is that the syntax of emplace and push/insert operations are the same, yet the efficiency of the former is much higher.</p>
      <p>Emplace members forward the constructor&apos;s arguments in an automagical fashion. Here is an example:</p>
      <pre>#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

int main()
{
  std::unordered_map&lt;unsigned int, std::string&gt; m;
  m.emplace(std::make_pair(33, std::string("blood-curdling")));
  m.emplace(17, "built-in");

  for (const auto &amp;p : m) {
    std::cout &lt;&lt; p.first &lt;&lt; " =&gt; " &lt;&lt; p.second &lt;&lt; '\n';
  }

  return 0;</pre>
      <p><strong>Note:</strong> emplace operations seem to bypass ordinary constructors and use the copy constructor instead.</p>

      <section id="list">
        <h2>Emplacing in STL List Containers</h2>
        <p>You can emplace at the front or back with:</p>
        <pre>template &lt;class... Args&gt;  void emplace_front (Args&amp;&amp;... args);
template &lt;class... Args&gt;  void emplace_back (Args&amp;&amp;... args);</pre>
        <p>For emplacing with hint, the first argument is an iterator that the new item is to be constructed before:</p>
        <pre>template &lt;class... Args&gt;
iterator emplace (const_iterator position, Args&amp;&amp;... args);</pre>
        <p>[...]</p>
      </section>

      <section id="associative">
        <h2>Emplacing in STL Associtive Containers</h2>
        <p><code>std::set</code> has an <code>emplace(...)</code> member function whose prototype is:</p>
        <pre>template &lt;class... Args&gt;  pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</pre>
        <p>where <var>args</var> are the arguments to construct a new set element.</p>
        <p>(If the function successfully inserts the element (because no equivalent element existed already in the set), the function returns a pair of an iterator to the newly inserted element and a value of <code>true</code>. Otherwise, it returns an iterator to the equivalent element within the container and a value of <code>false</code>.)</p>
        <p>Analogously, ...</p>
        <pre></pre>
        <p>where <var>args</var> is the arguments forwarded to construct the new element (of type <code>std::pair&lt;const key_type, mapped_type&gt;</code>).</p>
        <p>These can be one of:</p>
        <ul>
          <li>Two arguments: one for the key, the other for the mapped value.</li>
          <li>A single argument of a pair type with a value for the key as first member, and a value for the mapped value as second.</li>
          <li><code>piecewise_construct</code> as first argument, and two additional arguments with tuples to be forwarded as arguments for the key value and for the mapped value respectivelly.</li>
        </ul>
      </section>

    </main>

  </body>

</html>
