<!DOCTYPE html>
<html>
  <head>
    <title>Memory Management in C++</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a href="cpp.casts.html">C++ Casts</a></p>
        <p><a href="cpp.exceptions.html">C++ Exceptions</a></p>
      -->
      <div>
        <p><a rel="next" href="cpp.unique_ptr.html"><code>std::unique_ptr</code>: a Smart Pointer that Cannot be Copied</a></p>
        <p><a            href="cpp.shared_ptr.html"><code>std::shared_ptr</code>: a Smart Pointer that Keeps Count of its Copies</a></p>
        <p><a            href="cpp.weak_ptr.html"><code>std::weak_ptr</code>: Breaking Cycles of Counted Rerences</a></p>
      </div>
      <div>
        <p><a href="cpp.RAII.html">Resource Acquisition is Initialization (RAII) in C++</a></p>
        <p><a href='cpp.reference-counting.html'>Reference Counting with Smart Pointers in C++</a> </p>
      </div>
      <div>
        <p><a rel="prev" href="programming.html">Programming Computers</a></p>
      </div>
    </nav>

    <main>
      <h1>Memory Management in C++</h1>
      <p>Memory is obtained (from the Operating System) through operators <code>new</code> and <code>new []</code>, and is released through operator <code>delete</code> and <code>delete []</code>.</p>
      <pre>int * pInt = new int;
MyClass * pObj = new MyClass;</pre>
      <p>To get an array of <code>int</code>&apos;s or of <code>MyClass</code> objects use <code>new []</code>:</p>
      <pre>int * pArrayOfInt = new int[7];
MyClass * pArrayOfObj = new MyClass[4];</pre>

      <hr/>

      <p>Actually, <code>new</code> not only gets the requested memory (from the Operating System) but also constructs one or so many objects.</p>

      <hr/>

      <p>Memory is released likewise by means of the <code>delete</code> and <code>delete []</code> operators:</p>
      <pre>delete pInt;
delete [] pArrayOfInt;
delete pObj;
delete [] pArrayOfObj;</pre>
      <p>Note that <code>delete</code> and <code>delete []</code> take a pointer as their argument.</p>

      <hr/>

      <p>In the <a target="_blank" href="cpp.stl.html">Standard Template Library</a>, memory management is performed by allocators.</p>

      <section id="placement-new">
        <h2>Placement <code>new</code>*</h2>
        <pre>// ...</pre>
        <p>[...]</p>
      </section>

      <section id="writing-your-own-new">
        <h2>Writing your own <code>new</code> operators overrides for specific types</h2>
        <pre>// ...</pre>
        <p>[...]</p>
        <hr/>
        <p>The STL provides three smart pointers...</p>
        <ul>
          <li><a href="cpp.unique_ptr.html"><code>std::unique_ptr</code>: a Smart Pointer that Cannot be Copied</a></li>
          <li><a href="cpp.shared_ptr.html"><code>std::shared_ptr</code>: a Smart Pointer that Keeps Count of its Copies</a></li>
          <li><a href="cpp.weak_ptr.html"><code>std::weak_ptr</code>: Breaking Cycles of Counted Rerences</a></li>
        </ul>
      </section>

      <section id="nullptr">
        <h2><code>std::nullpt</code> (since C++11)</h2>
        <p>The keyword nullptr denotes the pointer literal. It is a prvalue of type <code>std::nullptr_t</code>. There exist implicit conversions from <code>nullptr</code> to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type <code>std::nullptr_t</code> as well as the macro <code>NULL</code>.</p>

        <p>The <code>nullptr</code> keyword can be used to test if a pointer or handle reference is null before the reference is used. Function calls among languages that use null pointer values for error checking should be interpreted correctly. You cannot initialize a handle to zero; only <code>nullptr</code> can be used.</p>
        <pre>...</pre>
        <p></p>

        <p>Here is another, somewhat more sophisticated, sample:</p>
        <pre>#include &lt;cstddef&gt;
#include &lt;iostream&gt;

template&lt;class T&gt;
constexpr T clone(const T&amp; t)
{
  return t;
}

void g(int*)
{
  std::cout &lt;&lt; "Function g called\n";
}

int main()
{
  g(nullptr);        // Fine
  g(NULL);           // Fine
  g(0);              // Fine

  g(clone(nullptr)); // Fine
//  g(clone(NULL));    // ERROR: non-literal zero cannot be a null pointer constant
//  g(clone(0));       // ERROR: non-literal zero cannot be a null pointer constant
}</pre>
        <!--
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        -->
      </section>



    </main>

  </body>

</html>
