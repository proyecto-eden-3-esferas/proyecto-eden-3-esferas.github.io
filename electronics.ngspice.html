<!DOCTYPE html>
<html>
  <head>
    <title>NGSpice, the Open Source Spice Simulator</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>
    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="electronics">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="prev" href="PREVIOUS_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel="next" href="https://ngspice.users-manual.v44.xhtml">Ngspice User&apos;s Manual, V44+ (development)</a>, by Holger Vogt, Giles Atkinson, Paolo Nenzi, December 2024</p>
        <p><a            href="https://ngspice.sourceforge.io/">ngspice - open source spice simulator</a>, at <code>https://ngspice.sourceforge.io/</code></p>
        <p><a href="https://ngspice.sourceforge.io/tutorials.html">Ngspice Tutorials</a> (external page)</p>
        <p><a href="https://sourceforge.net/p/ngspice/ngspice/ci/master/tree/examples/">Lots of Ngspice Examples,</a> where especially the Monte Carlo simulations make heavy use of more or less complex control scripts (external page)</p>
      </div>
      <div>
        <p><a            href="ngspice.mosfet.html">MOSFET models (NMOS/PMOS)</a></p>
        <p><a            href="ngspice.passive-elems-op.html">Circuit with Passive Elements, Operating Point</a></p>
        <p><a            href="ngspice.passive-elems-pulse.html">Circuit with Passive Elements, Transient Simulation</a></p>
      </div>
      <div>
        <p><a rel="prev" href="electronics.spice.html">Spice: an Analog-Circuit Simulator</a></p>
        <p><a            href="electronics.html">Electronics</a></p>
        <p><a            href="computing.html">Computing</a></p>
      </div>
    </nav>

    <main>
      <h1>NGSpice, the Open Source Spice Simulator</h1>
      <p><dfn>ngspice</dfn> is a text-mode circuit simulator that numerically solves equations describing (electronic) circuits: These are made of passive and active devices. Time varying currents and voltages are simulated as well as noise and small signal behavior.</p>
      <p>Ngspice is an <a target="_blank" href="open-source.html">open source</a> update of Spice3f5, the last Berkeley&apos;s release of Spice3 simulator family. Ngspice is being developed to include new features to existing Spice3f5 and to fix its bugs. Improving a complex software like a circuit simulator is a very hard task and, while some improvements have been made, most of the work has been done on bug fixing and code refactoring.</p>
      <aside>There are <a target="_blank" href="https://ngspice.sourceforge.io/resources.html">third party tools</a> available to draw the circuit and generate a ngspice netlist.</aside>
      <p>On a <a href="linux.html">linux</a> (here Ubuntu) distribution several packages are available:</p>
      <ul>
        <li><strong>ngspice</strong>: the executable, man pages and some documentation at <cite>/usr/share/doc/ngspice/</cite>, containing mainly an examples subdirectory (<cite>/usr/share/doc/ngspice/examples</cite>)</li>
        <li><strong>ngspice-doc</strong>: in directory <cite>/usr/share/doc/ngspice-doc/html</cite> are found one large HTML file (<cite>/usr/share/doc/ngspice-doc/html/manual.html</cite>, 4.2MB), a compressed PDF version of the manual (<cite>/usr/share/doc/ngspice-doc/manual.pdf.gz</cite>), and sundry image files presumably used by <cite>manual.html</cite>.</li>
      </ul>
      <p>There is a detailed <a target="_blank" href="https://sourceforge.net/projects/ngspice/files/ng-spice-rework/37/ngspice-37-manual.pdf/download">reference manual</a> available for ngspice. This manual describes all commands and procedures available in ngspice and lists numerous examples. However, it is not an ngspice how-to or introductory text.<del> This tutorial here gives you some information how to start. If you are interested in getting more in-depth information, you may refer to our <a href="https://ngspice.sourceforge.io/books.html">book page</a> or to a list of third party <a href="https://ngspice.sourceforge.io/tutorials.html">tutorials</a>.</del></p>

      <section id="install">
        <h2>Installing</h2>
        <section id="install.linux">
          <h3>Linux Installing</h3>
          <p>If you are using LINUX, please check if your distribution already offers a ngspice package for installation. If not, you will need to download the latest <cite>ngspice-<var>XX</var>.tar.gz</cite> at <code><a target="_blank" href="https://sourceforge.net/projects/ngspice/files/ng-spice-rework/">https://sourceforge.net/projects/ngspice/files/ng-spice-rework/</a></code> and compile ngspice with</p>
          <pre>./configure --with-x --enable-xspice --enable-cider\
--with-readline=yes --enable-openmp --disable-debug\
CFLAGS="-m64 -O2" LDFLAGS="-m64 -s"
make -j8
sudo make install</pre>
          <p>or by running the script <cite>compile_linux.sh</cite> from folder <cite>ngspice/</cite> by</p>
          <pre>./compile_linux.sh 64</pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>

        </section>
      </section>
      <section id="example">
        <h2>An Example/Procedure</h2>
        <p><del>As shown in Fig. 1, </del>You start with a circuit (here: an inverter). You have to create a <dfn>netlist</dfn> describing this circuit. The netlist is the input to ngspice, telling it about the circuit to be simulated. Together with some simulation commands this input cares for reading and parsing the netlist, starting the simulation and plotting the output.<del> The output voltage (plotted in red) is the inverse of the (green) input. Both voltages are plotted versus time.</del></p>
        <p>The input to ngspice is read from a file (either at the command line, as in <code>ngspice vdiv.cir</code> or at the ngspice prompt with command <code>source</code>, as in <code>ngspice 1 -> source ./vdiv.cir</code>), and it may be enhanced by commands given on the command line. The simulated output may be written to a file, or be plotted as a Y-X graph or a smith chart. There is no graphical user interface with schematic capture of circuit diagrams and automatic netlist generation.</p>
        <p>Next we shall be looking at a simple example, a <a href="ngspice.passive-elems-op.html">Circuit with Passive Elements, Operating Point</a>.</p>
      </section>

      <section id="supported-analyses">
        <h2>Supported Analyses*</h2> <!-- section 1.2 -->
      </section>

      <section id="description">
        <h2>Circuit Description</h2>
        <section id="structure-and-conventions">
          <h3>General Structure and Conventions</h3>
          <p>The circuit to be analyzed is described to ngspice by a set of <strong>element lines</strong>, which define the circuit topology and element values, and a set of <strong>control lines</strong>, which define the model parameters and the run controls. All lines are assembled in an input file to be read by ngspice.</p>
          <p>Two lines are essential:</p>
          <ul>
            <li>
              <p>The first line in the input file must be the <strong>title</strong>, which is the only comment line that does not need any special character in the first place.</p>
            </li>
            <li>
              <p>The last line must be <code>.end</code> (mind the leading period).</p>
            </li>
          </ul>
          <p>The order of the remaining lines is arbitrary (except, of course, that continuation lines must immediately follow the line being continued).</p>

          <section>
            <h3>Circuit Elements</h3>
            <p>Each element in the circuit is specified by an element line that contains:</p>
            <ul>
              <li>the element name,</li>
              <li>the circuit nodes to which the element is connected, and</li>
              <li>the values of the parameters that determine the electrical characteristics of the element.</li>
            </ul>
            <p>The first letter of the element name specifies the element type. For example, a resistor name must begin with the letter R and can contain one or more characters. Hence, <code>R</code>, <code>R1</code>, <code>RSE</code>, <code>ROUT</code>, and <code>R3AC2ZY</code> are valid resistor names. Details of each type of device are supplied below.</p>
            <p>Fields on a line are separated by one or more blanks, a comma, an equal (=) sign, or a left or right parenthesis; extra spaces are ignored. A line may be continued by entering a <q>+</q> (plus) in column 1 of the following line; ngspice continues reading beginning with column 2. A name field must begin with a letter (A through Z) and cannot contain any delimiters. A number field may be an integer field (12, -44), a floating point field (3.14159), either an integer or floating point number followed by an integer exponent (1e-14, 2.65e3), or either an integer or a floating point number followed by one of the following scale factors:</p>
            <table border="1">
            <thead>
              <caption>Ngspice scale factors</caption>
              <tr> <th>Suffix</th> <th>Name</th> <th>Factor</th> </tr> </thead>
                   <tr> <td>T</td> <td>Tera</td> <td>10<sup>12</sup></td> </tr>
                   <tr> <td>G</td> <td>Giga</td> <td>10<sup>9</sup></td> </tr>
                   <tr> <td>Meg</td> <td>Mega</td> <td>10<sup>6</sup></td> </tr>
                   <tr> <td>K</td> <td>Kilo</td> <td>10<sup>3</sup></td> </tr>
                   <tr> <td>mil</td> <td>Mil</td> <td>25.4 × 10<sup>−6</sup></td> </tr>
                   <tr> <td>m</td> <td>milli</td> <td>10<sup>−3</sup></td> </tr>
                   <tr> <td>u</td> <td>micro</td> <td>10<sup>−6</sup></td> </tr>
                   <tr> <td>n</td> <td>nano</td> <td>10<sup>−9</sup></td> </tr>
                   <tr> <td>p</td> <td>pico</td> <td>10<sup>−12</sup></td> </tr>
                   <tr> <td>f</td> <td>femto</td> <td>10<sup>−15</sup></td> </tr>
            </table>
            <p>Letters immediately following a number that are not scale factors are ignored, and letters immediately following a scale factor are ignored. Hence, 10, 10V, 10Volts, and 10Hz all represent the same number, and M, MA, MSec, and MMhos all represent the same scale factor. Note that 1000, 1000.0, 1000Hz, 1e3, 1.0e3, 1kHz, and 1k all represent the same number.</p>

            <p>Node names may be arbitrary character strings and are case insensitive. The ground node must be named <q>0</q> (zero). For compatibility reason <q>gnd</q> is accepted as ground node, and will internally be treated as a global node and be converted to <q>0</q>.</p>
            <p>Each circuit has to have a ground node (gnd or 0)!</p>
            <p>Note the difference in ngspice where the nodes are treated as character strings and not evaluated as numbers, thus <q>0</q> and <q>00</q> are distinct nodes in ngspice but not in SPICE2.</p>
            <hr/>
            <p>Ngspice requires that the following topological constraints are satisfied:</p>
            <ul>
              <li>The circuit cannot contain a loop of voltage sources and/or inductors and cannot contain a <strong>cut-set</strong> of current sources and/or capacitors.</li>
              <li>Each node in the circuit must have a dc path to ground.</li>
              <li>Every node must have at least two connections except for transmission line nodes (to permit unterminated transmission lines) and MOSFET substrate nodes (which have two internal connections anyway).</li>
            </ul>
          </section>
          <section id="basic-lines">
            <h3>Basic lines</h3>
            <section id="title">
              <h4>Title</h4>
              <p>Example:</p>
              <pre>POWER AMPLIFIER CIRCUIT
* additional comment lines following
*...</pre>
              <p>You can also precede the title with period command <code>.TITLE</code>:</p>
              <pre>.TITLE line example:
* additional lines following
* ...</pre>
            </section>
            <section id="end">
              <h4><code>.END</code> Line</h4>
              <p>The <q>.End</q> line must always be the last in the input file. Note that the period is an integral part of the name.</p>
              <p>Example:</p>
              <pre>. end</pre>
            </section>
            <section id="comments">
              <h4>Comments</h4>
              <p>The general form of a whole line comment is:</p>
              <pre>* &lt;<var>any comment</var>&gt;</pre>
              <p>Examples:</p>
              <pre>* RF=1K Gain should be 100
* Check open−loop gain and phase margin</pre>
              <p>The asterisk in the first column indicates that this line is a comment line. Comment lines may be placed anywhere in the circuit description.</p>
              <hr/>
              <p>The general form of end-of-line comments is:</p>
              <pre>&lt;<var>any command</var>&gt; ; &lt;<var>any comment</var>&gt;</pre>
              <p>Examples:</p>
              <pre>RF2=1K ; Gain should be 100
C1=10 p $ Check open−loop gain and phase margin</pre>
              <p>ngspice also supports comments that begin with single characters ’;’ or double characters ’$ ’ or ’//’ or ’- -’.</p>
            </section>
          </section>
          <section id="device-models">
              <h3>Device Models</h3>
              <p>General form:</p>
              <pre>.model mname type ( pname1=pval1 pname2=pval2 ... )</pre>
              <p>Example:</p>
              <pre>.model MOD1 npn ( bf=50 is=1e−13 vbf=50 )</pre>
              <p>Most simple circuit elements typically require only a few parameter values. However, some devices (semiconductor devices in particular) that are included in ngspice require many parameter values. Often, many devices in a circuit are defined by the same set of device model parameters. For these reasons, a set of device model parameters is defined on a separate <code>.model</code> line and assigned a unique model name. The device element lines in ngspice then refer to the model name.</p>
              <p>For these more complex device types, each device element line contains the device name, the nodes to which the device is connected, and the device model name. In addition, other optional parameters may be specified for some devices: geometric factors and an initial condition<!-- (see the following section on Transistors (8 to 11) and Diodes (7) for more details)-->. <var>mname</var> in the above is the model name, and <var>type</var> is one of the following fifteen types:</p>
              <table border="1">
                  <caption>Ngspice model types</caption>
                  <thead> <tr> <th>Code</th> <th>Model Type</th> </tr> </thead>
                          <tr> <td>R</td> <td>Semiconductor resistor model</td> </tr>
                          <tr> <td>C</td> <td>Semiconductor capacitor model</td> </tr>
                          <tr> <td>L</td> <td>Inductor model</td> </tr>
                          <tr> <td>SW</td> <td>Voltage controlled switch</td> </tr>
                          <tr> <td>CSW</td> <td>Current controlled switch</td> </tr>
                          <tr> <td>URC</td> <td>Uniform distributed RC model</td> </tr>
                          <tr> <td>LTRA</td> <td>Lossy transmission line model</td> </tr>
                          <tr> <td>D</td> <td>Diode model</td> </tr>
                          <tr> <td>NPN</td> <td>NPN BJT model</td> </tr>
                          <tr> <td>PNP</td> <td>PNP BJT model</td> </tr>
                          <tr> <td>NJF</td> <td>N-channel JFET model</td> </tr>
                          <tr> <td>PJF</td> <td>P-channel JFET model</td> </tr>
                          <tr> <td>NMOS</td> <td>N-channel MOSFET model</td> </tr>
                          <tr> <td>PMOS</td> <td>P-channel MOSFET model</td> </tr>
                          <tr> <td>NMF</td> <td>N-channel MESFET model</td> </tr>
                          <tr> <td>PMF</td> <td>P-channel MESFET model</td> </tr>
              </table>
              <p>Parameter values are defined by appending the parameter name followed by an equal sign and the parameter value. Model parameters that are not given a value are assigned the default values given below for each model type. Models are listed in the section on each device along with the description of device element lines<!--. Model parameters and their default values are given in chapter 30.--></p>
          </section>
          <section>
              <h3>Subcircuits</h3>
              <p>A subcircuit that consists of ngspice elements can be defined and referenced in a fashion similar to device models. Subcircuits are the way ngspice implements hierarchical modeling, but this is not entirely true because each subcircuit instance is flattened during parsing, and thus ngspice is not a hierarchical simulator.</p>
              <p>The subcircuit is defined in the input deck by a grouping of element cards delimited by the <code>.subckt</code> and the <code>.ends</code> cards<!-- (or the keywords defined by the substart and subend options (see 17.7))-->; the program then automatically inserts the defined group of elements wherever the subcircuit is referenced. Instances of subcircuits within a larger circuit are defined through the use of an instance card which begins with the letter <q>X</q>. A complete example of all three of these cards follows:</p>
              <pre>* The following is the instance card :
*
xdiv1 10 7 0 vdivide

* The following are the subcircuit definition cards :
*
.subckt vdivide 1 2 3
  r1 1 2 10 K
  r2 2 3 5 K
.ends</pre>
              <p>The above specifies a subcircuit with ports numbered <q>1</q>, <q>2</q> and <q>3</q>:</p>
              <ul>
                <li>Resistor <var>R1</var> is connected from port “1” to port “2”, and has value 10 kOhms.</li>
                <li>Resistor <var>R2</var> is connected from port “2” to port “3”, and has value 5 kOhms.</li>
              </ul>
              <p>The instance card, when placed in an ngspice deck, will cause subcircuit port “1” to be equated to circuit node “10”, while port “2” will be equated to node “7” and port “3” will equated to node “0”.</p>
              <p>There is no limit on the size or complexity of subcircuits, and subcircuits may contain other subcircuits.<!-- An example of subcircuit usage is given in chapter 20.6.--></p>
              <hr/>
              <p>The general form of the <code>.SUBCKT</code> line is:</p>
              <pre>.SUBCKT subnam N1 &lt;N2 N3 . . . &gt;</pre>
              <p>Example:</p>
              <pre>. SUBCKT OPAMP 1 2 3 4</pre>
              <p>A circuit definition is begun with a <code>.SUBCKT</code> line. <var>SUBNAM</var> is the subcircuit name, and <var>N1</var>, <var>N2</var>, ... are the external nodes, which cannot be zero. The group of element lines which immediately follow the <code>.SUBCKT</code> line define the subcircuit. The last line in a subcircuit definition is the <code>.ENDS</code> line (<i>see</i> below). Control lines may not appear within a subcircuit definition; however, subcircuit definitions may contain anything else, including other subcircuit definitions, device models, and subcircuit calls (<i>see</i> below). Note that any device models or subcircuit definitions included as part of a subcircuit definition are strictly local (i.e., such models and definitions are not known outside the subcircuit definition). Also, any element nodes not included on the <code>.SUBCKT</code> line are strictly local, with the exception of 0 (ground) which is always global. If you use parameters, the <code>.SUBCKT</code> line will be extended<!-- (see 2.8.3)-->.</p>
              <p>The <code>.ENDS [<var>subcircuit_name</var>]</code> line must be the last one for any subcircuit definition. The subcircuit name, if included, indicates which subcircuit definition is being terminated; if omitted, all subcircuits being defined are terminated. Therefore, the name is needed only when nested subcircuit definitions are being made.</p>
              <p>Last, a subcircuit is called with syntax:</p>
              <pre>X&lt;<var>any_name</var>&gt; <var>N1</var> [N2 N3 ...] <var>subnam</var></pre>
              <p>For example:</p>
              <pre>X1 2 4 17 3 1 MULTI</pre>
              <p>Subcircuits are used in ngspice by specifying pseudo-elements beginning with the letter <q>X</q>, followed by the circuit nodes to be used in expanding the subcircuit. If you use parameters, the subcircuit call will be modified<!-- (see 2.8.3).--></p>
          </section>
          <section>
            <h3>Other Dot Directives</h3>
            <section>
              <h4><code>.GLOBAL</code></h4> <!-- section 2.5 on page 51 -->
              <p>General form:</p>
              <pre>.GLOBAL <var>nodename1</var> [ <var>nodename2</var> ... ]</pre>
              <p>Examples:</p>
              <pre>. GLOBAL gnd vcc</pre>
              <p>Nodes defined in the <code>.GLOBAL</code> statement are available to all circuit and subcircuit blocks independently from any circuit hierarchy. After parsing the circuit, these nodes are accessible from top level.</p>
            </section>
            <section>
              <h4><code>.INCLUDE</code></h4>
              <p>General form:</p>
              <pre>.INCLUDE <var>filename</var></pre>
              <p>Examples:</p>
              <pre>. INCLUDE /users/spice/common/bsim3-param.mod</pre>
              <p>Frequently, portions of circuit descriptions will be reused in several input files, particularly with common models and subcircuits. In any ngspice input file, the <code>.INCLUDE</code> line may be used to copy some other file as if that second file appeared in place of the <code>.INCLUDE</code> line in the original file.</p>
              <p>If the filename is a relative path and the file is not found, it is searched for in the locations given by variable <code>sourcepath</code>. There is no restriction on the file name imposed by ngspice beyond those imposed by the local operating system.</p>
            </section>
            <section>
              <h4><code>.LIB</code></h4>
              <p>General form:</p>
              <pre>.LIB <var>filename</var> <var>libname</var></pre>
              <p>Examples:</p>
              <pre>.LIB /users/spice/common/mosfets.lib mos1</pre>
              <p>The <code>.LIB</code> statement allows including library descriptions into the input file. Inside the <cite>*.lib</cite> file a library libname will be selected. The statements of each library inside the <cite>*.lib</cite> file are enclosed in <code>.LIB <var>libname</var> &lt;...&gt; .ENDL</code> statements. The file is searched for in the same way as for <code>.include.</code></p>
              <p>If the compatibility mode is set to <q>ps</q> by <code>set ngbehavior=ps</code> in <code>spinit</code> or <code>.spiceinit</code>, then a simplified syntax <code>.LIB <var>filename</var></code> is available: a warning is issued and filename is simply included.</p>
            </section>
          </section>
        </section>
        <section>
              <h3><code>.PARAM</code> for Parametric netlists</h3>
              <p>Ngspice allows for the definition of parametric attributes in the netlists. This is an enhancement of the ngspice front-end that adds arithmetic functionality to the circuit description language.</p>
              <p>The general form of a <code>.param</code> line is:</p>
              <pre>.param &lt;<var>ident</var>&gt;= &lt;<var>expr</var>&gt; &lt;<var>ident</var>&gt;=&lt;<var>expr</var>&gt;...</pre>
              <p>Examples:</p>
              <pre>.param pippo = 5
.param po = 6 pp = 7.8 pap = { AGAUSS (pippo, 1, 1.67)}
.param pippp = { pippo + pp }
.param p = { pp }
.param pop = 'pp + p'</pre>
              <p>This line assigns numerical values to identifiers. More than one assignment per line is possible using a separating space. Parameter identifier names must begin with an alphabetic character. The other characters must be either alphabetic, a number, or ! # $ % [ ] _ as special char  acters. The variables time, temper, and hertz (see 5.1.1) are not valid identifier names. Other restrictions on naming conventions apply as well<!--, see 2.9.6-->.</p>
              <p>The <code>.param</code> lines inside subcircuits are copied per call, like any other line. All assignments are executed sequentially through the expanded circuit. Before its first use, a parameter name must have been assigned a value. Expressions defining a parameter should be put within braces <code>{p+p2}</code>, or alternatively within single quotes <code>'AGAUSS(pippo, 1, 1.67)'</code>. An assignment cannot be self-referential, something like <code>.param pip = 'pip+3'</code> will not work.</p>
              <p>The current ngspice version does not always need quotes or braces in expressions, especially when spaces are used sparingly. However, it is recommended to do so, as the following examples demonstrate.</p>
              <pre>.param a = 123*3 b=sqrt(9) $ doesn't work, a &lt;= 123
.param a = '123 * 3' b = sqrt (9) $ ok .
.param c = a + 123 $ won't work
.param c = 'a + 123 ' $ ok
.param c = a +123 $ ok</pre>
              <p>Parameters may also have string values, but support is limited. String-valued parameters can be
defined by <code>.param</code> and used in the same ways as numeric parameters. The only operation on
string values is concatenation and that is possible only in top-level <code>.param</code> assignments.</p>
<pre>.param str1 = "first" str2 = "second"
.param both ={str1}" and "str2</pre>
            </section>
            <section>
              <h4>Brace expressions in circuit elements</h4>
              <p>General form:</p>
              <pre>{&lt;<var>expression</var>&gt;}</pre>
              <p>These are allowed in <code>.model</code> lines and in device lines. A SPICE number is a floating point number with an optional scaling suffix, immediately glued to the numeric tokens. Brace expressions (<code>{..}</code>) cannot be used to parameterize node names or parts of names. All identifiers used within an <code><var>expr</var></code> must have known values at the time when the line is evaluated, else an error is flagged.</p>
            </section>
            <section>
              <h4>Subcircuit parameters</h4>
              <p>General form:</p>
              <pre>.subckt &lt;identn&gt; node node ... &lt;ident&gt;= &lt;value&gt; &lt;ident&gt;= &lt;value&gt; ...</pre>
              <p>Example:</p>
              <pre>.subckt myfilter in out rval =100 k cval =100 nF</pre>
              <p>&lt;identn&gt; is the name of the subcircuit given by the user. <var>node</var> is an integer number or an identifier, for one of the external nodes. The first &lt;ident&gt;=&lt;value&gt; introduces an optional section of the line. Each &lt;ident&gt; is a formal parameter, and each &lt;value&gt; is either a SPICE number or a brace expression. Inside the <code>.subckt ... .ends</code> context, each formal parameter may be used like any identifier that was defined on a <code>.param</code> control line. The &lt;value&gt; parts are default values of the parameters.</p>
              <p>The syntax of a subcircuit call (invocation) is:</p>
              <pre>X &lt;name&gt; node node ... &lt;identn&gt; &lt;ident&gt;=&lt;value&gt; &lt;ident&gt;= &lt;value&gt; ...</pre>
              <p>Example:</p>
              <pre>X1 input output myfilter rval=1k</pre>
              <p>Here &lt;name&gt; is the symbolic name given to that instance of the subcircuit, &lt;identn&gt; is the name of a subcircuit defined beforehand. <code><var>node</var> <var>node</var> ...</code> is the list of actual nodes where the subcircuit is connected. &lt;value&gt; is either a SPICE number or a brace expression {&lt;expr&gt;}.</p>
              <p>Subcircuit example with parameters:</p>
              <pre>* Param - example
.param amplitude = 1 V
*
.subckt myfilter in out rval=100 k cval=100 nF
Ra in p1 {2* rval }
Rb p1 out {2* rval }
C1 p1 0 {2* cval }
Ca in p2 { cval }
Cb p2 out { cval }
R1 p2 0 { rval }
.ends myfilter
*
X1 input output myfilter rval=1k cval=1n
V1 input 0 AC {amplitude}
.end</pre>
            </section>
            <section>
              <h4>Symbol scope</h4>
              <p><em>All subcircuit and model names are considered global and must be unique.</em> The <code>.param</code> symbols that are defined outside of any <code>.subckt ... .ends</code> section are global. Inside such a section, the pertaining params: symbols and any <code>.param</code> assignments are considered local: they mask any global identical names, until the <code>.ends</code> line is encountered. You cannot reassign to a global number inside a <code>.subckt</code>, a local copy is created instead. Scope nesting works up to a level of 10. For example, if the main circuit calls <var>A</var> that has a formal parameter <var>xx</var>, <var>A</var> calls <var>B</var> that has a param. <var>xx</var>, and <var>B</var> calls <var>C</var> that also has a formal param. <var>xx</var>, there will be three versions of <var>xx</var> in the symbol table but only the most local one --belonging to C-- is visible.</p>
            </section>
          </section>
          <section>
              <h3><code>.FUNC</code>*</h3>
              <p></p>
              <pre></pre>
            </section>
            <section>
              <h3><code>.CSPARAM</code>*</h3>
              <p></p>
              <pre></pre>
            </section>
            <section>
              <h3><code>.TEMP</code>*</h3>
              <p></p>
              <pre></pre>
              <p></p>
              <pre></pre>
              <p></p>
              <pre></pre>
              <p></p>
              <pre></pre>
              <p></p>
              <pre></pre>
              <p></p>
              <pre></pre>
              <p></p>
              <pre></pre>
        </section>

      <section id="circuit-elements-and-models">
        <h2>Circuit Elements and Models*</h2>
        <p></p>
      </section>

      <section id="control-language">
        <h2>Control Language (Formerly Nutmeg)</h2>
        <p style="text-align: right">(From <cite><a target="_blank" href="https://ngspice.sourceforge.io/ngspice-control-language-tutorial.html">https://ngspice.sourceforge.io/ngspice-control-language-tutorial.html</a></cite>)</p>


        <p>ngspice circuit simulator offers a built-in control language (formerly know as nutmeg language). It allows to create scripts which automate the simulation flow and provide support for simulation data analysis.</p>
        <p>There are three basic methods to start a simulation with ngspice. The traditional method is the <dfn>batch mode</dfn>. With an input netlist given (see below), the command <code>ngspice -b -r inv-example.raw inv-example.cir</code> will start the simulation, executing the dot commands from the netlist, saving the simulation data in the <q>raw</q> file, without any further user interaction. Besides, we have the <dfn>interactive mode</dfn>. You start ngspice by <code>ngspice inv-example.cir</code>. ngspice sources the netlist and then waits for user input. You may type any of the commands found in chapter 17.5 of the <cite>ngspice manual</cite> or the <cite>ngspice xhtml manual</cite> to initiate some action (e.g. running the simulation, plotting or saving the data etc.). The real power of using these commands however is unfolded in the third mode of running ngspice, the <dfn>control mode</dfn>. You assemble a sequence of commands into a script, add this script to the netlist, and then start ngspice as usual by <code>ngspice inv-example.cir</code>. ngspice will execute the commands from the script, enabling multiple simulations, loops, data processing, plotting and saving data. About 100 commands are available, scripts may range from simple ones with few lines up to complex ones with several hundred commands.</p>
        <p>More info on starting ngspice is available in chapter 16.4 of the ngspice manual. Commands used in the scripts below are not all explained in detail, please use the <cite>ngspice manual chapter 17.5</cite> as your reference.</p>
        <aside>
          <p>The control section is enclosed between directives <code>.control</code> and <code>.endc</code>:</p>
          <pre>.control
* lines with control commands
.endc</pre>
        </aside>
        <section id="tran">
          <h3><code>.tran</code> and <code>tran</code>*</h3>
          <p>...</p>
          <pre>tran 100p 500n</pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section id="tran">
          <h3><code>dc</code> and <code>tran</code>*</h3>
          <p></p>
          <pre>dc vin 0 2 0.01</pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3>Looping a simulation, altering the supply voltage</h3>
          <p>The next script executes a repeat loop. For five times the inverter supply voltage is changed, each time a new dc simulation is run. Finally all dc simulation results are plotted in a single plot. In addition we plot the inverter gain and its current consumption during the dc sweep.</p>
          <pre>* control language script
.control
let vccc = 1.2            ; create a vector vccc and assign value 1.2
repeat 5                  ; loop start
  alter Vcc $&amp;vccc        ; alter the voltage Vcc using vector vccc
  dc vin 0 2 0.01         ; run the dc simulation
  let vccc = vccc + 0.2   ; calculate new voltage value for Vcc by updating vector vccc
end                       ; loop end, jump back to loop start
set xbrushwidth=2         ; assign value 2 to the predefined variable
plot dc1.v(out) dc2.v(out) dc3.v(out) dc4.v(out) dc5.v(out)
set nounits               ; do not plot units on the x and y axes.
plot deriv(dc1.v(out)) deriv(dc2.v(out)) deriv(dc3.v(out)) deriv(dc4.v(out)) deriv(dc5.v(out)) ylabel 'Inverter gain V / V' xlabel 'vsweep V'
unset nounits             ; undo the previous set command
plot dc1.I(vcc) dc2.I(vcc) dc3.I(vcc) dc4.I(vcc) dc5.I(vcc) ylabel 'Inverter current consumption'
.endc</pre>
          <p>Several new concepts are introduced in this script. Please refer to chapter 17.5 of the manual for details of the commands. <code>repeat 5 ... end</code> will loop the enclosed commands five times. <code>let vccc = 1.2</code> creates a vector (of length 1) and assigns a value 1.2 to it. <code>let vccc = vccc + 0.2</code> adds 0.2 to the current vector value. alter <code>Vcc $&amp;vccc</code> changes the voltage <var>Vcc</var> according to the value of vector <var>vccc</var>. <code>$&amp;vccc</code> returns the value of vector <var>vccc</var>. <code>nounits</code> and <code>xbrushwidth</code> are predefined variables (<i>see</i> manual chapter 17.7). Command <code>plot</code> generates a graphical output by plotting one or several vectors versus a scale vector (predefined is scale vector <q>time</q> for transient, <q>v-sweep</q> for dc). The results of the last and all previous dc simulations are accessed by <code>dc1.v(out) dc2.v(out) ...</code>. This will be explained in the next paragraph. <code>plot deriv(dc1.v(out))</code> uses function <code>deriv</code>, returning the derivative of v(out) versus v-sweep (see manual, chapt. 17.2), therefore plotting the voltage gain of the inverter. The supply current during dc sweep is measured as current out of the voltage source <var>Vcc</var>, thus appearing negative.</p>
        </section>
        <section>
          <h3>About plots, variables and vectors</h3>
          <p>The output data of any simulation is available as vectors. An operating point simulation will create vectors of length 1. A dc simulation will create vectors with length determined by the number of points during sweeping. These vectors are stored in <strong>plots</strong>, a traditional SPICE notion (see also chapter 17.3 of the manual). <q>Plot</q> here is not to be confused with a plot resulting from plotting data. So a plot is a group of vectors. In our previous example the first <code>dc</code> command will generate several vectors within a plot <var>dc1</var>. A subsequent <code>dc</code> command will store their vectors in plot <var>dc2</var> and so on. Transient simulation vectors would have been stored in plots <var>tran1</var>, <var>tran2</var>, etc. So each simulation command (<code>dc</code>, <code>op</code>, <code>tran</code>, <code>sp</code> ...) creates a new plot. The lastly created plot will stay active, until another plot is created or selected. There are also some functions creating their own plots, e.g. <code>fft</code> or <code>linearize</code>. The command <code>setplot</code> will show all plots and mark the active plot. For our example we have this</p>
          <pre>List of plots available:

Current dc5	inverter example circuit for control language tutorial (DC transfer characteristic)
	dc4	inverter example circuit for control language tutorial (DC transfer characteristic)
	dc3	inverter example circuit for control language tutorial (DC transfer characteristic)
	dc2	inverter example circuit for control language tutorial (DC transfer characteristic)
	dc1	inverter example circuit for control language tutorial (DC transfer characteristic)
	const	Constant values (constants)</pre>
          <p>with <var>dc5</var> being the current plot. There is a pre-defined plot named <code>const</code>. It contains several constants. Command <code>display</code> will list all vectors in the current plot. <code>setplot dc2</code> will switch the current plot to <var>dc2</var>.</p>
          <pre>Here are the vectors currently active:

Title: inverter example circuit for control language tutorial
Name: dc5 (DC transfer characteristic)
Date: Tue Jun  7 17:25:58  2022

    cc                  : voltage, real, 201 long
    in                  : voltage, real, 201 long
    out                 : voltage, real, 201 long
    v-sweep             : voltage, real, 201 long [default scale]
    vcc#branch          : current, real, 201 long
    vin#branch          : current, real, 201 long</pre>
          <p><code>[default scale]</code> denotes the scale vector, which is used as X axis (during plotting or for calculating the derivative). Vectors contain numbers (format double as real or complex numbers). They may contain a single value, be one-dimensional or multi-dimensional. In the above example we have vectors of real numbers of length 201 each. Vectors are local to their plot. You may access vectors from a different plot by prepending the plot name to the vector name, separated by a dot, e.g. <code>dc1.v(out)</code> or <code>dc2.I(vcc)</code>. <code>Btw. I(vcc)</code> is equal to <code>vcc#branch</code>, the branch current through voltage source <var>Vcc</var>. The user may create their own vectors with the <code>let</code> command, e.g. by <code>let vccc = 1.2</code>. As this command has been given before any simulation is run, the vector <var>vccc</var> will reside in plot <var>const</var>. All vectors in plot <var>const</var> are globally available, no need to prepend anything.</p>
          <p>Another class of storage elements is created by the ngspice variables. These are globally accessible and may contain numbers, strings, or lists. There are pre-defined variables (see manual chapter 17.7) which control many ngspice features. The command <code>set</code> will instantiate a variable and/or assign a content of it. in our example we have used the pre-defined <code>set xbrushwidth=2</code> to increase the plotting line width.</p>
        </section>
        <section>
          <h3>Looping a simulation, plot the maximum gain versus supply voltage</h3>
          <p>In the following example the loop is used to simulate and extract the inverter's voltage gain as function of its supply voltage. We simulate the output versus input of the inverter as a series of dc sweeps, the maximum gain for each voltage is determined and saved for plotting.</p>
          <pre>* control language script
.control
let loops = 6                     ; number of loops, vector in plot 'const'
let vecmaxgain = vector(loops)    ; vector in plot 'const'
let vecvcc = vector(loops)        ; vector in plot 'const'
let vccc = 1.0                    ; supply voltage in plot 'const'
let index = 0                     ; loop index in plot 'const'
repeat $&amp;loops                    ; loop start
  alter Vcc $&amp;vccc                ; alter the voltage Vcc
  dc vin 0 2 0.01                 ; run the dc simulation
  let gain = deriv(v(out))        ; calculate the gain
  let maxgain = vecmin(gain)      ; find the maximum of the gain (min because gain is negative)
  let vecmaxgain[index] = maxgain ; store the maximum gain
  let vecvcc[index] = vccc        ; store the corresponding voltage
  let vccc = vccc + 0.2           ; calculate new voltage value for Vcc
  let index = index + 1           ; raise the index
end                               ; loop end
destroy all                       ; delete all plot dc1 ..., no longer needed
set xbrushwidth=2                 ; linewidth of graph
set nolegend                      ; no legend on graph
plot vecmaxgain vs vecvcc xlabel 'Inverter supply voltage /V' ylabel 'Inverter gain V/V'
.endc                             ; end of control section</pre>
          <p>The vectors loops, vecmaxgain, vecvcc, vccc, and index are created in plot const, which is the current plot in the beginning of the script execution, before any simulation command is run. So these vectors will be accessible from within all plots created later by the simulation runs.</p>
          <p>vector loops sets the number of loops and the size of the data storage vectors vecmaxgain and vecvcc. repeat $&amp;loops requires $&amp;loops for reading the vector value.</p>
          <p>During each simulation run the voltage Vcc is set, the dc simulation executed, the derivative of the output vector v(out) calculated, its maximum (minimum of the negative gain as function of the sweep voltage) determined and saved to the indexed location of vecmaxgain, together with vccc saved to vecvcc. Finally supply voltage and index are increased appropriately.</p>
          <p>After the loop has ended, the command destroy all deletes all plots created during dc simulation (dc1 to dc6). They are no longer needed, so we save their memory. set nolegend supresses the legend, because we have only a single vector plotted. plot vecmaxgain vs vecvcc plots our new output (the max gain) versus the user selected scale, the corresponding supply voltage.</p>
          <p>An alternative to the destroy all is to delete only the most recent (current) plot by destroy $curplot, now from inside the loop. curplot is another predefined variable containing a string with the name of the current plot. Accessing the string is possible by the prepended $.</p>
          <pre>...
  let index = index + 1           ; raise the index
  destroy $curplot                ; remove the current plot (created by dc...)
end                               ; loop end
set xbrushwidth=2                 ; linewidth of graph</pre>
        </section>
        <section>
          <h3>Looping the simulation as before, no plot, write data to file only</h3>
          <p>The inverter's voltage gain is determined as in the example above. The result is, however, not plotted, but written into a file as a simple table.</p>
          <pre>* control language script
.control
let loops = 11                    ; number of loops, vector in plot 'const'
let vccc = 1.0                    ; supply voltage in plot 'const'
repeat $&amp;loops                    ; loop start
  alter Vcc $&amp;vccc                ; alter the voltage Vcc
  dc vin 0 2 0.01                 ; run the dc simulation
  let gain = deriv(v(out))        ; calculate the gain
  let maxgain = vecmin(gain)      ; find the maximum of the gain (min because gain is negative)
  setscale vccc                   ; define the x axis (scale) with vector of length 1
  wrdata mgain.out maxgain        ; write out maxgain versus vccc for the current plot
  let vccc = vccc + 0.1           ; calculate new voltage value for Vcc
  destroy $curplot                ; remove the current plot (created by dc...)
  set appendwrite                 ; wrdata now adds data to existing file mgain.out
end                               ; loop end
.endc                             ; end of control section</pre>
          <p><code>wrdata</code> writes vector(s) to a file as a simple table. Each vector is written as a pair, first the scale (x axis value), then the output value. In our case the output is maxgain (vector of length 1). The scale after a dc simulation is the voltage sweep. This is not what we need here, as the scale for maxgain is vccc. So we use setscale vccc to re-define the scale (before writing to file). wrdata creates a file or overwrites an existing file with the current data. Here we use a trick: When entering the loop for the first time, wrdata mgain.out maxgain creates the file mgain.out. Then, after first writing, set appendwrite is issued. From then on, wrdata appends all data to the already existing file. Calling set appendwrite several times does not hurt.</p>
        </section>
        <section>
          <h3>About loops in general</h3>
          <p>Several control structures are available for creating loops. Each loop starts with a keyword and ends with end. Nesting is supported. We use vectors (instatiated by let, de-referenced by $&amp;, like $&amp;loopindex) and variables (instantiated by set, de-referenced by $, like $val).</p>
          <p>Here we have foreach...end and if...else...end:</p>
          <pre>foreach val -40 -20 0 20 40
  if $val &lt; 0
    echo variable $val is less than 0
  else
    echo variable $val is greater than or equal to 0
  end
end</pre>
          <p>dowhile allows looping until a condition is fulfilled. The condition is tested after the statements in the loop have been executed:</p>
          <pre>let loopindex = 0
dowhile loopindex &lt;> 5
  echo index is $&amp;loopindex
  let loopindex = loopindex + 1
end</pre>
          <p>We have already used the repeat loop:</p>
          <pre>set loops = 7
repeat $loops
  echo How many loops? $loops
end</pre>
          <p>while allows looping until a condition is fulfilled. The condition is tested befor the statements are executed:</p>
          <pre>let loopindex = 0
while loopindex &lt; 5
  echo index is $&amp;loopindex
  let loopindex = loopindex + 1
end</pre>
          <p>In the Sourceforge <cite><a target="_blank" href="https://sourceforge.net/p/ngspice/ngspice/ci/master/tree/examples/loops/">git examples for loops</a></cite> page you will find examples netlists for all loops, ready to run. You may also have a look at the manual, chapter 17.6 on Control Structures, where additionally the commands label, goto, break and continue are described.</p>
        </section>
        <section>
          <h3>String substitution</h3>
          <p>Vectors contain numbers. They may be one-dimensional (often with only a single element, aka length = 1) or multi-dimensional. Variables may contain integer or real numbers, strings, a boolean yes, or a list of elements as strings.</p>
          <p>Both are used in the following script as part of new variables. Substitution is done by replacing the <code>{}</code> with the contents of the vector or variable element named inside of the <code>{}</code>.</p>
          <pre>*ng_script                ; this is a script only
.control
* simple replacement
let ii = 1                ; new 1D vector containing value 1
set myplot = tran2        ; new variable containing a string
* substitution
set subs1 = {$myplot}.out ; {} is substituted by string of variable <var>myplot</var>
set subs2 = dc{$&amp;ii}.in   ; {} is substituted by vector contents converted to string
echo $subs1 $subs2        ; print both variables

* somewhat more complex substitutions
let vec = vector(6)             ; new vector with 6 elements, numbered from 0 to 5
set myplots = ( tran3 dc5 op1 ) ; new variable with list of 3 elements, numbered from 1 to 3
let vec4 = vec[4]               ; intermediate stage, read vector element 4 into a new vector.
set subs3 = {$myplots[3]}.out   ; {} is substituted by element 3 of string list in variable myplots
set subs4 = dc{$&amp;vec4}.in       ; {} is substituted by vector contents converted to string
echo $subs3 $subs4              ; print both variables

.endc
.end</pre>
          <p>The outputs echoed to the console are:</p>
          <pre>tran2.out dc1.in
op1.out dc4.in</pre>
          <p>Some comments to this script are due:</p>
          <ul>
            <li><code>*ng_script</code> in the upper left of the first row will tell <code>ngspice</code> that a pure script is following, thus skipping any circuit parsing.</li>
            <li>Substitution may happen with a single element from a vector or variable.</li>
            <li>Elements of a vector are numbered by 0 to number-of-elements - 1</li>
            <li>elements of a string list in a variable are numbered 1 to number-of-elements.</li>
            <li>Elements of a vector may be used for substituting only after an intermediate step of converting them to a vector of length 1.</li>
            <li>When defining a list variable, take care for spaces between ( or ) and the elements.</li>
          </ul>
        </section>
        <section>
          <h3>Nested loops</h3>
          <p>In the following netlist there is a very simple circuit: 3 resistors in series, powered by a voltage source. We want to change each resistor using the <code>alter</code> command. We use 3 interlaced while loops.</p>
          <pre>3 interlaced while loops, simple circuit

R1 1 11 1
R2 11 12 1
R3 12 0 1

V1 1 0 1

.control
* initialization (vectors in plot const)
let rsta1 = 1k
let rsto1 = 5k
let rste1 = 1k
let rsta2 = 200  ; start value for R2
let rsto2 = 1000 ; stop value
let rste2 = 200  ; step value
let rsta3 = 20
let rsto3 = 200
let rste3 = 20
let rloop1 = rsta1
let rloop2 = rsta2 ; loop value for R2
let rloop3 = rsta3
* three nested while loops
while rloop1 &lt; rsto1
  alter R1 rloop1
  while rloop2 &lt; rsto2
    alter R2 rloop2 ; modify R2 by current rloop2 value
    while rloop3 &lt;= rsto3
      alter R3 rloop3
      op
      let rtotal = rloop1 + rloop2 + rloop3
      echo $&amp;rloop1 $&amp;rloop2 $&amp;rloop3 $&amp;rtotal $&amp;V1#branch
      let rloop3 = rloop3 + rste3
    end
    let rloop3 = rsta3
    let rloop2 = rloop2 + rste2 ; calculate new rloop2 value
  end
  let rloop2 = rsta2            ; reset rloop2 to its start value
  let rloop1 = rloop1 + rste1
end
rusage
.endc

.end</pre>
          <p>In varying each resistor, each resistor gets its vectors for the start, stop and step values. The three <code>rloop</code> vectors will be varied during looping.</p>
          <p>One has to be careful where to place the command lines <code>alter R2 rloop2</code>, and <code>let rloop2 = rloop2 + rste2</code>. Right after a loop has finished, its corresponding rloop vector has to be reset to its start value, e.g. by <code>let rloop2 = rsta2</code> again.</p>
        </section>
        <section>
          <h3>Emulate nested <code>.step</code> commands</h3>
          <p>Creating nested loops and running several simulations in series without external intervention are a powerful tool to characterize circuits. Unfortunately, currently ngspice does not offer the <code>.step</code> command, which may simplify setting up such simulation loops. However the control language allows us to emulate such behaviour. The netlist below will emulate code like</p>
          <pre>.step lin R1 list 10k 20k 30k
.step lin C2 list 1u 0.5u 0.25u
.step lin R2 list 1m 3.3k 6.6k</pre>
          <p>In the future ngspice may be able to translate such <code>.step</code> commands into emulating control sections automatically and transparently to the user, thus simplifying their job. For now we may use such a netlist for learning about some new features of the control language.</p>
          <pre>* .step emulation: 3 nested loops, ac simulation
* R1, C2 change by param, R2 changes directly
* loops by foreach
* commands alterparam, alter: all three alter commands inside of inner loop
* alterparam first, followed by reset, only then followed by alter
* print out the results into a file threeloopsac.txt, located in the input
* directory (where this netlist has been found).

.param rr1 = 1k cc2 = 1u

V1 1 0 dc 0 ac 1
R1 1 11 {rr1}
R2 11 10 100
C2 10 0 {cc2}

.ac dec 10 1 1e4

.control
let index = 0        ; new loop index vector (in plot 'const')
set plotstrdb = ' '  ; new variable containing string with space (will become a list of strings, see below)
set plotstrph = ' '  ; new variable containing string with space (will become a list of strings, see below)
set writestr = ' '   ; new variable containing string with space (will become a list of strings, see below)
set cvalues = ( 1u 0.5u 0.25u ) ; variable containing loop values for C2

** loop start **
foreach val1 10k 20k 30k                                    ; outermost loop with a value list
  foreach val2 $cvalues                                     ; loop in the middle with a variable containing a value list
    foreach val3 1m 3.3k 6.6k                               ; inner loop with a value list
      let index = index + 1                                 ; raise loop index
      echo ac sim no. $&amp;index',' R1=$val1',' R2=$val3',' C2=$val2 ; print to console where we are
      alterparam rr1 = $val1                                ; change parameter of outer loop
      alterparam cc2 = $val2                                ; change paramater of middle loop
      reset                                                 ; reset to activate above parameter changes
      alter R2 $val3                                        ; change inner loop value (possible only after reset!)
      run                                                   ; run the simulation (see .ac ... above)
      set plotstrdb = ( $plotstrdb db({$curplot}.v(10)) )   ; add a new item (string) to already exising list of strings
      set plotstrph = ( $plotstrph cph({$curplot}.v(10)) )  ; add a new item (string) to already exising list of strings
      set writestr = ( $writestr {$curplot}.v(10) )         ; add a new item (string) to already exising list of strings
    end
  end
end
** loop end, start plotting **
set nolegend                  ; legend for 27 graphs is unreadable
set units=degrees             ; phase in degrees
set xbrushwidth=2             ; increase linewidth of graphs
plot $plotstrdb xlimit 1 1e4  ; plot all 27 magnitudes
plot $plotstrph xlimit 1 1e4  ; plot all 27 phases
set wr_singlescale            ; for wrdata: write the scale only once
set wr_vecnames               ; for wrdata: write the vector names
option numdgt = 3             ; for wrdata: 3 digits after decimal point
wrdata $inputdir/threeloopsac.txt $writestr  ; write ac output v(10) into file for all runs
rusage                        ; list some resource usage
.endc

.end</pre>
          <p>The output file, written by command wrdata, looks like this:</p>
          <pre>frequency  ac1.v(10)  ac1.v(10)  ac2.v(10)  ac2.v(10)  ac3.v(10)  ac3.v(10) ...
 1.000e+00  9.961e-01 -6.258e-02  9.931e-01 -8.299e-02  9.892e-01 -1.032e-01 ...
 1.259e+00  9.938e-01 -7.861e-02  9.891e-01 -1.041e-01  9.831e-01 -1.291e-01 ...
 1.585e+00  9.902e-01 -9.860e-02  9.828e-01 -1.302e-01  9.734e-01 -1.609e-01 ...
 1.995e+00  9.845e-01 -1.234e-01  9.730e-01 -1.622e-01  9.585e-01 -1.995e-01 ...
 ...</pre>
          <p>The first column is the frequency, the next 2 columns are the real and the imaginary parts of complex vector v(10) from plot ac1, then follow real and imaginary parts of vector V(10) from plot ac2 etc.</p>
          <p>Some comments also here: The circuit is simply two resistors in series (<var>R1</var> + <var>R2</var>) with capacitor <var>C2</var> from output <var>v(1)</var> to ground, a low pass filter. We set three variables in the beginning, each containing just a space. '...' delimit a string, even if it contains special characters (e.g. a space). Three nested <code>foreach</code> loops are used with a value list or with a variable containing such a list. The echo command in the loop again uses '...' for formatting. Otherwise spaces or commas would just be swallowed and replaced by a single space. The <code>alterparam</code> command has to be followed by a <code>reset</code> command to become activated. Also, <code>alter</code> commands are resetted by <code>reset</code>. Therefore all three altering commands have to be in the inner loop, repeated each time the loop is executed. Any <code>alterparam</code> has to come first, then <code>reset</code>, only then any <code>alter</code> (or <code>altermod</code>) commands.</p>
          <p><code>set plotstrdb = ( $plotstrdb db({$curplot}.v(10)) )</code> requires some explanation: <code>{$curplot}.v(10)</code> substitutes the {} part with the name of the current plot (e.g. <var>ac3</var>), just to obtain, say, <var>ac3.v(10)</var>. This string, embedded in <code>db(...)</code> is added to the variable <var>plotstrdb</var>, increasing its string list. In the beginning <var>plotstrdb</var> started with a space, then one item is added per loop, e.g. yielding <var>db(ac1.v(10))</var> <var>db(ac2.v(10))</var> <var>db(ac3.v(10))</var> ....</p>
          <hr/>
          <p>Another group of <code>.step</code> commands loops the temperature and device parameters given by a start, stop and step value for each parameter, like</p>
          <pre>* .step temp -55 125 10
* .step npn 2N2222 (VAF) 50 300 50
* .step param R1 2k 10k 2k</pre>
          <p>Again there are three nested loops, but now we use the <code>while ... end</code> loop command.</p>
          <pre>*** Emulate the .step command

.param ptemp = -55 R1 = 2k
.temp {ptemp}                      ; set the overall circuit temperature

V1 vcc 0 5                         ; the circuit
R1 vcc cc {R1}
Q1 cc bb 0 BC546B
R2 vcc bb 500k

.probe I(Q1)                       ; measure the Q1 terminal currents
.save all                          ; not only save the Q1 current values, but all node values

.op

.control
let index = 1                       ; new loop index vector (in plot 'const')
let tcur = 25                       ; new temperature vector (in plot 'const')
while tcur &lt;= 125                   ; the temperature loop
  let mvaf = 50                     ; new model parameter vector (in plot 'const')
  while mvaf &lt;= 300                 ; the VAF loop
    let rr1 = 2k                    ; new resistance parameter vector (in plot 'const')
    while rr1 &lt;= 10k                ; the resistor R1 loop
      echo
      echo
      echo *** op no. $&amp;index',' R1=$&amp;rr1',' VAF=$&amp;mvaf',' temp=$&amp;tcur *** ; print to console where we are
      alterparam ptemp = $&amp;tcur     ; change the temperature parameter
      alterparam R1 = $&amp;rr1         ; change the R1 resistance parameter
      reset                         ; activate the parameter changes by reloading the ciruit
      altermod BC546B VAF = $&amp;mvaf  ; change the VAF model parameter
      run                           ; run the op simulation
      print v(cc) v(bb) i(q1:c) i(q1:b) ; the data output, i(q1:c) is the same as q1:c#branch
      let rr1 = rr1 + 2k            ; new resistance value
      let index = index + 1
    end
    let mvaf = mvaf + 50            ; new VAF value
  end
  let tcur = tcur + 10              ; new temperature value
end
display
rusage
.endc

*From Philips SC04 "Small signal transistors 1991"
* Base spreading parameters (RB,IRB,RBM) estimated. TR derived using BCY58 data
.model BC546B npn ( IS=7.59E-15 VAF=73.4 BF=480 IKF=0.0962 NE=1.2665
+ ISE=3.278E-15 IKR=0.03 ISC=2.00E-13 NC=1.2 NR=1 BR=5 RC=0.25 CJC=6.33E-12
+ FC=0.5 MJC=0.33 VJC=0.65 CJE=1.25E-11 MJE=0.55 VJE=0.65 TF=4.26E-10
+ ITF=0.6 VTF=3 XTF=20 RB=100 IRB=0.0001 RBM=10 RE=0.5 TR=1.50E-07)

.end</pre>
          <p>So what is new here? Command <code>.temp {ptemp}</code> sets the overall circuit temperature to the value of parameter <var>ptemp</var>. We now use an active device, the npn bipolar transistor Q1, whose model parameters are given in the <code>.model BC546B npn ...</code> line. The <code>.probe(Q1)</code> command allows to measure the device Q1 terminal currents as shown by the display command:</p>
          <pre>q1:b#branch         : current, real, 1 long
    q1:c#branch         : current, real, 1 long
    q1:e#branch         : current, real, 1 long</pre>
          <p>The three nested loops start with <code>while tcur &lt;= 125</code>. One has to be careful where to place correctly the initial loop value <code>let tcur = 25</code> and the command let <code>tcur = tcur + 10</code> to increase the value. Changing the model parameter <var>VAF</var> (forward Early voltage) is done by <code>altermod</code>, again after setting the parameters by <code>alterparam</code> and after <code>reset</code>. Data output is provided here by the simple <code>print</code> command.</p>
          <p>The above netlist implicitely provides a linear increase of parameters. A <code>.step</code> command like</p>
          <pre>* .step oct v1 1 100 5</pre>
          <p>with its option <code>oct</code> implies a non-linear distribution of input parameters (here 5 values per octave, that is within a factor of 2). A netlist with a single loop demonstrates this command:</p>
          <pre>*** Emulate the .step command
* .step oct v1 1 100 5

V1 vcc 0 1                          ; the circuit
R1 vcc 0 1

.op                                 ; simulation type required

.control
let vstart = 1                      ; start voltage vector (in plot 'const')
let vend = 100                      ; end voltage vector (in plot 'const')
let numb = 5                        ; number of points per octave (in plot 'const')

let index = 1                       ; new loop index vector (in plot 'const')
let vmult = 2^(1/numb)              ; multiplicator

let xx = vend/vstart                ; find the total number of steps
let ind1 = 0
while xx > 1
  let xx = xx / vmult
  let ind1 = ind1 + 1
end
echo number of steps $&amp;ind1

if ind1 &lt; 1                          ; move on when number of steps is positive
  echo error with number of steps $&amp;ind1 --'>'  stop!
else
  let vecx = vector(ind1)            ; create vectors for x and y
  let vecy = vector(ind1)
  settype voltage vecx               ; set the correct vector type
  settype current vecy

  let vcur = vstart                   ; current voltage value in the loop
  while vcur &lt;= vend                  ; the voltage loop
    alter V1 vcur                     ; a new voltage value for V1
    echo run no. $&amp;index
    run                               ; simulate
    let indloc = index - 1            ; indexes for vectors start with 0
    let vecx[indloc] = vcur           ; x value into vector
    let vecy[indloc] = v1#branch      ; y value into vector
*    print vcur v1#branch
    unlet indloc                      ; remove vector no longer used
    echo
    let vcur = vcur * vmult           ; calculate new voltage value
    let index = index + 1
  end
  plot vecy vs vecx pointplot xlog    ; plot y versus x
end
rusage                                ; memory and time used
.endc

.end</pre>
          <p>Here we use a multiplicator to alter the voltage value, derived from the information "5 values per octave". After calculating the total number of steps, we create and use 2 vectors vecx, vecy to store the result of the op simulation versus the V1 value. Some checking against wrong point numbers is done. A pointplot in Fig. 5 demonstrates the uniform x value distribution, when plotted logarithmically.</p>
        </section>
        <section>
          <h3>Modify a circuit on the fly</h3>
          <p>By using the <code>.if ... .elseif ... .endif</code> construct, you may choose from different circuit blocks which are enclosed within the conditional statements. Selection is done by altering a parameter as selector with the alterparam command.</p>
          <p>In the first example we switch between a simple low pass and a high pass circuit, run an <code>.ac</code> simulation for each one and plot the output in a single plot window.</p>
          <pre>High pass, low pass on the fly

.param select = 0          ; selector

.IF (select == 0)          ; select low pass
    R1 in out 1k
    C1 out 0 1u
.ELSEIF (select == 1)      ; select high pass
    R1 out 0 1k
    C1 in out 1u
.ENDIF

Vin in 0 dc 0 ac 1         ; input voltage

.ac dec 10 1 100k

.control
run                        ; run the simulation
alterparam select = 1      ; modify the selector from 0 to 1
reset                      ; reload the circuit with new selector, so with new circuit
run                        ; run the simulation again
set xbrushwidth=3          ; increase linewidth of graphs
plot db(ac1.out) db(ac2.out) xlimit 1 1e5 ; plot both simulations in one graph
.endc

.end</pre>
          <p>Some restrictions apply, as the following netlist components are not supported within the .IF ... .ENDIF block: .SUBCKT, .INC, .LIB, and .PARAM.</p>
          <p>In the next example we choose from 2 different operational amplifiers. We have to include all of their models, and we select by calling the appropriate model in the call to their subcircuit (X line).</p>
          <pre>* Modify circuit (here: changing OpAmps) using .IF ... .ENDIF

.param select = 0                ; selector

.IF (select == 0)                ; select OpAmp
    X1 0 INM P6V M6V OUT OPA1656
.ELSEIF (select == 1)
    X2 0 INM P6V M6V OUT OPA164x
.ENDIF

R1 INM OUT 10K                    ; inverting amplifier, gain -2
R2 IN INM 5k

V1 P6V 0 4V                       ; power supply
V2 M6V 0 -4V

Vin IN 0 dc 0 ac 1                ; input (for ac)

.ac dec 20 1e4 1e8                ; ac simulation conditions

.include OPA1656.lib ; download OpAmp model from TI's web site
.include OPA164x.lib ; download OpAmp model from TI's web site

.control
save out                   ; save only the output, all other nodes are discarded
run                        ; run the simulation
alterparam select = 1      ; modify the selector from 0 to 1
reset                      ; reload the circuit with new selector, so with new OpAmp
run                        ; run the simulation again

let dbout1 = db(ac1.out)   ; calculate db in preparation for meas command, previous run
let dbout2 = db(out)       ; calculate db in preparation for meas command, current run
set xbrushwidth=3          ; increase linewidth of graphs
plot dbout1 dbout2
meas ac fmin3db1 when dbout1=3 ; gain 6 dB, measure fall-off to 3 dB
meas ac fmin3db2 when dbout2=3 ; gain 6 dB, measure fall-off to 3 dB
.endc

.end</pre>
          <p>Finally we use two meas(ure) commands to find the frequency where the opamp gain has rolled off by -3 dB.</p>
        </section>
        <!--
        <section>
          <h3>*</h3>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3>*</h3>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3>*</h3>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        -->
      </section>

      <!--
      <section id="*">
        <h2></h2>
        <p></p>
      </section>

      <section id="*">
        <h2></h2>
        <p></p>
      </section>
      -->

    </main>

  </body>

</html>
