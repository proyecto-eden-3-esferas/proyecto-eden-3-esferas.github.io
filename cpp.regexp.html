<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>STL Regular Expressions</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      <p><a            href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a            href="cpp.stl.html">C++ Standad Template Library (STL)</a></p>
        <p><a            href="cpp.containers.html">C++ STL Containers</a> </p>
      -->
      <div>
        <p><a href="regexp.html">Regular Expressions: A Language of Text Patterns</a></p>
        <p><a rel="prev" href="js.regexp.html">JavaScript Regular Expressions</a></p>
      </div>
      <div>
        <p><a            href="cpp.strings.html">The C++ Programming Language</a> </p>
        <p><a rel="next" href="cpp.string-to-number.html">Converting a String to a Number Type in C++</a> </p>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a> </p>
        <p><a            href="cpp.iterators.html">Iterators: Pointers for STL Containers</a> </p>
      </div>
    </nav>
    <main>
      <h1>Regular Expressions in the STL</h1>

      <p>Regular expressions, defined in the <cite><code>&lt;regex&gt;</code></cite> header, are a powerful feature of the Standard Library. They are a special mini-language for string processing. They might seem complicated at first, but once you get to know them, they make working with strings easier.</p>

      <nav>
        <p><a href="#functions">Regular Expression Functions Provided</a></p>
        <p><a href="#versions">Different Regular Expression Grammars</a></p>
        <p><a href="#using-raw">Using Raw Strings</a></p>
        <p><a href="#procedure">Procedure for Applying Regular Expressions</a></p>
        <p><a href="#text-tá»³pes">Text Types</a></p>
        <p><a href="#objs">Regular Expression Objects</a></p>
        <p><a href="#match_results">The Search Result <code>match_results</code></a></p>
        <p><a href="#sub_match"><code>td::sub_match</code></a></p>
        <p><a href="#matching">Matching</a></p>
        <p><a href="#searching">Searching</a></p>
        <p><a href="#replacing">Replacing</a></p>
        <p><a href="#formatting">Formatting</a></p>
        <p><a href="#repeated-search">Repeated Search</a></p>
        <p><a href="#removing-greediness">Removing Greediness</a></p>
      </nav>




      <section id="functions">
        <h2>Regular Expression Functions Provided</h2>
        <p>Some of the functions provided are:</p>
        <ul>
          <li><code>regex_match()</code>: Match a regular expression against a string (of known size).</li>
          <li><code>regex_search()</code>: Search for a string that matches a regular expression in an (arbitrarily long) stream of data. The result of a regex_search() is a collection of matches, typically represented as an <code class="classname">smatch</code>, which is a container of regex results.</li>
          <li><code>regex_replace()</code>: Search for strings that match a regular expression in an (arbitrarily long) stream of data and replace them.</li>
          <li><code>regex_iterator</code>: iterate over matches and submatches.</li>
          <li><code>regex_token_iterator</code>: iterate over non-matches.</li>
        </ul>
        <p>Some simple operations are next exemplified:</p>
        <pre>#include &lt;regex&gt;
#include &lt;iostream&gt;

int main (int argc, const char * argv[]) {
    std::regex r("st|mt|tr");
    std::cerr &lt;&lt; "st|mt|tr" &lt;&lt; " matches st? " &lt;&lt; std::regex_match("st", r) &lt;&lt; std::endl;
    std::cerr &lt;&lt; "st|mt|tr" &lt;&lt; " matches mt? " &lt;&lt; std::regex_match("mt", r) &lt;&lt; std::endl;
    std::cerr &lt;&lt; "st|mt|tr" &lt;&lt; " matches spruce? " &lt;&lt; std::regex_match("spruce", r) &lt;&lt; std::endl;

    return 0;
}</pre>
      </section>

      <section id="versions">
        <h2>Different Regular Expression Grammars</h2>
        <p>There are several different grammars for regular expressions. For this reason, C++ includes support for several of these grammars: ECMAScript, basic, extended, awk, grep, and egrep. If you already know any of these regular expression grammars, you can use it straight away in C++ by telling the regular expression library to use that specific syntax ( syntax_option_type ). The default grammar in C++ is ECMAScript whose syntax is explained in detail in the following section. It is also the most powerful grammar, so it&apos;s recommended to use ECMAScript instead of one of the other more limited grammars. Explaining the other regular expression grammars falls outside the scope of this section.</p>
        <section id="ECMAScript">
          <h3>ECMAScript Syntax</h3>
          <p>The ECMAScript 3 regular expression grammar in C++ is ECMA-262 grammar with modifications marked with <a href="#ECMAScript-cpp-only">(C++ only)</a> below.</p>
          <p>The modified regular expression grammar is mostly <a target="_blank" href="js.regexp.html">ECMAScript RegExp grammar</a> with a POSIX-type expansion on locales under ClassAtom. Some clarifications on equality checks and number parsing is made.</p>
          <hr/>
          <p>The <q>normative references</q> in the standard specifies ECMAScript 3.</p>
          <p>See the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">MDN Guide on JavaScript RegExp</a> for an overview on the dialect features.</p>
          <hr/>
          <p>ECMAScript syntax recognizes the following special characters:</p>
          <pre>^ $ \ . * + ? ( ) [ ] { } |</pre>
          <p>If you need to match one of these special characters, you need to escape it using the \ character. For example:</p>
          <pre>\[ or \. or \* or \\</pre>
          <section id="ECMAScript-cpp-only">
            <h3>C++-Only Differences</h3>
          </section>
        </section>

        <section id="basic">
          <h3>basic Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section id="extended">
          <h3>extended Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section id="awk">
          <h3>awk Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>


        <section id="grep">
          <h3>grep Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section id="egrep">
          <h3>egrep Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
      </section>

      <section id="using-raw">
        <h2>Using Raw Strings</h2>
        <p>Use <a target="_blank" href="cpp.raw-strings.html">raw string literals</a> in regular expressions.</p>
        <p>The regular expression for the text <q>C++</q> is fairly unwieldly: <code>C\\+\\+</code>. You have to use two backslashes for each + sign. First, the + sign is a unique character in a regular expression. Second, the backslash is a special character in a string. Therefore one backslash escapes the + sign; the other backslash escapes the backslash. By using a raw string literal, the second backslash is not necessary anymore because the backslash is not interpreted in the string.</p>
        <pre>#include &lt;regex&gt;

//...

std::string regExpr("C\\+\\+");
std::string regExprRaw(R"(C\+\+)");</pre>
      </section>

      <section id="procedure">
        <h2>Procedure for Applying Regular Expressions</h2>
        <dl>
          <dt>Define the regular expression [<a href="#objs">object</a>]</dt>
          <dd>
            <pre>std::string text="C++ or c++.";
std::string regExpr(R"(C\+\+)");
std::regex rgx(regExpr);</pre>
          </dd>
          <dt>Store the result of the search</dt>
          <dd>
            <pre>std::smatch result;
std::regex_search(text, result, rgx);</pre>
          </dd>
          <dt>Process the result</dt>
          <dd>
            <p></p>
            <pre>std::cout &lt;&lt; result[0] &lt;&lt; '\n';</pre>
          </dd>
        </dl>
        <section id="ex_raw-strings-exceptions">
          <h3>An Example with Raw Strings, Exceptions...</h3>
          <p>The following code snippet is a basic example that demonstrates how other elements of C++ work in tandem with regex. This snippet brings together core constructs such as string handling, control structures, and function definition, culminating in a small program that employs regex search functionality:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

// Function to search for a pattern within a provided text
bool containsPattern(const std::string&amp; text, const std::string&amp; patternStr) {
  try {
    std::regex pattern(patternStr);
    return std::regex_search(text, pattern);
  } catch (const std::regex_error&amp; e) {
    std::cerr &lt;&lt; "Regex error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    return false;
  }
}

int main() {
  // Defining a sample string and a simple regex pattern to identify an email address
  std::string sampleText = "Contact: example@example.com for more information.";
  std::string emailPattern = R"((\w+@\w+\.\w+))";

  // Using the containsPattern function to check if an email address exists in the sample text
  if (containsPattern(sampleText, emailPattern)) {
    std::cout &lt;&lt; "A valid email address was found in the text." &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "No valid email address was found in the text." &lt;&lt; std::endl;
  }
  return 0;
}</pre>
        </section>

        <section id="ex_basic-patterns">
          <h3>An Example: Matching Basic Patterns</h3>
          <p>The code below highlights how literal characters, metacharacters, character classes, quantifiers, grouping, and alternation can work together in a straightforward example. This example is implemented in a programming context and serves as a practical demonstration of the theoretical constructs of regex:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main() {
 // Define a basic regex pattern to match either "cat", "dog", or an email-like string
 std::regex pattern(R"((cat|dog)|([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}))");

 // Sample texts to test the regex pattern
 std::string test1 = "I have a cat and a dog.";
 std::string test2 = "Please contact us at info@example.com.";

 // Test the pattern against the sample texts using regex_search
 std::smatch match;
 if (std::regex_search(test1, match, pattern)) {
 std::cout &lt;&lt; "Match found in test1: " &lt;&lt; match.str() &lt;&lt; std::endl;
 }
 if (std::regex_search(test2, match, pattern)) {
 std::cout &lt;&lt; "Match found in test2: " &lt;&lt; match.str() &lt;&lt; std::endl;
 }

 return 0;
}</pre>
          <p>In this example, the regex pattern is constructed to match either the literal strings âcatâ or âdogâ, or an email address format. The use of grouping (with the parentheses) allows us to manage these two distinct options within a single pattern. The alternation operator (|) separates the options, and the pattern within the second group demonstrates the use of character classes and quantifiers.</p>
        </section>
        <section id="ex_greedy-lazy">
          <h3>An Example...</h3>
          <p>The following short programme demonstrates the difference between <a target="_blank" href="regexp.html#greedy-lazy">greedy and lazy</a> quantifiers:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main() {
  // Demonstration of greedy versus lazy quantifiers
  std::string greedyTest = "&lt;tag&gt;Content&lt;/tag&gt;&lt;tag&gt;More&lt;/tag&gt;";
  // Greedy quantifier: matches as much as possible
  std::regex greedyPattern("&lt;tag&gt;.*&lt;/tag&gt;");
  // Lazy quantifier: matches as little as possible
  std::regex lazyPattern("&lt;tag&gt;.*?&lt;/tag&gt;");

  std::smatch match;
  if (std::regex_search(greedyTest, match, greedyPattern)) {
    std::cout &lt;&lt; "Greedy match: " &lt;&lt; match.str() &lt;&lt; std::endl;
  }
  if (std::regex_search(greedyTest, match, lazyPattern)) {
    std::cout &lt;&lt; "Lazy match: " &lt;&lt; match.str() &lt;&lt; std::endl;
  }
  return 0;
}</pre>
        </section>
        <!--
        <section>
          <h3>An Example...</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3>An Example...</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        -->
      </section>

      <section id="text-tá»³pes">
        <h2>Text Types</h2>
        <p>The text type determines the character type of the regular expression and the type of the search result.</p>
        <p>The table below shows the four different combinations.</p>
        <table border="1" id="simple_with_header">
          <thead> <tr> <td>Text type</td> <td>Regular expression type</td> <td>Result type</td> </tr> </thead>
                  <tr> <td>const char*</td> <td>std::regex</td> <td>std::cmatch</td> </tr>
                  <tr> <td>std::string</td> <td>std::regex</td> <td>std::smatch</td> </tr>
                  <tr> <td>const wchar_t*</td> <td>std::wregex</td> <td>std::wcmatch</td> </tr>
                  <tr> <td>std::wstring</td> <td>std::wregex</td> <td>std::wsmatch</td> </tr>
        </table>
      </section>

      <section id="objs">
        <h2>Regular Expression Objects</h2>
        <p>Objects of type regular expression are instances of the class template template <code>&lt;class charT, class traits= regex_traits &lt;charT&gt;&gt;</code> class basic_regex parametrized by their character type and traits class. The traits class defines the interpretation of the properties of regular grammar. There are two type synonyms in C++:</p>
        <pre>typedef basic_regex&lt;char&gt; regex;
typedef basic_regex&lt;wchar_t&gt; wregex;</pre>
        <p>You can further customize the object of type regular expression. Therefore you can specify the grammar used or adapt the syntax. As mentioned, C++ supports the basic, extended, awk, grep, and egrep grammars.</p>
        <p>A regular expression qualified by the <code>std::regex_constants::icase flag</code> is case insensitive. If you want to adopt the syntax, you have to specify the grammar explicitly.</p>
        <pre>// regexGrammar.cpp
...
#include &lt;regex&gt;

...

using std::regex_constants::ECMAScript;
using std::regex_constants::icase;

std::string theQuestion="C++ or c++, that's the question.";
std::string regExprStr(R"(c\+\+)");

std::regex rgx(regExprStr);
std::smatch smatch;

if (std::regex_search(theQuestion, smatch, rgx)){
std::cout &lt;&lt; "case sensitive: " &lt;&lt; smatch[0];
}
std::regex rgxIn(regExprStr, ECMAScript|icase);
if (std::regex_search(theQuestion, smatch, rgxIn)){
std::cout &lt;&lt; "case insensitive: " &lt;&lt; smatch[0];
}</pre>
        <p>If you use the case-sensitive regular expression <var>rgx</var>, the result of the search in the text <var>theQuestion</var> is <code>c++</code>. That&apos;s not the case if your case-insensitive regular expression <var>rgxIn</var> is applied. Now you get the match string <code>C++</code>.</p>
      </section>

      <section id="match_results">
        <h2>The Search Result <code>match_results</code>*</h2>
        <p>The object of type <code>std::match_results</code> is the result of a <code>std::regex_match</code> or <code>std::regex_search</code>.</p>
        <p><code>std::match_results</code> is a sequence container having at least one <a target="_blank" href="regexp.html#capture-group">capture group</a> of a <code>std::sub_match</code> object. The <code>std::sub_match</code> objects are sequences of characters.</p>
        <p>C++ has four typedef&apos;s for <code>std::match_results</code>:</p>
        <pre>typedef match_results&lt;const char*&gt; cmatch;
typedef match_results&lt;const wchar_t*&gt; wcmatch;
typedef match_results&lt;string::const_iterator&gt; smatch;
typedef match_results&lt;wstring::const_iterator&gt; wsmatch;</pre>


        <p>The search result <code>std::smatch</code> has a powerful interface.</p>
        <table border="1">
          <thead> <tr> <th>Member Function</th> <th>Description</th> </tr> </thead>
          <tbody>
                  <tr> <td><code>smatch.size()</code></td> <td>Returns the number of capture groups.</td> </tr>
                  <tr> <td><code>smatch.empty()</code></td> <td>Returns if the search result has a capture group.</td> </tr>
                  <tr> <td><code>smatch[i]</code></td> <td>Returns the ith capture group.</td> </tr>
                  <tr> <td><code>smatch.length(i)</code></td> <td>Returns the length of the ith capture group.</td> </tr>
                  <tr> <td><code>smatch.position(i)</code></td> <td>Returns the position of the ith capture group.</td> </tr>
                  <tr> <td><code>smatch.str(i)</code></td> <td>Returns the ith capture group as string.</td> </tr>
                  <tr> <td><code>smatch.prefix() and smatch.suffix()</code></td> <td>Returns the string before and after the capture group.</td> </tr>
                  <tr> <td><code>smatch.begin() and smatch.end()</code></td> <td>Returns the begin and end iterator for the capture groups.</td> </tr>
                  <tr> <td><code>smatch.format(...)</code></td> <td>Formats std::smatch objects for the output.</td> </tr>
          </tbody>
        </table>
        <p>The following program shows the output of the first four capture groups for different regular expressions.</p>
        <pre>// captureGroups.cpp
...
#include &lt;regex>
...
using namespace std;

void showCaptureGroups(const string&amp; regEx, const string&amp; text){
  regex rgx(regEx);
  smatch smatch;
  if (regex_search(text, smatch, rgx)) {
    cout &lt;&lt; regEx &lt;&lt; text &lt;&lt; smatch[0] &lt;&lt; " " &lt;&lt; smatch[1]
    &lt;&lt; " "&lt;&lt; smatch[2] &lt;&lt; " " &lt;&lt; smatch[3] &lt;&lt; endl;
  }
}

showCaptureGroups("abc+", "abccccc");
showCaptureGroups("(a+)(b+)", "aaabccc");
showCaptureGroups("((a+)(b+))", "aaabccc");
showCaptureGroups("(ab)(abc)+", "ababcabc");</pre>
      </section>
      <section id="sub_match">
        <h2><code>td::sub_match</code></h2>
        <p>The capture groups are of type <code>std::sub_match</code>. As with <code>std::match_results</code>, C++ defines the following four type synonyms.</p>
        <pre>typedef sub_match&lt;const char*&gt; csub_match;
typedef sub_match&lt;const wchar_t*&gt; wcsub_match;
typedef sub_match&lt;string::const_iterator&gt; ssub_match;
typedef sub_match&lt;wstring::const_iterator&gt; wssub_match;</pre>

        <p>You can further analyze the capture group <var>cap</var>.</p>
        <table border="1">
          <thead> <tr> <th>Member Function</th> <th>Description</th> </tr> </thead>
          <tbody>
                  <tr> <td><code>cap.matched()</code></td> <td>Indicates if this match was successful.</td> </tr>
                  <tr> <td><code>cap.first()</code> and <code>cap.end()</code></td> <td>Returns the begin and end iterator of the character sequence.</td> </tr>
                  <tr> <td><code>cap.length()</code></td> <td>Returns the length of the capture group.</td> </tr>
                  <tr> <td><code>cap.str()</code></td> <td>Returns the capture group as [a] string.</td> </tr>
                  <tr> <td><code>cap.compare(<var>other</var>)</code></td> <td>Compares the current capture group with the <var>other</var> capture group.</td> </tr>
          </tbody>
        </table>

        <p>Here is a code snippet showing the interplay between the search result <code>std::match_results</code> and its capture groups <code>std::sub_match</code>&apos;s:</p>
        <pre>// subMatch.cpp
...
#include &lt;regex&gt;
...
using std::cout;

std::string privateAddress="192.168.178.21";
std::string regEx(R"((\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3}))");
std::regex rgx(regEx);
std::smatch smatch;

if (std::regex_match(privateAddress, smatch, rgx)) {

  for (auto cap: smatch) {
    cout &lt;&lt; "capture group: " &lt;&lt; cap &lt;&lt; '\n';
    if (cap.matched) {
      std::for_each(cap.first,
                    cap.second,
                    [](int v) {
        cout &lt;&lt; std::hex &lt;&lt; v &lt;&lt; " ";
                              });
      cout &lt;&lt; '\n';
    }
  } // for

}

...

capture group: 192.168.178.21
31 39 32 2e 31 36 38 2e 31 37 38 2e 32 31

capture group: 192
31 39 32

capture group: 168
31 36 38

capture group: 178
31 37 38

capture group: 21
32 31</pre>

        <p>The regular expression <var>regEx</var> stands for an IPv4 address. <var>regEx</var> extracts the address&apos;s components using capture groups. Finally, the capture groups and the characters in ASCII are displayed in hexadecimal values.</p>
      </section>

      <section id="matching">
        <h2>Matching</h2>
        <p><code><a href="#regex_match">std::regex_match</a></code> determines if the text matches a text pattern. You can further analyze the search result, which is of type <code>std::match_results</code>, and is set by a different STL global: <code><a href="#regex_search">std::regex_search</a></code>.</p>

        <section>
          <h3>An Example</h3>
          <p>The code snippet below shows three simple applications of <code>std::regex_match</code>: a C string, a C++ string, and a range returning only a boolean. The three variants are available for <code>std::match_results</code> objects, respectively.</p>
          <pre>// match.cpp
...
#include &lt;regex&gt;
...
std::string numberRegEx(R"([-+]?([0-9]*\.[0-9]+|[0-9]+))");
std::regex rgx(numberRegEx);
const char* numChar{"2011"};

if (std::regex_match(numChar, rgx)) {
  std::cout &lt;&lt; numChar &lt;&lt; "is a number." &lt;&lt; '\n';
}
// 2011 is a number.

const std::string numStr{"3.14159265359"};
if (std::regex_match(numStr, rgx)){
  std::cout &lt;&lt; numStr &lt;&lt; " is a number." &lt;&lt; '\n';
}
// 3.14159265359 is a number.

const std::vector&lt;char&gt; numVec{{'-', '2', '.', '7', '1', '8', '2',
'8', '1', '8', '2', '8'}};
if (std::regex_match(numVec.begin(), numVec.end(), rgx)) {
  for (auto c: numVec) { std::cout &lt;&lt; c ;};
  std::cout &lt;&lt; "is a number." &lt;&lt; '\n';
} // if
// -2.718281828 is a number.</pre>
        </section>
        <section id="regex_match">
          <h3><code>std::regex_match</code> (C++11)</h3>
          <p>Its constructors may take as its first argument(s):</p>
          <ul>
            <li>a beginning and an end iterators, or</li>
            <li>a pointer to const CHAR (<code>const CHAR*</code>), or</li>
            <li>a constant reference to a string (<code>std::basic_string&lt;CHAR&gt; &amp;</code>)</li>
          </ul>
          <p>These one or two paramenters may be followed by a <code>std::match_results</code> non-constant reference.</p>
          <p>The next parameter is mandatory: a reference to a <code>std::basic_regex</code> object</p>
          <p>Last is an optional flags parameter.</p>
          <aside>
            <h5 class="bridgehead"><code>regex_match</code> only considers full matches</h5>
            <p>Because <code>regex_match</code> only considers full matches, the same regex may give different matches between <code>std::regex_match</code> and <code>std::regex_search</code>:</p>
            <pre>std::regex re("Get|GetValue");
std::cmatch m;
std::regex_search("GetValue", m, re);  // returns true, and m[0] contains "Get"
std::regex_match ("GetValue", m, re);  // returns true, and m[0] contains "GetValue"
std::regex_search("GetValues", m, re); // returns true, and m[0] contains "Get"
std::regex_match ("GetValues", m, re); // returns false</pre>
          </aside>
          <section>
            <h4><code>std::regex_constants::match_flag_type</code> Flags</h4>
            <p>Their type is implementation-defined.</p>
            <table border="0">
              <thead>
                <tr> <th>Name</th> <th>Explanation</th> </tr> </thead>
                <tr> <td><code>match_not_bol</code></td> <td>The first character in [first, last) will be treated as if it is not at the beginning of a line (i.e. ^ will not match [first, first)).</td> </tr>
                <tr> <td><code>match_not_eol</code></td> <td>The last character in [first, last) will be treated as if it is not at the end of a line (i.e. $ will not match [last, last)).</td> </tr>
                <tr> <td><code>match_not_bow</code></td> <td>\b will not match [first, first).</td> </tr>
                <tr> <td><code>match_not_eow</code></td> <td>\b will not match [last, last).</td> </tr>
                <tr> <td><code>match_any</code></td> <td>If more than one match is possible, then any match is an acceptable result.</td> </tr>
                <tr> <td><code>match_not_null</code></td> <td>Do not match empty sequences.</td> </tr>
                <tr> <td><code>match_continuous</code></td> <td>Only match a sub-sequence that begins at first.</td> </tr>
                <tr> <td><code>match_prev_avail</code></td> <td>--first is a valid iterator position.</td> </tr>
                <tr> <td><code>When</code></td> <td>set, causes match_not_bol and match_not_bow to be ignored.</td> </tr>
                <tr> <td><code>format_default</code></td> <td>Use ECMAScript rules to construct strings in std::regex_replace (syntax documentation).</td> </tr>
                <tr> <td><code>format_sed</code></td> <td>Use POSIX sed utility rules in std::regex_replace (syntax documentation).</td> </tr>
                <tr> <td><code>format_no_copy</code></td> <td>Do not copy un-matched strings to the output in std::regex_replace.</td> </tr>
                <tr> <td><code>format_first_only</code></td> <td>Only replace the first match in std::regex_replace.</td> </tr>
            </table>
            <p>All constants, except for match_default and format_default, are bitmask elements. The match_default and format_default constants are empty bitmasks.</p>
          </section>
        </section>
      </section>

      <section id="searching">
        <h2>Searching</h2>
        <p><code>std::regex_search&lt;<var>CHAR</var>&gt;</code> checks if the text contains a text pattern. You can use the function with and without a <code>std::match_results</code> object and apply it to a C string, a C++ string, or a range.</p>
        <section>
          <h3>An Example</h3>
          <p>The example below shows how to use <code>std::regex_search</code> with texts of type <code>const char*</code>, <code>std::string</code>, <code>const wchar_t*</code>, and <code>std::wstring</code>.</p>
          <pre>// search.cpp
...
#include &lt;regex&gt;
...

// regular expression holder for time
std::regex crgx("([01]?[0-9]|2[0-3]):[0-5][0-9]");

// const char*
std::cmatch cmatch;

const char* ctime{"Now it is 23:10." };
if (std::regex_search(ctime, cmatch, crgx)) {
  std::cout &lt;&lt; ctime &lt;&lt; '\n';
  std::cout &lt;&lt; "Time: " &lt;&lt; cmatch[0] &lt;&lt; '\n'; // Time: 23:10
}

// std::string
std::smatch smatch;
std::string stime{"Now it is 23:25." };
if (std::regex_search(stime, smatch, crgx)) {
  std::cout &lt;&lt; stime &lt;&lt; '\n';
  std::cout &lt;&lt; "Time: " &lt;&lt; smatch[0] &lt;&lt; '\n'; // Time: 23:25
}

// regular expression holder for time
std::wregex wrgx(L"([01]?[0-9]|2[0-3]):[0-5][0-9]");

// const wchar_t*
std::wcmatch wcmatch;

const wchar_t* wctime{L "Now it is 23:47." };
if (std::regex_search(wctime, wcmatch, wrgx)) {
  std::wcout &lt;&lt; wctime &lt;&lt; '\n';
  std::wcout &lt;&lt; "Time: " &lt;&lt; wcmatch[0] &lt;&lt; '\n'; // Time: 23:47
}

// std::wstring
std::wsmatch wsmatch;

std::wstring wstime{L "Now it is 00:03." };
if (std::regex_search(wstime, wsmatch, wrgx)) {
  std::wcout &lt;&lt; wstime &lt;&lt; '\n';
  std::wcout &lt;&lt; "Time: " &lt;&lt; wsmatch[0] &lt;&lt; '\n'; // Time: 00:03
}</pre>
        </section>
        <section id="regex_search">
          <h3><code>std::regex_search</code> (C++11)</h3>
          <p>Determines if there is a match between the regular expression e and some subsequence in the target character sequence. The detailed match result is stored in input-output parameter <code>std::match_results&lt;&gt; <var>m</var></code> (if present).</p>
          <p>The return type is <code>bool</code>.</p>
          <p>The main difference between <code>std::regex_match</code> and <code>std::regex_search</code> is... (<i>see below</i>)</p>
        </section>
      </section>

      <section>
        <h2>Difference Between <code>std::regex_match</code> and <code>std::regex_search</code></h2>
        <p><code>regex_match</code> only returns true when the entire input sequence has been matched, while <code>regex_search</code> will succeed even if only a sub-sequence matches the regex.</p>
      </section>

      <section id="replacing">
        <h2>Replacing</h2>
        <p><code>std::regex_replace</code> replaces sequences in a text matching a text pattern. It returns in the simple form <code>std::regex_replace(<var>text</var>, <var>regex</var>, <var>replString</var>)</code> its result as string. The function replaces an occurrence of <var>regex</var> in text with <var>replString</var>.</p>
        <pre>// replace.cpp
...
#include &lt;regex&gt;
...
using namespace std;

string future{"Future"};
string unofficialName{
  "The unofficial name of the new C++ standard is C++0x."};

regex rgxCpp{R"(C\+\+0x)"};
string newCppName{"C++11"};
string newName{regex_replace(unofficialName, rgxCpp, newCppName)};

regex rgxOff{"unofficial"};
string makeOfficial{"official"};
string officialName{regex_replace(newName, rgxOff, makeOfficial)};

cout &lt;&lt; officialName &lt;&lt; endl;
            // The official name of the new C++ standard is C++11.</pre>
        <p>In addition to the simple version, C++ has a version of <code>std::regex_replace</code> working on ranges. It enables you to push the modified string directly into another string:</p>
        <pre>typedef basic_regex&lt;char&gt; regex;
std::string str2;
std::regex_replace(std::back_inserter(str2),
                   text.begin(), text.end(),
                   regex,replString);</pre>
        <p>All variants of <code>std::regex_replace</code> have an additional optional parameter. If you set the parameter to <code>std::regex_constants::format_no_copy</code>, you will get the part of the text matching the regular expression. The unmatched text is not copied. If you set the parameter to <code>std::regex_constants::format_first_only</code>, then <code>std::regex_replace</code> will only be applied once.</p>
      </section>

      <section id="formatting">
        <h2>Formatting</h2>
        <p><code>std::regex_replace</code> and <code>std::match_results.format</code> in combination with capture groups enables you to format text. You can use a format string together with a placeholder to insert the value.</p>
        <p>Here are both possibilities, first with <code>regex</code>:</p>
        <pre>// format.cpp
...
#include &lt;regex&gt;
...
std::string future{"Future"};
const std::string unofficial{"unofficial, C++0x"};
const std::string official{"official, C++11"};

std::regex regValues{"(.*),(.*)"};
std::string standardText{"The $1 name of the new C++ standard is $2."};
std::string textNow = std::regex_replace(unofficial, regValues, standardText);
std::cout &lt;&lt; textNow &lt;&lt; '\n';
  // The unofficial name of the new C++ standard is C++0x.

std::smatch smatch;
if (std::regex_match(official, smatch, regValues)) {
  std::cout &lt;&lt; smatch.str(); // official,C++11
  std::string textFuture = smatch.format(standardText);
  std::cout &lt;&lt; textFuture &lt;&lt; '\n';
} // The official name of the new C++ standard is C++11.</pre>
        <p>In the function call <code>std::regex_replace(unoffical, regValues, standardText)</code>, the text matching the first and second capture group of the regular expression <var>regValues</var> is extracted from the string unofficial. The placeholders <code>$1</code> and <code>$2</code> in the text <var>standardText</var> are then replaced by the extracted values. The strategy of <code>smatch.format(standardTest)</code> is similar, but there is a difference:</p>
        <p>The creation of the search results <code>smatch</code> is separated from their usage when formatting the string.</p>
        <p>In addition to capture groups, C++ supports additional format escape sequences. You can use them in format strings:</p>
        <table border="1" id="simple_with_header_and_th">
          <thead> <tr> <th>Format escape sequence</th> <th>Description</th> </tr> </thead>
                  <tr> <td><code>$&amp;</code></td> <td>Returns the total match (0th capture group).</td> </tr>
                  <tr> <td><code>$$</code></td> <td>Returns $.</td> </tr>
                  <tr> <td><code>$`</code> (backward tic)</td> <td>Returns the text <em>before</em> the total match.</td> </tr> $`
                  <tr> <td><code>$ÃÂ´</code> (forward tic)</td> <td>Returns the text <em>after</em> the total match.</td> </tr>
                  <tr> <td><code>â$ iâ</code></td> <td>Returns the ith capture group.</td> </tr>
        </table>
      </section>
      <section id="repeated-search">
        <h2>Repeated Search</h2>
        <p>It&apos;s pretty convenient to iterate with <code>std::regex_iterator</code> and <code>std::regex_token_iterator</code> through the matched texts. <code>std::regex_iterator</code> supports the matches and their capture groups. <code>std::regex_token_iterator</code> supports more. You can address the components of each capture.</p>
        <p>Using a negative index enables it to access the text between the matches.</p>
        <section>
          <h3><code>std::regex_iterator</code></h3>
          <p>C++ defines the following four type synonyms for <code>std::regex_iterator</code>:</p>
          <pre>typedef  cregex_iterator regex_iterator&lt;const char*&gt;
typedef wcregex_iterator regex_iterator&lt;const wchar_t*&gt;
typedef  sregex_iterator regex_iterator&lt;std::string::const_iterator&gt;
typedef wsregex_iterator regex_iterator&lt;std::wstring::const_iterator&gt;</pre>
          <hr/>
          <p>You may use <code>std::regex_iterator</code> to count the occurrences of the words in a text:</p>
          <pre>// regexIterator.cpp
...
#include &lt;regex&gt;
#include &lt;unordered_map&gt;
...
using std::cout;

std::string text{"That's a (to me) amazingly frequent question. It may be the most freque\
ntly asked question. Surprisingly, C++11 feels like a new language: The pieces just fit t\
ogether better than they used to, and I find a higher-level style of programming more nat\
ural than before and as efficient as ever." };

std::regex wordReg{R"(\w+)"};
      std::sregex_iterator wordItBegin(text.begin(), text.end(), wordReg);
const std::sregex_iterator wordItEnd;
std::unordered_map&lt;std::string, std::size_t&gt; allWords;
for (; wordItBegin != wordItEnd; ++wordItBegin) {
  ++allWords[wordItBegin-&gt;str()];
}
for (auto wordIt: allWords)
  cout &lt;&lt; "(" &lt;&lt; wordIt.first &lt;&lt; ":"
       &lt;&lt; wordIt.second &lt;&lt; ")";
// (as:2)(of:1)(level:1)(find:1)(ever:1)(and:2)(natural:1)</pre>
          <p>A word consists of a least one word-character <code>(\w+)</code>. This regular expression is used to define the begin iterator <var>wordItBegin</var>, then the end iterator <var>wordItEnd</var> is defined (default constructor).</p>
          <p>The iteration through the matches happens in the <code>for</code> loop. Each word increments the counter: <code>++<var>allWords</var>[<var>wordItBegin</var>]->str()]</code>. A word whose counter equals 1 is created if it is not already in <var>allWords</var>.</p>
          <hr/>
          <p>Another example, from the <cite><a target="_blank" href="https://cplusplus.com/reference/regex/regex_iterator/regex_iterator/">CPlusPlus</a></cite> site:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

int main ()
{
  std::string s ("this subject has a submarine as a subsequence");
  std::regex e ("\\b(sub)([^ ]*)");   // matches words beginning by "sub"

  std::regex_iterator&lt;std::string::iterator&gt; rit ( s.begin(), s.end(), e );
  std::regex_iterator&lt;std::string::iterator&gt; rend;

  while (rit!=rend) {
    std::cout &lt;&lt; rit-&gt;str() &lt;&lt; std::endl;
    ++rit;
  }

  return 0;
}</pre>
          <p>[...]</p>
        </section>
        <section>
          <h3><code>std::regex_token_iterator</code></h3>
          <p>C++ defines the following four type synonyms for <code>std::regex_token_iterator</code>:</p>
          <pre>typedef  cregex_token_iterator regex_token_iterator&lt;const char*&gt;
typedef wcregex_token_iterator regex_token_iterator&lt;const wchar_t*&gt;
typedef  sregex_token_iterator regex_token_iterator&lt;std::string::const_iterator&gt;
typedef wsregex_token_iterator regex_token_iterator&lt;std::wstring::const_iterator&gt;</pre>
          <p><code>std::regex_token_iterator</code> enables you to use indexes to explicitly specify which capture groups you are interested in. If you don&apos;t specify the index, you will get all capture groups, even though you can also request specific capture groups using their respective index.</p>
          <p>The -1 index is particular: You can use -1 to address the text between the matches.</p>
          <pre>// tokenIterator.cpp
...
using namespace std;

std::string text{"Pete Becker, The C++ Standard Library Extensions, 2006:"
"Nicolai Josuttis, The C++ Standard Library, 1999:"
"Andrei Alexandrescu, Modern C++ Design, 2001"};

regex regBook(R"((\w+)\s(\w+),([\w\s\+]*),(\d{4}))");
sregex_token_iterator bookItBegin(text.begin(), text.end(), regBook);Regular Expressions
const sregex_token_iterator bookItEnd;
while (bookItBegin != bookItEnd){
cout &lt;&lt; *bookItBegin++ &lt;&lt; endl;
}
// Pete Becker,The C++ Standard Library Extensions,2006
// Nicolai Josuttis,The C++ Standard Library,1999

sregex_token_iterator bookItNameIssueBegin(text.begin(),
                                           text.end(),
                                           regBook, {{2,4}});
const sregex_token_iterator bookItNameIssueEnd;</pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
      </section>


      <!--

      <section>
        <h2>ing *</h2>
        <p></p>
        <pre></pre>
        <p></p>
      </section>
      -->

      <section id="removing-greediness">
        <h2>Removing Greediness</h2>
        <p>To make regular expression repetitions non-greedy, a ? can be added behind the repeat as in *? , +? , ?? , and {...}? . A non-greedy repetition repeats its pattern as few times as possible while still matching the remainder of the regular expression.</p>
      </section>

      <section id="compiling">
        <h2>Compiling Classes and Functions into an Object File, say (<cite>regex.o</cite>)*</h2>
        <p>Specialization <code>std::regex&lt;char&gt;</code> is particularly easy to declare</p>
        <pre>template class std::regex&lt;char&gt;;</pre>
        <p>and is bound to save about eight seconds&apos; compilation time.</p>
      </section>

    </main>
  </body>
</html>
