<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>STL Regular Expressions</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      <p><a            href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a            href="cpp.stl.html">C++ Standad Template Library (STL)</a></p>
        <p><a            href="cpp.containers.html">C++ STL Containers</a> </p>
      -->
      <div>
        <p><a href="regexp.html">Regular Expressions: A Language of Text Patterns</a></p>
        <p><a rel="prev" href="js.regexp.html">JavaScript Regular Expressions</a></p>
      </div>
      <div>
        <p><a            href="cpp.strings.html">The C++ Programming Language</a> </p>
        <p><a rel="next" href="cpp.string-to-number.html">Converting a String to a Number Type in C++</a> </p>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a> </p>
        <p><a            href="cpp.iterators.html">Iterators: Pointers for STL Containers</a> </p>
      </div>
    </nav>
    <main>
      <h1>Regular Expressions in the STL</h1>

      <p>Regular expressions, defined in the <cite><code>&lt;regex&gt;</code></cite> header, are a powerful feature of the Standard Library. They are a special mini-language for string processing. They might seem complicated at first, but once you get to know them, they make working with strings easier.</p>

      <nav>
        <p><a href="#functions">Regular Expression Functions Provided</a></p>
        <p><a href="#versions">Different Regular Expression Grammars</a></p>
        <p><a href="#using-raw">Using Raw Strings</a></p>
        <p><a href="#procedure">Procedure for Applying Regular Expressions</a></p>
        <p><a href="#text-tỳpes">Text Types</a></p>
        <p><a href="#objs">Regular Expression Objects</a></p>
        <p><a href="#match_results">The Search Result <code>match_results</code></a></p>
        <p><a href="#sub_match"><code>td::sub_match</code></a></p>
        <p><a href="#matching">Matching</a></p>
        <p><a href="#searching">Searching</a></p>
        <p><a href="#replacing">Replacing</a></p>
        <p><a href="#formatting">Formatting</a></p>
        <p><a href="#repeated-search">Repeated Search</a></p>
        <p><a href="#removing-greediness">Removing Greediness</a></p>
      </nav>




      <section id="functions">
        <h2>Regular Expression Functions Provided</h2>
        <p>Some of the functions provided are:</p>
        <ul>
          <li><code>regex_match()</code>: Match a regular expression against a string (of known size).</li>
          <li><code>regex_search()</code>: Search for a string that matches a regular expression in an (arbitrarily long) stream of data. The result of a regex_search() is a collection of matches, typically represented as an <code class="classname">smatch</code>, which is a container of regex results.</li>
          <li><code>regex_replace()</code>: Search for strings that match a regular expression in an (arbitrarily long) stream of data and replace them.</li>
          <li><code>regex_iterator</code>: iterate over matches and submatches.</li>
          <li><code>regex_token_iterator</code>: iterate over non-matches.</li>
        </ul>
        <p>Some simple operations are next exemplified:</p>
        <pre>#include &lt;regex&gt;
#include &lt;iostream&gt;

int main (int argc, const char * argv[]) {
    std::regex r("st|mt|tr");
    std::cerr &lt;&lt; "st|mt|tr" &lt;&lt; " matches st? " &lt;&lt; std::regex_match("st", r) &lt;&lt; std::endl;
    std::cerr &lt;&lt; "st|mt|tr" &lt;&lt; " matches mt? " &lt;&lt; std::regex_match("mt", r) &lt;&lt; std::endl;
    std::cerr &lt;&lt; "st|mt|tr" &lt;&lt; " matches spruce? " &lt;&lt; std::regex_match("spruce", r) &lt;&lt; std::endl;

    return 0;
}</pre>
      </section>

      <section id="versions">
        <h2>Different Regular Expression Grammars</h2>
        <p>There are several different grammars for regular expressions. For this reason, C++ includes support for several of these grammars: ECMAScript, basic, extended, awk, grep, and egrep. If you already know any of these regular expression grammars, you can use it straight away in C++ by telling the regular expression library to use that specific syntax ( syntax_option_type ). The default grammar in C++ is ECMAScript whose syntax is explained in detail in the following section. It is also the most powerful grammar, so it&apos;s recommended to use ECMAScript instead of one of the other more limited grammars. Explaining the other regular expression grammars falls outside the scope of this section.</p>
        <section id="ECMAScript">
          <h3>ECMAScript Syntax</h3>
          <p>The ECMAScript 3 regular expression grammar in C++ is ECMA-262 grammar with modifications marked with <a href="#ECMAScript-cpp-only">(C++ only)</a> below.</p>
          <p>The modified regular expression grammar is mostly <a target="_blank" href="js.regexp.html">ECMAScript RegExp grammar</a> with a POSIX-type expansion on locales under ClassAtom. Some clarifications on equality checks and number parsing is made.</p>
          <hr/>
          <p>The <q>normative references</q> in the standard specifies ECMAScript 3.</p>
          <p>See the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">MDN Guide on JavaScript RegExp</a> for an overview on the dialect features.</p>
          <hr/>
          <p>ECMAScript syntax recognizes the following special characters:</p>
          <pre>^ $ \ . * + ? ( ) [ ] { } |</pre>
          <p>If you need to match one of these special characters, you need to escape it using the \ character. For example:</p>
          <pre>\[ or \. or \* or \\</pre>
          <section id="ECMAScript-cpp-only">
            <h3>C++-Only Differences</h3>
          </section>
        </section>

        <section id="basic">
          <h3>basic Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section id="extended">
          <h3>extended Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section id="awk">
          <h3>awk Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>


        <section id="grep">
          <h3>grep Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section id="egrep">
          <h3>egrep Syntax</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
      </section>

      <section id="using-raw">
        <h2>Using Raw Strings</h2>
        <p>Use <a target="_blank" href="cpp.raw-strings.html">raw string literals</a> in regular expressions.</p>
        <p>The regular expression for the text <q>C++</q> is fairly unwieldly: <code>C\\+\\+</code>. You have to use two backslashes for each + sign. First, the + sign is a unique character in a regular expression. Second, the backslash is a special character in a string. Therefore one backslash escapes the + sign; the other backslash escapes the backslash. By using a raw string literal, the second backslash is not necessary anymore because the backslash is not interpreted in the string.</p>
        <pre>#include &lt;regex&gt;

//...

std::string regExpr("C\\+\\+");
std::string regExprRaw(R"(C\+\+)");</pre>
      </section>

      <section id="procedure">
        <h2>Procedure for Applying Regular Expressions</h2>
        <dl>
          <dt>Define the regular expression [<a href="#objs">object</a>]</dt>
          <dd>
            <pre>std::string text="C++ or c++.";
std::string regExpr(R"(C\+\+)");
std::regex rgx(regExpr);</pre>
          </dd>
          <dt>Store the result of the search</dt>
          <dd>
            <pre>std::smatch result;
std::regex_search(text, result, rgx);</pre>
          </dd>
          <dt>Process the result</dt>
          <dd>
            <p></p>
            <pre>std::cout &lt;&lt; result[0] &lt;&lt; '\n';</pre>
          </dd>
        </dl>
        <section id="ex_raw-strings-exceptions">
          <h3>An Example with Raw Strings, Exceptions...</h3>
          <p>The following code snippet is a basic example that demonstrates how other elements of C++ work in tandem with regex. This snippet brings together core constructs such as string handling, control structures, and function definition, culminating in a small program that employs regex search functionality:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

// Function to search for a pattern within a provided text
bool containsPattern(const std::string&amp; text, const std::string&amp; patternStr) {
  try {
    std::regex pattern(patternStr);
    return std::regex_search(text, pattern);
  } catch (const std::regex_error&amp; e) {
    std::cerr &lt;&lt; "Regex error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    return false;
  }
}

int main() {
  // Defining a sample string and a simple regex pattern to identify an email address
  std::string sampleText = "Contact: example@example.com for more information.";
  std::string emailPattern = R"((\w+@\w+\.\w+))";

  // Using the containsPattern function to check if an email address exists in the sample text
  if (containsPattern(sampleText, emailPattern)) {
    std::cout &lt;&lt; "A valid email address was found in the text." &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "No valid email address was found in the text." &lt;&lt; std::endl;
  }
  return 0;
}</pre>
        </section>

        <section id="ex_basic-patterns">
          <h3>An Example: Matching Basic Patterns</h3>
          <p>The code below highlights how literal characters, metacharacters, character classes, quantifiers, grouping, and alternation can work together in a straightforward example. This example is implemented in a programming context and serves as a practical demonstration of the theoretical constructs of regex:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main() {
 // Define a basic regex pattern to match either "cat", "dog", or an email-like string
 std::regex pattern(R"((cat|dog)|([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}))");

 // Sample texts to test the regex pattern
 std::string test1 = "I have a cat and a dog.";
 std::string test2 = "Please contact us at info@example.com.";

 // Test the pattern against the sample texts using regex_search
 std::smatch match;
 if (std::regex_search(test1, match, pattern)) {
 std::cout &lt;&lt; "Match found in test1: " &lt;&lt; match.str() &lt;&lt; std::endl;
 }
 if (std::regex_search(test2, match, pattern)) {
 std::cout &lt;&lt; "Match found in test2: " &lt;&lt; match.str() &lt;&lt; std::endl;
 }

 return 0;
}</pre>
          <p>In this example, the regex pattern is constructed to match either the literal strings “cat” or “dog”, or an email address format. The use of grouping (with the parentheses) allows us to manage these two distinct options within a single pattern. The alternation operator (|) separates the options, and the pattern within the second group demonstrates the use of character classes and quantifiers.</p>
        </section>
        <section id="ex_greedy-lazy">
          <h3>An Example...</h3>
          <p>The following short programme demonstrates the difference between <a target="_blank" href="regexp.html#greedy-lazy">greedy and lazy</a> quantifiers:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;

int main() {
  // Demonstration of greedy versus lazy quantifiers
  std::string greedyTest = "&lt;tag&gt;Content&lt;/tag&gt;&lt;tag&gt;More&lt;/tag&gt;";
  // Greedy quantifier: matches as much as possible
  std::regex greedyPattern("&lt;tag&gt;.*&lt;/tag&gt;");
  // Lazy quantifier: matches as little as possible
  std::regex lazyPattern("&lt;tag&gt;.*?&lt;/tag&gt;");

  std::smatch match;
  if (std::regex_search(greedyTest, match, greedyPattern)) {
    std::cout &lt;&lt; "Greedy match: " &lt;&lt; match.str() &lt;&lt; std::endl;
  }
  if (std::regex_search(greedyTest, match, lazyPattern)) {
    std::cout &lt;&lt; "Lazy match: " &lt;&lt; match.str() &lt;&lt; std::endl;
  }
  return 0;
}</pre>
        </section>
        <!--
        <section>
          <h3>An Example...</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3>An Example...</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        -->
      </section>

      <section id="text-tỳpes">
        <h2>Text Types</h2>
        <p>The text type determines the character type of the regular expression and the type of the search result.</p>
        <p>The table below shows the four different combinations.</p>
        <table border="1" id="simple_with_header">
          <thead> <tr> <td>Text type</td> <td>Regular expression type</td> <td>Result type</td> </tr> </thead>
                  <tr> <td>const char*</td> <td>std::regex</td> <td>std::cmatch</td> </tr>
                  <tr> <td>std::string</td> <td>std::regex</td> <td>std::smatch</td> </tr>
                  <tr> <td>const wchar_t*</td> <td>std::wregex</td> <td>std::wcmatch</td> </tr>
                  <tr> <td>std::wstring</td> <td>std::wregex</td> <td>std::wsmatch</td> </tr>
        </table>
      </section>

      <section id="objs">
        <h2>Regular Expression Objects</h2>
        <p>Objects of type regular expression are instances of the class template template <code>&lt;class charT, class traits= regex_traits &lt;charT&gt;&gt;</code> class basic_regex parametrized by their character type and traits class. The traits class defines the interpretation of the properties of regular grammar. There are two type synonyms in C++:</p>
        <pre>typedef basic_regex&lt;char&gt; regex;
typedef basic_regex&lt;wchar_t&gt; wregex;</pre>
        <p>You can further customize the object of type regular expression. Therefore you can specify the grammar used or adapt the syntax. As mentioned, C++ supports the basic, extended, awk, grep, and egrep grammars.</p>
        <p>A regular expression qualified by the <code>std::regex_constants::icase flag</code> is case insensitive. If you want to adopt the syntax, you have to specify the grammar explicitly.</p>
        <pre>// regexGrammar.cpp
...
#include &lt;regex&gt;

...

using std::regex_constants::ECMAScript;
using std::regex_constants::icase;

std::string theQuestion="C++ or c++, that's the question.";
std::string regExprStr(R"(c\+\+)");

std::regex rgx(regExprStr);
std::smatch smatch;

if (std::regex_search(theQuestion, smatch, rgx)){
std::cout &lt;&lt; "case sensitive: " &lt;&lt; smatch[0];
}
std::regex rgxIn(regExprStr, ECMAScript|icase);
if (std::regex_search(theQuestion, smatch, rgxIn)){
std::cout &lt;&lt; "case insensitive: " &lt;&lt; smatch[0];
}</pre>
        <p>If you use the case-sensitive regular expression <var>rgx</var>, the result of the search in the text <var>theQuestion</var> is <code>c++</code>. That&apos;s not the case if your case-insensitive regular expression <var>rgxIn</var> is applied. Now you get the match string <code>C++</code>.</p>
      </section>

      <section id="match_results">
        <h2>The Search Result <code>match_results</code>*</h2>
        <p>The object of type <code>std::match_results</code> is the result of a <code>std::regex_match</code> or <code>std::regex_search</code>.</p>
        <p><code>std::match_results</code> is a sequence container having at least one <a target="_blank" href="regexp.html#capture-group">capture group</a> of a <code>std::sub_match</code> object. The <code>std::sub_match</code> objects are sequences of characters.</p>
        <p>C++ has four typedef&apos;s for <code>std::match_results</code>:</p>
        <pre>typedef match_results&lt;const char*&gt; cmatch;
typedef match_results&lt;const wchar_t*&gt; wcmatch;
typedef match_results&lt;string::const_iterator&gt; smatch;
typedef match_results&lt;wstring::const_iterator&gt; wsmatch;</pre>


        <p>The search result <code>std::smatch</code> has a powerful interface.</p>
        <table border="1">
          <thead> <tr> <th>Member Function</th> <th>Description</th> </tr> </thead>
          <tbody>
                  <tr> <td><code>smatch.size()</code></td> <td>Returns the number of capture groups.</td> </tr>
                  <tr> <td><code>smatch.empty()</code></td> <td>Returns if the search result has a capture group.</td> </tr>
                  <tr> <td><code>smatch[i]</code></td> <td>Returns the ith capture group.</td> </tr>
                  <tr> <td><code>smatch.length(i)</code></td> <td>Returns the length of the ith capture group.</td> </tr>
                  <tr> <td><code>smatch.position(i)</code></td> <td>Returns the position of the ith capture group.</td> </tr>
                  <tr> <td><code>smatch.str(i)</code></td> <td>Returns the ith capture group as string.</td> </tr>
                  <tr> <td><code>smatch.prefix() and smatch.suffix()</code></td> <td>Returns the string before and after the capture group.</td> </tr>
                  <tr> <td><code>smatch.begin() and smatch.end()</code></td> <td>Returns the begin and end iterator for the capture groups.</td> </tr>
                  <tr> <td><code>smatch.format(...)</code></td> <td>Formats std::smatch objects for the output.</td> </tr>
          </tbody>
        </table>
        <p>The following program shows the output of the first four capture groups for different regular expressions.</p>
        <pre>// captureGroups.cpp
...
#include &lt;regex>
...
using namespace std;

void showCaptureGroups(const string&amp; regEx, const string&amp; text){
  regex rgx(regEx);
  smatch smatch;
  if (regex_search(text, smatch, rgx)) {
    cout &lt;&lt; regEx &lt;&lt; text &lt;&lt; smatch[0] &lt;&lt; " " &lt;&lt; smatch[1]
    &lt;&lt; " "&lt;&lt; smatch[2] &lt;&lt; " " &lt;&lt; smatch[3] &lt;&lt; endl;
  }
}

showCaptureGroups("abc+", "abccccc");
showCaptureGroups("(a+)(b+)", "aaabccc");
showCaptureGroups("((a+)(b+))", "aaabccc");
showCaptureGroups("(ab)(abc)+", "ababcabc");</pre>
      </section>
      <section id="sub_match">
        <h2><code>td::sub_match</code></h2>
        <p>The capture groups are of type <code>std::sub_match</code>. As with <code>std::match_results</code>, C++ defines the following four type synonyms.</p>
        <pre>typedef sub_match&lt;const char*&gt; csub_match;
typedef sub_match&lt;const wchar_t*&gt; wcsub_match;
typedef sub_match&lt;string::const_iterator&gt; ssub_match;
typedef sub_match&lt;wstring::const_iterator&gt; wssub_match;</pre>

        <p>You can further analyze the capture group <var>cap</var>.</p>
        <table border="1">
          <thead> <tr> <th>Member Function</th> <th>Description</th> </tr> </thead>
          <tbody>
                  <tr> <td><code>cap.matched()</code></td> <td>Indicates if this match was successful.</td> </tr>
                  <tr> <td><code>cap.first()</code> and <code>cap.end()</code></td> <td>Returns the begin and end iterator of the character sequence.</td> </tr>
                  <tr> <td><code>cap.length()</code></td> <td>Returns the length of the capture group.</td> </tr>
                  <tr> <td><code>cap.str()</code></td> <td>Returns the capture group as [a] string.</td> </tr>
                  <tr> <td><code>cap.compare(<var>other</var>)</code></td> <td>Compares the current capture group with the <var>other</var> capture group.</td> </tr>
          </tbody>
        </table>

        <p>Here is a code snippet showing the interplay between the search result <code>std::match_results</code> and its capture groups <code>std::sub_match</code>&apos;s:</p>
        <pre>// subMatch.cpp
...
#include &lt;regex&gt;
...
using std::cout;

std::string privateAddress="192.168.178.21";
std::string regEx(R"((\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3}))");
std::regex rgx(regEx);
std::smatch smatch;

if (std::regex_match(privateAddress, smatch, rgx)) {

  for (auto cap: smatch) {
    cout &lt;&lt; "capture group: " &lt;&lt; cap &lt;&lt; '\n';
    if (cap.matched) {
      std::for_each(cap.first,
                    cap.second,
                    [](int v) {
        cout &lt;&lt; std::hex &lt;&lt; v &lt;&lt; " ";
                              });
      cout &lt;&lt; '\n';
    }
  } // for

}

...

capture group: 192.168.178.21
31 39 32 2e 31 36 38 2e 31 37 38 2e 32 31

capture group: 192
31 39 32

capture group: 168
31 36 38

capture group: 178
31 37 38

capture group: 21
32 31</pre>

        <p>The regular expression <var>regEx</var> stands for an IPv4 address. <var>regEx</var> extracts the address&apos;s components using capture groups. Finally, the capture groups and the characters in ASCII are displayed in hexadecimal values.</p>
      </section>

      <section id="matching">
        <h2>Matching</h2>
        <p><code><a href="#regex_match">std::regex_match</a></code> determines if the text matches a text pattern. You can further analyze the search result, which is of type <code>std::match_results</code>, and is set by a different STL global: <code><a href="#regex_search">std::regex_search</a></code>.</p>

        <section>
          <h3>An Example</h3>
          <p>The code snippet below shows three simple applications of <code>std::regex_match</code>: a C string, a C++ string, and a range returning only a boolean. The three variants are available for <code>std::match_results</code> objects, respectively.</p>
          <pre>// match.cpp
...
#include &lt;regex&gt;
...
std::string numberRegEx(R"([-+]?([0-9]*\.[0-9]+|[0-9]+))");
std::regex rgx(numberRegEx);
const char* numChar{"2011"};

if (std::regex_match(numChar, rgx)) {
  std::cout &lt;&lt; numChar &lt;&lt; "is a number." &lt;&lt; '\n';
}
// 2011 is a number.

const std::string numStr{"3.14159265359"};
if (std::regex_match(numStr, rgx)){
  std::cout &lt;&lt; numStr &lt;&lt; " is a number." &lt;&lt; '\n';
}
// 3.14159265359 is a number.

const std::vector&lt;char&gt; numVec{{'-', '2', '.', '7', '1', '8', '2',
'8', '1', '8', '2', '8'}};
if (std::regex_match(numVec.begin(), numVec.end(), rgx)) {
  for (auto c: numVec) { std::cout &lt;&lt; c ;};
  std::cout &lt;&lt; "is a number." &lt;&lt; '\n';
} // if
// -2.718281828 is a number.</pre>
        </section>
        <section id="regex_match">
          <h3><code>std::regex_match</code> (C++11)</h3>
          <p>Its constructors may take as its first argument(s):</p>
          <ul>
            <li>a beginning and an end iterators, or</li>
            <li>a pointer to const CHAR (<code>const CHAR*</code>), or</li>
            <li>a constant reference to a string (<code>std::basic_string&lt;CHAR&gt; &amp;</code>)</li>
          </ul>
          <p>These one or two paramenters may be followed by a <code>std::match_results</code> non-constant reference.</p>
          <p>The next parameter is mandatory: a reference to a <code>std::basic_regex</code> object</p>
          <p>Last is an optional flags parameter.</p>
          <aside>
            <h5 class="bridgehead"><code>regex_match</code> only considers full matches</h5>
            <p>Because <code>regex_match</code> only considers full matches, the same regex may give different matches between <code>std::regex_match</code> and <code>std::regex_search</code>:</p>
            <pre>std::regex re("Get|GetValue");
std::cmatch m;
std::regex_search("GetValue", m, re);  // returns true, and m[0] contains "Get"
std::regex_match ("GetValue", m, re);  // returns true, and m[0] contains "GetValue"
std::regex_search("GetValues", m, re); // returns true, and m[0] contains "Get"
std::regex_match ("GetValues", m, re); // returns false</pre>
          </aside>
          <section>
            <h4><code>std::regex_constants::match_flag_type</code> Flags</h4>
            <p>Their type is implementation-defined.</p>
            <table border="0">
              <thead>
                <tr> <th>Name</th> <th>Explanation</th> </tr> </thead>
                <tr> <td><code>match_not_bol</code></td> <td>The first character in [first, last) will be treated as if it is not at the beginning of a line (i.e. ^ will not match [first, first)).</td> </tr>
                <tr> <td><code>match_not_eol</code></td> <td>The last character in [first, last) will be treated as if it is not at the end of a line (i.e. $ will not match [last, last)).</td> </tr>
                <tr> <td><code>match_not_bow</code></td> <td>\b will not match [first, first).</td> </tr>
                <tr> <td><code>match_not_eow</code></td> <td>\b will not match [last, last).</td> </tr>
                <tr> <td><code>match_any</code></td> <td>If more than one match is possible, then any match is an acceptable result.</td> </tr>
                <tr> <td><code>match_not_null</code></td> <td>Do not match empty sequences.</td> </tr>
                <tr> <td><code>match_continuous</code></td> <td>Only match a sub-sequence that begins at first.</td> </tr>
                <tr> <td><code>match_prev_avail</code></td> <td>--first is a valid iterator position.</td> </tr>
                <tr> <td><code>When</code></td> <td>set, causes match_not_bol and match_not_bow to be ignored.</td> </tr>
                <tr> <td><code>format_default</code></td> <td>Use ECMAScript rules to construct strings in std::regex_replace (syntax documentation).</td> </tr>
                <tr> <td><code>format_sed</code></td> <td>Use POSIX sed utility rules in std::regex_replace (syntax documentation).</td> </tr>
                <tr> <td><code>format_no_copy</code></td> <td>Do not copy un-matched strings to the output in std::regex_replace.</td> </tr>
                <tr> <td><code>format_first_only</code></td> <td>Only replace the first match in std::regex_replace.</td> </tr>
            </table>
            <p>All constants, except for match_default and format_default, are bitmask elements. The match_default and format_default constants are empty bitmasks.</p>
          </section>
        </section>
      </section>

      <section id="searching">
        <h2>Searching</h2>
        <p><code>std::regex_search&lt;<var>CHAR</var>&gt;</code> checks if the text contains a text pattern. You can use the function with and without a <code>std::match_results</code> object and apply it to a C string, a C++ string, or a range.</p>
        <section>
          <h3>An Example</h3>
          <p>The example below shows how to use <code>std::regex_search</code> with texts of type <code>const char*</code>, <code>std::string</code>, <code>const wchar_t*</code>, and <code>std::wstring</code>.</p>
          <pre>// search.cpp
...
#include &lt;regex&gt;
...

// regular expression holder for time
std::regex crgx("([01]?[0-9]|2[0-3]):[0-5][0-9]");

// const char*
std::cmatch cmatch;

const char* ctime{"Now it is 23:10." };
if (std::regex_search(ctime, cmatch, crgx)) {
  std::cout &lt;&lt; ctime &lt;&lt; '\n';
  std::cout &lt;&lt; "Time: " &lt;&lt; cmatch[0] &lt;&lt; '\n'; // Time: 23:10
}

// std::string
std::smatch smatch;
std::string stime{"Now it is 23:25." };
if (std::regex_search(stime, smatch, crgx)) {
  std::cout &lt;&lt; stime &lt;&lt; '\n';
  std::cout &lt;&lt; "Time: " &lt;&lt; smatch[0] &lt;&lt; '\n'; // Time: 23:25
}

// regular expression holder for time
std::wregex wrgx(L"([01]?[0-9]|2[0-3]):[0-5][0-9]");

// const wchar_t*
std::wcmatch wcmatch;

const wchar_t* wctime{L "Now it is 23:47." };
if (std::regex_search(wctime, wcmatch, wrgx)) {
  std::wcout &lt;&lt; wctime &lt;&lt; '\n';
  std::wcout &lt;&lt; "Time: " &lt;&lt; wcmatch[0] &lt;&lt; '\n'; // Time: 23:47
}

// std::wstring
std::wsmatch wsmatch;

std::wstring wstime{L "Now it is 00:03." };
if (std::regex_search(wstime, wsmatch, wrgx)) {
  std::wcout &lt;&lt; wstime &lt;&lt; '\n';
  std::wcout &lt;&lt; "Time: " &lt;&lt; wsmatch[0] &lt;&lt; '\n'; // Time: 00:03
}</pre>
        </section>
        <section id="regex_search">
          <h3><code>std::regex_search</code> (C++11)</h3>
          <p>Determines if there is a match between the regular expression e and some subsequence in the target character sequence. The detailed match result is stored in input-output parameter <code>std::match_results&lt;&gt; <var>m</var></code> (if present).</p>
          <p>The return type is <code>bool</code>.</p>
          <p>The main difference between <code>std::regex_match</code> and <code>std::regex_search</code> is... (<i>see below</i>)</p>
        </section>
      </section>

      <section>
        <h2>Difference Between <code>std::regex_match</code> and <code>std::regex_search</code></h2>
        <p><code>regex_match</code> only returns true when the entire input sequence has been matched, while <code>regex_search</code> will succeed even if only a sub-sequence matches the regex.</p>
      </section>

      <section id="replacing">
        <h2>Replacing</h2>
        <p><code>std::regex_replace</code> replaces sequences in a text matching a text pattern. It returns in the simple form <code>std::regex_replace(<var>text</var>, <var>regex</var>, <var>replString</var>)</code> its result as string. The function replaces an occurrence of <var>regex</var> in text with <var>replString</var>.</p>
        <pre>// replace.cpp
...
#include &lt;regex&gt;
...
using namespace std;

string future{"Future"};
string unofficialName{
  "The unofficial name of the new C++ standard is C++0x."};

regex rgxCpp{R"(C\+\+0x)"};
string newCppName{"C++11"};
string newName{regex_replace(unofficialName, rgxCpp, newCppName)};

regex rgxOff{"unofficial"};
string makeOfficial{"official"};
string officialName{regex_replace(newName, rgxOff, makeOfficial)};

cout &lt;&lt; officialName &lt;&lt; endl;
            // The official name of the new C++ standard is C++11.</pre>
        <p>In addition to the simple version, C++ has a version of <code>std::regex_replace</code> working on ranges. It enables you to push the modified string directly into another string:</p>
        <pre>typedef basic_regex&lt;char&gt; regex;
std::string str2;
std::regex_replace(std::back_inserter(str2),
                   text.begin(), text.end(),
                   regex,replString);</pre>
        <p>All variants of <code>std::regex_replace</code> have an additional optional parameter. If you set the parameter to <code>std::regex_constants::format_no_copy</code>, you will get the part of the text matching the regular expression. The unmatched text is not copied. If you set the parameter to <code>std::regex_constants::format_first_only</code>, then <code>std::regex_replace</code> will only be applied once.</p>
      </section>

      <section id="formatting">
        <h2>Formatting</h2>
        <p><code>std::regex_replace</code> and <code>std::match_results.format</code> in combination with capture groups enables you to format text. You can use a format string together with a placeholder to insert the value.</p>
        <p>Here are both possibilities, first with <code>regex</code>:</p>
        <pre>// format.cpp
...
#include &lt;regex&gt;
...
std::string future{"Future"};
const std::string unofficial{"unofficial, C++0x"};
const std::string official{"official, C++11"};

std::regex regValues{"(.*),(.*)"};
std::string standardText{"The $1 name of the new C++ standard is $2."};
std::string textNow = std::regex_replace(unofficial, regValues, standardText);
std::cout &lt;&lt; textNow &lt;&lt; '\n';
  // The unofficial name of the new C++ standard is C++0x.

std::smatch smatch;
if (std::regex_match(official, smatch, regValues)) {
  std::cout &lt;&lt; smatch.str(); // official,C++11
  std::string textFuture = smatch.format(standardText);
  std::cout &lt;&lt; textFuture &lt;&lt; '\n';
} // The official name of the new C++ standard is C++11.</pre>
        <p>In the function call <code>std::regex_replace(unoffical, regValues, standardText)</code>, the text matching the first and second capture group of the regular expression <var>regValues</var> is extracted from the string unofficial. The placeholders <code>$1</code> and <code>$2</code> in the text <var>standardText</var> are then replaced by the extracted values. The strategy of <code>smatch.format(standardTest)</code> is similar, but there is a difference:</p>
        <p>The creation of the search results <code>smatch</code> is separated from their usage when formatting the string.</p>
        <p>In addition to capture groups, C++ supports additional format escape sequences. You can use them in format strings:</p>
        <table border="1" id="simple_with_header_and_th">
          <thead> <tr> <th>Format escape sequence</th> <th>Description</th> </tr> </thead>
                  <tr> <td><code>$&amp;</code></td> <td>Returns the total match (0th capture group).</td> </tr>
                  <tr> <td><code>$$</code></td> <td>Returns $.</td> </tr>
                  <tr> <td><code>$`</code> (backward tic)</td> <td>Returns the text <em>before</em> the total match.</td> </tr> $`
                  <tr> <td><code>$Â´</code> (forward tic)</td> <td>Returns the text <em>after</em> the total match.</td> </tr>
                  <tr> <td><code>‘$ i’</code></td> <td>Returns the ith capture group.</td> </tr>
        </table>
      </section>
      <section id="repeated-search">
        <h2>Repeated Search</h2>
        <p>It&apos;s pretty convenient to iterate with <code>std::regex_iterator</code> and <code>std::regex_token_iterator</code> through the matched texts. <code>std::regex_iterator</code> supports the matches and their capture groups. <code>std::regex_token_iterator</code> supports more. You can address the components of each capture.</p>
        <p>Using a negative index enables it to access the text between the matches.</p>
        <section>
          <h3><code>std::regex_iterator</code></h3>
          <p>C++ defines the following four type synonyms for <code>std::regex_iterator</code>:</p>
          <pre>typedef  cregex_iterator regex_iterator&lt;const char*&gt;
typedef wcregex_iterator regex_iterator&lt;const wchar_t*&gt;
typedef  sregex_iterator regex_iterator&lt;std::string::const_iterator&gt;
typedef wsregex_iterator regex_iterator&lt;std::wstring::const_iterator&gt;</pre>
          <hr/>
          <p>You may use <code>std::regex_iterator</code> to count the occurrences of the words in a text:</p>
          <pre>// regexIterator.cpp
...
#include &lt;regex&gt;
#include &lt;unordered_map&gt;
...
using std::cout;

std::string text{"That's a (to me) amazingly frequent question. It may be the most freque\
ntly asked question. Surprisingly, C++11 feels like a new language: The pieces just fit t\
ogether better than they used to, and I find a higher-level style of programming more nat\
ural than before and as efficient as ever." };

std::regex wordReg{R"(\w+)"};
      std::sregex_iterator wordItBegin(text.begin(), text.end(), wordReg);
const std::sregex_iterator wordItEnd;
std::unordered_map&lt;std::string, std::size_t&gt; allWords;
for (; wordItBegin != wordItEnd; ++wordItBegin) {
  ++allWords[wordItBegin-&gt;str()];
}
for (auto wordIt: allWords)
  cout &lt;&lt; "(" &lt;&lt; wordIt.first &lt;&lt; ":"
       &lt;&lt; wordIt.second &lt;&lt; ")";
// (as:2)(of:1)(level:1)(find:1)(ever:1)(and:2)(natural:1)</pre>
          <p>A word consists of a least one word-character <code>(\w+)</code>. This regular expression is used to define the begin iterator <var>wordItBegin</var>, then the end iterator <var>wordItEnd</var> is defined (default constructor).</p>
          <p>The iteration through the matches happens in the <code>for</code> loop. Each word increments the counter: <code>++<var>allWords</var>[<var>wordItBegin</var>]->str()]</code>. A word whose counter equals 1 is created if it is not already in <var>allWords</var>.</p>
          <hr/>
          <p>Another example, from the <cite><a target="_blank" href="https://cplusplus.com/reference/regex/regex_iterator/regex_iterator/">CPlusPlus</a></cite> site:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

int main ()
{
  std::string s ("this subject has a submarine as a subsequence");
  std::regex e ("\\b(sub)([^ ]*)");   // matches words beginning by "sub"

  std::regex_iterator&lt;std::string::iterator&gt; rit ( s.begin(), s.end(), e );
  std::regex_iterator&lt;std::string::iterator&gt; rend;

  while (rit!=rend) {
    std::cout &lt;&lt; rit-&gt;str() &lt;&lt; std::endl;
    ++rit;
  }

  return 0;
}</pre>
          <p>[...]</p>
        </section>
        <section>
          <h3><code>std::regex_token_iterator</code></h3>
          <p>C++ defines the following four type synonyms for <code>std::regex_token_iterator</code>:</p>
          <pre>typedef  cregex_token_iterator regex_token_iterator&lt;const char*&gt;
typedef wcregex_token_iterator regex_token_iterator&lt;const wchar_t*&gt;
typedef  sregex_token_iterator regex_token_iterator&lt;std::string::const_iterator&gt;
typedef wsregex_token_iterator regex_token_iterator&lt;std::wstring::const_iterator&gt;</pre>
          <p><code>std::regex_token_iterator</code> enables you to use indexes to explicitly specify which capture groups you are interested in. If you don&apos;t specify the index, you will get all capture groups, even though you can also request specific capture groups using their respective index.</p>
          <p>The -1 index is particular: You can use -1 to address the text between the matches.</p>
          <pre>// tokenIterator.cpp
...
using namespace std;

std::string text{"Pete Becker, The C++ Standard Library Extensions, 2006:"
"Nicolai Josuttis, The C++ Standard Library, 1999:"
"Andrei Alexandrescu, Modern C++ Design, 2001"};

regex regBook(R"((\w+)\s(\w+),([\w\s\+]*),(\d{4}))");
sregex_token_iterator bookItBegin(text.begin(), text.end(), regBook);Regular Expressions
const sregex_token_iterator bookItEnd;
while (bookItBegin != bookItEnd){
cout &lt;&lt; *bookItBegin++ &lt;&lt; endl;
}
// Pete Becker,The C++ Standard Library Extensions,2006
// Nicolai Josuttis,The C++ Standard Library,1999

sregex_token_iterator bookItNameIssueBegin(text.begin(),
                                           text.end(),
                                           regBook, {{2,4}});
const sregex_token_iterator bookItNameIssueEnd;</pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
      </section>


      <!--

      <section>
        <h2>ing *</h2>
        <p></p>
        <pre></pre>
        <p></p>
      </section>
      -->

      <section id="removing-greediness">
        <h2>Removing Greediness</h2>
        <p>To make regular expression repetitions non-greedy, a ? can be added behind the repeat as in *? , +? , ?? , and {...}? . A non-greedy repetition repeats its pattern as few times as possible while still matching the remainder of the regular expression.</p>
      </section>

      <section id="compiling">
        <h2>Compiling Classes and Functions into an Object File, say (<cite>regex.o</cite>)*</h2>
        <p>Specialization <code>std::regex&lt;char&gt;</code> is particularly easy to declare</p>
        <pre>template class std::regex&lt;char&gt;;</pre>
        <p>and is bound to save about eight seconds&apos; compilation time.</p>
      </section>

    </main>
  </body>
</html>
