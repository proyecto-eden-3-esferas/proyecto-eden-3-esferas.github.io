<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Strings</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="JavaScript Strings"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel="next" href="js.regexp.html">JavaScript Regular Expressions</a></p>
        <p><a            href="js.objects.html">JavaScript Objects (as a Data Type and as a Class)</a></p>
        <p><a rel="prev" href="js.html">JavaScript: the Web Programming Language</a></p>
      </div>
      <div>
        <p><a            href="json.html">JavaScript Object Notation</a></p>
      </div>

    </nav>

    <main>
      <h1>JavaScript Strings</h1>
      <p>...</p>

      <section>
        <h2>UTF-16</h2>
        <p>JavaScript strings are encoded as a sequence of 16-bit numbers. These are called <dfn>code units</dfn>. A Unicode character code was initially supposed to fit within such a unit (which gives you a little over 65,000 characters). When it became clear that wasn&apos;t going to be enough, many people balked at the need to use more memory per character. To address these concerns, UTF-16, the format also used by JavaScript strings, was invented. It describes most common characters using a single 16-bit code unit but uses a pair of two such units for others.</p>
        <hr/>
        <p>UTF-16 is generally considered a bad idea today. It seems almost intentionally designed to invite mistakes. It&apos;s easy to write programs that pretend code units and characters are the same thing. And if your language doesn&apos;t use two-unit characters, that will appear to work just fine. But as soon as someone tries to use such a program with some less common Chinese characters, it breaks. Fortunately, with the advent of emoji, everybody has started using two-unit characters, and the burden of dealing with such problems is more fairly distributed.</p>
        <section>
          <h3>Surrogate Pairs</h3>
          <p>As said, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as <dfn>surrogate pairs</dfn>, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between 0xD800 and 0xDFFF, and these code units are not used to encode single-code-unit characters. (More precisely, <strong>leading surrogates</strong>, also called <strong>high-surrogate code units</strong>, have values between 0xD800 and 0xDBFF, inclusive, while <strong>trailing surrogates</strong>, also called <strong>low-surrogate code units</strong>, have values between 0xDC00 and 0xDFFF, inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with \u{xxxxxx} where xxxxxx represents 1–6 hex digits.</p>
        </section>
        <section>
          <h3>Lone Surrogates</h3>
          <p>A <dfn>lone surrogate</dfn> is a 16-bit code unit satisfying one of the descriptions below:</p>
          <ul>
            <li>It is in the range 0xD800–0xDBFF, inclusive (i.e., is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.</li>
            <li>It is in the range 0xDC00–0xDFFF, inclusive (i.e., is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate.</li>
          </ul>
          <p>Lone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems — for example, <code>encodeURI()</code> will throw a <code>URIError</code> for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called <dfn>well-formed strings</dfn>, and are safe to be used with functions that do not deal with UTF-16 (such as <code>encodeURI()</code> or <code>TextEncoder</code>). You can check if a string is well-formed with the <code>isWellFormed()</code> method, or sanitize lone surrogates with the <code>toWellFormed()</code> method.</p>
        </section>
        <section>
          <h3>Accessing Characters with Old <code>String.charCodeAt</code>, New <code>codePointAt</code>...</h3>
          <p>JavaScript&apos;s <code>charCodeAt</code> method gives you a code unit, not a full character code. The <code>codePointAt</code> method, added later, does give a full Unicode character, so we could use that to get characters from a string. But the argument passed to <code>codePointAt</code> is still an index into the sequence of code units. To run over all characters in a string, we&apos;d still need to deal with the question of whether a character takes up one or two code units.</p>
        </section>
      </section>

      <section id="toString">
        <h2><code>toString()</code></h2>
        <p>When you call the <code>String(<var>OBJ</var>)</code> function (which converts a value to a string) on an object, it will call the <code>toString()</code> method on that object to try to create a meaningful string from it.</p>
        <p>Some of the standard prototypes define their own version of <code>toString</code> so they can create a string that contains more useful information than <q>[object Object]</q>. You can also do that yourself.</p>
        <pre>Rabbit.prototype.toString = function() {
return `a ${this.type} rabbit`;
};</pre>
        <p>which you can use as follows:</p>
        <pre>console.log(String(killerRabbit));
// → a killer rabbit</pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
      </section>

      <section id="template">
        <h2>Template Literals/Strings</h2>
        <p><dfn>Template Strings</dfn> use back-ticks (``) rather than the quotes ("") to define a string:</p>
        <pre>let text = `Hello World!`;</pre>
        <p>Features:</p>
        <dl>
          <dt>Template Strings allow both single and double unscaped quotes inside a string:</dt>
          <dd>
            <p>Example:</p>
            <pre>let text = `He's often called "Johnny"`;</pre>
          </dd>
          <dt>Multiline Strings</dt>
          <dd>
            <p>Template Strings allow multiline strings</p>
            <pre>let text =
`The quick
brown fox
jumps over
the lazy dog`;</pre>
          </dd>
          <dt>Interpolation</dt>
          <dd>
            <p>Template Strings allow variables in strings. They provide an easy way to interpolate variables in strings.</p>
            <p><strong>Syntax</strong></p>
            <pre>${...}</pre>
            <p>Example. Variable Substitutions:</p>
            <pre>let firstName = "John";
let lastName = "Doe";

let text = `Welcome ${firstName}, ${lastName}!`;</pre>
          </dd>
          <dt>Expression Substitution</dt>
          <dd>
            <p>Template Strings allow interpolation of expressions in strings.</p>
            <p>Example:</p>
            <pre>let price = 10;
let VAT = 0.25;

let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;</pre>
          </dd>
          <dt>HTML Templates</dt>
          <dd>
            <p>Example:</p>
            <pre>let header = "Template Strings";
let tags = ["template strings", "javascript", "es6"];

let html = `&lt;h2&gt;${header}&lt;/h2&gt;&lt;ul&gt;`;
for (const x of tags) {
  html += `&lt;li&gt;${x}&lt;/li&gt;`;
}

html += `&lt;/ul&gt;`;</pre>
          </dd>
        </dl>
      </section>

      <section id="replacing">
        <h2>Replacing String Pieces with Other Pieces with <code>replace(<code>STARTSTRING</code>,<code>ENDSTRING</code>)</code> and <code>replaceAll(<code>STARTSTRING</code>,<code>ENDSTRING</code>)</code></h2>
        <p>The <code>replace()</code> method searches a string for a value or a regular expression and returns a new string with the value(s) replaced. It does not change the original string.</p>
        <pre>let text = "Visit Microsoft!";
let result = text.replace("Microsoft", "W3Schools");</pre>
        <p>Or with a regexp capture:</p>
        <pre>let text = "Mr Blue has a blue house and a blue car";
let result = text.replace(/blue/g, "red");</pre>
        <p><strong>Note</strong> If you replace a value, only the first instance will be replaced. To replace all instances, use a regular expression with the <code>g</code> modifier set.</p>
        <hr/>
        <p>The <code>replaceAll()</code> method searches a string for a value or a regular expression. A new string with all values replaced is returned, while the original string is not changed. (Introduced in JavaScript 2021.)</p>
        <p>You can replace <em>all</em> occurrances of a given substring:</p>
        <pre>text = text.replaceAll("Cats","Dogs");
text = text.replaceAll("cats","dogs");</pre>
        <p>You can also replace <em>all</em> occurrances of a regexp capture:</p>
        <pre>text = text.replaceAll(/Cats/g,"Dogs");
text = text.replaceAll(/cats/g,"dogs");</pre>
        <p><strong>Note</strong> If the parameter is a regular expression, the global flag (<code>g</code>) must be set, otherwise a <code>TypeError</code> is thrown.</p>
      </section>

      <section>
        <h2><code><var>STRING</var>.search(<var>SUBSTRING/REGEX</var>)</code> and <code><var>STRING</var>.match(<var>SUBSTRING/REGEX</var>)</code></h2>
        <p>The <code>search()</code> method matches a string against a substring or a regular expression and returns the index (position) of the first match, or -1 if no match is found. (The <code>search()</code> method is case sensitive.)</p>
        <p>An example with a string argument:</p>
        <pre>let text = "Mr. Blue has a blue house";
let position = text.search("blue");</pre>
        <p>An example with a regexp argument:</p>
        <pre>let text = "Mr. Blue has a blue house";
let position = text.search(/Blue/);</pre>
        <aside>
          <p>The <code>search()</code> cannot take a start position argument.</p>
          <p>The <code>indexOf()</code> method cannot search against a regular expression.</p>
          <p>The <code>match()</code> method returns an array of matches (and <code>null</code> if no match is found).</p>
        </aside>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
      </section>
      <!--
      <section>
        <h2></h2>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
      </section>
      -->

    </main>

  </body>

</html>
