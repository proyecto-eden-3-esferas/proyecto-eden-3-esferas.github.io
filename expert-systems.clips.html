<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>Expert Systems</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p> <a rel="prev" href="expert-systems.html">Expert Systems</a> </p>
        <p> <a rel="next" href="knowledge-representation.html">Knowledge Representation</a> </p>
        <p> <a            href="machine_learning.html">Machine Learning</a> </p>
        <p> <a            href="gai.html">Generative Artificial Intelligence</a> </p>
        <p> <a            href="ann.html">Artificial Neural Networks</a> </p>
        <p> <a            href="ai.html">Artificial Intelligence</a></p>
      </div>
      <div>
        <p> <a href="prolog.html">Programation Logique</a> </p>
        <p> <a href="lisp.html">Lisp: The List Processing Language</a> </p>
      </div>
    </nav>
    <main>
      <h1>CLIPS: an Open Source Expert System</h1>
      <div class="abstract">
        <p>CLIPS is an expert system tool originally developed by the Software Technology Branch (STB), NASA/Lyndon B. Johnson Space Center. Since its first release in 1986, CLIPS has undergone continual refinement and improvement. It is now used by thousands of people around the world.</p>
        <p>This section borrows heavily from <cite class="book">CLIPS User's Guide</cite>, by Joseph C. Giarratano, Ph.D.</p>
        <hr/>
        <p>There are three ways to represent knowledge in CLIPS:</p>
        <ul>
          <li><em>Rules</em>, which are primarily intended for heuristic knowledge based on experience.</li>
          <li><em>Deffunctions</em> and <em>generic functions</em>, which are primarily intended for procedural knowledge.</li>
          <li><em>Object-oriented programming</em>, also primarily intended for procedural knowledge. The five generally accepted features of object-oriented programming are supported: classes, message-handlers, abstraction, encapsulation, inheritance, and polymorphism. Rules may pattern match on objects and facts.</li>
        </ul>
        <p>You can develop software using only rules, only objects, or a mixture of objects and rules.</p>
        <p>CLIPS has also been designed for integration with other languages such as C and Java. In fact, CLIPS is an acronym for C Language Integrated Production System. Rules and objects form an integrated system too since rules can pattern-match on facts and objects. In addition to being used as a stand-alone tool, CLIPS can be called from a procedural language, perform its function, and then return control back to the calling program. Likewise, procedural code can be defined as external functions and called from CLIPS. When the external code completes execution, control returns to CLIPS.</p>
        <p>If you are already familiar with object-oriented programming in other languages such as Smalltalk, C++, Objective C, or Java, you know the advantages of objects in developing software. If you are not familiar with object-oriented programming, you will find that CLIPS is an excellent tool for learning this new concept in software development.</p>
      </div>
      <section>
        <h2>CLIPS Basics</h2>
        <p>CLIPS shell provides the basic elements of an expert system:</p>
        <ul>
          <li>1. fact-list, and instance-list: Global memory for data</li>
          <li>2. knowledge-base: Contains all the rules, the rule-base</li>
          <li>3. inference engine: Controls overall execution of rules</li>
        </ul>
        <p>A program written in CLIPS may consist of rules, facts, and objects. The inference engine decides which rules should be executed and when. A rule-based expert system written in CLIPS is a data-driven program where the facts, and objects if desired, are the data that stimulate execution via the inference engine.</p>
        <p>Lastly, The normal mode of leaving CLIPS is with the exit command. Just type</p>
        <pre>(exit)</pre>
        <p>in response to the CLIPS prompt and then press the carriage return key.</p>
      </section>
      <section>
        <h2>Facts in CLIPS</h2>
        <p>A fact consists of one or more fields enclosed in matching left and right parentheses. For simplicity we 'll only discuss facts in the first seven chapters, but most of the discussion of pattern matching applies to objects as well. Exceptions are certain functions such as assert and retract which only apply to facts, not objects.</p>
        <p>If you want to put data in the fact-list, you can use the assert command.</p>
        <p>As an example of assert, enter the following right after the CLIPS prompt as shown:</p>
        <pre>CLIPS&gt; (assert (duck))</pre>
        <p>Here the assert command takes (duck) as its argument. Be sure to always press the carriage return key to send the line to CLIPS.</p>
        <p>The keyboard command to see facts is with the facts command. Enter (facts) in response to the CLIPS prompt and CLIPS will respond with a list of facts in the fact-list. Be sure to put parentheses around the command or CLIPS will not accept it. The result of the (facts) command in this example should be</p>
        <pre>CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (duck)
For a total of 2 facts.
CLIPS&gt;</pre>
        <p>The terms f-0 and f-1 are the fact identifier assigned to each fact by CLIPS. Every fact inserted into the fact-list is assigned a unique fact identifier starting with the letter <q>f</q> and followed by an integer called the fact-index. On starting up CLIPS, and after certain commands such as <code class="command">clear</code> and <code class="command">reset</code> (to be discussed in more detail later), the fact-index will be set to zero, and then incremented by one as each new fact is asserted. The <kbd>(reset)</kbd> and <kbd>(clear)</kbd> commands will also insert a fact (initial-fact) as f-0. In prior versions of CLIPS this fact was used implicitly by CLIPS to initially activate some types of rules and could also be used explicitly by user programs to activate rules as well, but is now only provided for backwards compatibility.</p>
        <p>What happens if you try to put a second duck into the fact-list? Let 's try it and see. Assert a new (duck), then issue a (facts) command as follows</p>
        <pre>CLIPS&gt; (assert (duck))
FALSE
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (duck)
For a total of 2 facts.
CLIPS&gt;</pre>
        <p>The FALSE message is returned by CLIPS to indicate that it was not possible to perform this command. You 'll see just the original <q>f-1 (duck)</q>. This shows that CLIPS will not accept a duplicate entry of a fact. However, there is an override command, set-fact-duplication, which will allow duplicate fact entry.</p>
        <p>Facts may be removed or <dfn>retracted</dfn>. When a fact is retracted, the other facts do not have their indices changed, and so there may be missing fact-indices.</p>
        <p>The <code class="command">clear</code> command removes all facts from memory. The (clear) command essentially restores CLIPS to its original startup state. It clears the memory of CLIPS, resets the fact-identifier to zero, and asserts the (initial-fact). The (clear) command actually does more than just remove facts. (clear) also removes all the rules.</p>
        <section>
          <title>Fact Fields</title>
          <p/>
          <p>A fact such as (duck) or (quack) is said to consist of a <em>single</em> field. A field is a placeholder (named or unnamed) that may have a value associated with it. As a simple analogy, you can think of a field as a picture frame. The frame can hold a picture, perhaps a picture of your pet duck (For those of you who are curious what a picture of a <q>quack</q> looks like, it could be (1) a photo of an oscilloscope trace of a duck saying <q>quack</q>, where the signal input comes from a microphone, or (2) for those of you who are more scientifically inclined, a Fast Fourier Transform of the <q>quack</q> signal, or (3) a TV-huckster selling a miracle cure for wrinkles, losing weight, etc.). Named placeholders are only used with <a href="#CLIPS.deftemplate">deftemplates</a>, described in more detail further on.</p>
          <p>The (duck) fact has a single, unnamed placeholder for the value duck. This is an example of a single-field fact. A field is a placeholder for a value. As an analogy to fields, think of dishes (fields) for holding food (values).</p>
          <p>The order of unnamed fields is significant.</p>
          <p>Actually, it is good software engineering to start the fact with a relation that describes the fields. A well-constructed fact would be <kbd>(hunter-game duck Brian)</kbd> to imply that the first field is the hunter and the second field is the game.</p>
        </section>
        <section>
          <title>Fact Lists and <kbd>nil</kbd></title>
          <p/>
          <p>A <dfn>list</dfn> is a group of items with no implied order. Saying that a list is ordered means that the position in the list is significant. A multifield is a sequence of fields, each of which may have a value. The examples of (duck Brian) and (Brian duck) are multifield facts.</p>
          <p>If a field has no value, the special symbol <kbd>nil</kbd>, which means <q>nothing</q> may be used for an empty field as a placeholder. For example,</p>
          <pre>(duck nil)</pre>
          <p>would mean that the killer duck bagged no trophies today.</p>
          <p>Note that the nil is necessary to indicate a placeholder, even if it has no value. For example, think of a field as analogous to a mailbox. There 's a big difference between an empty mailbox, and no mailbox at all. Without the nil, the fact becomes a single-field fact (duck). If a rule depends on two fields, it will not work with only one field, as you 'll see later.</p>
        </section>
        <section>
          <title>Field Types</title>
          <p>There are a number of different types of fields available: float, integer, symbol, string, external-address, fact-address, instance-name and instance-address The type of each field is determined by the type of value stored in the field. In an unnamed field, the type is determined implicitly by what type you put in the field. In <a href="#CLIPS.deftemplate">deftemplates</a>, you can explicitly declare the type of value that a field can contain. The use of explicit types enforces the concepts of software engineering, which is a discipline of programming to produce quality software.</p>
          <p>A <dfn>symbol</dfn> is one type of field that starts with a printable ASCII character and is followed optionally by zero or more printable characters. Fields are commonly delimited or bounded, by one or more spaces or parentheses. For example,</p>
          <pre>(duck-shot Brian Gary Rey)</pre>
          <p>However, this could be a legal deftemplate fact if <q>shot</q> is defined as the name of a field, while <q>Brian Gary Rey</q> are the values associated with the named field.</p>
        </section>
        <section>
          <title>Characters in CLIPS</title>
          <p>CLIPS is case-sensitive. Also, certain characters have special meaning to CLIPS.</p>
          <pre>" ( ) &amp; | &lt; ~ ; ? $</pre>
          <p>The <q>&amp;</q>, <q>|</q>, and <q>~</q> may not be used as stand-alone symbols or as any part of a symbol.</p>
          <p>Some characters act as delimiters by ending a symbol. The following characters act as delimiters for symbols.</p>
          <ul>
            <li>any non-printable ASCII character, including spaces, carriage returns, tabs, and linefeeds</li>
            <li>double quotes, "</li>
            <li>opening and closing parentheses, ()</li>
            <li>ampersand, &amp;</li>
            <li>vertical bar, | </li>
            <li>less than, &lt;. Note that this may be the first character of a symbol</li>
            <li>tilde, ~</li>
            <li>semicolon, ; indicates start of a comment, a carriage return ends it</li>
            <li>? and $? may not begin a symbol but may be inside it</li>
          </ul>
          <p>The semicolon acts as the start of a comment in CLIPS. If you try to assert a semicolon, CLIPS will think you 're entering a comment and wait for you to finish. If you accidentally enter a semicolon in top-level, just type in a closing parenthesis and carriage return. CLIPS will respond with an error message and the CLIPS prompt will reappear (This is one of the few approved occasions in life in which it 's necessary to do something wrong to get something right.)</p>
          <p>The following are examples of symbols:</p>
          <pre>duck
duck1
duck_soup
duck-soup
duck1-1_soup-soup
d!?#%^</pre>
          <p>The correct way to put double quotes in a fact is with the backslash, <q>\</q>,</p>
        </section>
        <section>
          <title>String Fields in CLIPS</title>
          <p>The second type of field is the <dfn>string</dfn>. A string must begin and end with double quotes. The double quotes are part of the field. Zero or more characters of any kind can appear between the double quotes. Some examples of strings</p>
          <pre>"duck"
"duck1"
"duck/soup"
"duck soup"
"duck soup is good!!!"</pre>
        </section>
        <section>
          <title>Numeric Fields</title>
          <p>The third and fourth types of field are numeric fields. A field which represents a number can be either an integer or floating-point type field. A floating-point type is commonly referred to simply as a float.</p>
          <p>All numbers in CLIPS are treated as <classname>long long</classname> integers or double-precision floats. Numbers without a decimal point are treated as integers unless they are outside integer range. The range is machine dependent on the number of bits, N.</p>
          <p>Each fact must start with a symbol such as <q>number</q>, <q>x</q>, <q>y</q>, etc. Before CLIPS version 6.0, it was possible to enter only a number as a fact. However, now a symbol is required as the first field.</p>
          <p>Also, certain reserved words used by CLIPS cannot be used as the first field, but may be used for other fields. For example, the reserved word not is used to indicate a negated pattern and may not be used as the first field of a fact.</p>
        </section>
        <section>
          <title>Retracting Facts</title>
          <p>Removing facts from the fact-list is called retraction and is done with the retract command. To retract a fact, you must specify the fact index of the fact as the argument of retract. For example, after setting up your fact-list, to remove the last fact with index f-3, enter the retract command and then check your facts as follows.</p>
          <pre>CLIPS&gt; (retract 3)
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (animal-is duck)
f-2 (animal-sound quack)
For a total of 3 facts.
CLIPS&gt;</pre>
          <p>CLIPS issues an error message if you try to retract a non-existent fact.</p>
          <p>You can also retract multiple facts at once, as in <kbd>(retract 1 3 4)</kbd> or even use the wild card * to retract all the facts, as in <kbd>(retract *)</kbd>.</p>
        </section>
        <section>
          <title>Monitoring Facts</title>
          <p>CLIPS provides several commands to help you debug programs. One command allows you to continuously watch facts being asserted and retracted. This is more convenient than having to type in a (facts) command over and over again and trying to figure out what's changed in the fact- list.</p>
          <p>To start watching facts, enter the command (watch facts) as shown in the following example.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt; (watch facts)
CLIPS&gt; (assert (animal-is duck))
==&gt; f-1
(animal-is duck)
&lt;Fact-1&gt;
CLIPS&gt;</pre>
          <p>The right double arrow symbol, ==&gt;, means that a fact is entering memory while the left double arrow indicates a fact is leaving memory, as shown following.</p>
          <pre>CLIPS&gt; (reset)
&lt;== f-0 (initial-fact)
&lt;== f-1 (animal-is duck)
==&gt; f-0 (initial-fact)
CLIPS&gt; (assert (animal-is duck))
==&gt; f-1 (animal-is duck)
&lt;Fact-1&gt;
CLIPS&gt; (retract 1)
&lt;== f-1 (animal-is duck)
CLIPS&gt; (facts)
f-0 (initial-fact)
For a total of 1 fact.
CLIPS&gt;</pre>
          <p>The (watch facts) command provides a record that shows the <em>dynamic</em> or changing state of the fact-list. In contrast, the (facts) command show the <em>static</em> state of the fact-list since it displays the current contents of the fact-list. To turn off watching facts, enter (unwatch facts).</p>
          <p>There are a number of things you can watch. These include the following, which are described in more detail in the <cite class="book">CLIPS Reference Manual</cite>. The comment in CLIPS begins with a semicolon. Everything after the semicolon is ignored by CLIPS.</p>
          <pre>(watch facts)
(watch instances)         ; used with objects
(watch slots)             ; used with objects
(watch rules)
(watch activations)
(watch messages)          ; used with objects
(watch message-handlers)  ; used with objects
(watch generic-functions)
(watch methods)           ; used with objects
(watch deffunctions)
(watch compilations)      ; on by default
(watch statistics)
(watch globals)
(watch focus)
(watch all)            ; watch everything</pre>
          <p>As you use more of the capabilities of CLIPS, you'll find these (watch) commands very helpful in debugging. To turn off a (watch) command, enter an unwatch command. For example, to turn off watching compilations, enter (unwatch compilations). And so on.</p>
        </section>
      </section>
      <!-- end of "Facts in CLIPS" -->
      <section>
        <h2>Rules</h2>
        <p>To accomplish useful work, an expert system must have rules as well as facts. Since you 've seen how facts are asserted and retracted, it 's time to see how rules work. A rule is similar to an IF THEN statement in a procedural language like Java, C, or Ada. An IF THEN rule can be expressed in a mixture of natural language and computer language as follows:</p>
        <pre>IF &lt;certain conditions are true&gt;
THEN &lt;execute the following actions</pre>
        <p>Another term for the above statement is <dfn>pseudocode</dfn>, which literally means false code. While pseudocode cannot be directly executed by the computer, it serves as a very useful guide to writing executable code. Pseudocode is also helpful in documenting rules. A translation of rules from natural language to CLIPS is not very difficult if you keep this IF THEN analogy in mind. As your experience with CLIPS grows, you'll find that writing rules in CLIPS becomes easy. You can either type rules directly into CLIPS or load rules in from a file of rules created by a text editor.</p>
        <p>The following is a fact, and a rule named duck which is the pseudocode above expressed in CLIPS syntax. The name of the rule follows immediately after the keyword defrule. Although you can enter a rule on a single line, it 's customary to put different parts on separate lines to aid readability and editing.</p>
        <pre>CLIPS&gt; (unwatch facts)
CLIPS&gt; (clear)
CLIPS&gt; (assert (animal-is duck))
&lt;Fact-1&gt;
CLIPS&gt;
(defrule duck
  "Here comes the quack" ; comment
  (animal-is duck)
=&gt;
  (assert (sound-is quack)))
CLIPS&gt;</pre>
        <p>Also shown is the optional <dfn>rule-header</dfn> comment in quotes, "Here comes the quack". There can be only one rule-header comment and it must be placed after the rule name and before the first <dfn>pattern</dfn>. Although we 're only discussing pattern matching against facts now, more generally a pattern can be matched against a <dfn>pattern entity</dfn>. A pattern entity is either a fact or an instance of a user-defined class. Pattern matching on objects will be discussed later.</p>
        <p>Only one rule name can exist at one time in CLIPS. Entering the same rule name, such as <q>duck</q>, will replace any existing rule with that name. That is, while there can be many rules in CLIPS, there can be only one rule which is named <q>duck</q>. This is analogous to other programming languages in which only one procedure name can be used to uniquely identify a procedure.</p>
        <p>The entire rule must be surrounded by parentheses. Each of the rule patterns and <dfn>actions</dfn> must be surrounded by parentheses. An action is actually a function which typically has no return value, but performs some useful action, such as an (assert) or (retract). For example, an action might be (assert (duck)). Here the function name is <q>assert</q> and its argument is <q>duck</q>. Notice that we don 't want any return value such as a number. Instead, we want the fact (duck) to be asserted. A function in CLIPS is a piece of executable code identified by a specific name, which returns a useful value or performs a useful side-effect, such as (printout).</p>
        <p>If all the patterns of a rule match facts, the rule is <dfn>activated</dfn> and put on the <dfn>agenda</dfn>. The agenda is a collection of activations which are those rules which match pattern entities. Zero or more activations may be on the agenda.</p>
        <p>The symbol <q>=&gt;</q> that follows the patterns in a rule is called an <dfn>arrow</dfn>. The arrow represents the beginning of the THEN part of an IF-THEN rule (and may be read as <q>implies&#x201D;</q>).</p>
        <p>The last part of a rule is the list of zero or more actions that will be executed when the rule <dfn>fires</dfn>. In our example, the one action is to assert the fact (sound-is quack). The term fires means that CLIPS has selected a certain rule for execution from the agenda.</p>
        <section>
          <title>Firing Rules according to their Relative Salience</title>
          <p>When multiple activations are on the agenda, CLIPS automatically determines which activation is appropriate to fire. CLIPS orders the activations on the agenda in terms of increasing priority or <dfn><a href="CLIPS.salience">salience</a></dfn>.</p>
          <p>The part of the rule before the arrow is called the left-hand side (LHS) and the part of the rule after the arrow is called the right-hand side (RHS). If no patterns are specified, CLIPS automatically activates the rule when a (reset) command is entered.</p>
          <p>CLIPS always executes the actions on the RHS of the highest priority rule on the agenda. This rule is then removed from the agenda and the actions of the new highest salience rule is executed. This process continues until there are no more activations or a command to stop is encountered.</p>
          <p>You can check what's on the agenda with the agenda command. For example,</p>
          <pre>CLIPS&gt; (agenda)
0 duck: f-1
For a total of 1 activation.
CLIPS&gt;</pre>
          <p>The first number <q>0</q> is the salience of the <q>duck</q> activation, and <q>f-1</q> is the fact-identifier of the fact, (animal-is duck), which matches the activation. If the salience of a rule is not declared explicitly, CLIPS assigns it the default value of zero, where the possible salience values range from -10,000 to 10,000. Here we'll use the definition of the term <dfn>default</dfn> as meaning the standard way.</p>
          <p>If there is only one rule on the agenda, that rule will fire. Since the LHS pattern of the duck-sound rule is <kbd>(animal-is duck)</kbd> this pattern will be satisfied by the fact (animal-is duck) and so the duck-sound rule should fire.</p>
          <p>Each field of the pattern is said to be a <dfn>literal constraint</dfn>. The term <dfn>literal</dfn> means having a constant value, as opposed to a variable whose value is expected to change. In this case, the literals are <q>animal-is</q> and <q>duck</q>.</p>
          <p>To make a program run, just enter the run command. Type (run) and press the carriage return key. Then do a (facts) to check that the fact was asserted by the rule.</p>
          <pre>CLIPS&gt; (run)
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (animal-is duck)
f-2 (sound-is quack)
For a total of 3 facts.
CLIPS&gt;</pre>
        </section>
        <section>
          <title>Saving Rules</title>
          <p>Before going on, let 's save the duck rule with the save command so that you don 't have to type it
            in again (if you haven 't already saved it in an editor). Just enter a command such as</p>
          <pre>(save "duck.clp")</pre>
          <p>to save the rule from CLIPS memory to disk and name the file <filename>duck.clp</filename> where the <q>.clp</q> is simply a convenient extension to remind us this is a CLIPS source code file. Note that saving the code from CLIPS memory like this will only preserve the optional rule-header comment in quotes and not any semicolon comments.</p>
        </section>
        <section>
          <title>Activation and Refraction</title>
          <p>An interesting question may occur to you at this time. What if you (run) again? There is a rule and a fact which satisfies the rule, so the rule should fire. However, if you try this and (run) again, you 'll see that the rule won 't fire. This may be somewhat frustrating. However, before you do something drastic to ease your frustration &#x2014; like kicking your pet duck &#x2014; you need to know a little more about some basic principles of expert systems.</p>
          <p>A rule is activated if its patterns are matched by...</p>
          <ul>
            <li>1. a brand new pattern entity that did not exist before or,</li>
            <li>2. a pattern entity that did exist before but was retracted and reasserted, i.e., a <q>clone</q> of the old pattern entity, and thus now a new pattern entity.</li>
          </ul>
          <p>The rule, and indices of the matching patterns, is the activation. If either the rule or the pattern entity, or both change, the activation is removed. An activation may also be removed by a command or an action of another rule that fired before and removed the conditions necessary for activation.</p>
          <p>The Inference Engine sorts the activations according to their <a href="#CLIPS.salience">salience</a>. This sorting process is called <dfn>conflict resolution</dfn> because it eliminates the conflict of deciding which rule should fire next. CLIPS executes the RHS of the rule with the highest salience on the agenda, and removes the activation. This execution is called firing the rule in analogy with the firing of a neuron. A neuron emits a voltage pulse when an appropriate stimulus is applied. After a neuron fires, it undergoes <dfn>refraction</dfn> and cannot fire again for a certain period of time. Without refraction, neurons would just keep firing over and over again on exactly the same stimulus.</p>
          <p>Without refraction, expert systems always would be caught in trivial loops. That is, as soon as a rule fired, it would keep firing on that same fact over and over again. In the real world, the stimulus that caused the firing eventually would disappear. For example, a real duck might swim away or get a job in the movies. However, in the computer world, once data is stored, it stays there until explicitly removed or the power is turned off.</p>
          <p>The following example shows activations and firing of a rule. Notice that the (watch) commands are used to more carefully show every fact and activation. The arrow going to the right means an entering fact or activation while an arrow to the left would mean an exiting fact or activation.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule duck
  (animal-is duck)
=&gt;
  (assert (sound-is quack)))
CLIPS&gt; (watch facts)
CLIPS&gt; (watch activations)
CLIPS&gt; (assert (animal-is duck))
==&gt; f-1 (animal-is duck)
; Activation salience is 0 by default,
; then rule name:pattern entity index
==&gt; Activation 0 duck: f-1
&lt;Fact-1&gt;
; Notice that duplicate fact
; cannot be entered
CLIPS&gt; (assert (animal-is duck))
FALSE
CLIPS&gt; (agenda)
0 duck: f-1
For a total of 1 activation.
CLIPS&gt; (run)
==&gt; f-2 (sound-is quack)
; Nothing on agenda after rule fires
; Even though fact matches rule,
; refraction will not allow this
; activation because the rule already
; fired on this fact
CLIPS&gt; (agenda)
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (animal-is duck)
f-2 (sound-is quack)
For a total of 3 facts.
CLIPS&gt; (run)
CLIPS&gt;</pre>
          <p>You can make the rule fire again if you retract the fact and then assert it as a new fact.</p>
        </section>
        <section>
          <title>Showing the Rules</title>
          <p>Sometimes you may want to see a rule while you 're in CLIPS. There 's a command called ppdefrule &#x2013; the pretty print rule &#x2013; that prints a rule. To see a rule, specify the rule name as an argument to ppdefrule. For example,</p>
          <pre>CLIPS&gt; (ppdefrule duck)
(defrule MAIN::duck
  (animal-is duck)
  =&gt;
  (assert (sound-is quack)))
CLIPS&gt;</pre>
          <p>CLIPS puts different parts of the rule on different lines for the sake of readability. The patterns before the arrow are still considered the LHS and the actions after the arrow are still considered the RHS of the rule. The term MAIN refers to the MAIN module that this rule is in by default. You can define modules to put rules in analogous to the statements that may be put in different packages, modules, procedures, or functions of other programming languages. The use of modules make it easier to write expert systems having many rules since these may be grouped together with their own agendas for each module. For more information, see the <cite class="book">CLIPS Reference Manual</cite>.</p>
          <p>What if you want to print a rule but can't remember the name of the rule? No problem. Just use the rules command in response to a CLIPS prompt and CLIPS will print out the names of all the rules. For example, enter</p>
          <pre>CLIPS&gt; (rules)
duck
For a total of 1 defrule.
CLIPS&gt;</pre>
        </section>
        <section>
          <title>Print Out</title>
          <p>Besides asserting facts in the RHS of rules, you also can print out information using the printout function. CLIPS also has a carriage return/linefeed keyword called crlf which is very useful in improving the appearance of output by formatting it on different lines. For a change, the crlf is not included in parentheses. As an example,</p>
          <pre>CLIPS&gt;
(defrule duck
  (animal-is duck)
=&gt;
  ;; Be sure to type in the "t"
  (printout t "quack" crlf))
==&gt; Activation 0 duck: f-1
CLIPS&gt; (run)
quack
CLIPS&gt;</pre>
          <p>The output is the text within the double quotes. Be sure to type the letter <q>t</q> following the printout command. This tells CLIPS to send the output to the standard output device of your computer. Generally, the standard output device is your terminal (hence the letter <q>t</q> after printout). However, this may be redefined so that the standard output device is some other device, such as a modem or disk.</p>
        </section>
        <section>
          <title>Loading and Saving</title>
          <p>The <code class="command">load</code> command loads in the rule that you had previously saved to disk in the file <filename>duck.clp</filename> or whatever name and directory that you had saved it under. You can load a file of rules made on a text editor into CLIPS using the <code class="command">load</code> command.</p>
          <p>A faster way to load files is to first save them in a machine readable binary format with the save binary command called <code class="command">bsave</code>. The load binary command, <code class="command">bload</code>, can then be used to read these binary rules into CLIPS memory much faster since the files do not have to be re-interpreted by CLIPS.</p>
          <p>Two other useful commands allow you to save and load facts using a file. These are <code class="command">save-facts</code> and <code class="command">load-facts</code>. The (save-facts) will save all the facts in the fact-list to a file while (load-facts) will load in the facts from a file into the fact-list.</p>
          <p>The <code class="command">batch</code> command allows you to execute commands from a file as if they were typed in at the top-level.</p>
        </section>
        <section>
          <title>Other Features</title>
          <p>The <code class="command"><a href="#CLIPS.salience">declare salience</a></code> command provides explicit control over which rules will be put on the agenda. You must be careful in using this feature too freely lest your program become too controlled. The <code class="command">set-incremental-reset</code> command prohibits rules from seeing facts that are entered before the rules are entered. The command to get the current value of incremental reset is <code class="command">get-incremental-reset</code>. One way to make a rule fire again is to force the rule to be re-activated by the <code class="command">refresh</code> rule command.</p>
          <p>Another useful command provides an interface to your operating system. The <code class="command">system</code> command allows the execution of operating system commands or executables within CLIPS. For more information on all these topics, see the <cite class="book">CLIPS Reference Manual</cite>.</p>
        </section>
      </section>
      <section>
        <h2>Further Details</h2>
        <p>You can have any number of patterns or actions in a rule. The important point to realize is that the rule is placed on the agenda only if all the patterns are satisfied by facts. This type of restriction is called a <dfn>logical AND conditional element (CE)</dfn> in reference to the AND relation of Boolean logic. An AND relation is said to be true only if all its conditions are true.</p>
        <section>
          <title>Strategies</title>
          <p>In expert systems, one use of the term <dfn>strategy</dfn> is in conflict resolution of activations. Now you might say, <q>Well, I 'll just design my expert system so that only one rule can possibly be activated at one time. Then there is no need for conflict resolution.</q> The good news is that if you succeed, conflict resolution is indeed unnecessary. The bad news is that this success proves that your application can be well represented by a sequential program. So you should have coded it in C, Java, or Ada in the first place and not bothered writing it as an expert system.</p>
          <p>CLIPS offers seven different modes of conflict resolution: depth, breadth, LEX, MEA, complexity, simplicity, and random. It 's difficult to say that one is clearly better than another without considering the specific application. Even then, it may be difficult to judge which is <em>best</em>. For more information on the details of these strategies, see the <cite class="book">CLIPS Reference Manual</cite>.</p>
          <p>The <dfn>depth strategy</dfn> is the standard default strategy of CLIPS. The default setting is automatically set when CLIPS is first started. Afterwards, you can change the default setting. In the depth strategy, new activations are placed on the agenda after activations with higher <a href="#CLIPS.salience">salience</a>, but before activations with equal or lower salience. All this simply means is that the agenda is ordered from highest to lowest salience.</p>
          <note>In this section, all discussions and examples will assume depth strategy.</note>
          <p>Now that all these different optional settings are available, be sure that before you run an expert system developed by someone else, that your settings are the same as theirs. Otherwise, you may find the operation is inefficient or even incorrect. In fact, it's a good idea to explicitly encode all the settings in any system that you develop so that it will be configured properly.</p>
        </section>
        <section>
          <title>Commands <code class="command">deffacts</code> and <code class="command">undeffacts</code>*</title>
          <!--page 36-->
          <p>As you work with CLIPS, you may become tired of typing in the same assertions from the top- level. If you are going to use the same assertions every time a program is run, you can first load assertions from a disk using a batch file. An alternative way to enter facts is by using the define facts keyword, <code class="command">deffacts</code>. For example,</p>
          <pre>CLIPS&gt; (unwatch facts)
CLIPS&gt; (unwatch activations)
CLIPS&gt; (clear)
CLIPS&gt;
(deffacts walk "Some facts about walking"
  (status walking) ; fact to be asserted
  (walk-sign walk)) ; fact to be asserted
CLIPS&gt; (reset)
; reset causes facts from
; deffacts to be asserted
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (status walking)
f-2 (walk-sign walk)
For a total of 3 facts.
CLIPS&gt;</pre>
          <p>The required name of this deffacts statement, <var>walk</var>, follows the deffacts keyword. Following the name is an optional comment in double quotes. Like the optional comment of a rule, the (deffacts) comment will be retained with the (deffacts) after it 's been loaded by CLIPS. After the name or comment are the facts that will be asserted in the fact-list. The facts in a deffacts statement are asserted using the CLIPS (reset) command.</p>
          <p>The (initial-fact) is put in automatically by a (reset). The fact-identifier of the initial-fact is always f-0. Even without any deffacts statements, a (reset) always will assert an (initial-fact). In prior versions of CLIPS this fact was used to activate some types of rules, but is no longer used for this purpose. It is provided for backwards compatibility for programs which explicitly match against this fact.</p>
          <p>The (reset) has an advantage compared to a (clear) command in that (reset) doesn 't get rid of all the rules. The (reset) leaves your rules intact. Like (clear), it removes all activated rules from the agenda and also removes all old facts from the fact-list. Giving a (reset) command is a recommended way to start off program execution, especially if the program has been run before and the fact-list is cluttered with old facts.</p>
          <p>In summary, the (reset) does three things for facts:</p>
          <ul>
            <li>1. It removes existing facts from the fact-list, which may remove activated rules from the agenda.</li>
            <li>2. It asserts (initial-fact).</li>
            <li>3. It asserts facts from existing (deffacts) statements.</li>
          </ul>
          <p>Actually, the (reset) also does corresponding operations on objects. It deletes instances, creates initial-object, and asserts instances from <code class="command">definstances</code>.</p>
          <p>The undeffacts command excises a (deffacts) from asserting facts by eliminating the deffacts from memory. For example,</p>
          <pre>CLIPS&gt; (undeffacts walk)
CLIPS&gt; (reset)
CLIPS&gt; (facts)
f-0 (initial-fact)
For a total of 1 fact.
CLIPS&gt;</pre>
          <p>This example demonstrates how the (deffacts) has removed walk. To restore a deffacts statement after an (undeffacts) command, you must enter the deffacts statement again. You can even get rid of initial-fact with (undeffacts). In addition to facts, CLIPS also allows you to eliminate rules selectively by using the <code class="command">undefrule</code>.</p>
        </section>
        <section>
          <title>Watching, BreakPoints and <code class="command">matches</code>*</title>
          <p>You can <code class="command">watch rules</code> firing and <code class="command">watch activations</code> on the agenda. The <code class="command">watch statistics</code> prints information about the number of rules fired, run time, rules per second, mean number of facts, maximum number of facts, mean number of activations, and maximum number of activations. The statistics information may be useful in tuning up an expert system to optimize its speed. Another command, called <code class="command">watch compilations</code>, shows information when rules are being loaded. The <code class="command">watch all</code> command will watch everything.</p>
          <p>Printing of watch information to the screen or to disk with the <code class="command">dribble</code> command will slow down your program somewhat because CLIPS uses more time to print or to save to disk. The dribble-on command will store everything entered in the Dialog Window to a disk file until the dribble-off command is entered. This is convenient in providing a permanent record of everything that happens. These commands are as follows.</p>
          <pre>(dribble-on &lt;filename&gt;)
(dribble-off &lt;filename&gt;)</pre>
          <p>Another useful debugging command is (run) which takes an optional argument of the number of rule firings. For example, a (run 21) command would tell CLIPS to run the program and then stop after 21 rule firings. A (run 1) command allows you to step through a program firing one rule at a time.</p>
          <p>Just like many other programming languages, CLIPS also gives you the capability of setting <dfn>breakpoints</dfn>. A breakpoint is simply an indicator to CLIPS to stop execution just prior to executing a specified rule. A breakpoint is set by the <code class="command">set-break</code> command. The <code class="command">remove-break</code> command will remove a breakpoint that has been set. The <code class="command">show-breaks</code> will list all the rules which have breakpoints set. The syntax of these commands for the argument &lt;rulename&gt; is shown below:</p>
          <pre>(set-break &lt;rulename&gt;)
(remove-break &lt;rulename&gt;)
(show-breaks)</pre>
          <p>You may encounter a situation in which you are certain a rule should be activated but isn 't. While it is possible that this is due to a bug in CLIPS, it 's not very likely because of the great skill of the people who programmed CLIPS.</p>
          <p>In most cases, the problem occurs because of the way that you wrote the rule. As an aid to debugging, CLIPS has a command called <code class="command">matches</code> that can tell you which patterns in a rule match facts. Patterns which do not match prevent the rule from becoming activated. One common reason that a pattern won't match a fact results from misspelling an element in the pattern or in the assertion of the fact.</p>
          <p>The argument of (matches) is the name of the rule to be checked for matches. To see how (matches) works, first (clear), then enter the following rule.</p>
          <pre>(defrule take-a-vacation
  (work done) ; Conditional element 1
  (money plenty) ; Conditional element 2
  (reservations made) ; Conditional element 3
=&gt;
  (printout t "Let's go!!!" crlf))</pre>
          <p>The following shows how (matches) is used. Enter the commands as shown. Notice that (watch facts) is turned on. This is a good idea when you are asserting facts manually since it gives you an opportunity to check the spelling of facts.</p>
          <pre>CLIPS&gt; (watch facts)
CLIPS&gt; (assert (work done))
==&gt; f-1 (work done)
&lt;Fact-1&gt;
CLIPS&gt; (matches take-a-vacation)
Matches for Pattern 1
f-1
Matches for Pattern 2
  None
Matches for Pattern 3
  None
; CE is conditional element
Partial matches for CEs 1 - 2
  None
Partial matches for CEs 1 - 3
  None
Activations
  None
CLIPS&gt;</pre>
          <p>The fact with fact-identifier f-1 matches the first pattern or conditional element in the rule and is reported by (matches). Given that a rule has <var><var>N</var></var> patterns, the term <dfn>partial matches</dfn> refers to any set of matches of the first <var>N</var>-1 patterns with facts. That is, the partial matches begin with the first pattern in a rule and end with any pattern up to but not including the last (<var>N</var>th) pattern. As soon as one partial match cannot be made, CLIPS does not check any further. For example, a rule with four patterns would have partial matches of the first and second patterns and also of the first, second, and third patterns. If all <var>N</var> patterns match, the rule will be activated.</p>
          <pre/>
          <p/>
          <pre/>
        </section>
        <section>
          <title>Other Features</title>
          <p>Some additional commands are useful with deffacts. For example, the command <code class="command">list-deffacts</code> will list the names of currently loaded deffacts in CLIPS. Another useful command is <code class="command">ppdeffacts</code> which prints the facts stored in a deffacts.</p>
          <p>Other functions allow you to manipulate strings easily:</p>
          <dl>
            <!-- <varlistentry> -->
            <dt>
              <code class="command">assert-string</code>
            </dt>
            <dd>Performs a string assertion by taking a string as argument and asserted as a non-string fact.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>
              <code class="command">str-cat</code>
            </dt>
            <dd>Constructs a single-quoted string from individual items by string concatenation.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>
              <code class="command">str-index</code>
            </dt>
            <dd>Returns a string index of the first occurrence of a substring.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>
              <code class="command">sub-string</code>
            </dt>
            <dd>Returns a substring from a string.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>
              <code class="command">str-compare</code>
            </dt>
            <dd>Performs a string compare.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>
              <code class="command">str-length</code>
            </dt>
            <dd>Returns the string length which is the length of a string.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>
              <code class="command">sym-cat</code>
            </dt>
            <dd>Returns a concatenated symbol.</dd>
            <!-- </varlistentry> -->
          </dl>
          <p>If you want to printout a multifield variable without parentheses, the simplest way is by using the string implode function, <code class="command">implode$</code>.</p>
        </section>
      </section>
      <section>
        <h2>Variables</h2>
        <p>Just as with other programming languages, CLIPS has <dfn>variables</dfn> to store values. Unlike a fact, which is static or unchanging, the contents of a variable are <em>dynamic</em> as the values assigned to it change. In contrast, once a fact is asserted, it's fields can only be modified by retracting and asserting a new fact with the changed fields, Even the modify action (described later in the section on deftemplate) acts by retracting and asserting a modified fact, as you can see by checking the fact-index.</p>
        <p>The name of a variable, or <dfn>variable identifier</dfn>, is always written by a question mark followed by a symbol that is the name of the variable. The general format is</p>
        <pre>?&lt;variable-name&gt;</pre>
        <note>Global variables, to be described in more detail later, have a slightly different syntax.</note>
        <p>Just as in other programming languages, variable names should be meaningful for good style. Some examples of valid variable names follow.</p>
        <pre>?x
?noun
?color
?sensor
?valve
?ducks-eaten</pre>
        <p>Before a variable can be used, it should be assigned a value. CLIPS gives an error message when it cannot find a value bound to ?x. The term bound means the assignment of a value to a variable. Only global variables are bound in all rules. All other variables are only bound within a rule. Before and after a rule fires, non-global variables are not bound and so CLIPS will give an error message if you try to query a non-bound variable.</p>
        <p class="bridgehead">
          <i>Asserting Variables</i>
        </p>
        <p>One common use of variables is to match a value on the LHS and then assert this bound variable on the RHS. For example, enter</p>
        <pre>(defrule make-quack
  (duck-sound ?sound)
=&gt;
  (assert (sound-is ?sound)))</pre>
        <p>Now assert (duck-sound quack), then (run) the program. Check the facts and you 'll see that the rule has produced (sound-is quack) because the variable ?sound was bound to quack.</p>
        <p>Of course, you also can use a variable more than once. For example, enter the following. Be sure to do a (reset) and assert (duck-sound quack) again.</p>
        <pre>(defrule make-quack
  (duck-sound ?sound)
=&gt;
  (assert (sound-is ?sound ?sound)))</pre>
        <p>When the rule fires, it will produce (sound-is quack quack) since the variable ?sound is used twice.</p>
        <p class="bridgehead">
          <i>***</i>
        </p>
        <p>Variables also are used commonly in printing output, as in</p>
        <pre>(defrule make-quack
  (duck-sound ?sound)
=&gt;
  (printout t "The duck said " ?sound crlf))</pre>
        <p>Do a (reset), enter this rule, and assert the fact and then (run) to find out what the duck said.</p>
        <p>More than one variable may be used in a pattern, as the following example shows.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule whodunit
  (duckshoot ?hunter ?who)
=&gt;
  (printout t ?hunter " shot " ?who crlf))
CLIPS&gt; (assert (duckshoot Brian duck))
&lt;Fact-1&gt; ; Duck dinner tonight!
CLIPS&gt; (run)
Brian shot duck
CLIPS&gt; (assert (duckshoot duck Brian))
&lt;Fact-2&gt;
; Brian dinner tonight!
CLIPS&gt; (run)
duck shot Brian
; Missing third field
CLIPS&gt; (assert (duckshoot duck))
&lt;Fact-3&gt;
; Rule doesn't fire,
; no output
CLIPS&gt; (run)
CLIPS&gt;</pre>
        <p>Notice what a big difference the order of fields makes in determining who shot who. You can also see that the rule did not fire when the fact (duckshoot duck) was asserted. The rule was not activated because no field of the fact matched the second pattern constraint, ?who.</p>
        <p class="bridgehead">
          <i>Retracting Facts</i>
        </p>
        <p>Retraction is very useful in expert systems and usually done on the RHS rather than at the top- level. Before a fact can be retracted, it must be specified to CLIPS. To retract a fact from a rule, the <em>fact-address</em> first must be bound to a variable on the LHS.</p>
        <p>There is a big difference between binding a variable to the contents of a fact and binding a variable to the fact-address. In the examples that you 've seen such as (duck-sound ?sound), a variable was bound to the value of a field. That is, ?sound was bound to quack. However, if you want to remove the fact whose contents are (duck-sound quack), you must first tell CLIPS the address of the fact to be retracted.</p>
        <p>The fact-address is specified using the left arrow, <q>&lt;-</q>. To create this, just type a <q>&lt;</q> symbol followed by a <q>-</q>. As an example of fact retraction from a rule,</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt; (assert (bachelor Dopey))
&lt;Fact-1&gt;
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (bachelor Dopey)
For a total of 2 facts.
CLIPS&gt;
(defrule get-married
  ?duck &lt;- (bachelor Dopey)
=&gt;
  (printout t "Dopey is now happily married " ?duck crlf)
  (retract ?duck))
CLIPS&gt; (run)
Dopey is now happily married &lt;Fact-1&gt;
CLIPS&gt; (facts)
f-0 (initial-fact)
For a total of 1 fact.
CLIPS&gt;</pre>
        <p>Notice that the (printout) prints the fact-index of ?duck, &lt;Fact-1&gt;, since the left arrow bound the address of the fact to ?duck. Also, there is no fact (bachelor Dopey) because it has been retracted.</p>
        <p>Variables can be used to pick up a fact value at the same time as an address, as shown in the following example. For convenience, a (deffacts) has also been defined.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule marriage
  ?duck &lt;- (bachelor ?name)
=&gt;
  (printout t ?name " is now happily married" crlf)
  (retract ?duck))
CLIPS&gt;
(deffacts good-prospects
  (bachelor Dopey)
  (bachelor Dorky)
  (bachelor Dicky))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Dicky is now happily married
Dorky is now happily married
Dopey is now happily married
CLIPS&gt;</pre>
        <p>Notice how the rule fired on all facts that matched the pattern (bachelor ?name). CLIPS also has a function called <function>fact-index</function> which can be used to return the fact index of a fact address.</p>
        <p class="bridgehead">
          <i>Wildcards</i>
        </p>
        <p>Instead of binding a field value to a variable, the presence of a nonempty field can be detected alone using a <dfn>wildcard</dfn>. For example, suppose you 're running a dating service for ducks, and a duckette asserts that she only dates ducks whose first name is Dopey. Actually, two criteria are in this specification since there is an implication that the duck must have more than one name. So a plain (bachelor Dopey) isn 't adequate because there is only one name in the fact.</p>
        <p>This type of situation, in which only part of the fact is specified, is very common and very important. To solve this problem, a wildcard can be used to match the Dopeys.</p>
        <p>The simplest form of wildcard is called a single-field wildcard and is shown by a question mark, <q>?</q>. The <q>?</q> is also called a single-field constraint. A single-field wildcard stands for exactly one field, as shown following.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule dating-ducks
  (bachelor Dopey ?)
=&gt;
  (printout t "Date Dopey" crlf))
CLIPS&gt;
(deffacts duck
  (bachelor Dicky)
  (bachelor Dopey)
  (bachelor Dopey Mallard)
  (bachelor Dinky Dopey)
  (bachelor Dopey Dinky Mallard))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Date Dopey
CLIPS&gt;</pre>
        <p>The pattern includes a wildcard to indicate that Dopey 's last name is not important. So long as the first name is Dopey and there is any last name (but no middle names), the rule will be satisfied and fire. Because the pattern has three fields of which one is a single-field wildcard, only facts of exactly three fields can satisfy it. In other words, only Dopeys with exactly two names can satisfy this duckette.</p>
        <p>Suppose you want to specify Dopeys with exactly three names? All that you 'd have to do is write a pattern like</p>
        <pre>(bachelor Dopey ? ?)</pre>
        <p>Another interesting possibility occurs if Dopey must be the first name, but only those Dopeys with two or three names are acceptable. One way of solving this problem is to write two rules, though it 's much easier to use the multifield wildcard.</p>
        <p>Examle using two separate rules:</p>
        <pre>defrule eligible
  (bachelor Dopey ?)
=&gt;
(printout t "Date Dopey" crlf))
(defrule eligible-three-names
  (bachelor Dopey ? ?)
=&gt;
  (printout t "Date Dopey" crlf))</pre>
      </section>
      <section>
        <h2>Wild Cards</h2>
        <p>Rather than writing separate rules to handle each field, it's much easier to use the <dfn>multifield wildcard</dfn>. This is a dollar sign followed by a question mark, <q>$?</q>, and represents zero or more fields. Notice how this contrasts with the single-field wildcard which must match exactly one field.</p>
        <p>The two rules for dates can now be written in a single rule as follows.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule dating-ducks
  (bachelor Dopey $?)
=&gt;
  (printout t "Date Dopey" crlf))
CLIPS&gt;
(deffacts duck
  (bachelor Dicky)
  (bachelor Dopey)
  (bachelor Dopey Mallard)
  (bachelor Dinky Dopey)
  (bachelor Dopey Dinky Mallard))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Date Dopey
Date Dopey
Date Dopey
CLIPS&gt;</pre>
        <p>Wildcards have another important use because they can be attached to a symbolic field to create a variable such as ?x, $?x, ?name, or $?name. The variable can be a single-field variable or a multifield variable depending on whether a <q>?</q> or <q>$?</q> is used on the LHS. Note that on the RHS only a ?x is used, where the <q>x</q> can be any variable name. You can think of the <q>$</q> as a function whose argument is a single-field wildcard or a single-field variable and returns a multifield wildcard or a multifield variable, respectively.</p>
        <p>As an example of a multifield variable, the following version of the rule also prints out the name field(s) of the matching fact because a variable is equated to the name field(s) that match:</p>
        <pre>CLIPS&gt;
(defrule dating-ducks
  (bachelor Dopey $?name)
=&gt;
  (printout t "Date Dopey " ?name crlf))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Date Dopey (Dinky Mallard)
Date Dopey (Mallard)
Date Dopey ()
CLIPS&gt;</pre>
        <p>As you can see, on the LHS, the multifield pattern is $?name but is ?name when used as a variable on the RHS. When you enter and run, you'll see the names of all eligible Dopeys. The multifield wildcard takes care of any number of fields. Also, notice that multifield values are returned enclosed in parentheses.</p>
        <p>Suppose you wanted a match of all ducks who had a Dopey somewhere in their name, not necessarily as their first name. The following version of the rule would match all facts with a Dopey in them and then print out the names:</p>
        <pre>CLIPS&gt;
(defrule dating-ducks
  (bachelor $?first Dopey $?last)
=&gt;
  (printout t "Date "
              ?first
              " Dopey "
              ?last crlf))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Date () Dopey (Dinky Mallard)
Date (Dinky) Dopey ()
Date () Dopey (Mallard)
Date () Dopey ()
CLIPS&gt;</pre>
        <p>The pattern matches any names that have a Dopey anywhere in them.</p>
        <p>Single- and multifield wildcards can be combined. For example, the pattern</p>
        <pre>(bachelor ? $? Dopey ?)</pre>
        <p>means that the first and last names can be anything and that the name just prior to the last must be Dopey. This pattern also requires that the matching fact will have at least four fields, since the <q>$?</q> matches zero or more fields and all the others must match exactly four.</p>
        <tip>
          <p>Although multifield variables can be essential for pattern matching in many cases, their overuse can cause much inefficiency because of increased memory requirements and slower execution.</p>
          <p>As a general rule of style, you should use $? only when you don 't know the length of fields. Do not use $? simply as a typing convenience.</p>
        </tip>
        <p class="bridgehead">
          <i>The Ideal Bachelor</i>
        </p>
        <p>Variables used in patterns have an important and useful property, which can be stated as follows.</p>
        <blockquote>The first time a variable is bound it retains that value only within the rule, both on the LHS and also on the RHS, unless changed on the RHS.</blockquote>
        <p>For example, in the rule below</p>
        <pre>(defrule bound
  (number-1 ?num)
  (number-2 ?num)
=&gt;)</pre>
        <p>If there are some facts</p>
        <pre>f-1 (number-1 0)
f-2 (number-2 0)
f-3 (number-1 1)
f-4 (number-2 1)</pre>
        <p>then the rule can only be activated by the pair f-1, f-2, and the other pair f-3, f-4. That is, fact f-1 cannot match with f-4 because when ?num is bound to 0 in the first pattern, the value of ?num in the second pattern also must be 0. Likewise, when ?num is bound to 1 in the first pattern, the value of ?num in the second pattern must be 1. Notice that the rule will be activated twice by these four facts: one activation for the pair f-1, f-2, and the other activation for the pair f-3, f-4.</p>
        <p>As a more practical example, enter the following rule. Notice that the same variable, ?name, is used in both patterns. Before doing a (reset) and (run), also enter a (watch all) command so that you can see what happens during execution.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule ideal-duck-bachelor
  (bill big ?name)
  (feet wide ?name)
=&gt;
  (printout t "The ideal duck is " ?name crlf))
CLIPS&gt;
(deffacts duck-assets
  (bill big Dopey)
  (bill big Dorky)
  (bill little Dicky)
  (feet wide Dopey)
  (feet narrow Dorky)
  (feet narrow Dicky))
CLIPS&gt; (watch facts)
CLIPS&gt; (watch activations)
CLIPS&gt; (reset)
&lt;== f-0 (initial-fact)
==&gt; f-0 (initial-fact)
==&gt; f-1 (bill big Dopey)
==&gt; f-2 (bill big Dorky)
==&gt; f-3 (bill little Dicky)
==&gt; f-4 (feet wide Dopey)
==&gt; Activation 0 ideal-duck-bachelor: f-1,f-4
==&gt; f-5 (feet narrow Dorky)
==&gt; f-6 (feet narrow Dicky)
CLIPS&gt; (run)
The ideal duck is Dopey
CLIPS&gt;</pre>
        <p>When the program is run, the first pattern matches Dopey and Dorky since they both have big bills. The variable ?name is bound to each name. When CLIPS tries to match the second pattern of the rule, only the variable ?name which is bound to Dopey also satisfies the second pattern of (feet wide).</p>
        <p class="bridgehead">
          <i>The Lucky Duck</i>
        </p>
        <p>Many situations occur in life where it's wise to do things in a systematic manner. That way, if your expectations don't work out you can try again systematically (such as the common algorithm for finding the Perfect Spouse by getting married over and over again).</p>
        <p>One way of being organized is to keep a list. (Note: if you really want to impress people, show them a list of your lists.) In our case, we'll keep a list of duck bachelors, with the most likely prospect for matrimony at the front. Once an ideal duck bachelor has been identified, we'll shoot him up to the front of the list as the lucky duck.</p>
        <p>The following program shows how this can be done by adding a couple of rules to the ideal-duck-bachelor rule.</p>
        <pre>(defrule ideal-duck-bachelor
  (bill big ?name)
  (feet wide ?name)
=&gt;
  (printout t "The ideal duck is " ?name crlf)
  (assert (move-to-front ?name)))

(defrule move-to-front
  ?move-to-front &lt;- (move-to-front ?who)
  ?old-list &lt;- (list $?front ?who $?rear)
=&gt;
  (retract ?move-to-front ?old-list)
  (assert (list ?who ?front ?rear))
  (assert (change-list yes)))

(defrule print-list
  ?change-list &lt;- (change-list yes)
  (list $?list)
=&gt;
  (retract ?change-list)
  (printout t "List is : " ?list crlf))

(deffacts duck-bachelor-list
  (list Dorky Dinky Dicky))
(deffacts duck-assets
  (bill big Dicky)
  (bill big Dorky)
  (bill little Dinky)
  (feet wide Dicky)
  (feet narrow Dorky)
  (feet narrow Dinky))</pre>
        <p>The original list is given in the duck-bachelor-list deffacts. When the program is run, it will provide a new list of likely candidates.</p>
        <screen>CLIPS&gt; (unwatch all)
CLIPS&gt; (reset)
CLIPS&gt; (run)
The ideal duck is Dicky
List is : (Dicky Dorky Dinky)
CLIPS&gt;</screen>
        <p>Notice the assertion (change-list yes) in the move-to-front rule. Without this assertion, the print- list rule would always fire on the original list. This assertion is an example of a control fact made to control the firing of another rule. Control facts are very important in controlling the activation of certain rules, and you should study this example carefully to understand why it 's used. Another method of control is modules, as discussed in the <cite class="book">CLIPS Reference Manual</cite>.</p>
        <p>The move-to-front rule removes the old list and asserts the new list. If the old list was not retracted, two activations would be on the agenda for the print-list rule but only one would fire. Only one will fire because the print-list rule removes the control fact required for the other activation of the same rule. You would not know in advance which one would fire, so the old list might be printed instead of the new list.</p>
      </section>
      <section id="CLIPS.deftemplate">
        <h2>Doing It Up In Style</h2>
        <div class="abstract">In this section you will learn about a keyword called deftemplate, which stands for define template. This feature can aid you in writing rules whose patterns have a well-defined structure.</div>
        <p>Deftemplate is analogous to a struct definition in C. That is, the deftemplate defines a group of related fields in a pattern similar to the way in which a C struct is a group of related data. A deftemplate is a list of named fields called slots. Deftemplate allows access by name rather than by specifying the order of fields. Deftemplate contributes to good style in expert systems programs and is a valuable tool of software engineering.</p>
        <p>A slot is a named <dfn>single-slot</dfn> or <dfn>multislot</dfn>. A single-slot or simply slot contains exactly one field while a multislot contains zero or more fields. Any number of single or multislot slots may be used in a deftemplate. To write a slot, give the field name (attribute) followed by the field value. Note that a multislot slot with one value is strictly not the same as a single-slot slot. As an analogy, think of a cupboard (the multislot) that may contain dishes. A cupboard with one dish is not the same as a dish (single-slot). However, the value of a single-slot slot (or variable) may match a multislot slot (or multislot variable) that has one field.</p>
        <p>As an example of a deftemplate relation, consider the attributes of a duck who might be considered a good matrimonial prospect:</p>
        <dl>
          <!-- <varlistentry> -->
          <dt>name</dt>
          <dd>Dopey Wonderful</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>assets</dt>
          <dd>rich</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>age</dt>
          <dd>99</dd>
          <!-- </varlistentry> -->
        </dl>
        <p>A deftemplate may be defined for the relation <var>prospect</var> as follows, where white space and comments are used for readability and explanation.</p>
        <pre>; name of deftemplate relation
(deftemplate prospect
  ; optional comment in quotes
  "vital information"
  ; name of field
  (slot name
    ; type of field
    (type STRING)
    ; default value of field name
    (default ?DERIVE))
  ; name of field
  (slot assets
    ; type of field
    (type SYMBOL)
    ; default value of field assets
    (default rich))
  ; name of field
  (slot age
    ; type. NUMBER can be INTEGER or FLOAT
    (type NUMBER)
    ; default value of field age
    (default 80)))</pre>
        <p>In this example, the components of deftemplate are structured as:</p>
        <ul>
          <li>A deftemplate relation name</li>
          <li>Attributes called fields</li>
          <li>The field type, which can be any one of the allowed types: symbol, string, number, and others.</li>
          <li>The default for the field value</li>
        </ul>
        <p>This particular deftemplate has three single-slot slots called name, assets, and age.</p>
        <p>The deftemplate default values are inserted by CLIPS when a (reset) is done if no explicit values are defined. For example, enter the deftemplate for prospect after a (clear) command, and assert it as shown.</p>
        <screen>CLIPS&gt; (assert (prospect))
&lt;Fact-1&gt;
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (prospect (name "") (assets rich) (age 80))
For a total of 2 facts.
CLIPS&gt;</screen>
        <p>As you can see, CLIPS has inserted the default value of the null string, "", for the name field since that is the default for a STRING. Likewise, the assets and age defaults were also inserted by CLIPS. Different types have different default symbols such as the null string, "", for STRING; the integer 0 for INTEGER; the float 0.0 for FLOAT; and so on. The ?DERIVE keyword selects the appropriate type of constraint for that slot, e.g., the null string , "", for a slot of type STRING.</p>
        <p>You can explicitly set the field values, as the following example shows.</p>
        <pre>CLIPS&gt; (assert (prospect (age 99) (name "Dopey")))
&lt;Fact-2&gt;
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (prospect (name "") (assets rich) (age 80))
f-2 (prospect (name "Dopey") (assets rich) (age 99))
For a total of 3 facts.
CLIPS&gt;</pre>
        <p>Note that the order that the fields are typed in does not matter since these are named fields.</p>
        <p>In the deftemplate, it's important to realize that NUMBER is not a primitive field type like symbol, string, integer, and float. The NUMBER is really a compound type that can be integer or float. It is used for cases in which the user doesn't care what type of numbers are stored. An alternative to NUMBER would be specifying the types as follows.</p>
        <pre>(slot age
  (type INTEGER FLOAT)
  (default 80)))</pre>
        <p class="bridgehead">
          <i>Bye-Bye</i>
        </p>
        <p>In general, a deftemplate with <var>N</var> slots has the following general structure:</p>
        <pre>(deftemplate &lt;name&gt;
  (slot-1)
  (slot-2)
      .
      .
      .
  (slot-N))</pre>
        <p>In a deftemplate, the attribute values may be specified more precisely than a simple value such as 80 or rich. For example, in this deftemplate, a type of value is specified.</p>
        <p>The field values can be specified by either explicitly listing them or giving a range of values. The allowed-values can be any primitive type such as SYMBOL, STRING, INTEGER, FLOAT and so on. Some examples of deftemplate enumerated values are shown following:</p>
        <pre/>
        <p/>
        <pre/>
        <p/>
        <pre/>
        <p class="bridgehead">
          <i>Multislots</i>
        </p>
        <p>Notice that only single fields were used for the patterns in the examples so far. That is, the field values for name, assets, and age, were all single values. In some types of rules, you may want multiple fields. Deftemplate allows the use of multiple values in a multislot.</p>
        <p>As an example of multislot, suppose that you wanted to treat the name of the relation prospect as multiple fields. This would provide more flexibility in processing prospects since any part of the name could be pattern matched. Shown following is the deftemplate definition using multislot and the revised rule to pattern match on multiple fields. Notice that a multislot pattern, $?name, is now used to match all the fields that make up the name. For convenience, a (deffacts) is also given.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(deftemplate prospect
  (multislot name
    (type SYMBOL)
    (default ?DERIVE))
  (slot assets
    (type SYMBOL)
    (allowed-symbols poor rich wealthy loaded)
    (default rich))
  (slot age
    (type INTEGER)
    (range 80 ?VARIABLE) ; The older the
    (default 80)))       ; better!!!
CLIPS&gt;
(defrule happy_relationship
  (prospect (name $?name)
    (assets ?net_worth)
    (age ?months))
=&gt;
  (printout t "Prospect: "
    ?name crlf ; Note: not $?name
    ?net_worth crlf
    ?months " months old" crlf))
CLIPS&gt;
(deffacts duck-bachelor
  (prospect (name Dopey Wonderful)
            (assets rich)
            (age 99)))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Prospect: (Dopey Wonderful)
rich
99 months old
CLIPS&gt;</pre>
        <p>In the output, the parentheses around Dopey's name are put in by CLIPS to indicate that this is a multislot value. If you compare the output from this multislot version to the single-slot version, you'll see that the double quotes around <q>Dopey Wonderful</q> are gone. The name slot is not a string in the multislot version, so CLIPS treats the name as two independent fields, Dopey and Wonderful.</p>
        <p class="bridgehead">
          <i>
            <code class="command">modify</code>
          </i>
        </p>
        <p>Deftemplate greatly simplifies accessing a specific field in a pattern because the desired field can be identified by its slot name. The modify action can be used to retract and assert a new fact in one action by specifying one or more template slots to be modified.</p>
        <p>As an example, consider the following rules which show what happens when duck-bachelor Dopey Wonderful loses all his fish buying Donald Duck posters and banana fishsplits for his new duckette, Dixie.</p>
        <pre>CLIPS&gt; (undefrule *)
CLIPS&gt;
(defrule make-bad-buys
?prospect &lt;- (prospect (name $?name)
(assets rich)
(age ?months))
=&gt;
(printout t "Prospect: "
?name crlf ; Note: not $?name
"rich" crlf
?months " months old" crlf crlf)
(modify ?prospect (assets poor)))
CLIPS&gt;
(defrule poor-prospect
?prospect &lt;- (prospect (name $?name)
(assets poor)
(age ?months))
=&gt;
(printout t "Ex-prospect: "
?name crlf ; Note: not $?name
poor crlf
?months " months old"
crlf crlf))
CLIPS&gt;
(deffacts duck-bachelor
(prospect (name Dopey Wonderful)
(assets rich)
(age 99)))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Prospect: (Dopey Wonderful)
rich
99 months old
Ex-prospect: (Dopey Wonderful)
poor
99 months old
CLIPS&gt;</pre>
        <p>If you do a (facts) command as follows, you 'll see that the f-1 fact corresponding to (prospect (assets rich) (age 99) (name Dopey Wonderful)) is gone since the (modify) has retracted it and asserted f-2</p>
        <pre>CLIPS&gt; (facts)
f-0 (initial-fact)
f-2 (prospect (name Dopey Wonderful)
              (assets poor) (age 99))
For a total of 2 facts.
CLIPS&gt;</pre>
        <p>The make-bad-buys rule is activated by a rich prospect as specified by the assets slot. This rule changes the assets to poor using the modify action. Notice that the slot assets can be accessed by name. Without a deftemplate, it would be necessary to enumerate all the fields by single variables or by using a wildcard, which is less efficient. The purpose of the poor-prospect rule is simply to print out the poor prospects, thus demonstrating that the make-bad-investments rule did indeed modify the assets.</p>
      </section>
      <section>
        <h2>Being Functional</h2>
        <div class="abstract">
          <p>In this section, we will learn more powerful functions for matching patterns and some that are very useful with multifield variables. We will also learn how numeric calculations are done.</p>
        </div>
        <p class="bridgehead">
          <i>Not my Constraint</i>
        </p>
        <p>Let's reconsider the problem of designing an expert system to help a robot cross a street. One rule that you would have follows.</p>
        <pre/>
        <pre>(defrule green-light
  (light green)
=&gt;
  (printout t "Walk" crlf))</pre>
        <p>Another rule would cover the case of a red light.</p>
        <pre>(defrule red-light
  (light red)
=&gt;
  (printout t "Don't walk" crlf))</pre>
        <p>A third rule would cover the case in which a walk-sign said not to walk. This would take precedence over a green light.</p>
        <pre>(defrule walk-sign
  (walk-sign-says dont-walk)
=&gt;
  (printout t "Don't walk" crlf))</pre>
        <p>The previous rules are simplified and don't cover all cases such as the breakdown of the traffic- light. For example, what does the robot do if the light is red or yellow and the walk-sign says walk?</p>
        <p>A way of handling this case is to use a <dfn>field constraint</dfn> to restrict the values that a pattern may have on the LHS. The field constraint acts like constraints on patterns.</p>
        <p>One type of field constraint is called a <dfn>connective constraint</dfn>. There are three types of connective constraints. The first is called a ~ constraint. Its symbol is the tilde, <q>~</q>. The ~ constraint acts on the one value that immediately follows it and will not allow that value.</p>
        <p>As a simple example of the ~ constraint, suppose you wanted to write a rule that would print out <q>Don't walk</q> if the light was not green. One approach would be to write rules for every possible light condition, including all possible malfunctions: yellow, red, blinking yellow, blinking red, blinking green, winking yellow, blinking yellow and winking red, and so forth. However, a much easier approach is to use the ~ constraint as shown in the following rule:</p>
        <pre>(defrule walk
  (light ~green)
=&gt;
  (printout t "Don't walk" crlf))</pre>
        <p>By using the ~ constraint, this one rule does the work of many other rules that required specifying each light condition.</p>
        <p>The second connective constraint is the <dfn>bar constraint</dfn>, <q>|</q>. The <q>|</q> connective constraint is used to allow any of a group of values to match.</p>
        <p>For example, suppose you wanted a rule that printed out <q>Be cautious</q> if the light was yellow or blinking yellow. The following example shows how it's done using the <q>|</q> constraint.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule cautious
  (light yellow|blinking-yellow)
=&gt;
  (printout t "Be cautious" crlf))
CLIPS&gt; (assert (light yellow))
&lt;Fact-1&gt;
CLIPS&gt; (assert (light blinking-yellow))
&lt;Fact-2&gt;
CLIPS&gt; (agenda)
0 cautious: f-2
0
cautious: f-1
For a total of 2 activations.
CLIPS&gt;</pre>
        <p>The third type of connective constraint is the <dfn>&amp; connective constraint</dfn>. The symbol of the &amp; connective constraint is the ampersand, <q>&amp;</q>. The &amp; constraint forces connected constraints to match in union, as you'll see in the following examples. The &amp; constraint normally is used only with the other constraints, otherwise it's not of much practical use. As an example, suppose you want to have a rule that will be triggered by a yellow or blinking-yellow fact. That's easy enough &#x2014;just use the | connective constraint as you did in a previous example. But suppose that you also want to identify the light color?</p>
        <p>The solution is to bind a variable to the color that is matched using the <q>&amp;</q> and then print out the variable. This is where the <q>&amp;</q> is useful, as shown below.</p>
        <pre>(defrule cautious
  (light ?color&amp;yellow|blinking-yellow)
=&gt;
  (printout t "Be cautious because light is " ?color crlf))</pre>
        <p>The variable ?color will be bound to whatever color is matched by the field yellow|blinking- yellow.</p>
        <p>The <q>&amp;</q> also is useful with the <q>~</q>. For example, suppose you want a rule that triggers when the light is not yellow and not red.</p>
        <pre>(defrule not-yellow-red
  (light ?color&amp;~red&amp;~yellow)
=&gt;
 (printout t "Go, since light is " ?color crlf))</pre>
        <p class="bridgehead">
          <i>Numeric calculations</i>
        </p>
        <p>Besides dealing with symbolic facts, CLIPS also can perform numeric calculations. However, you should keep in mind that an expert system language like CLIPS is not primarily designed for number-crunching. Although the math functions of CLIPS are very powerful, they are really meant for modification of numbers that are being reasoned about by the application program. Other languages such as FORTRAN are better for number-crunching in which little or no symbolic reasoning is being done. You'll find the computational capability of CLIPS useful in many applications.</p>
        <p>CLIPS provides basic arithmetic and math functions +, /, *, -, div, max, min, abs, float, and integer. For more details, see the <cite class="book">CLIPS Reference Manual</cite>.</p>
        <p>Numeric expressions are represented in CLIPS according to the style of <a target="_blank" href="lisp.html">LISP</a>. In both LISP and CLIPS, a numeric expression that customarily would be written as 2 + 3 must be written in <dfn>prefix form</dfn>, (+ 2 3). In the prefix form of CLIPS, the function precedes the arguments, and parentheses must surround the numeric expression. The customary way of writing numeric expressions is called <dfn>infix form</dfn> because the math functions are fixed in between the arguments.</p>
        <p>Functions can be used on the LHS and the RHS. For example, the following shows how the arithmetic operation of addition is used on the RHS of a rule to assert a fact containing the sum of two numbers ?x and ?y. Note that the comments are in infix notation for your information only since infix cannot be evaluated by CLIPS.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule addition
  (numbers ?x ?y)
=&gt;
  ; Add ?x + ?y
  (assert (answer-plus (+ ?x ?y))))
CLIPS&gt; (assert (numbers 2 3))
&lt;Fact-1&gt;
CLIPS&gt; (run)
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (numbers 2 3)
f-2 (answer-plus 5)
For a total of 3 facts.
CLIPS&gt;</pre>
        <p>A function can be used on the LHS if an equal sign, =, is used to tell CLIPS to evaluate the following expression rather than use it literally for pattern matching. The following example shows how the hypotenuse is calculated on the LHS and used to pattern match against some stock items. The exponentiation, <q>**</q>, function is used to square the x and y values. The first argument of exponentiation is the number which is to be raised to the power of the second argument.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(deffacts database
  (stock A 2.0)
  (stock B 5.0)
  (stock C 7.0))
CLIPS&gt;
(defrule addition
  (numbers ?x ?y)
  ; Hypotenuse
  (stock ?ID =(sqrt (+ (** ?x 2) (** ?y 2))))
=&gt;
  (printout t "Stock ID=" ?ID crlf))
CLIPS&gt; (reset)
CLIPS&gt; (assert (numbers 3 4))
&lt;Fact-4&gt;
; Stock ID matches
; hypotenuse calculated
CLIPS&gt; (run)
Stock ID=B
CLIPS&gt;</pre>
        <p>Arguments in a numeric expression can be extended beyond two for many of the math functions. The same sequence of arithmetic calculations is performed for more than two arguments. The following example illustrates how three arguments are used. Evaluation proceeds from left to right. Before entering these, however, you may wish to do a (clear) to get rid of any old facts and rules.</p>
        <pre>(defrule addition
  (numbers ?x ?y ?z)
=&gt;
  ; ?x + ?y + ?z
  (assert (answer-plus (+ ?x ?y ?z))))</pre>
        <p>Enter the above program and assert (numbers 2 3 4). After you run, you'll see the following facts. Note that the fact-indices may be different if you've done a (reset) instead of a (clear) before loading this program.</p>
        <pre>CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (numbers 2 3 4)
f-2 (answer-plus 9)
For a total of 3 facts.
CLIPS&gt;</pre>
        <p>The infix equivalent of a multiple argument CLIPS expression can be expressed as</p>
        <pre>arg [function arg]</pre>
        <p>where the square brackets mean that there can be multiple terms.</p>
        <p>Besides the basic math functions, CLIPS has <dfn>Extended Math functions</dfn> including trig, hyperbolic, and so on. For a complete list, see the <cite class="book">CLIPS Reference Manual</cite>. These are called Extended Math functions because they are not considered basic math functions like <q>+</q>, <q>-</q>, etc.</p>
        <p>In dealing with expressions, CLIPS tries to keep the mode the same as the arguments. For example,</p>
        <pre>; both integer arguments
; give integer result
CLIPS&gt; (+ 2 2)
4
; both floating-point arguments
; give floating-point result
CLIPS&gt; (+ 2.0 2.0)
4.0
; mixed arguments
; give floating-point result
CLIPS&gt; (+ 2 2.0)
4.0
CLIPS&gt;</pre>
        <p>Notice that in the last case of mixed arguments, CLIPS converts the result to standard double-precision floating-point type.</p>
        <p>You can explicitly convert one type to another by using the float and integer functions, as demonstrated in the following examples.</p>
        <pre>; convert integer
; to float
CLIPS&gt; (float (+ 2 2))
4.0
; convert float
; to integer
CLIPS&gt; (integer (+ 2.0 2.0))
4
CLIPS&gt;</pre>
        <p>Parentheses are used to explicitly specify the order of expression evaluation if desired. In the example of ?x + ?y * ?z, the customary infix way to evaluate it is to multiply ?y by ?z and then add the result to ?x. However, in CLIPS, you must write the precedence explicitly if you want this order of evaluation, as follows.</p>
        <pre>(defrule mixed-calc
  (numbers ?x ?y ?z)
=&gt;
  ; ?y * ?z + ?x
  (assert (answer (+ ?x (* ?y ?z)))))</pre>
        <p>In this rule, the expression in the innermost parentheses is evaluated first; so ?y is multiplied by ? z. The result is added to ?x.</p>
        <p class="bridgehead">
          <i>Binding</i>
        </p>
        <p>The analog to assigning a value to a variable on the LHS by pattern matching is <dfn>binding</dfn> a value to a variable on the RHS using the <function>bind</function> function. It's convenient to bind variables on the RHS if the same values will be repeatedly used.</p>
        <p>As a simple example in a math calculation, let's first bind the answer to a variable and then print the <dfn>bound variable</dfn>.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule addition
  (numbers ?x ?y)
=&gt;
  (assert (answer (+ ?x ?y)))
  (bind ?answer (+ ?x ?y))
  (printout t "answer is " ?answer crlf))
CLIPS&gt; (assert (numbers 2 2))
&lt;Fact-1&gt;
CLIPS&gt; (run)
answer is 4
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (numbers 2 2)
f-2 (answer 4)
For a total of 3 facts.
CLIPS&gt;</pre>
        <p>The (bind) also can be used on the RHS to bind single or multifield values to a variable. The (bind) is used to bind zero, one, or more values to a variable without the <q>$</q> operator. Recall that on the LHS, you can only create a multifield pattern by using the <q>$</q> operator on a field, such as <q>$? x</q>. However, the <q>$</q> is unnecessary on the RHS because the arguments of (bind) explicitly tell CLIPS exactly how many values to bind. In fact, the <q>$</q> is a useless appendage on the RHS.</p>
        <p>The following rule illustrates some variable bindings on the RHS. The multifield value function, <function>create$</function>, is used to create a multifield value. Its general syntax is as follows.</p>
        <pre>(create$ &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;)</pre>
        <p>where any number of arguments can be appended together to create a multifield value. This multifield value, or a single-field value, can then be bound to a variable as shown in the RHS actions of the following rule</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule bind-values-demo
=&gt;
  (bind ?duck-bachelors
    (create$ Dopey Dorky Dinky))
  (bind ?happy-bachelor-mv
    (create$ Dopey))
  (bind ?none (create$))
  (printout t "duck-bachelors " ?duck-bachelors crlf
              "duck-bachelors-no-() " (implode$ ?duck-bachelors) crlf
              "happy-bachelor-mv " ?happy-bachelor-mv crlf
              "none " ?none crlf))
CLIPS&gt; (reset)
CLIPS&gt; (run)
duck-bachelors (Dopey Dorky Dinky)
duck-bachelors-no-() Dopey Dorky Dinky
happy-bachelor-mv (Dopey)
none ()
CLIPS&gt;</pre>
        <p class="bridgehead">
          <i>Defining your own Functions</i>
        </p>
        <p>Just like other languages, CLIPS allows you to define your own functions with <function>deffunction</function>. The deffunction is known globally, which saves you the effort of entering the same actions over and over again.</p>
        <p>Deffunctions also help in readability. You can call a deffunction just like any other function. A deffunction may also be used as the argument of another function. A (printout) can be used anywhere in a deffunction even if it's not the last action because printing is a side-effect of calling the (printout) function.</p>
        <p>The general syntax of a deffunction is shown following.</p>
        <pre>(deffunction &lt;function-name&gt; [optional comment]
  ; argument list. Last one may
  ; be optional multifield arg.
  (?arg1 ?arg2 ... ?argM [$?argN])
  ; action1 to action(K-1)
  ; do not return a value
  ; only last action returned
  (&lt;action1&gt;
   &lt;action2&gt;
      ...
   &lt;action(K-1)&gt;
   &lt;actionK&gt;)</pre>
        <p>The ?arg are <dfn>dummy arguments</dfn>, which mean that the names of the arguments will not conflict with variable names in a rule if they are the same. The term dummy argument is sometimes called a <dfn>parameter</dfn> in other books.</p>
        <p>Although each action may have returned values from function calls within the action, these are blocked by the deffunction from being returned to the user. The deffunction will only return the value of the last action, &lt;actionK&gt;. This action may be a function, a variable, or a constant.</p>
        <p>The following is an example of how a deffunction is defined to calculate the hypotenuse, and then used in a rule. Even if the variable names in the rule are the same as the dummy arguments, there's no conflict. That's why they're dummy, because they don't mean anything.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(deffunction hypotenuse
  ; name
  ; dummy arguments
  (?a ?b)
  ; action
  (sqrt(+ (* ?a ?a) (* ?b ?b))))
CLIPS&gt;
(defrule calculate-hypotenuse
  (dimensions ?base ?height)
=&gt;
  (printout t "Hypotenuse=" (hypotenuse ?base ?height) crlf))
CLIPS&gt; (assert (dimensions 3 4))
&lt;Fact-1&gt;
CLIPS&gt; (run)
Hypotenuse=5.0
CLIPS&gt;</pre>
        <p>Deffunctions may be used with multifield values, as the following example shows.</p>
        <pre>CLIPS&gt; (clear)
CLIPS&gt;
(deffunction count
  ($?arg)
  (length $?arg))
CLIPS&gt; (count 1 2 3 a duck "quacks")
6
CLIPS&gt;</pre>
        <p class="bridgehead">
          <i>Other Functions</i>
        </p>
        <p>Other useful functions:</p>
        <dl>
          <!-- <varlistentry> -->
          <dt>
            <function/>
          </dt>
          <dd/>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>round</function>
          </dt>
          <dd>Round toward closest integer. If exactly between two integers, rounds toward negative infinity.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>integer</function>
          </dt>
          <dd>Truncates the decimal part of a number.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>format</function>
          </dt>
          <dd>Formats output.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>list-deffunctions</function>
          </dt>
          <dd>List all deffunctions.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>ppdeffunction</function>
          </dt>
          <dd>Pretty print deffunction.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>undeffunction</function>
          </dt>
          <dd>Deletes a deffunction if it is not currently executing and not referred to elsewhere. Specifying <q>*</q> for &lt;name&gt;   deletes all.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>length</function>
          </dt>
          <dd>Number of fields, or the number of characters in a string or symbol.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>nth$</function>
          </dt>
          <dd>Specified field if it exists, else nil.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>member$</function>
          </dt>
          <dd>Number of the field if literal or variable exists, else FALSE.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>subsetp</function>
          </dt>
          <dd>Returns TRUE if a multi field value is a subset of another multifield value, else FALSE.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>delete$</function>
          </dt>
          <dd>Given a field number, deletes the value in the field.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>explode$</function>
          </dt>
          <dd>Each string element is returned as part of a new multifield value.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>subseq$</function>
          </dt>
          <dd>Returns a specified range of fields.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>
            <function>replace$</function>
          </dt>
          <dd>Replaces a specified value.</dd>
          <!-- </varlistentry> -->
        </dl>
      </section>
      <section>
        <h2>Control in CLIPS</h2>
        <section>
          <title>Reading</title>
          <p>CLIPS can read the
              information that you type from the keyboard using the <function>read</function> function. The following example shows how (read) is used to input data. Note that no extra (crlf) is needed after the (read) to put the cursor on a new line. The (read) automatically resets the cursor to a new line.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defrule read-input
=&gt;
  (printout t "Name a primary color" crlf)
  (assert (color (read))))
CLIPS&gt;
(defrule check-input
  ?color &lt;-
    (color ?color-read&amp;red|yellow|blue)
=&gt;
  (retract ?color)
  (printout t "Correct" crlf))
CLIPS&gt; (reset)
CLIPS&gt; (agenda)
0  read-input: *
For a total of 1 activation.
CLIPS&gt; (run)
Name a primary color
red
Correct
CLIPS&gt; (reset)
CLIPS&gt; (run)
Name a primary color
green
CLIPS&gt;
; No "correct"</pre>
          <p>The rule is designed to use keyboard input on the RHS, so it 's convenient to trigger the rule by not specifying any patterns on the LHS so it will automatically be activated when a (reset) occurs. When the activation for the read-input rule is displayed by the (agenda) command, an * is printed rather than a fact identifier such as f-1. The * is used to indicate that the pattern is satisfied, but not by a specific fact.</p>
          <p>The (read) function is not a general-purpose function that will read anything you type on the keyboard. One limitation is that (read) will read only one field. So if you try to read</p>
          <pre>primary color is red</pre>
          <p>only the first field, <q>primary</q>, will be read. To (read) all the input, you must enclose the input within double quotes. Of course, once the input is within double quotes, it is a single literal field. You can then access the substrings <q>primary</q>, <q>color</q>, <q>is</q>, and <q>red</q> with the <code class="command">str-explode</code> or <code class="command">sub-string</code> functions.</p>
          <p>The second limitation of (read) is that you can 't input parentheses unless they are within double quotes. Just as you can 't assert a fact containing parentheses, you can 't (read) parentheses directly except as literals.</p>
          <p>The <code class="command">readline</code> function is used to read multiple values until terminated by a carriage return. This function reads in data as a string. In order to assert the (readline) data, an (assert-string) function is used to assert the nonstring fact, just as input by (readline). A top-level example of (assert-string) follows.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt; (assert-string "(primary color is red)")
&lt;Fact-1&gt;
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (primary color is red)
For a total of 2 facts.
CLIPS&gt;</pre>
          <p>Notice that the argument of (assert-string) must be a string The following shows how to assert a fact of multiple fields from (readline).</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
  (defrule test-readline
=&gt;
  (printout t "Enter input" crlf)
  (bind ?string (readline))
  (assert-string (str-cat "(" ?string ")")))
CLIPS&gt; (reset)
CLIPS&gt; (run)
Enter input
primary color is red
CLIPS&gt; (facts)
f-0 (initial-fact)
f-1 (primary color is red)
For a total of 2 facts.
CLIPS&gt;</pre>
          <p>Since (assert-string) requires parentheses around the string to be asserted, the (str-cat) function is used to put them around ?string.</p>
          <p>Both (read) and (readline) also can be used to read information from a file by specifying the logical name of the file as the argument. For more information, see the <cite class="book">CLIPS Reference Manual</cite>.</p>
        </section>
        <section>
          <title>Efficiency (Rete Algorithm)*</title>
          <p>CLIPS is a rule-based language that uses a very efficient pattern-matching algorithm called the Rete Algorithm, devised by Charles Forgy of Carnegie-Mellon University for his OPS shell. The term Rete is Latin for net, and describes the software architecture of the pattern-matching process.</p>
          <p>It is very difficult to give precise rules that will always improve the efficiency of a program running under the Rete Algorithm. However, the following should be taken as general guidelines that may help:</p>
          <ul>
            <li>Put the most specific patterns in a rule first. Patterns with unbound variables and wildcards should be lower down in the list of rule patterns. A control fact should be put first in the patterns.</li>
            <li>Patterns with fewer matching facts should go first to minimize partial matches.</li>
            <li>Patterns that are often retracted and asserted, volatile patterns, should be put last in the list of patterns.</li>
          </ul>
          <p>As you can see, these guidelines are potentially contradictory. A non-specific pattern may have few matches (see guidelines 1 and 2). Where should it go? The overall guideline is to minimize changes of the partial matches from one cycle of the Inference Engine to the next. This may require much effort by the programmer in watching partial matches. An alternative solution is simply to buy a faster computer, or an accelerator board. This is becoming more attractive since the price of hardware always goes down while the price of human labor always goes up. Because CLIPS is designed for portability, any code developed on one machine should work on another.</p>
        </section>
        <section>
          <title>Comparisons and Tests*</title>
          <p>The test conditional element provides a very powerful way by which to compare numbers, variables, and strings on the LHS. The (test) is used as a pattern on the LHS. A rule will only be triggered if the (test) is satisfied together with other patterns.</p>
          <p>Many predefined functions are provided by CLIPS. Logical functions are:</p>
          <ul>
            <li><function>not</function>: Boolean not</li>
            <li><function>and</function>: Boolean and</li>
            <li><function>or</function>: Boolean or</li>
          </ul>
          <p>Arithmetic functions are:</p>
          <ul>
            <li><function>/</function>: Division</li>
            <li><function>*</function>: Multiplication</li>
            <li><function>+</function>: Addition</li>
            <li><function>-</function>: Subtraction</li>
          </ul>
          <p>Comparison functions are:</p>
          <ul>
            <li><function>eq</function>: Equal (any type). Compares type and magnitude.</li>
            <li><function>neq</function>: Not equal (any type).</li>
            <li><function>=</function>: Equal (numeric type). Compares magnitude.</li>
            <li><function>&lt;&gt;</function>: Not equal (numeric type).</li>
            <li><function>&gt;=</function>: Greater than or equal to</li>
            <li><function>&gt;</function>: Greater than.</li>
            <li><function>&lt;=</function>: Less than or equal to.</li>
            <li><function>&lt;</function>: Less than.</li>
          </ul>
          <p/>
          <p>All the comparison functions except <code class="command">eq</code> and <code class="command">neq</code> will give an error message if they are used to compare a number and non-number. If the type is not known in advance, the <code class="command">eq</code> and <code class="command">neq</code> functions should be used. The eq function checks for the same magnitude and type of its arguments while the <code class="command">=</code> function only checks the magnitude of its (numeric) arguments and doesn 't care if they 're integer or floating-point.</p>
          <p>The logical functions of CLIPS are <code class="command">and</code>, <code class="command">or</code>, and <code class="command">not</code>. They can be used in expressions as Boolean functions. In CLIPS, true and false are represented by the symbols <literal>TRUE</literal> and <literal>FALSE</literal>. Note that upper-case must be used for logical values in CLIPS.</p>
          <p>In addition to all the predefined functions, you may write <dfn>external functions</dfn> or user-defined functions in C, Ada, or other procedural languages and link to CLIPS. These external functions are then used as you would any predefined function.</p>
          <p>CLIPS also gives you the capability of specifying an explicit <dfn>and conditional element</dfn>, an <dfn>or conditional element</dfn>, and a <dfn>not conditional element</dfn> on the LHS. The absence of a fact is specified as a pattern on the LHS using the <code class="command">not</code> conditional element.</p>
          <p>The alteration of our information to conform to reality is called <dfn>truth maintenance</dfn>. That is, we try to maintain the state of our minds to contain only true information so as to minimize conflicts with the real world.</p>
          <p>While people can do this fairly easily (practice makes perfect), it 's difficult for computers because they don 't normally know which pattern entities are <em>logically dependent</em> on other pattern entities. CLIPS has a feature to support truth maintenance which will internally tag those pattern entities which are logically dependent on others. If these other pattern entities are retracted, CLIPS will automatically retract the logically dependent ones. The <dfn>logical conditional element</dfn> uses the keyword <kbd>logical</kbd> around a pattern to indicate that the matching pattern entities provide logical support to the assertions on the RHS.</p>
          <p>Although the logical support works for assertions, it does not reassert retracted facts. The moral is, if you lose something due to erroneous information, you can 't get it back (like losing money on your stockbrokers advice.)</p>
          <p>CLIPS has two functions to help with logical support. The <function>dependencies</function> function lists the partial matches from which a pattern entity receives logical support, or none if there is no support. The second logic function is <function>dependents</function> which lists all pattern entities which receive logical support from a pattern entity.</p>
          <p>The connective constraint, uses <code class="command">&amp;</code>, <code class="command">|</code>, or <code class="command">~</code>. Another type of field constraint is called a <dfn>predicate constraint</dfn> and is often used for pattern matching of more complex fields. The purpose of a predicate constraint is to constrain a field depending on the result of a Boolean expression. If the Boolean returns FALSE, the constraint is not satisfied and the pattern matching fails. You 'll find that the predicate constraint is very useful with numeric patterns.</p>
          <p>A <dfn>predicate function</dfn> is one which returns a FALSE or a non-FALSE value. The colon, <q>:</q> followed by a predicate function is called a <dfn>predicate constraint</dfn>. The <q>:</q> may be preceded by <q>&amp;</q>, <q>|</q>, or <q>~</q> or may stand by itself as in the pattern (fact :(&gt; 2 1)). It is typically used with the &amp; connective constraint as <q>&amp;:</q>. The following list contains some of the predicate functions defined by CLIPS:</p>
          <ul>
            <li>(<function>evenp</function> &lt;arg&gt;): check if &lt;arg&gt; is even number.</li>
            <li>(<function>oddp</function> &lt;arg&gt;): check if &lt;arg&gt; is odd number.</li>
            <li>(<function>floatp</function> &lt;arg&gt;): check if &lt;arg&gt; is floating-point number.</li>
            <li>(<function>integerp</function> &lt;arg&gt;): check if &lt;arg&gt; is integer.</li>
            <li>(<function>numberp</function> &lt;arg&gt;): check if &lt;arg&gt; is float or integer.</li>
            <li>(<function>stringp</function> &lt;arg&gt;): check if &lt;arg&gt; is string.</li>
            <li>(<function>symbolp</function> &lt;arg&gt;): check if &lt;arg&gt; is symbol.</li>
            <li>(<function>lexemep</function> &lt;arg&gt;): check if &lt;arg&gt; is symbol or string.</li>
            <li>(<function>multifieldp</function> &lt;arg&gt;): check if &lt;arg&gt; is multifield value.</li>
            <li>(<function>pointerp</function> &lt;arg&gt;): check if &lt;arg&gt; is external address.</li>
          </ul>
        </section>
        <section>
          <title>Globals</title>
          <!--page 80-->
          <p>There are often cases in which it's convenient to have values which are globally known in an expert system. For example, it is inefficient to have to redefine universal constants such as <constant>&#x3C0;</constant>.</p>
          <p>CLIPS provides the <kbd>defglobal</kbd> construct so that values may be universally known to all rules.</p>
        </section>
        <section>
          <title>Random Numbers</title>
          <p>Another type of useful function is random numbers. CLIPS has a <function>random</function> function which returns a <q>random</q> integer value. The random number function of CLIPS actually returns pseudorandom numbers, which means they are not truly random but are generated by a mathematical formula. For most purposes the pseudorandom numbers will be fine. Note that the random function of CLIPS uses the ANSI C library function rand which may not be available on all computers that do not adhere to this standard. For more information on all these topics, please see the <cite class="book">CLIPS Reference Manual</cite>.</p>
        </section>
        <section id="CLIPS.salience">
          <title>Priority (Salience)*</title>
          <p>In addition to control facts to control the execution of programs, CLIPS provides a more direct way of control by the explicit assignment of <dfn>salience</dfn> to rules. The main problem associated with explicitly using salience while you were just starting to learn CLIPS is the tendency to overuse salience and write sequential programs. This overuse defeats the whole purpose of using a rule-based language, which is to provide a natural vehicle for those applications best represented by rules. In the same way, procedural languages are best for strong control-oriented applications, while object-oriented languages are best for representing objects. CLIPS has keywords called <code class="command">declare salience</code> which can be used to explicitly set the priority of rules.</p>
          <p>Salience is set using a numeric value ranging from the smallest value of -10000 to the highest of 10000. If a rule has no salience explicitly assigned by the programmer, CLIPS assumes a salience of zero. Notice that a salience of zero is midway between the largest and smallest salience values. A salience of zero does not mean that the rule has no salience but, rather, that it has an intermediate priority level.</p>
        </section>
        <section>
          <title>Control Structures and Loops*</title>
          <p>CLIPS provides some procedural programming structures that can be used on the RHS. These structures are the <kbd>while</kbd> and <kbd>if [...] then [...] else [...]</kbd> that also are found in modern high-level languages such as Ada, C, and Java.</p>
          <p>Another useful function with (while) loops is <function>break</function> which ends the currently executing (while) loop. The return function immediately ends the currently executing deffunction, generic function, method, or message-handler.</p>
        </section>
        <section>
          <title>Side Effects</title>
          <p>Any function may be called from the RHS, which greatly contributes to the power of CLIPS. Many other CLIPS functions are available that may return with numbers, symbols, or strings. These functions may be used for their return values or for their side-effects. An example of a function only used for its side-effect is (printout). The value returned by (printout) is meaningless. The importance of (printout) is in its side-effect of output. In general, functions may have nested arguments if appropriate to your desired effect.</p>
        </section>
        <section id="CLIPS.files">
          <title>Handling Files*</title>
          <p/>
          <p>Before a file can be accessed for reading or writing, it must be opened using the <function>open</function> function. The number of files that can be opened at once is dependent on your operating system and hardware. When you no longer need to access a file, you should close it with the <function>close</function> function. Unless a file is closed, there is no guarantee that the information written to it will be saved.</p>
          <p>The <dfn>logical name</dfn> of a file is how CLIPS identifies the file. The logical name is a global name by which CLIPS knows this file in all rules. Although the logical name could be identical to the filename, you may want to use something different. Another advantage of a logical name is that you can easily substitute a different filename without making major program changes.</p>
          <p>The function to read data from a file is the familiar (read) or (readline). The only new thing that you have to do is to specify the logical name from which to read as the argument of (read) or (readline).</p>
          <p>To (read) more than one field, you must use a loop. Even with (readline), a loop is necessary to read multiple lines. A loop can be written by having one rule trigger another or with a while-loop. The loop should not try to read past the end of file or the operating system will issue an error message. To help prevent this, CLIPS returns an EOF symbolic field if you try to read past the end of file (EOF).</p>
        </section>
        <section>
          <title>Evaluate and Build</title>
          <p>The evaluation function, eval, is used for evaluating any string or symbol except the <q>def</q> type constructs such as <function>defrule</function>, <function>deffacts</function>, etc., as if entered at the top-level. The <function>build</function> function takes care of the <q>def</q> type constructs. The (build) function is the complement of (eval). The build function evaluates a string or symbol as if it were entered at the top-level and returns TRUE if the argument is a legal def-type construct such as (defrule), (deffacts), and so forth.</p>
        </section>
      </section>
      <section id="CLIPS.OOP">
        <h2>Object-Oriented Programming in CLIPS</h2>
        <section>
          <title>Introduction to the OOP Paradigm</title>
          <p>A key characteristic of good program design is <em>flexibility</em>. Unfortunately, the rigid methodology of structured programming techniques does not provide the needed flexibility for fast, reliable, and efficient changes. The object-oriented programming (OOP) paradigm. provides this flexibility.</p>
          <p>The term paradigm comes from the Greek word paradeigma which means a model, example, or pattern. In computer science, a paradigm is a consistent, organized methodology for trying to solve a problem. Today, there are many programming paradigms such as OOP, procedural, rule- based, and connectionist. The term artificial neural systems, is a modern synonym for the older term connectionist.</p>
          <p>Traditional programming is procedural because it emphasizes algorithms or procedures in solving problems. Many languages have been developed to support this procedural paradigm, such as Pascal, C, Ada, FORTRAN, and BASIC. These languages have also been adapted for object-oriented design (OOD) by either adding extensions or imposing a design methodology on the programmers. In contrast, new languages have been developed to provide OOP, which is not the same as OOD. You can do OOD in any language, even assembly language.</p>
          <p>CLIPS provides three paradigms: rules, objects, and procedures. You will learn more about the objects in the CLIPS Object-Oriented Language (COOL) which is integrated with the rule and procedural based paradigms of CLIPS. CLIPS supports the procedural paradigm through generic functions, deffunctions, and user-defined external functions. Depending on the application, you can use rules, objects, procedures, or a combination.</p>
          <p>Rather than imposing a single paradigm on the user, our philosophy is that a variety of specialized tools, a multi-paradigm approach, is better than trying to force everyone to use a single general purpose tool. As an analogy, while you could use a hammer and nails for fastening everything, there are cases in which other fasteners are preferred. For example, imagine fastening your pants with a hammer and nails instead of a zipper.</p>
        </section>
        <section>
          <title>Classes in CLIPS</title>
          <p>In OOP a class is a template which describes the common characteristics or attributes of objects. Note that this use of the term template is not the same as a deftemplate as described in an earlier chapter. Here, the word template is used in the sense of a tool that is used to build objects having common attributes. As analogies, a straightedge is a template for drawing straight lines while a cookie-cutter is a curvaceous template.</p>
          <p>Classes of objects are arranged in a hierarchy or in a graph to describe the relationships of objects in a system. Each class is an abstraction of a real-world system or some other logical system that we are trying to model. For example, one abstract model of a real-world system might be an automobile. Another abstract model of a logical system could be financial instruments such as stocks and bonds, or complex numbers. The term <dfn>abstraction</dfn> refers to (1) the abstract description of a real-world object or other system that we are trying to model, or (2) the process of representing a system in terms of classes. Abstraction is one of the five generally accepted features of a true OOP language. The others are <dfn>inheritance</dfn>, <dfn>encapsulation</dfn>, <dfn>polymorphism</dfn> and <dfn>dynamic binding</dfn>. These terms will be explained in detail as you read through this section. CLIPS supports all five of these features.</p>
          <p>The term abstract means that we are not concerned with nonessential details. An abstract description of a complex system is a simplified description that concentrates on relevant information for a specific purpose. Thus, the system is represented by a simpler, easier to understand model. As a familiar example, when certain people drive cars, they utilize an abstract model of driving that consists of two items &#x2014; the steering wheel and the accelerator. That is, these people are not concerned with the hundreds of components that make up an automobile, nor the theory of internal combustion engines, traffic laws, and so forth. Knowing only how to use the steering wheel and accelerator is their abstract model of driving.</p>
          <p>One of the five fundamental features of OOP is inheritance. Classes are arranged in a hierarchy with the most general classes at the top and the more specialized classes below. This allows new classes to be easily defined as specialized refinements or modifications of existing classes.</p>
          <p>The use of inheritance can greatly speed up software development and increase reliability because new software does not need to be created from scratch each time a new program is made. OOP makes it easy to utilize reusable code. OOP programmers often make use of object libraries consisting of hundreds or thousands of objects. These objects can be used or modified as desired in a new program. In addition to public domain object libraries, a number of companies market commercial object libraries. Although the concept of reusable software components has been around since the early days of FORTRAN subroutine libraries in the 1960s, the concept has never before been so successfully used for general software development.</p>
          <p>In order to define a class, you must specify one or more parent classes or superclasses of the class to be defined. As an analogy to superclasses, every person has parents; people do not spontaneously come into existence (although sometimes you may wonder if certain people really had parents.) The opposite of a superclass is a child class or subclass.</p>
          <p>This determines the inheritance of the new class. A subclass inherits <dfn>attributes</dfn> from one or more superclasses. The term attribute in COOL refers to the properties of an object, which are named slots that describe it. For example, an object to represent a person might have slots for name, age, address, and so forth.</p>
          <p>An <dfn>instance</dfn> is an object that has values for the slots such as John Smith, 28, 1000 Main St., Clear Lake City, TX. Lower-level classes automatically inherit their slots from higher-level classes, unless the slots are explicitly blocked. New slots are defined in addition to the inherited slots to set all the attributes that describe the class.</p>
          <p>An object's behavior is defined by its <dfn>message-handlers</dfn>, or <dfn>handlers</dfn> for short. A message-handler for an object responds to messages and performs the required actions. For example, sending the message</p>
          <pre>(send [John_Smith] print)</pre>
          <p>would cause the appropriate message-handler to print the values of the slots of the instance John_Smith. Instances are generally specified within brackets, [ ]. A message begins with the <function>send</function> function, followed by the instance name, message name, and any required arguments. For example, in the case of the print message, there are no arguments. An <dfn>object</dfn> in CLIPS is an instance of a class.</p>
          <p>The <dfn>encapsulation</dfn> of slots and handlers inside an object is another of the five generally accepted features of an OOP. The term encapsulated means that a class is defined in terms of its slots and handlers. Although an object of a class may inherit slots and handlers from its superclasses, with a few exceptions discussed later, the object's slot values cannot be altered or examined without sending a message to the object.</p>
          <p>The root class or simply root of CLIPS is a predefined system class called OBJECT. The predefined system class USER is a subclass of OBJECT.</p>
        </section>
        <section>
          <title>Inheriting in CLIPS</title>
          <p>As an example, suppose we wanted to define a class called UPPIE, which is a colloquial term for urban professional. Note that in this section, we'll follow the convention of writing classes in all uppercase.</p>
          <p>UPPIE is defined as a subclass of USER.</p>
          <p>CLIPS supports only is-a relationships.</p>
          <p>The is-a link indicates the inheritance of slots from a class to its subclass. A class may have zero or more subclasses. All classes except OBJECT must have a superclass. Since UPPIE also inherits all slots of USER, and USER inherits all slots of OBJECT, it follows that UPPIE inherits all slots of OBJECT too. The same principle of inheritance also applies to the message-handlers of each class. For example, UPPIE inherits all the handlers of USER and OBJECT.</p>
          <p>The inheritance of slots and handlers is particularly important in OOP since it means that you do not have to redefine the properties and behavior of each new class of objects that is defined. Instead, each new class inherits all the properties and behavior from its higher-level classes. Since the new behavior is inherited, it may substantially reduce the <dfn>verification and validation</dfn> (V&amp;V) of the handlers. V&amp;V essentially means that the product was built properly and that it meets the requirements. The task of verifying and validating software may take more time and money than the software development itself, especially if the software affects human life and property. Inheritance of handlers allows for efficient reuse of existing code and speeds up development.</p>
        </section>
        <section>
          <title>Coding Classes in CLISP</title>
          <p>Classes are defined in CLIPS using the <kbd>defclass</kbd> construct. The UPPIE class is defined in one statement as follows.</p>
          <pre>(defclass UPPIE (is-a USER))</pre>
          <p>You do not have to enter the USER or the OBJECT classes since these are predefined classes and so CLIPS already knows their relationship. In fact, if you try to define USER or OBJECT, an error message will result since you cannot change the predefined classes, unless you change the source code of CLIPS.</p>
          <p>Since CLIPS is case-sensitive, commands and functions must be entered in lowercase. Predefined system classes such as USER and OBJECT must be entered in uppercase. Although you can enter user-defined classes in lowercase or uppercase, we will follow the convention of using all uppercase for classes for the sake of readability.</p>
          <p>The basic format of the defclass command to define classes only, and not slots, is,</p>
          <pre>(defclass &lt;class&gt;
(is-a &lt;direct-superclasses&gt;))</pre>
          <p>The list of classes, &lt;direct-superclasses&gt;, is called a <dfn>direct superclass precedence list</dfn> because it defines how a class is linked to its direct superclasses. The direct superclasses of a class are the one or more classes named after the <kbd>is-a</kbd> keyword. In our example, class DUCKLING is the direct superclass of DUCK. Note that at least one direct superclass must be given in the direct superclass precedence list.</p>
          <p>If the direct superclass list was as follows,</p>
          <pre>(defclass DUCK
(is-a DUCKLING USER OBJECT))</pre>
          <p>then USER and OBJECT would also be direct superclasses of DUCK. In this example, it makes no difference whether USER and OBJECT are specified in addition to DUCKLING. In fact, since USER and OBJECT are predefined classes that are always linked such that USER is-a OBJECT, and OBJECT is the root, you need never specify them except when defining a subclass of USER. Since USER only inherits from OBJECT, it is not necessary to specify OBJECT if USER is specified.</p>
          <p>The <dfn>indirect superclasses</dfn> of a class are all the classes not named after the <kbd>is-a</kbd> that contribute slots and message-handlers by inheritance. In our example, the indirect superclasses are USER and OBJECT. A class inherits slots and message-handlers from all its direct and indirect superclasses. Thus, DUCK inherits from DUCKLING, USER, and OBJECT.</p>
          <p>The root class OBJECT is the only class that does not have a superclass.</p>
          <p>Using this fancy new terminology allows us to state the Principle of OOP Inheritance: A class may inherit from all its superclasses.</p>
          <p>This is a simple, yet powerful concept fully exploited in OOP. This principle means that slots and message-handlers may be inherited to save us the trouble of redefining them for new subclasses. In addition, slots may be easily customized for new subclasses as modifications and as composites of superclass slots. By allowing easy and flexible reuse of existing code, program development time and cost are decreased. In addition, the reuse of working, existing code minimizes the amount of verification and validation needed. All these advantages facilitate the program maintenance tasks of debugging, modification, and enhancement once the code is released.</p>
          <p>The reason for using <q>may</q> in the principle is to emphasize that inheritance of slots from a class may be blocked by including a no-inherit facet in the class slot definition.</p>
          <p>The direct and indirect classes of a class are all those that lie on an <dfn>inheritance path</dfn> to OBJECT. An inheritance path is a set of connected nodes between the class and OBJECT. In our example, the single inheritance path of DUCK is DUCK, DUCKLING, USER, and OBJECT. In some cases a class has multiple inheritance paths to OBJECT.</p>
        </section>
        <section>
          <title>Eliciting Information about Classes in CLIPS</title>
          <p>CLIPS provides a number of functions to show information about classes, such as predicate functions to test whether a class is a superclass or subclass of another.</p>
          <p>The <function>superclassp</function> function returns TRUE if &lt;class1&gt; is a superclass of &lt;class2&gt;, and FALSE otherwise. The <function>subclassp</function> function returns TRUE if &lt;class1&gt; is a subclass of &lt;class2&gt;, and FALSE otherwise. The general form of both functions is</p>
          <pre>(function &lt;class1&gt; &lt;class2&gt;)</pre>
          <p>Now, to check to see if CLIPS accepted all these new classes. One way of doing this is with the <code class="command">list-defclasses</code> command. Following is the output of the command.</p>
          <pre>CLIPS&gt; (list-defclasses)
FLOAT
INTEGER
SYMBOL
STRING
MULTIFIELD
EXTERNAL-ADDRESS
FACT-ADDRESS
INSTANCE-ADDRESS
INSTANCE-NAME
OBJECT
PRIMITIVE
NUMBER
LEXEME
ADDRESS
INSTANCE
USER
INITIAL-OBJECT
UPPIE
CHILD
SUPPIE
MUPPIE
YUPPIE
PUPPIE
YUKKIE
For a total of 24 defclasses.
CLIPS&gt;</pre>
          <p>Notice that the (list-defclasses) command does not indicate the hierarchical class structure. That is, list-defclasses does not indicate which classes are subclasses or superclasses of others.</p>
          <p>The <code class="command">browse-classes</code> command shows the class hierarchy through indentation.</p>
          <pre>CLIPS&gt; (browse-classes)
OBJECT
PRIMITIVE
NUMBER
91INTEGER
FLOAT
LEXEME
SYMBOL
STRING
MULTIFIELD
ADDRESS
EXTERNAL-ADDRESS
FACT-ADDRESS
INSTANCE-ADDRESS *
INSTANCE
INSTANCE-ADDRESS *
INSTANCE-NAME
USER
INITIAL-OBJECT
UPPIE
SUPPIE
MUPPIE
YUPPIE
PUPPIE
YUKKIE *
CHILD
YUKKIE *
CLIPS&gt;</pre>
          <note>The asterisk after a class name indicates that it has multiple superclasses.</note>
          <p>The (browse-classes) command has an optional argument which specifies the starting class for the subclasses you want to see. This is convenient if you are not interested in listing all the classes.</p>
        </section>
        <section>
          <title>Abstract Classes, Instances etc.</title>
          <p>An <dfn>abstract class</dfn> is designed for inheritance only. The abstract class USER cannot have <dfn>direct instances</dfn> defined for it, which are instances defined directly for a class. In addition to the class information, the <dfn>inheritance precedence</dfn> of the classes is described. This is an ordered list in which the order from left to right indicates the highest to lowest precedence that classes contribute by inheritance. The inheritance precedence lists all the superclasses of a class back to the root class OBJECT. You can also see that the direct superclasses information indicates the superclass that is one link above a class while the inheritance precedence list shows all superclasses.</p>
          <p>Even if a class has no direct instances, it will have indirect instances if it has subclasses which have instances. The indirect instances of a class are all the instances of its subclasses.</p>
          <p>A concrete class is allowed to have direct instances. For example, given a concrete class COW, the direct instance Elsie would be the famous TV salescow. Normally classes inheriting from abstract classes are also abstract classes. However, classes inheriting from system classes, such as USER, are considered to be concrete unless otherwise specified. So UPPIE and YUPPIE are also concrete classes.</p>
          <important>It is strongly recommended that all classes you define in CLIPS be subclasses of USER. CLIPS will automatically provide handlers for print, init, and delete if your classes are subclasses of USER.</important>
        </section>
        <section>
          <title>Other Functions related-to Classes</title>
          <p>Some other functions useful with classes are shown following.</p>
          <ul>
            <li><function>ppdefclass</function>: Pretty-print the declass internal structure.</li>
            <li><function>undefclass</function>: Eliminate class.</li>
            <li><function>describe-class</function>: Additional information about classes.</li>
            <li><function>class-abstractp</function>: Predicate function returns TRUE if the class is abstract.</li>
          </ul>
        </section>
      </section>
      <!-- end of "Object-Oriented Programming in CLIPS" -->
      <section>
        <!--page 101-->
        <h2>Sending Messages in CLIPS</h2>
        <p>In this section you'll learn more about classes and objects called instances. You will see how to specify the attributes of classes using slots and how to send messages to objects.</p>
        <p>Whereas in Smalltalk, everything is an object, even the classes, in CLIPS classes are <em>not</em> objects.</p>
        <p>The general syntax of an instance name is simply a symbol surrounded by brackets, [ ], as follows.</p>
        <pre>[&lt;name&gt;]</pre>
        <p>The brackets are not actually part of the instance name, which is a symbol, like Elsie. Brackets are used to surround an instance name if there is danger of ambiguity in using the name. This may occur in the (send) function and so brackets are used in a (send). In case of doubt, use brackets, since it doesn't hurt.</p>
        <p>Some examples of different types of objects in CLIPS are shown following:</p>
        <dl>
          <!-- <varlistentry> -->
          <dt>Symbol</dt>
          <dd>Dorky_Duck</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>String</dt>
          <dd>"Dorky_Duck"</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>Float</dt>
          <dd>1.0</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>Integer</dt>
          <dd>1</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>Multifield</dt>
          <dd>(1 1.0 Dorky_Duck "Dorky_Duck")</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
          <dt>DUCK</dt>
          <dd>[Dorky_Duck]</dd>
          <!-- </varlistentry> -->
        </dl>
        <p>The classes of SYMBOL, STRING, FLOAT, INTEGER, and MULTIFIELD have the same names as those you are familiar with from rule-based programming in CLIPS. These are called <dfn>primitive object types</dfn> because they are provided by CLIPS and automatically maintained as needed. These primitive types are mainly provided for use in <dfn>generic functions</dfn>. Two <dfn>compound classes</dfn> are NUMBER which is FLOAT or INTEGER, and LEXEME which is SYMBOL or STRING. The compound classes are provided for convenience if the type of number, or type of characters doesn't matter.</p>
        <p>In contrast, user-defined object types are those that you define through user-defined classes.</p>
        <p>Two functions convert a symbol to an instance name, and vice versa. The <function>symbol-to-instance-name</function> converts a symbol to an instance name, as shown by the following.</p>
        <pre>CLIPS&gt; (clear) ; Get rid of any old classes
CLIPS&gt; (symbol-to-instance-name Dorky_Duck)
[Dorky_Duck]
CLIPS&gt;
(symbol-to-instance-name
  (sym-cat Dorky "_" Duck))
[Dorky_Duck]
CLIPS&gt;</pre>
        <p>Notice how standard CLIPS functions such as (sym-cat), which concatenates items, can be used with the object system of CLIPS.</p>
        <p>The opposite function, <function>instance-name-to-symbol</function>, converts an instance name to a symbol, as the following examples show.</p>
        <pre>CLIPS&gt; (instance-name-to-symbol [Dorky_Duck])
Dorky_Duck
CLIPS&gt;
(str-cat
  (instance-name-to-symbol [Dorky_Duck])
  " is a DUCK")
"Dorky_Duck is a DUCK"
CLIPS&gt;</pre>
        <section>
          <title>Roles, Instances...</title>
          <p>In order to see how messages work, let's start by entering the following commands to create a user-defined DUCK class and check that it's entered. Notice that no role descriptor is specified for the DUCK class. If a class has role concrete, direct instances of the class can be created. If the role is unspecified, CLIPS determines the role by inheritance. For determining role by inheritance, system classes behave as concrete classes. Thus by default, any class inheriting from USER is a concrete class and does not need to be declared as such in order to allow direct instances to be created.</p>
          <p>If a class has role abstract no direct instances of it can be made. Abstract classes are defined for inheritance purposes only. For example, an abstract class called PERSON could be defined whose properties such as name, address, age, height, weight, and so on are inherited by concrete classes MAN and WOMAN. A direct instance of MAN could be a man-person called Harold, and a direct instance of WOMAN is a woman-person called Henrietta.</p>
          <screen>CLIPS&gt; (defclass DUCK (is-a USER))
CLIPS&gt; (describe-class DUCK)
====================================================

****************************************************
Concrete: direct instances of this class can be created.
Reactive: direct instances of this class can match defrule
patterns.
Direct Superclasses: USER
Inheritance Precedence: DUCK USER OBJECT
Direct Subclasses:
----------------------------------------------------
Recognized message-handlers:
init primary in class USER
delete primary in class USER
create primary in class USER
print primary in class USER
direct-modify primary in class USER
message-modify primary in class USER
direct-duplicate primary in class USER
message-duplicate primary in class USER
****************************************************
====================================================
CLIPS&gt;</screen>
          <p>Since classes are not objects in CLIPS, we can't send a message to make an object. Instead, the make-instance function is used to make an instance object. The basic syntax is as follows.</p>
          <pre>(make-instance [&lt;instance-name&gt;] of &lt;class&gt;
  &lt;slot-override&gt;)</pre>
          <p>Normally, you specify an instance-name. However, If you do not, CLIPS will generate one using the gensym* function. Slot values also can be specified.</p>
          <p>Now that we have a duck factory, let's make some instances as follows, where the name of the instance is in brackets. Note the use of the <kbd>of</kbd> keyword to separate the instance name from the class name. You must include the <kbd>of</kbd> or a syntax error will result. Also, note that the brackets in the code mean an instance name, while brackets in the metasyntax such as for (make-instance) above, mean optional.</p>
          <pre>CLIPS&gt; (make-instance [Dorky] of DUCK)
[Dorky]
CLIPS&gt; (make-instance [Elsie] of COW)
[PRNTUTIL1] Unable to find class COW.
CLIPS&gt; (make-instance Dorky_Duck of DUCK)
[Dorky_Duck]
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky] of DUCK
[Dorky_Duck] of DUCK
For a total of 3 instances.
CLIPS&gt;</pre>
          <p>After the instance is successfully created, CLIPS responds with the name of the instance. If it is not possible to create an instance, CLIPS responds with a FALSE. Also, like the (rules) and (facts) commands, CLIPS has an instances function to print out the instances of a class. The initial- object object listed is similar to the initial-fact fact. It was provided in previous versions of CLIPS to initially activate some types of rules, but it now only provided for backwards compatibility for programs which directly reference it.</p>
          <p>For the case of (make-instance), the brackets around the instance name is optional for a USER-defined class.</p>
          <p>There are two important rules about instances to keep in mind.</p>
          <ul>
            <li>Only one instance of the same name may be used in a module.</li>
            <li>A class cannot be redefined if instances of the class exist.</li>
          </ul>
        </section>
        <section><title>Wiping Out and Recreating Instances</title><p>If a (reset) command is issued, all the instances in memory are deleted and an instance [initial- instance] is created, analogous to the fact, initial-fact.</p>

                  Just as (deffacts) defines facts, there is also a definstances to define instances when a (reset) is
                  issued. The following (definstances) also illustrates the optional comment in double quotes after
                  the instance name, DORKY_OBJECTS.
            <pre>CLIPS&gt; (reset)
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
For a total of 1 instance.
CLIPS&gt;</pre>
            <p>Just as (deffacts) defines facts, there is also a <code class="command">definstances</code> to define instances when a (reset) is issued. The following (definstances) also illustrates the optional comment in double quotes after the instance name, DORKY_OBJECTS.</p>
            <pre>CLIPS&gt;
(definstances DORKY_OBJECTS "The Dorky Cousins"
  (Dorky of DUCK)
  (Dorky_Duck of DUCK))
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
For a total of 1 instance.
CLIPS&gt; (reset)
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky] of DUCK
[Dorky_Duck] of DUCK
For a total of 3 instances.
CLIPS&gt;</pre>
            <p>Although a (reset) will delete all instances except [initial-instance], it will also make new instances from (definstances). If you want to permanently delete an instance, the function <function>unmake-instance</function> will delete one or all instances, depending on its argument. To delete all instances, use the <q>*</q>.</p>
            <p>The following examples illustrate the (unmake-instance) command.</p>
            <pre>; Delete all instances
CLIPS&gt; (unmake-instance *)
TRUE
; Check that all are gone
CLIPS&gt; (instances)
; Create new instances again
CLIPS&gt; (reset)
; Check new instances created
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky] of DUCK
[Dorky_Duck] of DUCK
For a total of 3 instances.
; Delete a specific instance
CLIPS&gt; (unmake-instance [Dorky])
TRUE
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky_Duck] of DUCK
For a total of 2 instances.
CLIPS&gt;</pre>
            <p>Another way to delete a specific instance is to send a delete message. The general syntax of the (send) function is as follows.</p>
            <pre>(send &lt;instance-name&gt; &lt;message&gt;)</pre>
            <important>Only one instance name can be specified in a command and it must be surrounded by brackets if it is a user-defined name.</important>
            <p>For example, the following will make Dorky_Duck disappear.</p>
            <pre>; Create new instances again
CLIPS&gt; (reset)
; Check new instances created
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky] of DUCK
[Dorky_Duck] of DUCK
For a total of 3 instances.
CLIPS&gt; (send [Dorky_Duck] delete)
TRUE
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky] of DUCK
For a total of 2 instances.
CLIPS&gt;</pre>
            <p>The <q>*</q> in a (send) will not work to delete all instances. The <q>*</q> only works with the (unmake) function. Another alternative is to define your own handler for delete that will accept the <q>*</q> and thus allow you to (send &lt;instance-name&gt; my_delete *) messages.</p>
            <p>A (send) message is acted upon only by a <dfn>target object</dfn> which has an appropriate handler. CLIPS automatically provides handlers for print, init, delete and so on for each user-defined class. It's important to realize that the message (send [Dorky_Duck] delete) works only because this instance is a user-defined class. If you define classes which do not inherit from USER such as a subclass of INTEGER, you must also create appropriate handlers to carry out all desired tasks such as printing, creating, and deleting instances. It's much easier to define subclasses of USER and take advantage of system-supplied handlers.</p>
          </section>
        <section>
          <title>Sending Messages. Setters and Getters</title>
          <p>The (send) function is the heart of OOP operation since it is the only proper way for objects to communicate. According to the principle of object encapsulation, one object should only be allowed to access another object's data by sending a message.</p>
          <p>For example, if someone wants to know what you had for breakfast, they'll generally ask you, i.e., send a message. An impolite alternative would be to yank open your mouth and peer down your throat. If the principle of object encapsulation is not followed, any object can fool around with the private parts of other objects, with potentially disastrous results.</p>
          <p>One useful application of (send) is to print information about an object. So far all the examples of objects that you have seen have no structure. However, just as <function>deftemplate</function> gives structure to a rule pattern, the slots give an object structure. For both deftemplate and objects, a slot is a named location in which data can be stored. However, unlike deftemplate slots, objects obtain their slots from classes, and classes use inheritance. Thus, the information in object slots can be effectively inherited by objects of subclasses. An unbound slot is one that has no values assigned. All slots must be bound.</p>
          <p>As a simple example, let's make an object with slots to hold personal information and then send messages to it. The following commands will first set up the CLIPS environment with the appropriate constructs. The slots named sound and age initially contain no data, i.e., nil values.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (slot sound)
  (slot age))
CLIPS&gt;
(definstances DORK_OBJECTS
  (Dorky_Duck of DUCK))
CLIPS&gt; (reset)
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound nil)
(age nil)
CLIPS&gt; (send [Dorky_Duck] put-sound quack)
quack
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack)
(age nil)
CLIPS&gt;</pre>
          <p>Notice that the slots are printed in the order defined in the class. However, if the instance inherits slots from more than one class, the slots from the more general classes will be printed first.</p>
          <p>The value of a slot is changed using the put- message. By default, CLIPS creates a put- handler for each slot of a class to handle put- messages. Notice the dash, <q>-</q>, at the end of <q>put-</q>. The dash is an essential part of the message syntax since it separates the <q>put</q> from the slot name. Only one <q>put-</q> is allowed in a (send). Thus, to change multiple slots or the same slot of many instances, you must send multiple messages. Instead of doing this manually, it's possible to write a function to do multiple sends, or use the <function>modify-instance</function> function.</p>
          <p>The value of a slot can be set by a slot-override in a make-instance. As an example,</p>
          <pre>CLIPS&gt;
(make-instance Dixie_Duck of DUCK
  (sound quack) (age 2))
[Dixie_Duck]
CLIPS&gt; (send [Dixie_Duck] print)
[Dixie_Duck] of DUCK
(sound quack)
(age 2)
CLIPS&gt;</pre>
          <p>The complementary message to <q>put-</q> is get- which gets the data from a slot, as shown in the following example. If a put- is successful it returns the new value, while if get- is successful it returns the appropriate data. If the put- or get- does not succeed, an error message will be returned. The following examples show how this works.</p>
          <pre>; No slot color
CLIPS&gt; (send [Dorky_Duck] put-color white)
[MSGFUN1] No applicable primary message-handlers found for
put-color.
FALSE
CLIPS&gt; (send [Dorky_Duck] get-age)
nil
; Value put in age
CLIPS&gt; (send [Dorky_Duck] put-age 1)
1
; Check value is correct
CLIPS&gt; (send [Dorky_Duck] get-age)
1
CLIPS&gt;</pre>
          <p>In contrast to the put- message, the get- message returns the value of a slot. Since the value of get- is returned, it can be used by another function, assigned to a variable, and so forth. In contrast, a value that is printed out cannot be used by another function, assigned to a variable, and so forth because the value goes to the standard output device. One way of getting around this problem is to print out to a file and then read in the data from the file. While this is not an elegant solution, it does work. Another way is to write your own print message-handler that also returns values.</p>
          <p>A very important point about slots is that you cannot modify the slots of a class by adding slots, deleting slots, or changing the characteristics of slots. The only way to change a class is to (1) delete all instances of the class, and (2) use a (defclass) with the same class name and the desired slots. This situation is analogous to modifying a rule by loading in a new rule with the same name.</p>
        </section>
        <section>
          <title>Other Useful Predicate Functions for Slots</title>
          <p>There are a number of useful predicate functions for slots. If you use these predicate functions to test for appropriate values to functions, your program will be more robust against crashes. In general, if a function does not return TRUE, it returns FALSE. Slot functions provided by CLIPS include:</p>
          <ul>
            <li><function>class-slot-exists</function>: Returns TRUE if the class slot exists.</li>
            <li><function>slot-existp</function>: Returns TRUE if the instance slot exists.</li>
            <li><function>slot-boundp</function>: Returns TRUE if the specified slot has a value.</li>
            <li><function>instance-address</function>: Returns the machine address at which the specified instance is stored.</li>
            <li><function>instance-name</function>: Returns the name given an instance.</li>
            <li><function>instancep</function>: Returns TRUE if its argument is an instance.</li>
            <li><function>instance-addressp</function>: Returns TRUE if its argument is an instance address.</li>
            <li><function>instance-namep</function>: Returns TRUE if its argument is an instance name.</li>
            <li><function>instance-existp</function>: Returns TRUE if the instance exists.</li>
            <li><function>list-definstances</function>: Lists all the definstances.</li>
            <li><function>ppdefinstances</function>: Pretty-prints the definstance.</li>
            <li><function>watch instances</function>: Allows you to watch instances being created and deleted.</li>
            <li><function>unwatch instances</function>: Turns off watching instances.</li>
            <li><function>save-instances</function>: Saves instances to a file.</li>
            <li><function>load-instances</function>: Loads instances from a file.</li>
            <li><function>undefinstances</function>: Deletes the named definstance.</li>
          </ul>
        </section>
      </section>
      <!-- end of "Meaningful Messages" -->
      <section>
        <h2>Facets</h2>
        <p>In this section you'll learn more about slots and how to specify their characteristics by using <dfn>facets</dfn>. Just as slots describe instances, facets describe slots. The use of facets is good software engineering because there is a greater chance of CLIPS flagging an illegal value rather than risking a runtime error or crash. There are many types of facets that may be used to specify slots, as summarized in the following list:</p>
        <ul>
          <li><dfn>default</dfn> and <dfn>default-dynamic</dfn>: Set initial values for slots.</li>
          <li><dfn>cardinality</dfn>: Number of multifield values.</li>
          <li><dfn>access</dfn>: Read-write, read-only, initialize-only access.</li>
          <li><dfn>storage</dfn>: Local slot in instance or shared slot in class.</li>
          <li><dfn>propagation</dfn>: Inherit or no inherit slots.</li>
          <li><dfn>source</dfn>: Composite or exclusive inheritance.</li>
          <li><dfn>override-message</dfn>: Indicates message to send for slot override.</li>
          <li><dfn>create-accessor</dfn>: Create put- and get- handler.</li>
          <li><dfn>visibility</dfn>: Public or private to defining class only.</li>
          <li><dfn>reactive</dfn>: Changes to a slot trigger pattern-matching.</li>
        </ul>
        <p>For reasons of space, we'll only describe a few facets in more detail in the rest of this section.</p>
        <section>
          <title>The <kbd>default</kbd> Facet</title>
          <p>The default facet sets the default value of a slot when an instance is created or initialized, as shown in the following example.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (slot sound (default quack))
  (slot ID)
  (slot sex (default male)))
CLIPS&gt; (make-instance Dorky_Duck of DUCK)
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack)
(ID nil)
(sex male)
CLIPS&gt;</pre>
          <p>As you can see, the default values for slot sex and slot sound were set by the default facet values. Following the default keyword can be any valid CLIPS expression that does not involve a <em>variable</em>. For example, the default expression of the sound slot is the symbol quack. Functions may be used in the <dfn>facet expression</dfn> as will be shown in the next example.</p>
          <p>This default facet is a static default because the value of its facet expression is determined when the class is defined and never changed unless the class is redefined. For example, let's set the default value of slot <var>ID</var> to the (gensym*) function which returns a new value not in the system every time it's called.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (slot sound (default quack))
  (slot ID (default (gensym*)))
  (slot sex (default male)))
CLIPS&gt; ; Dorky_Duck #1
(make-instance [Dorky_Duck] of DUCK)
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack)
(ID gen1)
(sex male)
CLIPS&gt; ; Dorky_Duck #2
(make-instance [Dorky_Duck] of DUCK)
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack)
(ID gen1)
(sex male)
CLIPS&gt;</pre>
          <p>As you can see, the ID is always gen1 since (gensym*) is only evaluated once, and not again when the second instance is created. Note that the (gensym*) values may be different on your computer if you have already called (gensym*) since it increments by one each time it is called, and is not reset by a (clear). The (gensym*) function is reset to its starting value only if you restart CLIPS.</p>
          <p>Now suppose that we want to keep track of the different Dorky_Duck instances that have been created. Rather than using the static default, we can use the facet called <dfn>default dynamic</dfn>, which will evaluate its facet expression every time a new instance is created. Notice the difference between the following example and the previous.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (slot sound (default quack))
  (slot ID (default-dynamic (gensym*)))
  (slot sex (default male)))
CLIPS&gt; ; Dorky_Duck #1
(make-instance [Dorky_Duck] of DUCK)
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack)
(ID gen2)
(sex male)
CLIPS&gt; ; Dorky_Duck #2
(make-instance [Dorky_Duck] of DUCK)
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack)
(ID gen3) ; Note ID is different
(sex male) ; from Dorky_Duck #1
CLIPS&gt;</pre>
        </section>
        <section>
          <title>The <kbd>cardinality</kbd> Facet</title>
          <p>The <dfn>cardinality</dfn> of a slot refers to one of two types of fields that a slot can hold: (1) single-field, or (2) multifield. The term cardinality refers to a count. A bound single-field slot contains only one field, while a bound multifield slot may contain zero or more fields. The bound single-field slot and the bound multifield slot each contain one value. However, the one multifield value may have multiple fields in it. For example, (a b c) is a single multifield value with three fields. The empty string "" is a single-field value, just as "a b c" is. In contrast, an unbound slot has no value.</p>
          <p>As an analogy to single and multifield variables, think of a slot as your mailbox. Sometimes you may find a single piece of junk-mail that doesn't have an envelope. Instead, an address label has just been stuck on a folded piece of paper addressed to <q>Resident.</q> Other times you may find an envelope with multiple ads in it. The single piece of junk mail without an envelope is like a single-field value while the envelope with multiple ads is like the multifield value. If the junk-mail distributor slips up and mails you an envelope with nothing inside, this corresponds to the empty multifield variable. (Come to think of it, if the junk-mail envelope is empty, have you really received junk-mail?)</p>
          <p>A <dfn>multiple facet</dfn> with keyword <kbd>multislot</kbd>, is used to store a multifield value as shown in the following example</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (multislot sound (default quack quack)))
CLIPS&gt; (make-instance [Dorky_Duck] of DUCK)
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] print)
[Dorky_Duck] of DUCK
(sound quack quack)
CLIPS&gt;</pre>
          <p>A multifield value can be accessed using get- and put- as shown in the following examples, which shows how to keep track of quacks.</p>
          <pre>CLIPS&gt;
(send [Dorky_Duck] put-sound
                   quack1 quack2 quack3)
(quack1 quack2 quack3)
CLIPS&gt; (send [Dorky_Duck] get-sound)
(quack1 quack2 quack3)
CLIPS&gt;</pre>
          <p>Standard CLIPS functions such as <function>nth$</function> to get the nth field of a multislot value can be used. The following example shows how to pick a certain quack.</p>
          <pre>CLIPS&gt; (nth$ 1 (send [Dorky_Duck] get-sound))
quack1
CLIPS&gt; (nth$ 2 (send [Dorky_Duck] get-sound))
quack2
CLIPS&gt; (nth$ 3 (send [Dorky_Duck] get-sound))
quack3
CLIPS&gt;</pre>
          <note>A multifield slot with no values, e.g., the empty multifield value (), may be assigned to a slot with a (multiple) facet. Note that there is a difference between a slot with an empty multifield value () and an unbound slot. If you think of an empty multifield value as analogous to an empty bus, you can see there is a difference between no people (unbound slot) and a bus with no people (empty multifield value, () ).</note>
        </section>
        <section>
          <title>The <kbd>create-accessor</kbd> Facet</title>
          <p>A <kbd>create-accessor</kbd> facet tells CLIPS whether to create put- and get- handlers for a slot. By default, all slots have a read-write create-accessor so you don't actually have to specify this facet to create handlers. If you define your own handlers, then you need to use ?NONE with the create-accessor facet. The other facet types for create accessor are read and write.</p>
        </section>
        <section>
          <title>The <kbd>storage</kbd>, <kbd>local</kbd> and <kbd>shared</kbd> Facets</title>
          <p>A storage facet defines one of two places that a slot value is stored: (1) in an instance, or (2) in the class. A slot value stored in the instance is called local because the value is only known to the instance. Thus, different instances may exist that have different local slot values. In contrast, a slot value stored in a class is called shared because it is the same for all instances of the class.</p>
          <p>A local value is specified by the local facet, which is the default for a slot. A shared value is specified by the shared facet and all instances with this slot type will have their slot value automatically changed if one changes.</p>
        </section>
        <section>
          <title><kbd>access</kbd> Facet</title>
          <p>An access facet defines one of three types of access for a slot, whether you use the handlers created by CLIPS or else define your own. The default type, <literal>read-write</literal>, allows you to both read and write the value of the slot. The other types are <literal>read-only</literal> and <literal>initialize-only</literal>.</p>
          <p>Two predicate functions are designed for use with the access facets. Both these predicate functions return an error message if the specified slot or instance does not exist. The <function>slot-writablep</function> is a predicate function which returns TRUE if a slot is writable and FALSE if it is not. The <function>slot-initablep</function> predicate function returns TRUE if the slot is initializable and FALSE if it is not. The term <dfn>initializable</dfn> means that it is not read-only.</p>
        </section>
        <section>
          <title><kbd>inherit</kbd> Facet</title>
          <p>The inherit facet, which is the default, specifies that indirect instances of a class may inherit this slot from the class. As you recall, the indirect instances of a class are the instances of its subclasses, while the direct instances are those defined specifically for the class. The indirect instances of a class are direct instances of the subclasses in which they are defined. For example, [Dorky_Duck] is a direct instance of DUCK and an indirect instance of USER which is the superclass of DUCK. The no-inherit facet specifies that only a direct instance has the class slot.</p>
          <p>It's important to realize that the (no-inherit) facet only prohibits inheritance from the class and not from its superclasses. This means that an instance may still inherit from superclasses of the (no-inherit) class.</p>
        </section>
        <section>
          <title><kbd>composite</kbd> Facet</title>
          <p>The composite facet states that facets which are not explicitly defined in the highest precedence class take their facets from the next higher precedence class. If the facet is not explicitly set in the next higher precedence class and it is composite too, CLIPS tries the next higher and so on until the facet is defined or there are no more classes. If the next higher class is not composite, CLIPS does not check further. The opposite to the composite facet is the <literal>exclusive</literal> facet, which is the default.</p>
        </section>
        <section>
          <title>Initializing (Cold and Warm) and Resetting</title>
          <p>Another way to set the instance values is with the <function>initialize-instance</function> function. An (initialize-instance) can be called at any time to reset the default values and retain values in non- (default) slots.</p>
          <p>A (reset) can be thought of as a <dfn>cold-initialization</dfn> since all values in non-(default) slots are cleared, while a (initialize-instance) can be considered a <dfn>warm-initialization</dfn> since non-(default) values are retained. Of course, only (definstances) can be cold-initialized since non-(definstances) will simply be deleted. Also, slot-overrides may be used in (initialize-instance) as the last example shows.</p>
        </section>
        <section>
          <title>Other Functions on Facets</title>
          <p>CLIPS has several multifield slot functions as shown in the following list.</p>
          <ul>
            <li><function>slot-replace$</function>: Replace the specified range.</li>
            <li><function>slot-insert$</function>: Insert the specified range.</li>
            <li><function>slot-delete$</function>: Delete the specified range.</li>
          </ul>
        </section>
      </section>
      <!-- end of "Facets" -->
      <section>
        <h2>Handlers in CLIPS</h2>
        <!--page 121-->
        <div class="abstract">
          <p>Handlers are essential in OOP because they support object encapsulation. The only proper way that objects can respond to messages is by having an appropriate handler to receive the message and take appropriate action. In this chapter you'll learn the how messages are interpreted by objects. You'll see how to modify existing message-handlers, and how to write your own.</p>
        </div>
        <section>
          <title>Writing a Handler</title>
          <p/>
          <p>In addition to the predefined handlers such as print, you may define your own handlers. Let's start by writing a handler to add numbers through messages.</p>
          <p>The class NUMBER has subclasses INTEGER and FLOAT. Since these are predefined classes, it would seen natural to do numeric calculations by sending messages to numbers. Let's try it as follows.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt; (send 1 + 2)
[MSGFUN1] No applicable primary message-handlers found for +.
FALSE
CLIPS&gt;</pre>
          <p>Well, as you can see, this example didn't work. The reason why is implied in the error message. Let's check it out by obtaining more information about the INTEGER class since that was the target object of the print message.</p>
          <pre>CLIPS&gt; (describe-class INTEGER)</pre>
          <p>The problem is that the INTEGER class has no handler for <q>+</q>. In fact, it has no handlers at all since none are listed. As you recall, the USER class and its subclasses always have print, delete, and other handlers automatically defined by CLIPS. If we want to send print messages to an object like 1 of the INTEGER class, we'll have to write our own print handler.</p>
          <p>Before writing this handler, let's answer a question that you may have concerning how INTEGER can have instances. Since INTEGER is an abstract class, you may wonder how it can have instances such as 1, 2, 3, etc. Although you cannot make direct instances of an abstract class, you can make use of existing instances. For the case of the predefined system class INTEGER, all the integers up to the maximum allowed are available as objects. Likewise, strings and symbols are available for the system defined abstract classes STRING and SYMBOL, and so forth for the other predefined classes.</p>
          <p>Shown following is the definition of a handler for the NUMBER class that will handle addition by messages. The handler is defined for NUMBER rather than INTEGER because we would also like to handle FLOAT objects too. Instead of defining the same handler for FLOAT and for INTEGER, it's easier to just define a handler for the superclass NUMBER. If a handler for a message is not defined in the class of the object, CLIPS tries all the handlers in the inheritance precedence list. Since <q>+</q> is not defined for INTEGER, CLIPS tries NUMBER next, finds the applicable handler, and returns the result of 3.</p>
          <pre>CLIPS&gt;
; ?arg is argument of handler
(defmessage-handler NUMBER + (?arg)
  ; Function addition of handler
  (+ ?self ?arg))
CLIPS&gt; (send 1 + 2)
3
CLIPS&gt; (send 2.5 + 3)
5.5
CLIPS&gt; (send 2.5 + 2.6)
5.1
CLIPS&gt; (describe-class NUMBER)
===========================================================
***********************************************************
Abstract: direct instances of this class cannot be created.
Direct Superclasses: PRIMITIVE
Inheritance Precedence: NUMBER PRIMITIVE OBJECT
Direct Subclasses: INTEGER FLOAT
-----------------------------------------------------------
Recognized message-handlers:
+ primary in class NUMBER
***********************************************************
===========================================================
CLIPS&gt;</pre>
          <p>The variable <var>?self</var> is a special variable in which CLIPS stores the <dfn>active instance</dfn>. The <var>?self</var> is a reserved word that cannot be explicitly included in a handler argument, nor can it be bound to a different value. The active instance is the instance to which the message was sent. In our example, all the predefined classes such as NUMBER, INTEGER, and FLOAT are all subclasses of the PRIMITIVE class. This is in contrast to USER, which is the other main subclass of OBJECT.</p>
          <p>As another example, lets write a handler to concatenate strings, symbols or both.</p>
          <pre>CLIPS&gt;
; ?arg is argument of handler
(defmessage-handler LEXEME + (?arg)
  ; Function concatenation of handler
  (sym-cat ?self ?arg))
; SYMBOL + STRING
CLIPS&gt; (send Dorky_ + "Duck")
Dorky_Duck ; SYMBOL result
CLIPS&gt;</pre>
          <p>Notice that the handler is defined for the LEXEME class since that is a superclass of both SYMBOL and STRING. In this case, the handler returns a SYMBOL since (sym-cat) is used.</p>
          <p>This example also illustrates why brackets may be necessary in a (send). As shown in this example, the message goes to the SYMBOL Dorky_ without brackets. With brackets, the message goes to an object [Dorky_] of a user-defined class. Here we assume that [Dorky_] could be an object of a user-defined class, such as DUCK.</p>
        </section>
        <section>
          <title>Writing a Handler for a User-Defined Class</title>
          <p>The real utility of handlers is with subclasses of USER since you can define instances of these classes. To see how handlers work in this case, let's first set up the environment as follows.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCKLING (is-a USER)
  (slot sound (default quack))
  (slot age (visibility public)))
CLIPS&gt;
(defclass DUCK (is-a DUCKLING)
  (slot sound (default quack)))
CLIPS&gt;
(definstances DUCKY_OBJECTS
  (Dorky_Duck of DUCK (age 2))
  (Dinky_Duck of DUCKLING (age .1)))
CLIPS&gt; (reset)
CLIPS&gt;</pre>
          <p>As a simple example, let's write a handler that will print out the slots of the active instance. We can make use of the <function>ppinstance</function> function to print out the slots of the active instance. This function does not return a value and is used only for its side-effect of printing to the standard device. Also, it can only be used from within a handler since only there is the active instance known. Shown following is a USER-defined handler called <function>print-slots</function> that prints out the slots of the active instance using (ppinstance).</p>
          <pre>CLIPS&gt;
(defmessage-handler USER print-slots ()
  (ppinstance))
CLIPS&gt; (send [Dorky_Duck] print-slots)
[Dorky_Duck] of DUCK
(age 2)
120(sound quack)
CLIPS&gt;</pre>
          <p>Although the handler could be defined just for DUCK in this case, a handler defined for USER will be called for all subclasses of USER, not just DUCKLING and DUCK. Thus, the handler print-slots will work for all subclasses that we may define of USER.</p>
          <p>Of course it's possible to get carried away and define all your message handlers as USER handlers. However, it's good style and improves efficiency to define handlers as close as possible to the class or classes for which they are intended. Efficiency is improved because CLIPS does not have to keep searching through a lot of classes to find the applicable handler.</p>
        </section>
        <section>
          <title>More on Writing Handlers (<dfn>handler type</dfn>)</title>
          <p>Let's examine message-handlers in more detail now. We'll define a handler to print out a header when an object receives a message to print itself. The message-handler is defined using a <function>defmessage-handler</function> construct as follows.</p>
          <pre>CLIPS&gt;
(defmessage-handler USER print before ()
  (printout t "*** Starting to print ***" crlf))
CLIPS&gt; (send [Dorky_Duck] print)
*** Starting to print ***
[Dorky_Duck] of DUCK
(age 2)
(sound quack)
CLIPS&gt;</pre>
          <p>The reason that a header is printed rather than a trailer at the end has to do with the <dfn>handler type</dfn>. A before type handler is used before the print message. To make a trailer, use the after type handler as shown in the following example.</p>
          <pre>CLIPS&gt;
(defmessage-handler USER print after ()
  (printout t "*** Finished printing ***" crlf))
CLIPS&gt; (send [Dorky_Duck] print)
*** Starting to print ***
[Dorky_Duck] of DUCK
(age 2)
(sound quack)
*** Finished printing ***
CLIPS&gt;</pre>
          <p>The general format of a message-handler is as follows.</p>
          <pre>(defmessage-handler &lt;class-name&gt;
  &lt;message-name&gt; [handler-type]
  [comment]
  (&lt;parameters&gt;* [wildcard-parameter])
  &lt;action&gt;*)</pre>
          <p>While there may be multiple actions in a handler, only the value of the last action is returned. Notice that this is just like a (deffunction).</p>
          <p>Since [Dorky_Duck] is of class DUCK, a subclass of USER, we can take advantage of the print handler that is predefined by CLIPS for the USER class. All subclasses of USER can take advantage of the handlers of USER, which saves you the trouble of writing handlers for every class that you define. Notice how the concept of inheritance from USER to its subclass DUCK simplifies program development by allowing reuse of existing code, i.e., the print handler of USER.</p>
          <p>The empty parentheses () that follow the before handler type mean that there are neither parameters nor a wildcard parameter. In other words, the header handler takes no arguments and so the parentheses are empty, but required. Note that while multiple parameters may be used, there can be only one wildcard.</p>
        </section>
        <section>
          <title>Handler Types and Roles</title>
          <p>As you can see, the trailer handler is the same as the header handler except that an after handler type is used, and the action text is different. Thus, a before handler type does its task before the <dfn>primary</dfn> type handler, and an after handler does its task after the primary handler. A primary is intended to do the major task. An around handler type is intended to set up the environment for the rest of the handlers. The before and after types are intended for minor tasks such as initializing variables or printing, while the primary does the major task.</p>
          <p>The following list summarizes the class role and return value of each handler type:</p>
          <ul>
            <li>around: Set up environment for other handlers. Returns a value.</li>
            <li>before: Auxillary work before primary. No return value.</li>
            <li>primary: Perform major task of message. Returns a value.</li>
            <li>after: Auxillary work after primary. No return value.</li>
          </ul>
          <p>The handler types are listed in the order that they are normally called during execution of a message. Depending on the handler type, CLIPS knows when to execute it. That is, an around handler starts before any before handlers. A before handler is executed before any primary handlers, which are followed by the after handlers. The exception to this sequential handler execution is the around type handler. If an around handler is defined, it will start execution before any of the others, perform specified actions, and then complete its actions after all the other handler types have finished. You'll see a detailed example of these handlers execution soon.</p>
          <p>The <dfn>class role</dfn> describes the intended purpose of each type. The return value describes whether the handler type is generally intended for a return value or simply to provide a useful side-effect such as printing. This consideration will depend on the handler. For example, many user-defined primary handlers may be written to return a value as the result of some numeric calculation or string operation. An exception to returning a useful return value is a print primary handler whose main task is the side-effect of printing, and does not have a return value.</p>
          <p>The list of predefined primary handlers of USER and their class role is shown following. By inheritance, these are available for all subclasses of USER.</p>
          <ul>
            <li>init: Initializes an instance.</li>
            <li>delete: Deletes an instance.</li>
            <li>print: Prints an instance.</li>
            <li>direct-modify: Directly modifies slots.</li>
            <li>message-modify: Modifies slots using put- messages.</li>
            <li>direct-duplicate: Duplicates an instance without using put- messages.</li>
            <li>message-duplicate: Duplicates an instance using messages.</li>
          </ul>
          <p>These primary handlers are predefined and cannot be modified unless you change the source code of CLIPS. However, you may define the before, after and around handler types for these primaries. You've already seen an example of changing the before and after handler types for the USER print handler. Now let's look at some examples of defining the before and after handler types for the init primary handler.</p>
          <pre>CLIPS&gt;
(defmessage-handler USER init before ()
  (printout t "*** Starting to make instance ***" crlf))
CLIPS&gt;
(defmessage-handler USER init after ()
  (printout t "*** Finished making instance ***" crlf))
CLIPS&gt; (reset)
*** Starting to make instance ***
*** Finished making instance ***
*** Starting to make instance ***
*** Finished making instance ***
*** Starting to make instance ***
*** Finished making instance ***
CLIPS&gt; (make-instance Dixie_Duck of DUCK (age 1))
*** Starting to make instance ***
*** Finished making instance ***
[Dixie_Duck]
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Dorky_Duck] of DUCK
[Dinky_Duck] of DUCKLING
[Dixie_Duck] of DUCK
For a total of 4 instances.
CLIPS&gt;</pre>
        </section>
        <section>
          <title><var>?self</var>*</title>
          <p>The self parameter is useful because it can be used to read a slot value in the form</p>
          <pre>?self:&lt;slot-name&gt;</pre>
          <p>It can also be used to write a slot value using the <function>bind</function> function. The <kbd>?self:</kbd> notation is more efficient than sending messages but can only be used from within a handler on its active instance.</p>
          <p>In contrast, the <function>dynamic-get-</function> and <function>dynamic-put-</function> functions can be used from within a handler to read and write a slot value of the active instance. Although you can use messages from inside a handler, such as the following, it's not efficient.</p>
          <pre>(send ?self dynamic-get-&lt;slot&gt;)
(send ?self dynamic-put-&lt;slot&gt;)</pre>
          <p>As an example of dynamic-get-, let's change our example as follows.</p>
          <pre>CLIPS&gt;
(defmessage-handler USER print-age primary ()
  (printout t "*** Starting to print ***" crlf
   "Age = " (dynamic-get age) crlf
   "*** Finished printing ***" crlf))
CLIPS&gt; (send [Dorky_Duck] print-age)
*** Starting to print ***
Age = 2
*** Finished printing ***
CLIPS&gt;</pre>
          <p>The ?self:age can only be used in a class and its subclasses which inherit the slot age. The ? self:&lt;slot-name&gt; is evaluated in a static way through inheritance. This means that if a subclass redefines a slot, a superclass message-handler will fail if it tries to directly access the slot using ? self:&lt;slot-name&gt;.</p>
          <p>In contrast, the dynamic-get- and dynamic-put- can be used by superclasses and subclasses because these check slots dynamically. In order for a superclass to dynamically reference a slot, however, the visibility facet of the slot must be public. The following example would not work if DUCK is changed to USER.</p>
          <pre>CLIPS&gt;
(defmessage-handler DUCK print-age primary ()
  (printout t "*** Starting to print ***" crlf
  "Age = " ?self:age crlf
  "*** Finished printing ***" crlf))
CLIPS&gt; (send [Dorky_Duck] print-age)
*** Starting to print ***
Age = 2
*** Finished printing ***
CLIPS&gt;</pre>
          <p>As an example of using a dynamic-put- function in a handler, suppose we want to help Dorky_Duck regain some of his youth. The following example shows how his age can be changed using a handler. This example also illustrates how a value can be passed to a handler through the ?change variable.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (slot sound (default quack))
  (slot age))
CLIPS&gt;
(defmessage-handler DUCK lie-about-age
  (?change)
  (bind ?new-age (- ?self:age ?change))
  (dynamic-put age ?new-age)
  (printout t "*** Starting to print ***" crlf
  "I am only " ?new-age crlf
  "*** Finished printing ***" crlf))
CLIPS&gt;
(make-instance [Dorky_Duck] of DUCK (age 3))
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] lie-about-age 2)
*** Starting to print ***
I am only 1
*** Finished printing ***
CLIPS&gt;</pre>
          <p>Notice how the handler uses the variable ?new-age to store the changed age, which is then put into the age slot of the instance.</p>
        </section>
        <section>
          <title>Daemons*</title>
          <p>A <dfn>daemon</dfn> is a handler which executes whenever some <dfn>basic action</dfn> like initialization, deletion, get, or put is performed on an instance. A rule cannot be considered a daemon because it's not certain that it will be executed just because its LHS patterns are satisfied. The only thing that is certain is that a rule will become activated when its LHS is satisfied &#x2014; not that it will execute.</p>
          <p>There is no explicit keyword for daemon since it's just a concept. The before and after handlers that printed strings can be considered print daemons. These handlers waited for a <kbd>(send [Dorky_Duck] print-age)</kbd> message to trigger their action. First the before handler printed its string, then the primary handler printed, and finally the after handler printed. One daemon is the before handler which waits for a print message. The second daemon is the after handler that waits for the print primary to finish printing.</p>
          <p>Printing is not considered a basic action because there is no return value associated with a <kbd>(send &lt;instance&gt; print)</kbd>. The print message is only sent for the side-effect of printing. In contrast, a (send &lt;instance&gt; get-&lt;slot&gt;) message will return a value that may be used by other code. Likewise, the initialization, deletion, and put all have an effect on an instance and so are considered basic actions like get.</p>
          <p>Daemons are easily implemented using before and after handlers since these will be executed before and after their primary handler. Implementing daemons like this is called <dfn>declarative implementation</dfn> because no explicit actions on the part of the handler is necessary for it to be executed. That is, CLIPS will always execute a before handler before its primary and will always execute an after handler after its primary. In a declarative daemon implementation, the normal operation of CLIPS will cause the daemons to be activated when their time has come. Thus, the declarative implementation is implicit in the normal operation.</p>
          <p>The opposite of implicit execution is the <dfn>imperative implementation</dfn> in which the actions are explicitly programmed. The around handler is very convenient to use for imperative daemons. The basic idea of the around handler is as follows.</p>
          <ul>
            <li>1. Start before any other handlers.</li>
            <li>2. Call the next handler using either <function>call-next-handler</function> to pass the same arguments or <function>override-next-handler</function> to pass different ones.</li>
            <li>3. Continue execution when the last handler finishes.</li>
            <li>4. After any other around, before, primary, or after handlers finish, the around handler resumes execution.</li>
          </ul>
          <p>The keyword <function>call-next-handler</function> is used to call the next handler(s). A handler is said to be shadowed by a <dfn>shadower</dfn> if it must be called from the shadower by a function such as call-next-handler. The call-next-handler may be used multiple times to call the same handler(s).</p>
          <p>A predicate function called <function>next-handlerp</function> is used to test for the existence of a handler before the call is made. If no handler exists, then <function>next-handlerp</function> will return FALSE.</p>
          <p>The following example illustrates the around handler through a truthful daemon that tells on Dorky_Duck whenever he lies about his age.</p>
          <pre>CLIPS&gt;
(defmessage-handler DUCK lie-about-age around
  (?change)
  (bind ?old-age ?self:age)
  (if (next-handlerp) then
    (call-next-handler))
  (bind ?new-age ?self:age)
  (if (&lt;&gt; ?old-age ?new-age) then
    (printout t "Dorky_Duck is lying!" crlf
                "Dorky_Duck is lying!" crlf
                "He's really " ?old-age crlf)))
CLIPS&gt;
(make-instance [Dorky_Duck] of DUCK (age 3))
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] lie-about-age 1)
*** Starting to print ***
I am only 2
*** Finished printing ***
Dorky_Duck is lying!
Dorky_Duck is lying!
He's really 3
CLIPS&gt;</pre>
          <p>Although Dorky_Duck may still lie about his age, the daemon tells the truth. Notice the ?change argument. Although the around handler does not use ?change, the lie-about-age primary that is called by the call-next-handler does need it to change the age. Thus, ?change must be passed to the primary by the around handler. An error message will occur if you leave out the ?change.</p>
          <p>The call-next-handler always passes the arguments of the shadower to the shadowed handler. It's possible to pass different arguments to a shadowed handler by use of the <function>override-next-handler</function> function as shown i n the following example.</p>
          <pre>CLIPS&gt;
(defmessage-handler DUCK lie-about-age around
  (?change)
  (bind ?old-age ?self:age)
  (if (next-handlerp) then
    ; Divide age in half!
    (override-next-handler (/ ?change 2)))
  (bind ?new-age ?self:age)
  (if (&lt;&gt; ?old-age ?new-age) then
    (printout t "Dorky_Duck is lying!" crlf
                "Dorky_Duck is lying!" crlf
                "He's really " ?old-age crlf)))
CLIPS&gt;
(make-instance [Dorky_Duck] of DUCK (age 3))
[Dorky_Duck]
CLIPS&gt; (send [Dorky_Duck] lie-about-age 1)
*** Starting to print ***
I am only 2.5
*** Finished printing ***
Dorky_Duck is lying!
Dorky_Duck is lying!
He's really 3
CLIPS&gt;</pre>
          <important>It's important to keep in mind that the return value of call-next-handler and override-next-handler is that of the shadowed handlers.</important>
          <p>Shown following are the <cite>Rules of Message Dispatch</cite>:</p>
          <ul>
            <li>1. All the around handlers start execution. Then the before, primary, and after handlers start and finish, followed by completion of the around's execution.</li>
            <li>2. The around, before, and primary handlers are called in order of highest precedence class to lowest.</li>
            <li>3. The after handlers are called from lower precedence class to highest.</li>
            <li>4. Each around handler must explicitly call the next shadowed handler.</li>
            <li>5. Higher precedence primaries must explicitly call lower precedence (shadowed) primaries if they are to execute.</li>
          </ul>
          <p>However, note the following prerequisite to any message handling:</p>
          <blockquote>There must be at least one applicable primary handler.</blockquote>
          <p>Since only around and primary handlers can return values, and the around shadows primaries, it follows that the return value of a (send) will be the around return value. If there is no around, then the return value will be that of the highest precedence primary.</p>
          <p>The following list summarizes the return value of the handler types.</p>
          <ul>
            <li><em>around</em>: Ignore or capture return value of next most specific around or primary.</li>
            <li><em>before</em>: Ignore. Side-effect only.</li>
            <li><em>primary</em>: Ignore or capture return value of most general primary scope.</li>
            <li><em>after</em>: Ignore. Side-effect only.</li>
          </ul>
        </section>
        <section>
          <title>Defining Points</title>
          <p>Up to now, we've discussed inheritance using only is-a links. As you've seen, this type of inheritance relationship is good for defining classes that are more and more specialized. That is, you start off by defining the most general classes as a subclass of USER, and then define more specialized classes with more slots in the lower levels of the class hierarchy.</p>
          <p>Normally, you design new classes as specializations of existing ones. This paradigm is <dfn>Inheritance by Specialization</dfn>.</p>
          <p>Inheritance can also be used to build up more complex classes. However, this is not quite as direct in CLIPS. As an example, the basic class for geometry is a POINT containing a single slot point1. A LINE can be then defined by adding point2 to POINT. A TRIANGLE is defined by adding point3 to LINE, and so on for QUADRILATERALS, PENTAGONS, etc.</p>
          <pre>(defclass POINT (is-a USER)
  (multislot point1))
(defclass LINE (is-a POINT)
  (multislot point2))
(defclass TRIANGLE (is-a LINE)
  (multislot point3))</pre>
          <p>Notice how each class is a specialization of its parent class by inheriting the superclass points and then adding one new point.</p>
          <p>The opposite paradigm is <dfn>Inheritance by Generalization</dfn> in which more general classes are built up from simple ones. For example, a LINE is considered made up of two points. A TRIANGLE is made up of three lines. A QUADRILATERAL is made up of four lines, and so forth. This would be a good paradigm for building an object-oriented drawing system in which new objects could be built up out of simpler ones.</p>
          <p>Notice how each class is a specialization of its parent class by inheriting the superclass points and then adding one new point.</p>
          <p>The opposite paradigm is <dfn>Inheritance by Generalization</dfn> in which more general classes are built up from simple ones. For example, a LINE is considered made up of two points. A TRIANGLE is made up of three lines. A QUADRILATERAL is made up of four lines, and so forth. This would be a good paradigm for building an object-oriented drawing system in which new objects could be built up out of simpler ones.</p>
          <p>There is a subtle but important difference between this example of specialization, and generalization. In specialization, new classes are built up by adding specialized slots which are the same type as superclass slots. Thus, POINT, LINE, and TRIANGLE all have point-type slots. In contrast, generalization builds up using new types of slots defined for each class. Class POINT has a point-type slot. LINE has two point-type slots. TRIANGLE has three line-type slots. QUADRILATERAL has four line-type slots, and so on. Generalization is good for synthesis, which means a building up. The opposite of synthesis is analysis, which means taking apart or a simplification. The model for analysis is specialization.</p>
          <p>Links such as <kbd>is-made-of</kbd> can be simulated in CLIPS by appropriate slot definitions even though only is-a links are supported in Version 6.3. As an example of generalization, let's build up a LINE class as a generalization of a POINT class. The POINT class will provide instances that have a position. In order to make this example realistic, we'll assume an arbitrary number of dimensions by defining the position as (multiple). Thus, a one-dimensional point will have one value in the position slot, a two-dimensional point will have two values, and so forth. The definition of the POINT class is very simple.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass POINT (is-a USER)
  (multislot position
            (propagation no-inherit)
  )
)
CLIPS&gt;</pre>
          <p>The (no-inherit) facet is used to prevent a LINE from inheriting a position slot. Instead, a LINE will be defined by two points called slot point1 and slot point2. These two slots will define the line and it is extraneous to have an additional position slot by inheritance.</p>
          <p>The definition of the LINE class is a little more complex. The reason for the added complexity is that the details of implementation are included in the (defclass) because Version 6.3 only supports is-a relationships.</p>
          <pre>(defclass LINE (is-a POINT)
  (slot point1
    (default-dynamic
      (make-instance (gensym*) of POINT))
    (propagation no-inherit))
  (slot point2
    (default-dynamic
      (make-instance (gensym*) of POINT))
  (propagation no-inherit))
(message-handler find-point)
(message-handler print-points)
(message-handler find-distance)
(message-handler print-distance))</pre>
          <p>Note that the message-handlers of LINE are <dfn>forward-declared</dfn> for documentation purposes.</p>
          <p>At this time you may be wondering why POINT and LINE are not both defined as subclasses of USER since all their slots have (no-inherit) facets. Since all the slots of POINT, LINE, and the TRIANGLE class to be defined later have (no-inherit) facets, all these classes could be defined as direct subclasses of USER rather than defining LINE as a subclass of POINT and TRIANGLE as a subclass of LINE.</p>
          <p>However, the whole point of this example is to illustrate Inheritance by Generalization, which is a logical concept that is not directly supported by Version 6.3. Thus, defining LINE as a subclass of POINT and TRIANGLE as a subclass of LINE is done for reasons of documenting the logical concept of Inheritance by Generalization. Admittedly, a comment could be added by the (defclass LINE (is-a USER)) and (defclass TRIANGLE (is-a USER)) stating that we are trying to implement Inheritance by Generalization, but seeing the code in place is better documentation. If Inheritance by Generalization is ever directly supported by CLIPS, these (defclass) statements will make it easy to convert.</p>
          <p>The reason for including the (make-instance (gensym*)) in the LINE slots is to provide the inheritance from the POINT class. With the standard Inheritance by Specialization, only one position slot of LINE is possible because POINT has only one position slot. It is not possible for both slot point1 and slot point2 of LINE to inherit the position slot of POINT. The actual slot value of each LINE will be a gensym* value. Each gensym* value will be the instance name of a point instance. The point position can then be accessed through the gensym* value. Thus, the gensym* values act as pointers to different instances.</p>
          <p>This indirect access technique of (gensym*) values is analogous to using a pointer to access a value in a procedural language. Thus, the different slots of LINE can indirectly inherit the same slots of POINT. It's convenient to use (gensym*) because we don't care what the pointer names of LINE are, any more than we care what the pointer addresses are in a procedural language.</p>
          <p>The following examples show how the points are accessed for one-dimensional points at position 0 and 1.</p>
          <pre>CLIPS&gt;
(definstances LINE_OBJECTS
  (Line1 of LINE))
CLIPS&gt; (reset)
CLIPS&gt;
(send (send [Line1] get-point1)
       put-position 0)
(0)
CLIPS&gt;
(send (send [Line1] get-point2)
       put-position 1)
(1)
CLIPS&gt; (send [Line1] print)
[Line1] of LINE
(point1 [gen1])
(point2 [gen2])
CLIPS&gt;
(send (send [Line1] get-point1)
       get-position)
(0)
CLIPS&gt;
(send (send [Line1] get-point2)
       get-position)
(1)
CLIPS&gt;</pre>
          <p>Now that you understand how the indirect access works, let's define some handlers to avoid the trouble of entering the nested (send) messages, as in the last two cases. Let's define a handler called <code class="command">find-point</code> to print out a specified point value, and a handler called <code class="command">print-points</code> to print out the values of both LINE points as follows. The argument of <code class="command">find-point</code> will be either a 1 for point1 or a 2 for point2.</p>
          <pre>CLIPS&gt;
(defmessage-handler LINE find-point (?point)
  (send (send ?self (sym-cat "get-point" ?point))
  get-position))
CLIPS&gt;
(defmessage-handler LINE print-points ()
  (printout t "point1 " (send ?self find-point 1) crlf
              "point2 " (send ?self find-point 2) crlf))
CLIPS&gt; (send [Line1] find-point 1)
(0)
CLIPS&gt; (send [Line1] find-point 2)
(1)
CLIPS&gt;</pre>
          <p>For real use, it would be best to provide error detection so that only a 1 or 2 is allowed.</p>
          <p>As you can see, the handler works fine for one-dimensional points. It can be tested for two-dimensional points as follows. We'll assume the first number for each point is the X-value, and the second number is the Y-value. That is, point1 has X-value 1 and Y-value 2.</p>
          <pre>CLIPS&gt;
(send (send [Line1] get-point1)
  put-position 1 2)
(1 2)
CLIPS&gt;
(send (send [Line1] get-point2)
  put-position 4 6)
(4 6)
CLIPS&gt; (send [Line1] print)
[Line1] of LINE
(point1 [gen1])
(point2 [gen2])
CLIPS&gt;
(send (send [Line1] get-point1) get-position)
(1 2)
CLIPS&gt;
(send (send [Line1] get-point2) get-position)
(4 6)
CLIPS&gt;</pre>
          <p>As expected, the handler also works correctly for two-dimensional points.</p>
          <p>Now that we have the two point positions, it's easy to find the distance between the points, which is the length of the line. The distance can be determined by defining a new handler called find-distance which uses the Pythagorean Theorem to calculate the distance as the square root of the sum of the squares. Since no assumptions were made as to the number of dimensions, the (nth) function is used to pick out each multifield value up to the maximum number of coordinates, as stored in the ?len variable.</p>
          <pre>CLIPS&gt;
(defmessage-handler LINE find-distance ()
  (bind ?sum 0)
  (bind ?index 1)
  (bind ?len (length (send ?self find-point 1)))
  (bind ?Point1 (send ?self find-point 1))
  (bind ?Point2 (send ?self find-point 2))
  (while (&lt;= ?index ?len)
    (bind ?dif (- (nth ?index ?Point1)
                  (nth ?index ?Point2)))
    (bind ?sum (+ ?sum (* ?dif ?dif)))
    (bind ?index (+ ?index 1)))
  (bind ?distance (sqrt ?sum)))
CLIPS&gt;
(defmessage-handler LINE print-distance ()
  (printout t "Distance = "
              (send ?self find-distance) crlf))
CLIPS&gt; (send [Line1] print-distance)
Distance = 5.0
CLIPS&gt;</pre>
          <p>The values 1, 2 for point1 and 4, 6 for point2 were chosen for an easy check of the handler since these coordinates define a 3&#x2013;4&#x2013;5 triangle. As you can see, the distance is 5.0, as expected.</p>
        </section>
        <section>
          <title>Defining Triangles</title>
          <p>Now that the POINT and LINE classes have been defined by generalized inheritance, why stop now? Let's continue with the next simplest class that can be defined from a line &#x2014; the triangle. Shown following are the three defclasses required.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass POINT (is-a USER)
  (multislot position (propagation no-inherit)))
CLIPS&gt;
(defclass LINE (is-a POINT)
  (slot point1 (default-dynamic
               (make-instance (gensym*) of POINT))
               (propagation no-inherit))
(slot point2 (default-dynamic
             (make-instance (gensym*) of POINT))
             (propagation no-inherit)))
CLIPS&gt;
(defclass TRIANGLE (is-a LINE)
  (slot line1 (default-dynamic
              (make-instance (gensym*) of LINE))
              (propagation no-inherit))
  (slot line2 (default-dynamic
              (make-instance (gensym*) of LINE))
              (propagation no-inherit))
  (slot line3 (default-dynamic
              (make-instance (gensym*) of LINE))
              (propagation no-inherit)))
CLIPS&gt;</pre>
          <p>Notice that the (no-inherit) facets in TRIANGLE are technically not necessary since there is no subclass of TRIANGLE defined. The reason for including the (no-inherit) facets is because of <dfn>defensive-programming</dfn>, which is analogous to defensive-driving. If another subclass is added, either by you or someone else, the (defclass) of TRIANGLE must be modified to include the (no-inherit) facets. This is bad style because it means that existing, debugged code must be modified. If you're going to enhance existing, debugged code, you shouldn't have to modify it. It's better to plan ahead for enhancements.</p>
          <p>Next we'll define a triangle instance and check the instances generated. Note that your gen values may be different from those shown unless you've just started or restarted CLIPS, or have not used (gensym*) or (gensym) since you started.</p>
          <pre>CLIPS&gt;
(definstances TRIANGLE_OBJECTS
  (Triangle1 of TRIANGLE))
CLIPS&gt; (reset)
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[Triangle1] of TRIANGLE
[gen3] of LINE
[gen4] of POINT
[gen5] of POINT
[gen6] of LINE
[gen7] of POINT
[gen8] of POINT
[gen9] of LINE
[gen10] of POINT
[gen11] of POINT
For a total of 11 instances.
CLIPS&gt;</pre>
          <p>At first you may be surprised at all the gensym* values created. However, all of them are necessary. First, gen3 was created for slot line1, which required gen4 and gen5 for the slots point1 and point2 associated with it by inheritance. Second, gen6 was created for slot line2, which required gen7 and gen8 for its slots point1 and point2. Finally, gen9 was created for slot line3, which required gen10 and gen11 for the slots point1 and point2 associated with it . The slots for [Triangle1] and one of its pointer values, [gen3], is shown following.</p>
          <pre>CLIPS&gt; (send [Triangle1] print)
[Triangle1] of TRIANGLE
(line1 [gen3])
(line2 [gen6])
(line3 [gen9])
CLIPS&gt; (send [gen3] print)
[gen3] of LINE
(point1 [gen4])
(point2 [gen5])
CLIPS&gt;</pre>
          <p>Now lets put in the X, Y coordinates of [Triangle1] as follows.</p>
          <pre>CLIPS&gt;
(send (send (send [Triangle1] get-line1)
            get-point1)
      put-position -1 0)
(-1 0)
CLIPS&gt;
(send (send (send [Triangle1] get-line1)
            get-point2)
      put-position 0 2)
(0 2)
CLIPS&gt;
(send (send (send [Triangle1] get-line2)
            get-point1)
      put-position 0 2)
(0 2)
CLIPS&gt;
(send (send (send [Triangle1] get-line2)
            get-point2)
      put-position 1 0)
(1 0)
CLIPS&gt;
(send (send (send [Triangle1] get-line3)
            get-point1)
      put-position 1 0)
(1 0)
CLIPS&gt;
(send (send (send [Triangle1] get-line3)
            get-point2)
      put-position -1 0)
(-1 0)
CLIPS&gt;</pre>
          <p>The stored values are as follows.</p>
          <pre>CLIPS&gt; (send [Triangle1] print)
[Triangle1] of TRIANGLE
(line1 [gen3])
(line2 [gen6])
(line3 [gen9])
CLIPS&gt; (send [gen3] print)
[gen3] of LINE
(point1 [gen4])
(point2 [gen5])
CLIPS&gt; (send [gen4] print)
[gen4] of POINT
(position -1 0)
CLIPS&gt; (send [gen5] print)
[gen5] of POINT
(position 0 2)
CLIPS&gt;</pre>
          <p>As you can see, the line1 pointer [gen1] points to point1 and point2 with their pointers [gen2] and [gen3]. These last two pointers finally point to the actual values of (-1 0) and (0 2) that define line1 of [Triangle1]. It's analogous to Long John Silver finding a treasure chest with a map, [gen1], which leads to another chest with two maps, [gen2] and [gen3], which lead to the two buried treasures at the locations specified by [gen2] and [gen3].</p>
          <p>The values stored for each line of [Triangle1] can be retrieved by a single command using nested messages such as the following.</p>
          <!--page 46-->
          <pre>(send (send (send [Triangle1] get-line1)
                                                 get-point1)
                                           get-position)</pre>
          <p>Although these commands work, it's not much fun to type them in unless you get paid by the hour and need the typing practice. As you might have guessed from the LINE handlers that we defined in the previous section, it's possible to define TRIANGLE handlers as follows.</p>
          <pre>CLIPS&gt;
(defmessage-handler TRIANGLE find-line-point
  (?line ?point)
  (send (send (send ?self
                    (sym-cat "get-line"
                             ?line))
              (sym-cat "get-point" ?point))
        get-position))
CLIPS&gt;
(defmessage-handler TRIANGLE print-line
  (?line)
  (printout t "point1 "
              (send ?self find-line-point
                          ?line 1)
              crlf
              "point2 "
              (send ?self find-line-point
                          ?line 2)
              crlf))
CLIPS&gt; (send [Triangle1] print-line 1)
point1 (-1 0)
point2 (0 2)
CLIPS&gt;</pre>
          <p>Using these handlers is a lot more convenient than typing in the nested messages.</p>
          <p>At this point, you might be tempted to define a handler called <function>find-line</function> which returns both point values of the specified line. Recall that find-line-point requires the specification of both the line and one of the two points which define the line. So why not just send two messages in the same handler to return both point values of the specified line? Shown following is the handler for <function>find-line</function> and what it returns for line1 of [Triangle1]</p>
          <pre>CLIPS&gt;
(defmessage-handler TRIANGLE find-line (?line)
  (send (send (send ?self
                    (sym-cat "get-line" ?line))
              get-point1)
        get-position)
  (send (send (send ?self
                    (sym-cat "get-line" ?line))
              get-point2)
        get-position))
CLIPS&gt; (send [Triangle1] find-line 1)
(0 2)
CLIPS&gt;</pre>
          <p>As you can see, the handler only returns the last message value of (0 2). Thus, the first value of (-1 0) is not returned by CLIPS. This is like the case of deffunctions which only return the last action. One way of getting around this problem and returning both point values of the line is shown following.</p>
          <pre>CLIPS&gt;
(defmessage-handler TRIANGLE find-line (?line)
  (create$ (send (send (send ?self
                             (sym-cat "get-line" ?line))
                       get-point1)
                 get-position)
           (send (send (send ?self
                             (sym-cat "get-line" ?line))
                       get-point2)
                 get-position)))
CLIPS&gt; (send [Triangle1] find-line 1)
(-1 0 0 2)
CLIPS&gt;</pre>
          <p>Notice that the (create$) function was used to combine both point values into a single multifield value (-1 0 0 2) which was then returned.</p>
        </section>
        <section>
          <title>Other Functions for Handlins Message Handlers</title>
          <p>A number of other functions are useful with handlers. Some of these follow.</p>
          <ul>
            <li><function>undefmessage-handler</function>: Deletes a specified handler.</li>
            <li><function>list-defmessage-handlers</function>: Lists the handlers.</li>
            <li><function>delete-instance</function>: Operates on the active handler.</li>
            <li><function>message-handler-existp</function>: Returns TRUE if handler exists, else FALSE.</li>
          </ul>
          <p>The <dfn>grouping functions</dfn> group COOL items into a multifield variable.</p>
          <ul>
            <li><function>get-defmessage-handler-list</function>: Groups the class names, message names, and types (direct or inherited).</li>
            <li><function>class-superclasses</function>: Groups all superclass names (direct or inherited).</li>
            <li><function>class-subclasses</function>: Groups all subclass names (direct or inherited).</li>
            <li><function>class-slots</function>: Groups all slot names (explicitly define or inherited).</li>
            <li><function>slot-existp</function>: Returns TRUE if the class slot exists, else FALSE.</li>
            <li><function>slot-facets</function>: Groups the specified slot facet values of a class.</li>
            <li><function>slot-sources</function>: Groups the slot names of classes which contribute to a slot in the specified class.</li>
          </ul>
          <p>The <function>preview-send</function> function is useful in debugging since it displays the sequence of all handlers that potentially may be involved in processing a message. The reason for the term potentially is that shadowed handlers will not be executed if the shadower does not use <function>call-next-handler</function> or <function>override-next-handler</function>.</p>
          <p>Handlers are arranged in a message-handler precedence which determines how they are called. The process of determining which handlers should be called and in what order is called the <dfn>message dispatch</dfn>. Every time a message is sent to an object, CLIPS arranges the message dispatch for the applicable handlers of that object, which can be viewed by the (preview-send) command. The applicable handlers are all handlers in all classes along the object's inheritance path that may respond to the type of message. Other functions useful with pattern matching objects by rules follow.</p>
          <ul>
            <li><function>object-pattern-match-delay</function>: Delay pattern matching of rules until after instances are created, modified, or deleted.</li>
            <li><function>modify-instance</function>: Modifies instance using slot overrides. Object pattern matching delayed until after modifications.</li>
            <li><function>active-modify-instance</function>: Change the values of the instance concurrent with object pattern matching with direct-modify message.</li>
            <li><function>message-modify-instance</function>: Change the values of the instance. Delay object pattern matching until all slots are changed.</li>
            <li><function>active-message-modify-instance</function>: Changes the values of the instance concurrent with object pattern matching using message-modify.</li>
          </ul>
        </section>
      </section>
      <!-- end of "Handlers in CLIPS" -->
      <section>
        <h2>Pattern Matching on Instances*</h2>
        <div class="abstract">
          <p>In this chapter you'll learn how to pattern match on instances. One way is with rules. Also, CLIPS has a number of query functions to match instances. In addition, control facts and slot daemons can be used for pattern matching.</p>
        </div>
        <section>
          <title>Matching Classes, Slots, and Objects</title>
          <p>One of the new features of Version 6.0 is the ability of rules to pattern match on objects. The following example shows how the value of the slot sound is pattern matched by a rule.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DUCK (is-a USER)
  (multislot sound (default quack quack)))
CLIPS&gt;
(make-instance [Dorky_Duck] of DUCK)
[Dorky_Duck]
CLIPS&gt;
(make-instance [Dinky_Duck] of DUCK)
[Dinky_Duck]
CLIPS&gt;
(defrule find-sound
  ?duck &lt;- (object (is-a DUCK)
                   (sound $?find))
=&gt;
  (printout t "Duck "
              (instance-name ?duck)
              " says " ?find crlf))
CLIPS&gt; (run)
Duck [Dinky_Duck] says (quack quack)
Duck [Dorky_Duck] says (quack quack)
CLIPS&gt;</pre>
          <p>The object-pattern conditional element object is followed by the classes and slots to be matched against. Following the is-a and the slot-name can be constraint expressions involving ?, $?, &amp;, and |.</p>
          <p>In addition, instance names can be specified for pattern matching. The following example shows how only one instance of the DUCK class is matched using the <dfn>name constraint</dfn>, <dfn>name</dfn>, of instances. Note that name is a reserved word and cannot be used as a slot name.</p>
          <pre>CLIPS&gt;
(defrule find-sound
  ?duck &lt;- (object (is-a DUCK)
                   (sound $?find)
                   (name [Dorky_Duck]))
=&gt;
  (printout t "Duck "
              (instance-name ?duck)
              " says " ?find crlf))
CLIPS&gt; (run)
Duck [Dorky_Duck] says (quack quack)
CLIPS&gt;</pre>
        </section>
        <!-- end of "Matching Classes, Slots, and Objects" -->
        <section>
          <title>Querying the Database of Objects</title>
          <p>Consider the following general type of problem. Given some instances, how many satisfy a specified condition? For example, shown following are the defclasses and definstances of Joe's <var>Home</var> showing the various types of sensors and the appliances connected to them. Notice that an abstract class DEVICE is defined since both SENSOR and APPLIANCE inherit common slots type and location.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt;
(defclass DEVICE (is-a USER)
  (role abstract)
  ; Sensor type
  (slot type (access initialize-only))
  ; Location
  (slot loc (access initialize-only)))
CLIPS&gt;
(defclass SENSOR (is-a DEVICE)
  (role concrete)
  (slot reading)
  ; Min reading
  (slot min (access initialize-only))
  ; Max reading
  (slot max (access initialize-only))
  ; SEN. APP.
  (slot app (access initialize-only)))
CLIPS&gt;
(defclass APPLIANCE (is-a DEVICE)
  (role concrete)
  ; Depends on appliance
  (slot setting)
  ; off or on
  (slot status))
CLIPS&gt;
(definstances ENVIRONMENT_OBJECTS
  (T1 of SENSOR
    (type temperature)
    (loc kitchen)
    (reading 110) ; Too hot
    (min 20)
    (max 100)
    (app FR))
  (T2 of SENSOR
    (type temperature)
    (loc bedroom)
    (reading 10) ; Too cold
    (min 20)
    (max 100)
    (app FR))
  (S1 of SENSOR
    (type smoke)
    (loc bedroom)
    (reading nil) ; Bad sensor nil reading
    (min 1000)
    (max 5000)
    (app SA))
  (W1 of SENSOR (type water)
    (loc basement)
    (reading 0)
    ; OK
    (min 0)
    (max 0)
    (app WP))
  (FR of APPLIANCE
    (type furnace)
    (loc basement)
    (setting low) ; low or high
    (status on))
  (WP of APPLIANCE
    (type water_pump)
    (loc basement)
    (setting fixed)
    (status off))
  (SA of APPLIANCE
    (type smoke_alarm)
    (loc basement)
    (setting fixed)
    (status off)))
CLIPS&gt;</pre>
          <p>Suppose the following questions or queries are asked. What are all the objects in the database? How are all the objects arranged? What are the relationships between objects? What are all the devices? What are all the sensors? What are all the appliances? Which sensor is connected to which appliance? Are there any sensors whose type is temperature? What sensors of type temperature have a reading between min and the max? An even more basic query is whether or not there are any sensors present.</p>
          <p>The <dfn>query system</dfn> of COOL is a set of six functions that may be used for pattern matching an <dfn>instance-set</dfn> and performing actions. An instance-set is a set of instances, such as the instances of SENSOR. The instances in the instance-set may come from multiple classes that do not have to be related. In other words, the classes do not have to be from the same inheritance path.</p>
          <p>The following list from the <cite class="book">CLIPS Reference Manual</cite>, summarizes the predefined <dfn>query functions</dfn> that may be used for instance-set access.</p>
          <ul>
            <li><function>any-instancep</function>: Determines if one or more instance-sets satisfy a query.</li>
            <li><function>find-instance</function>: Returns the first instance-set that satisfies a query.</li>
            <li><function>find-all-instances</function>: Groups and returns all instance-sets which satisfy a query.</li>
            <li><function>do-for-instance</function>: Performs an action for the first instance-set which satisfies a query.</li>
            <li><function>do-for-all-instances</function>: Performs an action for every instance-set which satisfies a query as they are found.</li>
            <li><function>delayed-do-for-all-instances</function>: Groups all instance-sets which satisfy a query and then iterates an action over this group.</li>
          </ul>
          <p>The <function>any-instancep</function> function is a predicate function that returns TRUE if there is an instance matching the pattern and FALSE otherwise. Shown following is an example of this query function used with the SENSOR and APPLIANCE classes and instances. The query function determines if there is any instance in the SENSOR class.</p>
          <pre>CLIPS&gt; (reset)
CLIPS&gt; (instances)
[initial-object] of INITIAL-OBJECT
[T1] of SENSOR
[T2] of SENSOR
[S1] of SENSOR
[W1] of SENSOR
[FR] of APPLIANCE
[WP] of APPLIANCE
[SA] of APPLIANCE
For a total of 8 instances.
; Function returns TRUE because
; there is a SENSOR instance
CLIPS&gt; (any-instancep ((?ins SENSOR)) TRUE)
TRUE
; Evaluation error&#x2014;Bad!
; No DUCK class
CLIPS&gt; (any-instancep ((?ins DUCK)) TRUE)
[PRNTUTIL1] Unable to find class DUCK.
CLIPS&gt;</pre>
          <p>The basic format of a query function involves an <dfn>instance-set-template</dfn> to specify the instances and their classes, an <dfn>instance-set-query</dfn> as the boolean condition that the instances must satisfy, and actions to specify the actions to be taken. The predicate function <function>class-existp</function> returns TRUE if the class exists and FALSE otherwise.</p>
          <p>The combination of instance name followed by the one or more <dfn>class restrictions</dfn> is called an <dfn>instance-set-member-template</dfn>. The query functions may generally be used like any other function in CLIPS.</p>
          <p>There are two steps involved in trying to satisfy a query. First, CLIPS generates all the possible instance-sets that match the instance-set-template. Second, the boolean instance-set- query is applied to all the instance-sets to see which ones, if any, satisfy the query. Instance-sets are generated by a simple <dfn>permutation</dfn> of the members in a template, where the rightmost members are varied first. Note that a permutation is not the same as a <dfn>combination</dfn> because order matters in a permutation but not in a combination.</p>
          <p>The function <function>find-all-instances</function> returns a multifield value of all instances which satisfy the query, or an empty multifield value for none. The <function>do-for-instance</function> query function is similar to <function>find-instance</function> except that it performs a single <dfn>distributed action</dfn> when the query is satisfied. The <function>do-for-all-instances</function> function is similar to the do-for-instance except that it performs its actions for every instance-set that satisfies the query.</p>
        </section>
        <!-- end of "Querying the Database of Objects" -->
        <section>
          <title>Generics in CLIPS</title>
          <p>In contrast to rules which are only activated when their patterns are satisfied, <em>deffunctions</em> are explicitly called and then executed. Just because a rule is activated does not mean it will be executed. Deffunctions are completely procedural in nature because once called by name, their code is executed in a procedural manner, statement by statement. Also, no pattern matching involving constraints is used in a deffunction to decide if its actions should be executed. Instead, any arguments that match the number expected by the deffunction argument list will satisfy the deffunction and cause its actions to be executed.</p>
          <p>The basic idea of deffunctions as named procedural code is carried to a much greater degree with defgenerics and the defmethods that describe their implementation. A <dfn>defgeneric</dfn> is like a deffunction but much more powerful because it can do different tasks depending on its argument constraints and types. The ability of a generic function to perform different actions depending on the classes of its arguments is called overloading the function name.</p>
          <p>By proper use of operator overloading, it's possible to write code that is more readable and reusable. For example, a defgeneric for the <q>+</q> function can be defined with different <dfn>defmethods</dfn>. The expression,</p>
          <pre>(+ ?a ?b)</pre>
          <p>could add two real numbers represented by <var>?a</var> and <var>?b</var>, or two complex numbers, or two matrices, or concatenate two strings, and so forth depending if there is a defmethod defined for the argument classes. CLIPS does this by first recognizing the type of the arguments and then calling the appropriate defmethod defined for those types. A separate overloaded defmethod for <q>+</q> would be defined for each set of argument types except for the predefined system types such as real numbers. Once the defgeneric is defined, it's easy to reuse in other programs.</p>
          <p>Any <dfn>named function</dfn> that is system defined or external can be overloaded using a generic function. Notice that a deffunction cannot be overloaded. An appropriate use of a <em>generic</em> function is to overload a named function. If overloading is not required, you should define a deffunction or an external function.</p>
          <p>The syntax of defgenerics is very simple, consisting of just the legal CLIPS symbol name and an optional comment.</p>
          <pre>(defgeneric &lt;name&gt; [&lt;comment&gt;])</pre>
          <p>As a simple example of generic functions, consider the following attempt in CLIPS to compare two strings using the <q>&gt;</q> function.</p>
          <pre>CLIPS&gt; (clear)
CLIPS&gt; (&gt; "duck2" "duck1")
[ARGACCES5] Function &gt; expected argument #1 to be of type
integer or float
CLIPS&gt;</pre>
          <p>It's not possible to do this comparison with the <q>&gt;</q> function because it expects NUMBER types as arguments.</p>
          <p>However, it's easy to define a (defgeneric) which will overload the <q>&gt;</q> to accept STRING types as well as NUMBER types. For example, if the arguments of <q>&gt;</q> are of type STRING, the defgeneric will do a string comparison, letter by letter starting from the left until the ASCII codes differ. In contrast, if the arguments of <q>&gt;</q> are of type NUMBER, the system compares the sign and magnitude of the numbers. The user-defined <q>&gt;</q> for STRING types is an <dfn>explicit method</dfn>, while a system-defined or user-defined external function such as <q>&gt;</q> for NUMBER type is an <dfn>implicit method</dfn>.</p>
          <p>The technique of overloading a function name so that the method which implements it is not known until run-time is another example of <dfn>dynamic binding</dfn>. Any object reference of name or address may be bound at run-time in CLIPS to functions through dynamic binding also.</p>
          <p>Some languages such as Ada have a more restrictive type of overloading in which the function name must be known at compile time rather than at run-time. The run-time dynamic binding is the least restrictive since methods can be created during execution by the (build) statement. However, you should be careful in using (build) since dynamically creating constructs is often hard to debug. Also, the resulting code may be difficult to verify and validate since you'll have to stop execution to examine the code. Dynamic binding is a characteristics of a true object-oriented programming language.</p>
          <p>Following is an example of a defgeneric, <q>&gt;</q>, for STRING types and its method.</p>
          <pre>; Header declaration. Actually unnecessary
CLIPS&gt; (defgeneric &gt;)
CLIPS&gt;
(defmethod &gt; ((?a STRING) (?b STRING))
  (&gt; (str-compare ?a ?b) 0))
; The overload "&gt;" works correctly
; in all three cases.
CLIPS&gt; (&gt; "duck2" "duck1")
TRUE
CLIPS&gt; (&gt; "duck1" "duck1")
FALSE
CLIPS&gt; (&gt; "duck1" "duck2")
FALSE
CLIPS&gt;</pre>
          <p>The (defgeneric) acts as a <dfn>header declaration</dfn> to declare the type of function being overloaded. It's not actually necessary to use a defgeneric in this case because CLIPS implicitly deduces the function name from the defmethod name, which is the first symbol following <kbd>defmethod</kbd>. The header is a forward declaration that is necessary if the (defgeneric) methods have not yet been defined, but other code such as defrules, defmessage-handlers, and so forth refers to the (defgeneric) name.</p>
        </section>
        <!-- end of "Generics in CLIPS" -->
        <section>
          <title>Other Features*</title>
          <!--page 157-->
          <p>Compared to deffunctions, a method has an optional <dfn>method index</dfn>. If you don't supply this index, CLIPS will provide a unique index number among the methods for that generic function, that can be viewed by the <function>list-defmethods</function> command. The method body can be printed using the <function>ppdefmethod</function> command. A method can be removed with an <function>undefmethod</function> function call.</p>
          <p>The ranking of methods determines the <dfn>method precedence</dfn> of a generic function. It is the method precedence which determines the methods order of listing. Higher precedence methods are listed before lower precedence methods. The highest precedence method will also be tried first by CLIPS.</p>
          <p>A <dfn>shadowed method</dfn> is one in which one method must be called by another. The process by which CLIPS picks the method with highest precedence is called the <dfn>generic dispatch</dfn>. For more information, see the <cite class="book"><cite class="book">CLIPS Reference Manual</cite></cite>.</p>
        </section>
      </section>
      <!-- end of "Pattern Matching on Instances" -->
      <section>
        <h2>Support Information*</h2>
        <!--page 159-->
      </section>
      <!-- end of "CLIPS" -->
    </main>
  </body>
</html>
