<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>Artificial Intelligence</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>

    <link rel="alternate" hreflang="x-default" href="http://www.example.com/"/>
    <link rel="alternate" hreflang="es" href="http://es.example.com/"/>
    <link rel="alternate" hreflang="de" href="http://de.example.com/"/>

    <link rel="author" href="https://plus.google.com/ExampleProfile"/>
    <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      <p><a                    href="ANOTHER_PAGE.html">ANOTHER_PAGE</a</p>>
      <p><a rel="RELATIONSHIP" href="ANOTHER_PAGE.html">LINK_TEXT</a</p>>
      <p><a rel="alternate"    href="VERSION.html">ANOTHER VERSION</a</p>>
      <hr/>
      <p><a href="A_PAGE.html">LINK_TEXT</a</p>>
      <p><a href="ANOTHER_PAGE.html">LINK_TEXT</a</p>>
      <p><a rel="prev" href="PREVIOUS_PAGE.html">LINK_TEXT</a</p>>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a</p>>
      -->
      <div>
        <p> <a rel="prev" href="ai.html">Artificial Intelligence</a></p>
        <p> <a rel="next" href="lisp.html">Lisp: The List Processing Language</a> </p>
        <p> <a href="knowledge-representation.html">Knowledge Representation</a> </p>
        <p> <a href="machine_learning.html">Machine Learning</a> </p>
        <p> <a href="gai.html">Generative Artificial Intelligence</a> </p>
        <p> <a href="ann.html">Artificial Neural Networks</a> </p>
      </div>
    </nav>
    <main>
      <h1>Prolog: Symbolic Programming or <i>Programation Logique</i></h1>
      <p>Prolog is a general-purpose logic programming language associated with <a html="ai.html">artificial intelligence</a> and computational linguistics. Prolog has its roots in first-order logic, a formal logic, and unlike many other programming languages, Prolog is intended as primarily a <em linkend="declarative">declarative</em> programming language: the program logic is expressed in terms of relations, represented as facts and rules. A computation is initiated by running a query over these relations.</p>
      <p>Prolog implements the predicate calculus via <a href="Horn_clauses_in_prolog">Horn clauses</a>. The inference mechanism of Prolog is based upon Robinson's resolution principle (1965) together with mechanisms for extracting answers proposed by Green (1968). These ideas came together forcefully with the advent of linear resolution procedures. Explicit goal-directed linear resolution procedures, such as those of Kowalski and Kuehner (1971) and Kowalski (1974), gave impetus to the development of a general purpose logic programming system.</p>
      <p><q>Prolog</q> stands for <i lang="fr">Programation Logique</i>.</p>
      <p>A logic program is a set of axioms, or rules, defining relations between objects. A <dfn>computation</dfn> of a logic program is a deduction of consequences of the program. A program defines a set of consequences, which is its meaning. The art of logic programming is constructing concise and elegant programs that have the desired meaning.</p>
      <p>The <dfn>meaning</dfn> of a logic program <var>P</var>, <code class="function">M</code>(<var>P</var>), is the set of ground goals deducible from <var>P</var>.</p>
      <p>Prolog was one of the first logic programming languages, and remains the most popular among such languages today, with several free and commercial <a html="pl_implementations">implementations</a> available. The language has been used for theorem proving, <a html="expert_sys_in_pl">expert systems</a>, term rewriting, type inference, and automated planning, as well as its original intended field of use, natural language processing. Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications.</p>
      <p>Prolog is well-suited for specific tasks that benefit from rule-based logical queries such as searching databases, voice control systems, and filling templates.</p>
      <section>
        <h2>Why Prolog?</h2>
        <p>Much has been written about the wonders of Prolog as a declarative programming language and its strength as a language for implementing artificial intelligence (AI) applications. A look under the hood of both AI and Prolog reveals why.</p>
        <p>A collection of search and pattern- matching algorithms. This, it turns out, is the essence of much AI programming. A chess program searches for patterns in the game, a natural language program searches for patterns in lists of words, and a diagnostic program searches for rules that match symptoms. Prolog is very good at pattern matching and search.</p>
        <p>Two features in a programming language that make pattern-matching easier are 1) support for symbols as a primitive data type that can be manipulated without the need to call special functions, and 2) dynamic memory management so the developer can simply use the symbols without worrying about memory allocation issues. Languages that have these features, such as Prolog and LISP, are called symbolic languages.</p>
        <p>Consider, for example, a simple control loop that reads a command from a user and then does something. In C that code might look like</p>
        <pre>void main()
{
  char buf[20];
  do {
     gets(buf);
     if (0 == strcmp(buf, "open")) ...
     else if (0 == strcmp(buf, "add")) ...
     else if (0 == strcmp(buf, "delete")) ...
  } while (strcmp(buf, "quit"));
  printf("done");
}</pre>
        <p>In Prolog, dynamically allocated symbols are used instead of character strings, so the equivalent code looks like</p>
        <pre>

    main :-
      repeat,
      read(X),
      do(X),
      X == quit,
      write(done).

    do(open) :- ...
    do(add) :- ...
    do(delete) :- ...

</pre>
        <p>Notice the lack of data definition statements or string compares. The difference is not significant in a simple example such as this, but in applications where the bulk of the work is comparing symbols, it becomes quite significant.</p>
        <p>In addition to dynamically allocated symbols, Prolog has, as an integral part of the language, a sophisticated pattern matching algorithm, called <dfn>unification</dfn>, and a search mechanism, called <dfn>backtracking</dfn>.</p>
        <p>These can both be seen in the code fragment above. The pattern <kbd>do(X)</kbd> is unified against the first of the three <kbd>do</kbd> rules, defined by the <kbd>:-</kbd> symbol meaning <q>if</q>. If the user entered <kbd>open</kbd> then the first clause, as it's called, would match and the code on the right of the <kbd>:-</kbd> would be executed. If the user entered something other than <kbd>open</kbd>, Prolog would <em>backtrack</em> and continue to look for a <kbd>do</kbd> rule that does match the user's input.</p>
        <p>Similarly, the use of the <kbd>repeat</kbd> and <kbd>X == quit</kbd> in the <kbd>main</kbd> rule causes the sample section of code to <em>loop</em> until the user types <kbd>quit</kbd>. The Prolog programmer doesn't write <q>if-then-elses</q>, <q>calls</q>, <q>whiles</q>, or other flow-of-control constructs, however, between unification and backtracking the programmer can induce any flow-of-control behavior in a Prolog program that can be achieved in any other language.</p>
        <p>Symbols, unification, backtracking, and dynamic memory management, all tend to eliminate procedural code a programmer normally needs to write. It is no surprise that what is left looks much more declarative than conventional code and is often a fraction of the size. For example, Prolog can be used to analyze simple English sentences. In fact Prolog was originally designed for working with language. As such it is well suited for not just natural language work, but for implementing and/or experimenting with formal languages as well.</p>
        <p>One common use in this line is to build shells for implementing expert systems. The shells use their own language to represent the knowledge for a particular type of problem. Diagnostic systems, for example, work differently from configuration systems.</p>
        <p>A tax application in Prolog is simply a collection of rules that specify how to fill out each line of the form. Prolog's search and unification do the work of linking related lines of the form together so the program code winds up looking very much like the tax form itself. Business applications such as customer order entry are expressed as relationships describing the various transactions and constraints. Pricing and configuration, two difficult components of such a system, are relatively straight-forward when coded in Prolog.</p>
        <p>While C can be used to write anything written in Prolog, Prolog code, for the applications it does best, is much less complex. For this reason, the Prolog developer can manage and maintain a greater degree of complexity in an application, thus providing a greater degree of sophistication to the user of an application.</p>
        <p>For commercial applications, this leads to a competive edge, but the real benefit applies to any application-- Prolog is simply fun.</p>
      </section>
      <section>
        <h2>How Prolog is Used</h2>
        <p>The examples above provide insight into how a Prolog program is used. The grammar rules, for example, are a Prolog program. They are queried with lists of words. All Prolog programs are similar collections of rules, and are similarly activated by being queried, much the same way a database is queried.</p>
        <p>This is true even of stand-alone compiled Prolog programs. In that case there is usually a single query, <code class="function">main</code>, used to start the program. <code class="function">main</code> is the name of a rule which then queries other rules which query other rules and so on. For example, the following Prolog program could be compiled and executed, with a classic result.</p>
        <pre>main :- write('Hello World').</pre>
        <p>It could also be loaded and run from an interpreter.</p>
        <pre>?- main.
Hello World</pre>
      </section>
      <section>
        <h2>Binding to C</h2>
        <p>The nature of this interaction with Prolog dictates the nature of a C to Prolog interface. It too must be able to either execute compiled Prolog code, or query a loaded Prolog program. In this sense, the interface from C to Prolog will look more like a database API than procedural interlanguage calls.</p>
        <p>The Hello World program illustrates the Prolog to C direction of the interface as well. Note that the <kbd>write</kbd> statement has nothing to do with logic, pattern- matching, or search; it simply performs I/O. Prolog provides a number of special predicates, such as <code class="function">write</code>, which are used primarily for their side effects. It is in this area that Prolog is weaker than C.</p>
        <p>The Prolog programmer must rely on whatever special predicates a particular vendor provides with an implementation. So, for example, if a particular Prolog implementation doesn't supply the tools for accessing Windows, then it can't be used to implement Windows applications. This is where Prolog to C connections come in. They let a programmer define as many extended predicates, such as <code class="function">write</code>, as desired, to allow Prolog code access to any services accessable from C. This fundamental architecture of Prolog shapes the design of an interface between it and C. The calls from C to Prolog reflect the database nature of Prolog. The calls from Prolog to C reflect the procedural nature of C.</p>
      </section>
      <section>
        <h2>Starting Prolog</h2>
        <p>Consider the following problem description:</p>
        <blockquote id="three_different_friends">
          <p>Three friends come first, second, and third in a tournament. Each of them has a different first name, likes a different sport and has a different nationality.</p>
          <p>Michael likes basketball and did better than the American. Simon, the Israeli, did better than the tennis player. The cricket player came first.</p>
        </blockquote>
        <p>A prolog shell may be started for the user-programmer to work interactively. Alternatively, you may cause a shell to read a <dfn>database</dfn> file, for instance by issueing <kbd>consult(<cite>my_database</cite>).</kbd> Alternatively, type <kbd>[<cite>my_database</cite>].</kbd></p>
        <p class="warning"><strong>Warning:</strong> The database name must be stripped of its extension</p>
      </section>
      <section>
        <h2>The Building Blocks of a Prolog Program</h2>
        <section>
        <h3>Facts</h3>
          <p>We first discuss facts about objects. Suppose we want to tell Prolog the fact that <q>John likes Mary</q>. This fact consists of two objects, called <q>Mary</q> and <q>John</q>, and a relationship or <dfn>predicate</dfn>, called <q>likes</q>. In Prolog, we need to write facts in a standard form, like this:</p>
          <pre>likes(john, mary).</pre>
          <p>The following things are important:</p>
          <ul>
            <listitem>The names of all relationships and objects must begin with a lower-case letter. For example, <kbd>likes</kbd>, <kbd>john</kbd>, <kbd>mary</kbd>.</listitem>
            <listitem>The relationship is written first, and the objects are written separated by commas and enclosed in round brackets.</listitem>
            <listitem>The dot character <q>.</q> must come at the end of a fact. The dot is what some people also call a <q>period</q> or a <q>full stop</q>.</listitem>
          </ul>
        </section>
        <section>
        <h3>Questions</h3>
          <p>Once we have some facts, we can ask some questions about them. In Prolog, a question looks just like a fact, except that we put a special symbol before it. The special symbol is written as a question mark followed by a hyphen. Consider the question:</p>
          <pre>?- owns(mary, book).</pre>
          <p>If we interpret <kbd>mary</kbd> to be a person called Mary, and <kbd>book</kbd> to be some particular book, this question is asking <q>Does Mary own the book?</q>, or <q>Is it a fact that Mary owns the book?</q> We are not asking whether she owns all books, or books in general, because the first letter of <kbd>book</kbd> is lower case.</p>
          <p>When a question is asked of a Prolog system, it will search through the database. It looks for facts that unify the fact in the question. Two facts <dfn>unify</dfn> if their predicates are the same (spelled the same way), and if their corresponding arguments each are the same. If Prolog finds a fact that unifies with the question, Prolog will respond <samp>yes</samp>. If no such fact exists in the database, Prolog will respond <samp>no</samp>.</p>
        </section>
        <section xml.id="pl_rules">
        <h3>Rules</h3>
          <p>In Prolog, rules are used when you want to say that a fact depends on a group of other facts. Rules are also used to express definitions. A rule is a general statement about objects and their relationships. For example, we can say that <q>Fred is a bird</q> if <var>Fred</var> is an animal and <var>Fred</var> has feathers, and we can also say that <var>Bertram</var> is a bird if <var>Bertram</var> is an animal and <var>Bertram</var> has feathers. So, we can allow a variable to stand for a different object in each different use of the rule.</p>
          <!-- <p class="bridgehead"/> -->
          <p>In Prolog, a rule consists of a <dfn>head</dfn> and a <dfn>body</dfn>. The head and body are connected by the symbol <q>:-</q>, which is made up of a colon and a hyphen. The <q>:-</q> is pronounced <q>if</q>.</p>
          <p>That John lkes whoever likes wine is written in Prolog as:</p>
          <pre>likes(john, X) :- likes(X, wine).</pre>
          <p>Notice that rules also end with a dot (actually a <q>period</q> or <q>full stop</q> character). The head of this rule is <kbd>likes(john, X)</kbd>. The head of the rule describes what fact the rule is intended to define. The body, in this case <kbd>likes(X, wine)</kbd>, describes the conjunction of goals that must be satisfied, one after the other, for the head to be true. For example, we can make John more choosy about whom he likes, simply by adding more goals onto the body, separated by commas:</p>
          <pre>likes(john, X) :- likes(X, wine), likes(X, food).</pre>
          <p>or, in words, John likes anyone who likes wine and food. Or, suppose John likes any female who likes wine:</p>
          <pre>likes(john, X) :- female(X), likes(X, wine).</pre>
          <p>And so on.</p>
        </section>
        <section>
        <h3>Input, Output, and Input-Output Arguments to Predicates in Prolog</h3>
          <p>An argument may be either of them three and change its role according to the situation, for there is nothing in the syntax of prolog to indicate which.</p>
        </section>
        <section>
        <h3>Functors or <q>Structures</q></h3>
          <p>A structure is written in Prolog by specifying its <dfn>functor</dfn> and its components. The functor names the general kind of structure, and corresponds to a datatype in an ordinary programming language. The components are enclosed in round brackets and separated by commas. The functor is written just before the opening round bracket. Consider the following fact, that John owns the book called Wuthering Heights, by Emily Bronte:</p>
          <pre>owns(john, book(wuthering_heights, bronte)).</pre>
          <p>Inside the <kbd>owns</kbd> fact we have a structure by the name of <kbd>book</kbd>, which has two components, a title and an author. Since the book structure appears inside the fact as one of the fact's arguments, it is acting as an object, taking part in a relationship. If we like, we can also have another structure for the author's name, because there were three Bronte writers we wish to distinguish:</p>
          <pre>owns(john, book(wuthering_heights, author(emily, bronte))).</pre>
          <p>Structures may participate in the process of question-answering using variables. For example, we may ask if John owns any book by any of the Bronte sisters:</p>
          <pre>?- owns(john, book(X, author(Y, bronte))).</pre>
          <p>And so on.</p>
          <p>If you have guessed that the syntax for structures is the same as for Prolog facts, you are correct. A predicate (used in facts and rules) is actually the functor of a structure. The arguments of a fact or rule are actually the components of a structure. There are many advantages to representing Prolog programs themselves as structures. It is not important to know why just now, but do keep in mind that all parts of Prolog, even Prolog programs themselves, are made up of constants, variables, and structures.</p>
        </section>
        <section id="Horn_clauses_in_prolog">
        <h3>Horn Clauses</h3>
          <blockquote>
            <p>In mathematical logic and logic programming, a <dfn>Horn clause</dfn> is a logical formula of a particular rule-like form which gives it useful properties for use in logic programming, formal specification, and model theory. Horn clauses are named for the logician Alfred Horn, who first pointed out their significance in 1951.</p>
            <p style="text-align: right">The Wikipedia</p>
          </blockquote>
          <p>In logic programming, a <dfn>Horn clause</dfn> is an implication from a conjunction of none, one or several goals.</p>
          <blockquote>Jess will come <em>if</em> it is sunny <em>AND</em> her car starts, <em>AND</em> her mother is <em>not</em> ill.</blockquote>
          <p>This might be coded in prolog like this:</p>
          <pre>come(jess) :- sunny, start(car(jess)), not ill(mother(jess)).</pre>
        </section>
        <section>
        <h3>A Simple Database of Prolog Facts and Rules</h3>
          <p>This is a simple database to establish if two people are friends:</p>
          <pre>friends(X,Y) :- likes(X,Z), likes(Y,Z).
likes(john,gin).
likes(peter,gin).
likes(andy,beer).</pre>
          <section>
        <h4>Symmetric Relationships in Prolog</h4>
            <p>The following database and program lead off to infinite loops when consulted (<kbd>has_met(X,a).</kbd>):</p>
            <pre>% database:
has_met(a,b).
has_met(a,c).
% rules:
has_met(X,Y) :- has_met(Y,X).</pre>
            <p>The following one, though, behaves well:</p>
            <pre>% forward 'has_met' data base:
has_met_fwd(a,b).
has_met_fwd(a,c).
has_met(X,Y) :- has_met_fwd(X,Y) ; has_met_fwd(Y,X).</pre>
            <p>Alternatively:</p>
            <pre>% forward 'has_met' data base:
has_met_fwd(a,b).
has_met_fwd(a,c).
% rules:
has_met(X,Y) :- has_met_fwd(X,Y).
has_met(X,Y) :- has_met_fwd(Y,X).</pre>
            <p>Which obligingly yields:</p>
            <pre>| ?- has_met(X,a).
X = b ? ;
X = c
yes</pre>
          </section>
          <section>
        <h4>Transitivity</h4>
            <p>Here is a slightly more complicated example which codes some transitivity.</p>
            <pre>% database:
tr(a,b).
tr(b,c).
tr(c,d).
tr(bb,c).
tr(d,e).
tr(e,f).
% rules:
transitive(X,Y) :-           tr(X,Y).
transitive(X,Z) :-           tr(X,Y), transitive(Y,Z).</pre>
            <p>And this is the result of a difficult query:</p>
            <pre>| ?- transitive(X,f).
X = e ? ;
X = a ? ;
X = b ? ;
X = c ? ;
X = bb ? ;
X = d ? ;
no
</pre>
          </section>
          <section>
        <h4>Equivalence</h4>
            <p>Next, we would like to code an equivalence relationship.</p>
            <pre/>
            <p>...</p>
            <pre/>
            <p>...</p>
            <pre/>
            <p>...</p>
          </section>
        </section>
        <section id="lists_in_prolog">
        <h3>Lists in Prolog</h3>
          <p>Writing a list to standard output is a nice exercise for understanding both lists and recursive control:</p>
          <pre>writelist([]).
writelist([H|T]) :- write(H),nl,writelist(T).</pre>
          <section id="member_in_prolog">
        <h4>Membership in Prolog</h4>
            <p>Membership is established through recursion. I don't like it, though.</p>
            <pre>member(X,[X|_]).
member(X,[_|T] :- member(X,T).</pre>
          </section>
          <section>
        <h4>Appending</h4>
            <p>The arguments to non-built-in <code class="function">append/3</code> predicate are the initial sublist and the remaining sublist of a list, which is the third argument. It may be defined as:</p>
            <pre>append([], X, X).
  append([A|B], C, [A|D]) :- append(B, C, D).</pre>
            <p>Here is an example of execution of a query (find the lists X and Y such that the concatenation of X and Y is [a,b]):</p>
            <pre>
| ?- append(X,Y,[a,b,c]).
X = []
Y = [a,b,c] ? ;
X = [a]
Y = [b,c] ? a % here the user presses a to compute all remaining solutions
X = [a,b]
Y = [c]
X = [a,b,c]
Y = []
no</pre>
          </section>
        </section>
      </section>
      <section>
        <h2>Backtracking: Cuts and Repeats</h2>
        <p>We can imagine a conjunction of goals to be arranged from left to right, separated by commas. When handling such a conjunction of goals, Prolog attempts to satisfy each goal in turn, working from left to right. If a goal becomes satisfied, Prolog leaves a place-marker in the database that is associated with the goal. Think of this as drawing an arrow from the goal to the place in the database where the solution is. Furthermore, any variables previously uninstantiated might now be instantiated. If a variable becomes instantiated, all its occurrences in the question become instantiated, too. Prolog then attempts to satisfy the goal's right-hand neighbour, starting from the top of the database.</p>
        <p>As each goal in turn becomes satisfied, it leaves behind a place-marker in the database (draws another arrow from the goal to the unifying fact), in case the goal needs to be re-satisfied at a later time. Any time a goal fails (cannot find a unifying fact), Prolog goes back and attempts to satisfy its left-hand neighbour, starting from its place-marker. Furthermore, Prolog must <q>uninstantiate</q> any variables that became instantiated at this goal. In other words, Prolog must <q>undo</q> all the variables when it re-satisfies a goal. If each goal, upon being entered from its right, cannot be re-satisfied, then the failures will cause Prolog to gradually creep to the left as each goal fails. If the first goal (the left-most goal) fails, then, since it does not have a left-hand neighbour it can attempt to re-satisfy, the entire conjunction fails. This behaviour, where Prolog repeatedly attempts to satisfy and re-satisfy goals in a conjunction, is called <dfn>backtracking</dfn>.</p>
        <section id="prolog_cut_operator">
        <h3>The Use of Cut to Prevent Backtracking in Prolog</h3>
          <p>Sometimes it is desirable to selectively turn off backtracking. Prolog provides a predicate that performs this function. It is called the cut, represented by an exclamation mark (!).</p>
          <p>The cut effectively tells Prolog to freeze all the decisions after it occurs in a predicate. That is, if required to backtrack, Prolog will automatically fail without trying other alternatives.</p>
          <p>The following database and query seems to fail:</p>
          <pre>related(X,Y) :- related(X,Z), related(Z,Y).
related(phil, roxanne).
related(roxanne, carol).
related(carol, alex).</pre>
          <p>Followed by the query:</p>
          <pre>related(phil,carol).</pre>
          <!-- <p class="bridgehead"/> -->
          <p>Performance is the main reason to use the cut. This separates the logical purists from the pragmatists. Various arguments can also be made as to its effect on code readability and maintainability. It is often called the <q>goto</q> of logic programming.</p>
          <p>You will most often use the cut when you know that at a certain point in a given predicate, Prolog has either found the only answer, or if it hasn't, then there is no answer. In this case you insert a cut in the predicate at that point.</p>
          <p>Similarly, you will use it when you want to force a predicate to fail in a certain situation, and you don't want it to look any further.</p>
        </section>
        <section>
        <h3>Some Examples of the Use of Cuts</h3>
          <p>The following program defines the <code class="function">minimum</code> predicate with cuts:</p>
          <pre>minimum(X, Y, X) :- X =&lt; Y, !.
minimum(X,Y,Y) :- X &gt; Y, !.</pre>
          <note>Predicate <code class="function">maximum</code> can be defined analogously.</note>
          <p>...</p>
        </section>
        <section>
          <title>
            <kbd>repeat</kbd>
          </title>
          <p>The built-in predicate <kbd>repeat</kbd> is provided as an extra way to generate multiple solutions through backtracking. Although it is built-in, it can be thought of as behaving as though defined as follows:</p>
          <pre>repeat.
repeat :- repeat.</pre>
          <p>What is the effect of this if we put <kbd>repeat</kbd> as a goal in one of our rules? First of all, the goal will succeed, because of the fact which is the first clause of repeat. Secondly, if backtracking reaches this point again, Prolog will be able to try an alternative: the rule that is provided as the second clause of <kbd>repeat</kbd>. When it uses this rule, another goal <kbd>repeat</kbd> is generated. Since this matches the first fact, we have succeeded again. If backtracking reaches here again, Prolog will again use the rule where it used the fact before. To satisfy the extra goal generated, it will again pick the fact as the first option. And so on. In fact, the goal <kbd>repeat</kbd> will be able to succeed infinitely many times on backtracking. Note the importance of the order of the clauses here. (What would happen if the fact appeared after the rule?).</p>
          <p>Why is it useful to generate goals that will always succeed again on backtracking? The reason is that they allow one to build &#x2014; from rules that have no choices in them &#x2014; rules that <em>do</em> have choices. And we can make them generate different values each time.</p>
          <p class="bridgehead"><i>Loops with <kbd>repeat/0</kbd></i></p>
          <p>Furthermore, a clause body with a repeat/O followed by fail/O will go back and forth forever. This is one way to write an endless loop in Prolog.</p>
          <p>A repeat/O followed by some intermediate goals followed by a test condition will loop until the test condition is satisfied. It is equivalent to a <q>do until</q> in other languages.</p>
          <pre>command_loop :-
  repeat,
  write('Enter command (end to exit): '),
  read(X),
  write(X), nl,
  X = end.</pre>
        </section>
      </section>
      <section>
        <h2>Unification, the Engine for Predicate Matching and Evaluation</h2>
        <p>When queried, a prolog program  performs a series of resolutions on its database entries, rather than sequentally evaluating statements and expressions like a traditional language. This has an important ramification: variables are bound (assigned values, instantiated,...) by <dfn>unification</dfn> and <em>not</em> by evaluation unless an evaluation is <a html="prolog_is_operator">explicitly</a> requested.</p>
        <p>One consequence of this is the relaxation of the requirement to specify variables (function parameters) as input or output.</p>
        <p>Unification is a powerful technique for rule-based and frame-based expert systems, where it matches case-specific data to the rules that best meet these specifications. All production systems require a form of this matching, and it is often necessary to write a unification algorithm in languages that don't provide one.</p>
        <section id="prolog_is_operator">
        <h3>Forcing Evaluation with Operator <command>is</command></h3>
          <p>An important difference between unification-based computing and the use of more traditional languages is that unification performs syntactic matches (with appropriate parameter substitution) on structures. It does <em>not</em> evaluate expressions.</p>
          <p>Prolog provides an operator, <command>is</command>, that performs arithmetic evaluation. It evaluates the expression on its right-hand side and attempts to unify the result with the object on its left. Thus,</p>
          <pre>X is Y + Z</pre>
          <p>unifies <var>X</var> with the value of <var>Y</var> added to <var>Z</var>. Because it performs arythmetic evaluation:</p>
          <ul>
            <listitem>If <var>Y</var> and <var>Z</var> do not have values (are not bound at execution time) evaluation of the <command>is</command> causes a run-time error. Therefore</listitem>
            <listitem><kbd>X is Y + Z</kbd> cannot (as one might think with a declarative programming language) assign a value to <var>Y</var> when <var>X</var> and <var>Z</var> are bound.</listitem>
            <listitem>Programs must use <command>is</command> to evaluate expressions containing arithmetic operators, +, -, *, /, and <command>mod</command>.</listitem>
          </ul>
          <p>Finally, as in the predicate calculus, variables in prolog may have one and only one binding. Once given a value, through local assignment or unification, they can never take on a new value, except through a backtrack in the and/or search space of the current interpretation. Thus, <command>is</command> does not function like a traditional assignment operator; an expression such as <kbd>X is X + 1</kbd> will always fail.</p>
        </section>
      </section>
      <section>
        <h2>Conjunction, disjunction, if-then</h2>
        <p>These are realized through operators <kbd>,</kbd>, <kbd>;</kbd>, and <kbd>-&gt;</kbd>.</p>
        <p class="bridgehead"><i>The Gory Details</i></p>
        <p><kbd>Goal1 , Goal2</kbd> executes <var>Goal1</var> and, in case of success, executes <var>Goal2</var>.</p>
        <p><kbd>Goal1 ; Goal2</kbd> first creates a choice-point and executes <var>Goal1</var>. On backtracking <var>Goal2</var> is executed.</p>
        <p><kbd>Goal1 -&gt; Goal2</kbd> first executes <var>Goal1</var> and, in case of success, removes all choice-points created by <var>Goal1</var> and executes <var>Goal2</var>. This control construct acts like an if-then (<var>Goal1</var> is the test part and <var>Goal2</var> the then part). Note that if <var>Goal1</var> fails then <kbd>-&gt;/2</kbd> fails also. <kbd>-&gt;/2</kbd> is often combined with <kbd>;/2</kbd> to define an if-then-else as follows: <kbd>Goal1 -&gt; Goal2 ; Goal3</kbd>. Note that <kbd>Goal1 -&gt; Goal2</kbd> is the first argument of the <kbd>(;)/2</kbd> and <var>Goal3</var> (the else part) is the second argument. Such an if-then-else control construct first creates a choice-point for the else-part (intuitively associated with <kbd>;/2</kbd>) and then executes <var>Goal1</var>. In case of success, all choice-points created by <var>Goal1</var> together with the choice-point for the else-part are removed and <var>Goal2</var> is executed. If <var>Goal1</var> fails then <var>Goal3</var> is executed.</p>
      </section>
      <section>
        <h2>Negation by Failure in Prolog</h2>
        <p>A goal <var>G</var> fails (or <kbd>not g</kbd> succeeds), if <var>G</var> cannot be derived from the consulted database.</p>
        <p>Here is how we might define operator <kbd>not</kbd>:</p>
        <pre>not X :- X, !, fail.
not X.</pre>
        <p>...</p>
      </section>
      <section>
        <h2>Prolog Programming Styles</h2>
        <p>There are two basic styles of developing logic programs: defining a logical database, and manipulating data structures.</p>
        <p>A logic database comprises a set of facts and rules. A set of facts can define relations, as in relational databases. And rules can define complex relational queries, as in relational algebra.</p>
        <p>Data structures in Prolog are based on <a html="lists_in_prolog">lists</a>.</p>
      </section>
      <section>
        <h2>Prolog Operators</h2>
        <p>Sometimes it is convenient to write some functors as <dfn>operators</dfn>. This is a form of syntax that makes some structures easier to read. For example, arithmetic operations are commonly written as operators. When we write the arithmetic expression <inlineequation>x + y * z</inlineequation>, we call the <q>plus</q> sign and the <q>multiply</q> sign <em>operators</em>. If we had to write the arithmetic expression <inlineequation>x + y*z</inlineequation> in the normal way for structures, it would look like this: <kbd>+(x,*(y,z))</kbd>, and this would be a legal Prolog term.</p>
        <p>The operators are sometimes easier to use, however, because we have grown accustomed to using them in arithmetic expressions ever since our schooldays. Also, the structure form requires that round brackets be placed around the functor's components, which may be awkward at times.</p>
        <p>It is important to note that the operators do not <em>cause</em> any arithmetic to be carried out. So in Prolog, <kbd>3+4</kbd> does not mean the same thing as <kbd>7</kbd>. The term <kbd>3+4</kbd> is another way to write the term <kbd>+(3,4)</kbd>, which is a data structure.</p>
        <p>First we need to know how to read arithmetic expressions that have operators in them. To do this, we need to know three things about each operator: its <em>position</em>, its <em>precedence</em>, and its <em>associativity</em>. In this section we will describe how to use Prolog operators with these three things in mind, but we will not go into very much detail. Although many different kinds of operators can be made up, we shall deal only with the familiar atoms +, -, *, and /.</p>
        <p>The <dfn>precedence</dfn> of an operator is used to indicate which operation is carried out first. Each operator that is used in Prolog has a precedence class associated with it. The precedence class is an integer that is associated with an operator. The exact value of the integer depends on the particular version of Prolog you are using. However, it is always true that an operator with a higher precedence has a precedence class that is closer to 1. If precedence classes range from 1 to 255, then an operator in the first precedence class is carried out first, before operators belonging to the 129th (say) precedence class. In Prolog the multiplication and division operators are in a higher precedence class than addition and subtraction, so the term <kbd>a-b/c</kbd> is the same as the term <kbd>-(a,/(b,c))</kbd>. The exact association of operators to precedence classes is not important at the moment, but it is worth remembering the relative order in which operations are carried out.</p>
        <p>Finally, consider how different operators associate. How they associate comes to our attention when we have several operators of the same precedence. When we see the expression <inlineequation>8/2/2</inlineequation>, does this mean <inlineequation>(8/2)/2</inlineequation> or <inlineequation>8/(2/2)</inlineequation>? In the first case, the expression could be interpreted to mean <inlineequation>2</inlineequation>, and in the second case, <inlineequation>8</inlineequation>. To be able to distinguish between these two cases, we must be able to tell whether an operator is left associative or right associative. A <dfn>left associative</dfn> operator must have the same or lower precedence operations on the left, and lower precedence operations on the right. For example, all the arithmetic operations (add, subtract, multiply, and divide) are left associative. This means that expressions like <kbd>8/4/4</kbd> are parsed as <inlineequation>(8/4)/4</inlineequation>. Also, <kbd>5+8/2/2</kbd> is read as <inlineequation>5+((8/2)/2)</inlineequation>.</p>
        <note>Remember that a structure made up of arithmetic operators is like any other structure. No arithmetic is actually carried out until commanded by the <q>is</q> predicate.</note>
        <section id="equality_and_unification">
        <h3>Equality and Unification</h3>
          <blockquote>There really is no equivalent of the assignment in prolog, and you should <em>not</em> use the dynamic database for this purpose.</blockquote>
          <p>One noteworthy built-in predicate is equality, which is an infix operator written as <kbd>=</kbd>. When an attempt is made to satisfy the goal</p>
          <pre>?- X = Y.</pre>
          <p>(pronounced <q>X equals Y</q>), Prolog attempts to unify <var>X</var> and <var>Y</var>, and the goal succeeds if they unify. We can think of this act as <em>trying to make X and Y equal</em>. The equality predicate works as though it were defined by the following fact:</p>
          <pre>X = X.</pre>
          <section id="strict_equality_in_prolog">
        <h4>Strict Equality (<kbd>X == Y</kbd>)</h4>
            <p>The predicate <kbd>==</kbd> represents a much stricter equality test than <kbd>=</kbd>. That is, if <kbd>X == Y</kbd> ever succeeds then <kbd>X = Y</kbd> does as well. On the other hand, this is not so the other way round. The way that <kbd>==</kbd> is more strict is by the way it considers variables. The <kbd>=</kbd> predicate will consider an uninstantiated variable to be equal to anything, because it will match anything. On the other hand, <kbd>==</kbd> will only consider an uninstantiated variable to be equal to another uninstantiated variable that is already sharing with it. Otherwise the test will fail. So we get the following behaviour:</p>
            <pre>?- X == Y.
no
?- X == X.
X = _23
?- X=Y, X==Y.
X = _23, Y = _23
?- append([A|B], C) == append(X, Y).
no
?- append([A|B], C) == append([A|B], C).
A = _23, B = _24, C = _25</pre>
          </section>
          <section>
            <title>
              <kbd/>
            </title>
          </section>
          <section>
            <title>
              <kbd/>
            </title>
          </section>
        </section>
        <section>
        <h3>Arithmetic in Prolog</h3>
          <p>Arithmetic can be used for calculating. For example, if we know the population and ground area of a country, we can calculate the population density of the country. The population density tells us how crowded the country would be if all the people were evenly spread throughout the country. Consider the following database about the population and area of various countries in 1976. We will use the predicate <kbd>population</kbd> to represent the relationship between a country and its population. Nowadays, the populations of countries are generally quite large numbers. So, we will represent population figures in millions: <kbd>population(X, Y)</kbd> means <q>the population of country X is about Y million people</q>. The predicate <kbd>area</kbd> will denote the relationship between a country and its area (in millions of square miles). The numbers given here are not exact, but they will do for the purpose of demonstrating arithmetic:</p>
          <pre>population(usa, 203).
population(india, 548).
population(china, 800).
population(brazil, 108).
area(usa, 3).
area(india, 1).
area(china, 4).
area(brazil, 3).</pre>
          <p>Now to find the population density of a country, we must use the rule that the density is the population divided by the area. This can be represented as the predicate <kbd>density</kbd>, where the goal <kbd>density(X,Y)</kbd> succeeds for country X having Y as the population density of that country. A Prolog rule for this is:</p>
          <pre>density(C, Y) :-
  population(C, P),
  area(C, A),
  Y is P / A.</pre>
          <p>We need to use built-in infix predicator <kbd>is</kbd> to cause evaluation and then unification.</p>
          <p class="bridgehead"><i>Standard Arithmetic Operators in Prolog</i></p>
          <p>Depending on what computer you use, various arithmetic operators can be used</p>
          on the right-hand side of the <kbd>is</kbd> operator. All Standard Prolog systems, however, will have the following, as well as many more:
          <ul>
            <listitem><kbd>X + Y</kbd>: the sum of X and Y</listitem>
            <listitem><kbd>X - Y</kbd>: the difference of X and Y</listitem>
            <listitem><kbd>X * Y</kbd>: the product of X and Y</listitem>
            <listitem><kbd>X / Y</kbd>: the quotient of X divided by Y</listitem>
            <listitem><kbd>X // Y</kbd>: the integer quotient of X divided by Y</listitem>
            <listitem><kbd>X mod Y</kbd>: the remainder of X divided by Y</listitem>
          </ul>
        </section>
        <!-- end of "Arithmetic in Prolog" -->
        <section>
        <h3>Numerical Comparison Operators in Prolog</h3>
          <p>Given two numbers, we can tell whether one number is equal to the other, or less than the other, or greater than the other. Prolog provides certain built-in predicates for comparing numbers. Actually these predicates evaluate terms that are treated as arithmetic expressions. The arguments could be variables instantiated to integers, or they could be integers written as constants, or they could be more general expressions. Here we will use these predicates just for comparing numbers, but later we'll use them in general arithmetic expressions. Note that we are allowed to write them as infix operators:</p>
          <ul>
            <listitem><kbd>X =:= Y</kbd>: X and Y stand for the same number</listitem>
            <listitem><kbd>X =\= Y</kbd>: X and Y stand for different numbers</listitem>
            <listitem><kbd>X &lt; Y</kbd>: X is less than Y</listitem>
            <listitem><kbd>X &gt; Y</kbd>: X is greater than Y</listitem>
            <listitem><kbd>X =&lt; Y</kbd>: X is less than or equal to Y</listitem>
            <listitem><kbd>X &gt;= Y</kbd>: X is greater than or equal to Y</listitem>
          </ul>
          <p>Note that the <q>less than or equal to</q> symbol is <em>not</em> written as <q>&lt;=</q> as in many programming languages. This is done so that the Prolog programmer is free to use the <q>&lt;=</q> atom, which looks like an arrow, for other purposes.</p>
          <section>
            <title>
              <kbd>X=Y</kbd>
            </title>
            <p>The <a html="equality_and_unification">equality</a> predicate, when applied on numbers, succeeds when two number arguments are the same. However, if one of the arguments is a variable, the equality predicate will cause the variable to be instantiated because the equality predicate performs a unification of its two arguments. In many numeric calculations, this is not desirable. Instead, Prolog makes available predicates specifically for comparing equality and inequality of numbers. In all of the following predicates, both arguments must be instantiated, or an error occurs. Using these predicates for numeric calculation can also cause the program to be executed more efficiently.</p>
          </section>
          <section>
            <title>
              <kbd>=:=</kbd>
            </title>
            <p>This numeric equality predicate succeeds when the left-hand number argument is equal to the right-hand number argument.</p>
          </section>
          <section>
            <title>
              <kbd>=\=</kbd>
            </title>
            <p>This numeric equality predicate succeeds when the left-hand number argument is <em>not</em> equal to the right-hand number argument.</p>
          </section>
        </section>
        <!-- end of "Numerical Comparison Operators in Prolog" -->
        <section>
        <h3>Comparing Arbitrary Terms</h3>
          <p>They start with character <kbd>@</kbd>: <kbd>@&lt;</kbd>, <kbd>@&gt;</kbd>, <kbd>@&gt;=</kbd>, and <kbd>@=&lt;</kbd>.</p>
          <p>Here are the principles that determine whether one term is considered less than another:</p>
          <ul>
            <listitem>All uninstantiated variables are less than all floating-point numbers, which are less than all integers, which are less than all atoms, which are less than all structures.</listitem>
            <listitem>For two non-sharing uninstantiated variables, one will be less than the other (which one is less may be different in different Prolog implementations). A floating point number is less than another floating point number or an integer is less than anothe integer in the expected way.</listitem>
            <listitem>One atom is less than another if it would come earlier than it in the normal dictionary ordering. To be precise, the ordering depends on the character codes, but these are usually ordered as one would expect, at least for alphabetic characters.</listitem>
            <listitem>One structure is less than another if its functor has a lower arity. If two structures have the same arity, one is less than the other if its functor is less than the other (using the ordering for atoms). If two structures have the same arity and functor, they are ordered by considering the arguments in turn &#x2013; for the first corresponding arguments that differ, the order of the structures is the order of the relevant arguments.</listitem>
          </ul>
        </section>
        <section>
        <h3>Declaring Operators with Predicate <kbd>op/3</kbd></h3>
          <p>In Prolog, if we wish to declare that an operator with a given position, precedence class, and associativity is to be recognised when terms are read and written, we use the built-in predicate <kbd>op</kbd>. If <var>Name</var> is the desired operator (the atom that we want to be an operator), <var>Prec</var> the precedence class (an integer within the appropriate range), and <var>Spec</var> the position/associativity specifier (one of the above atoms), then the operator is declared by providing the following goal:</p>
          <pre>?- op(Prec, Spec, Name).</pre>
          <p>As an example of declaring operators, the following is a list of the most important operators that are already defined in Standard Prolog:</p>
          <pre>?- op( 1200, xfx, &amp;apos;:-&amp;apos; ).
?- op( 1200, fx, '?-' ).
?- op( 1200, fx, ':-' ).
?- op( 1100, xfy, ';' ).
?- op( 1000, xfy, ',' ).
?- op( 900, fy, '\+' ).
?- op( 700, xfx, '=').
?- op( 700, xfx,\=).
?- op( 700, xfx, '==' ).
?- op( 700, xfx, \== ).
?- op( 700, xfx, '=..' ).
?- op( 700, xfx, '&lt;' ).
?- op( 700, xfx, '&gt;' ).
?- op( 700, xfx, '=&lt;' ).
?- op( 700, xfx, '&gt;=' ).
?- op( 700, xfx, '@&lt;' ).
?- op( 700, xfx, '@=&lt;' ).
?- op( 700, xfx, '@&gt;' ).
?- op( 700, xfx, '@&gt;=' ).
?- op( 700, xfx, 'is' ).
?- op( 500, yfx, '+' ).
?- op( 500, yfx, '-' ).
?- op( 400, yfx, '*' ).
?- op( 400, yfx, '//' ).
?- op( 400, yfx, '/' ).
?- op( 400, yfx, 'mod' ).
?- op( 200, fy, '-').</pre>
          <p>...</p>
          <p>An operator declared <kbd>yfx</kbd> is left associative. Similarly, an operator declared xfy is right associative.</p>
          <p>Note that the meanings of <kbd>x</kbd> and <kbd>y</kbd> (in terms of what other operators can appear unbracketed in the relevant position) are the same in all the other cases as well. This means that, for instance, the sequence</p>
          <pre>not not a</pre>
          <p>is legal syntactically if not is declared as <kbd>fy</kbd>, but is illegal if it is declared <kbd>fx</kbd>.</p>
          <p>...</p>
        </section>
      </section>
      <!-- end of "Prolog Operators" -->
      <section>
        <h2>File I/O in Prolog</h2>
        <section>
        <h3>Prolog Input and Output</h3>
          <p>Here are some predicates for reading from <em>the</em> input stream and writing to <em>the</em> output stream:</p>
          <section>
        <h4>Reading and writing one character</h4>
            <p>The goal <kbd>get_char(<var>X</var>)</kbd> succeeds if <var>X</var> can be matched with the next character encountered on the current input stream. <kbd>get_char</kbd> succeeds only once (it cannot be re-satisfied). The operation of moving to the next character is not undone on backtracking, because there is no way to put a character back onto the current input stream.</p>
            <p>The goal <kbd>put_char(<var>X</var>)</kbd> writes the character <var>X</var> on the current output stream. <kbd>put_char</kbd> succeeds only once. An error occurs if <var>X</var> is not instantiated.</p>
          </section>
          <section>
        <h4>Reading and Writing a Term</h4>
            <p>The goal <kbd>read(X)</kbd> reads the next term from the current input stream and matches it with <var>X</var>. A read succeeds only once. The term must be followed by a dot <q>.</q>, which does not become a part of the term, and at least one non-printing character. The dot is removed from the current input stream</p>
            <p>The goal <kbd>write(X)</kbd> writes the term <var>X</var> to the current output stream. <kbd>write</kbd> succeeds only once. Any uninstantiated variables in <var>X</var> are written as uniquely numbered variables beginning with an underscore, such as <q>_239</q>. Co-referring variables within the same argument to write have the same number when they are printed out. The predicate <kbd>write</kbd> takes account of current operator declarations when it prints a term. Thus an infix operator will be printed out between its arguments, for instance.</p>
            <p>The predicate <kbd>write_canonical</kbd> works in exactly the same way as <kbd>write</kbd>, except that it ignores any operator declarations. When <kbd>write_canonical</kbd> is used, any structure is printed out in prefixed notation with the functor first and the arguments in brackets afterwards.</p>
          </section>
          <section>
        <h4>Effecting a New Line</h4>
            <p>The goal <kbd>nl</kbd> writes a control sequence to the current output stream that causes a <q>new line</q>. On a computer display, all characters after the use of <kbd>nl</kbd> appear on the next line of the page. <kbd>nl</kbd> succeeds only once.</p>
          </section>
        </section>
        <section>
        <h3>Handling Files</h3>
          <p>The following predicates open and close files, get file handles, and set current input and output streams.</p>
          <section>
            <title>
              <kbd>open(X, Y, Z)</kbd>
            </title>
            <p>This goal opens a file whose name is <var>X</var> (an atom). If <var>Y</var> is <kbd>read</kbd> then the file is opened for reading; otherwise if <var>Y</var> is <kbd>write</kbd> then the file is opened for writing. <var>Z</var> is instantiated to a special term naming the stream that must be referred to when the file is accessed later. An error occurs if <var>X</var> is not instantiated, or if <var>X</var> names a file that does not exist.</p>
          </section>
          <section>
            <title>
              <kbd>close(X)</kbd>
            </title>
            <p>This is used when <var>X</var> is a term naming a stream. The stream is closed and can no longer be used.</p>
          </section>
          <section>
            <title>
              <kbd>set_input(X)</kbd>
            </title>
            <p>Sets the current input to the stream whose name is provided by <var>X</var>. <var>X</var> will be a term returned in the third argument of <kbd>open</kbd>, or the atom <kbd>user_input</kbd>, which specifies that input is to come from the keyboard.</p>
          </section>
          <section>
            <title>
              <kbd>set_output(X)</kbd>
            </title>
            <p>Sets the current output to the stream whose name is provided by <var>X</var>. <var>X</var> will be a term returned in the third argument of <kbd>open</kbd>, or the atom <kbd>user_output</kbd>, which specifies that output is to go to the computer display.</p>
          </section>
          <section>
            <title>
              <kbd>current_input(X)</kbd>
            </title>
            <p>This goal succeeds if the name of the current input stream matches with <var>X</var>, and fails otherwise.</p>
          </section>
          <section>
            <title>
              <kbd>current_output(X)</kbd>
            </title>
            <p>This goal succeeds if <var>X</var> matches with the name of the current output stream, and fails otherwise.</p>
          </section>
        </section>
      </section>
      <!-- end of "File I/O in Prolog" -->
      <section>
        <h2>Prolog Meta-Predicates</h2>
        <p>These predicates query and manipulate other predicates rather than the terms or objects that the other, non-meta predicates denote. Some of them are:</p>
        <ul>
          <listitem><command>var(<var>X</var>)</command>, which succedes only when <var>X</var> is an unbound variable;</listitem>
          <listitem><command>nonvar(<var>X</var>)</command>, which succedes only when <var>X</var> is bound to a nonvariable term;</listitem>
          <listitem><command>=..</command>, which creates a list from a predicate term; for instance, <kbd>jump(tick,3)=..X</kbd> unifies <var>X</var> with <kbd>[jump,tick,3]</kbd>;</listitem>
          <listitem><a html="prolog_functor_predicate"><command>functor(A,B,C)</command></a> succeeds with <var>A</var> a term whose principal functor has name <var>B</var> and arity <var>C</var>; this predicate can be used to produce a predicate or to to produce all the terms with a given name and/or arity.</listitem>
          <listitem><a html="prolog_clause_predicate"><command>clause(A,B)</command></a> unifies <var>B</var> with the body of a clause whose head unifies with <var>A</var>;</listitem>
          <listitem><command>any_predicate(...,P,...) :- P</command> executes a predicate <var>P</var>, the argument of an arbitrary predicate: a predicate, here <var>P</var>, may be passed as a parameter and executed at any desired time in the computation;</listitem>
          <listitem><a html="prolog_call_predicate"><command>call(C)</command></a>, where <var>C</var> is a clause, also succeeds with the execution of predicate <var>C</var>;</listitem>
        </ul>
        <p>Next some of these predicates will be explained further:</p>
        <section id="prolog_clause_predicate">
          <title>
            <kbd>clause(X,Y)</kbd>
          </title>
          <p>Satisfying a goal of the form <kbd>clause(X, Y)</kbd> causes <var>X</var> and <var>Y</var> to be matched with the head and body of an existing clause (for a <q>public</q> predicate) in the database. When an attempt is made to satisfy the goal, <var>X</var> must be instantiated enough so that the main predicate of the clause is known. If there are no clauses for the predicate, the goal just fails. If there is more than one clause that matches, Prolog will choose the first one. In this case, if an attempt is made to re-satisfy the goal, the other matching clauses will be chosen, one at a time.</p>
          <p>Notice that, although <kbd>clause</kbd> always has an argument for the body of a clause, not every clause actually has a body. If a clause does not have a body, it is considered to have the dummy body <kbd>true</kbd>. We have been calling such clauses <q>facts</q>. By providing <var>X</var>'s and <var>Y</var>'s that are more or less instantiated, you can look for either all the clauses for a given predicate and number of arguments, or all the ones that match some pattern.</p>
        </section>
        <section id="prolog_functor_predicate">
          <title>
            <kbd>functor(T, F, N)</kbd>
          </title>
          <p>The predicate <kbd>functor</kbd> is defined in such a way that <kbd>functor(<var>T</var>,<var>F</var>,<var>N</var>)</kbd> means, <q><var>T</var> is a structure with functor [name] <var>F</var> and arity (number of arguments) <var>N</var></q>. It can be used in basically two ways. In the first way, <var>T</var> is already instantiated. The goal fails if <var>T</var> is not an atom or a structure. If <var>T</var> is an atom or structure, <var>F</var> is matched with the functor and <var>N</var> is matched with the integer giving the arity (number of arguments) of the functor. Note that in this context, an atom is considered to be like a structure with arity 0.</p>
          <p>Here are some examples of goals involving functor:</p>
          <pre>?- functor(f(a, b, g(Z)), F, N).
Z = _23, F = f, N = 3
?- functor(a + b, F, N).
F = +, N = 2
?- functor([a, b, c], F, N).
F = ., N = 2
?- functor(apple, F, N).
F = apple, N = 0
?- functor([a, b, c], '.', 3).
no
?- functor([a, b, c], a, Z).
no</pre>
          <p>There is a second use to <kbd>functor</kbd>. This occurs when the first argument of the goal (<var>T</var>) is uninstantiated. In this case, both of the others must be instantiated: specifying a functor and a number of arguments respectively. A goal of this form will always succeed, and as a result <var>T</var> will become instantiated to a structure with the functor and number of arguments provided. So this is a way of constructing arbitrary structures, given a specification in terms of a functor [name] and its number of arguments. The arguments of such a structure constructed by <code class="function">functor</code> are uninstantiated variables. Hence the structure will match any other structure with the same <code class="function">functor</code> and number of arguments.</p>
          <p class="bridgehead"><i>Copying an Existing Structure with <kbd>function/3</kbd></i></p>
          <p>A common use of functor to create a structure is when we wish to make a <q>copy</q> of an existing structure with new variables as the arguments of the principal functor. We can encapsulate this use in the definition of a predicate <kbd>copy</kbd>, as follows:</p>
          <pre>copy(Old, New) :- functor(Old, F, N), functor(New, F, N).</pre>
          <p>Here, two functor goals occur adjacently. If the copy goal has the first argument instantiated and the second uninstantiated, then the following will happen. The first functor goal will involve the first possible use of the predicate (because the first argument will be instantiated). Hence <var>F</var> and <var>N</var> will become instantiated to the functor and number of arguments of this existing structure. The second functor goal uses the predicate in the second way. This time the first argument is uninstantiated, and the information in <var>F</var> and <var>N</var> is used to construct the structure <var>New</var>. This is a structure involving the same functor and number of arguments as <var>Old</var>, but with variables as its components. Thus we would get interactions like:</p>
          <pre>?- copy(sentence(np(n(john)), v(eats)), X).
X = sentence(_23, _24)</pre>
        </section>
        <section>
        <h3>Accessing Arguments in a Structure Through <kbd>arg(N,T,A)</kbd></h3>
          <p>The predicate <kbd>arg</kbd> must always be used with its first two arguments instantiated. It is used to access a particular argument of a structure. The first argument of <kbd>arg</kbd> specifies which argument is required. The second specifies the structure that the argument is to be found inside. Prolog finds the appropriate argument and then tries to match it with the third argument. Thus <kbd>arg(N, T, A)</kbd> succeeds if the Nth argument of <var>T</var> is <var>A</var>. Let us look at some goals involving <kbd>arg</kbd>.</p>
          <pre>?- arg(2, related(john, mother(jane)), X).
X = mother(jane)
?- arg(1, a+(b+c), X).
X=a
?- arg(2, [a,b,c], X).
X = [b,c]
?- arg(1, a+(b+c), b).
no</pre>
          <!-- <p class="bridgehead"/> -->
          <p>Sometimes we will want to use functor and arg when the possible structures <em>are</em> known. This is because there may be so many arguments that it is inconvenient to specify them every time. Consider an example where we use structures to represent books. We might have a component for the title, the author, the publisher, the date of publication, and so on. Let us say that the resulting structures have fourteen components. We might write the following useful definitions:</p>
          <pre>is_a_book(book(_,_,_,_,_,_,_,_,_,_,_,_,_,_)).
title(book(T,_,_,_,_,_,_,_,_,_,_,_,_,_), T).
author(book(_,A,_,_,_,_,_,_,_,_,_,_,_,_), A).</pre>
          <p>In fact, we can write these much more compactly as:</p>
          <pre>is_a_book(X) :- functor(X, book, 14).
title(X, T) :- is_a_book(X), arg(1, X, T).
author(X, A) :- is_a_book(X), arg(2, X, T).</pre>
        </section>
        <section id="prolog_univ_predicate">
          <title>
            <kbd>X =.. L</kbd>
          </title>
          <p>The predicates <kbd>functor</kbd> and <kbd>arg</kbd> provide one way of creating and accessing arguments of arbitrary structures. The predicate <kbd>=..</kbd> (pronounced <q>univ</q> for historical reasons) provides an alternative way, which is useful if you want to obtain the arguments of a structure all together, or if you want to construct a structure, given a list of arguments.</p>
          <p>The goal <kbd>X =.. L</kbd> means, <q><var>L</var> is the list consisting of the functor of <var>X</var> followed by the arguments of <var>X</var>.</q></p>
          <p>Such a goal can be used in two ways, in the same way that a <kbd>functor</kbd> goal can. If <var>X</var> is instantiated, Prolog constructs the appropriate list and tries to match it with <var>L</var>. Alternatively, if <var>X</var> is uninstantiated, the list will be used to construct an appropriate structure for <var>X</var> to stand for. In this case, the head of <var>L</var> must be an atom (it will become the functor of <var>X</var>). Here are some examples of <kbd>=..</kbd> goals:</p>
          <pre>?- foo(a,b,c) =.. X.
X = [foo,a,b,c]
?- [a,b,c,d] =.. L.
L = ['.',a,[b,c,d]].
?- (a+b) =.. L.
L = [+,a,b].
?- (a+b) =.. [+,X,Y].
X = a, Y = b.
?- [a,b,c,d] =.. [X|Y].
X = '.', Y = [a,[b,c,d]]
?- X =.. [a,b,c,d].
X = a(b,c,d)</pre>
        </section>
        <section id="prolog_call_predicate">
          <title>
            <kbd>call(<var>X</var>)</kbd>
          </title>
          <p>It is assumed that <var>X</var> is instantiated to a term that can be interpreted as a goal. The <kbd>call(X)</kbd> goal succeeds if an attempt to satisfy <var>X</var> succeeds. The <kbd>call(X)</kbd> goal fails if an attempt to satisfy <var>X</var> fails. At first sight, this predicate may seem redundant, because one might ask why the argument of call shouldn't simply appear by itself as a goal?</p>
          <p>For instance, the goal</p>
          <pre>..., call(member(a, X)),...</pre>
          <p>can always be replaced by</p>
          <pre>..., member(a, X),...</pre>
          <p>However, if we are constructing goals by using the <kbd>=..</kbd> predicate or <kbd>functor</kbd> and <kbd>arg</kbd>, then it is possible to call goals that have a functor that is unknown at the time you type in your program.</p>
          <p>Assuming that <var>P</var>, <var>X</var>, and <var>Y</var> are instantiated to a functor and arguments appropriately, <kbd>call</kbd> can be used as follows:</p>
          <pre>..., Z =.. [P,X,Y], call(Z),...</pre>
        </section>
        <section id="prolog_not_predicate">
        <h3>Negating with <kbd>\+ X</kbd></h3>
          <p>The <kbd>\+</kbd> predicate (pronounced <q>not</q>) is declared as a prefix operator. It is assumed that <var>X</var> is instantiated to a term that can be interpreted as a goal. The <kbd>\+ X</kbd> goal succeeds if an attempt to satisfy <var>X</var> fails. The <kbd>\+ X</kbd> goal fails if an attempt to satisfy <var>X</var> succeeds. In this way, <kbd>\+</kbd> is rather like <a html="prolog_call_predicate"><kbd>call</kbd></a>, except that the success or failure of the argument, interpreted as a goal, is reversed.</p>
        </section>
        <section>
        <h3>Adding and Removing Rules</h3>
          <p>You use <kbd>assert</kbd>, <kbd>asserta</kbd>, <kbd>assertz</kbd> and <kbd>retract</kbd> to add and remove rules. They will only work on the definitions of predicates which have been declared <q>dynamic</q> . The intention again is to prevent accidental unplanned changing of definitions. A predicate foo/4 can be declared as <q>dynamic</q> by including the following in the relevant program file (before the definition of <kbd>foo/4</kbd> or, if there is no definition, before the code that uses asserta etc.):</p>
          <pre>:- dynamic foo/4.</pre>
          <p>Several predicates can be declared as dynamic on one line by separating them with commas, e.g:</p>
          <pre>:- dynamic foo/4, baz/3.</pre>
          <p class="warning"><strong>Warning:</strong> These commands are deprecated because they create and remove global structures, introduce side effects and may cause other problems associated with poorly structured programs.</p>
        </section>
        <section>
        <h3>Working with Characters</h3>
          <p>The following two predicates compose and decompose an atom into its characters.</p>
          <section>
        <h4>atom_chars(A,L)</h4>
            <p>Predicate <kbd>atom_chars</kbd> relates an atom to the list of characters (atoms with one element) that make it up. This can be used either to find the characters for a given atom, or to find the atom that has some given characters. The goal <kbd>atom_chars(A,L)</kbd> means that <q>the characters for the atom <var>A</var> are the members of the list <var>L</var></q>. If the argument <var>A</var> is instantiated, Prolog creates the list of characters and tries to match them with <var>L</var>. Otherwise Prolog uses the list <var>L</var> to make an atom for <var>A</var> to stand for. Example uses of <kbd>atom_chars</kbd> are as follows:</p>
            <pre>?- atom_chars(apple, X).
X = [a,p,p,l,e]
?- atom_chars(X, [a,p,p,l,e]).
X = apple</pre>
          </section>
          <section>
            <title>
              <kbd>number_chars(A,L)</kbd>
            </title>
            <p>This predicate is just like <kbd>atom_chars</kbd> except that it works with numbers, rather than atoms. Notice that in:</p>
            <pre>?- atom_chars(X, ['1' ,'2', '3']).</pre>
            <p>the variable <var>X</var> will be instantiated to the atom '123'. If we want it to be a number instead, we need to use <kbd>number_chars</kbd>. Here are some uses of <kbd>number_chars</kbd>:</p>
            <pre>?- number_chars(123.5, X).
X = ['1', '2', '3', '.', '5']
?- number_chars(X, ['1', '2', '3']).
X = 123</pre>
          </section>
        </section>
      </section>
      <section>
        <h2>Recursive Control Loop</h2>
        <p>The purity of logic programming is undermined by the asserts and retracts of the database. Using these makes code unpredictable, since the behavior of the code depends on global data whose value might change.</p>
        <p>Because logical variables cannot have their values changed by assignment, the commands must take two arguments representing the old state and the new state. The repeat-fail control structure will not let us repeatedly change the state in this manner, so we need to write a recursive control structure that recursively sends the new state to itself.</p>
        <p>This style of Prolog programming is logically purer, and lends itself to certain types of applications. It also avoids the difficulties often associated with global data. On the other hand, it requires more complexity in dealing with state information in arguments, and the multiple lists and recursive routines can be confusing to debug. You will have to decide which approach to use for each application you write.</p>
        <p>There could be serious performance problems with this approach. Prolog uses a stack to keep track of the levels of predicate calls. In the case of a recursive predicate, the stack grows at each recursive call. The stack could easily be consumed in a short period of time by the recursive control structure.</p>
        <p>Fortunately, there is a performance feature built into most Prologs that makes these programs behave efficiently.</p>
        <section>
        <h3>Tail Recursion</h3>
          <p>There are actually two kinds of recursive routines. In a true recursive routine, each level must wait for the information from the lower levels in order to return an answer. This means that Prolog must build a stack with a new entry for each level.</p>
          <p>This is in contrast to iteration, which is more common in conventional languages. Each pass through the iteration updates the variables and there is no need for building a stack.</p>
          <p>There is a type of recursion called <dfn>tail recursion</dfn> that, while written recursively, behaves iteratively. In general, if the recursive call is the last call, and there are no computations based on the information from the lower levels, then a good Prolog interpreter can implement the predicate iteratively, without growing the stack.</p>
          <p>One classic example of tail recursion is the factorial predicate. First we'll write it using normal recursion. Note that the variable <var>FF</var>, which is returned from the lower level, is used in the top level.</p>
          <pre>factorial_1 (1,1).
factorial_1 (N,F):-
  N &gt; 1,
  NN is N - 1,
  factorial_1 (NN,FF),
  F is N * FF.</pre>
          <p>It works as expected.</p>
          <pre>?- factorial_1 (5,X).
x = 120</pre>
          <p>By introducing a new second argument to keep track of the result so far, we can rewrite factorial tail-recursively. The new argument is initially set to 1. Each recursive call builds on the second argument. When the boundary condition is reached, the third argument is bound to the second argument.</p>
          <pre>factorial_2(1,F,F).
factorial_2(N, T, F) :-
  N &gt;1,
  TT is N * T,
  NN is N - 1,
  factorial_2(N N, TT, F).</pre>
          <p>It gives the same results as the previous version, but because the recursive call is the last call in the second clause, its arguments are not needed at each level.</p>
          <pre>7- factorial_2(5,1,X).
x = 120</pre>
          <!-- <p class="bridgehead"/> -->
          <p>By introducing a new second argument which will accumulate the partial answer through levels of recursion, we can rewrite reverse. It turns out that the partial answer is already reversed when it reaches the boundary condition.</p>
          <pre>reverse{[], Rev, Rev).
reverse([HIT], Temp, Rev) :-
  reverse(T ,[H ITemp], Rev).</pre>
          <p>We can now try the second reverse.</p>
          <pre>?- reverse([ants, mice, zebras], [], X).
X = [zebras, mice, ants]</pre>
        </section>
      </section>
      <section>
        <h2>Abstract Data Types and Search</h2>
        <section id="recursion_based_graph_search">
        <h3>Recursion-Based Graph Search</h3>
          <p>We next introduce the 3 x 3 knight's tour problem, create a predicate calculus based representation of problem states, and a recursive search of its state space. The chess knight can move on a restricted board as on any regular chessboard: two squares one direction (horizontally or vertically) and one in the other (vertically or horizontally). Thus, the knight can go from square 1 to either square 6 or 8 or from square 9 to either 2 or 4. We ask if the knight can generate a sequence on legal moves from one square to another on this restricted chessboard, from square 1 to 9, for example. The knight's moves are represented in Prolog using <kbd>move</kbd> facts.</p>
          <p>The <kbd>path</kbd> predicate defines an algorithm for a path between its two arguments, the present state, X, and the goal that it wants to achieve, Y. To do this it first tests whether it is where it wants to be, <kbd>path(Z, Z)</kbd>, and if not, looks for a state, W, to move to.</p>
          <p>The Prolog search defined by <kbd>path</kbd> is a recursive, depth-first, left-to-right, tree walk. As shown before, <kbd>assert</kbd> is a built-in Prolog predicate that always succeeds and has the side effect of placing its argument in the database of specifications. The <kbd>been</kbd> predicate is used to record each state as it is visited and then <kbd>not(been(X))</kbd> determines, with each new state found whether that state has been previously visited, thus avoiding looping within the search space.</p>
          <pre>path(Z, Z).
path(X, Y) :-
  move(X, W), not(been(W)), assert(been(W)),
  path(W, Y).</pre>
          <p>This use of the <kbd>been</kbd> predicate violates good programming practice in that it uses global side-effects to control search. <kbd>been(3)</kbd>, when asserted into the database, is a fact available to any other predicate and, as such, has global extension. We created <kbd>been</kbd> to modify the program execution.</p>
          <p>A more sophisticated method for control of search is to create a list that keeps track of visited states. We create this list and make it the third argument of the <kbd>path</kbd> predicate. As each new state is encountered, the <kbd linkend="member_in_prolog">member</kbd> predicate<?see Section 2.3,?> checks whether or not it is already a visited state. If the state is not a member of the list we put it on this list in the order in which it was encountered, the most recent state encountered the head of the list. If the new state is on the list of already visited states, the path predicate backtracks looking for new non-visited states. This approach remedies the problems of using global <kbd>been(W)</kbd>. The following clauses implement depth-first left-to right graph search with backtracking.</p>
          <pre>path(Z, Z, L).
path(X, Y, L) :-
  move(X, Z), not(member(Z, L)),
  path(Z, Y, [Z|L]).</pre>
          <para/>
        </section>
        <section id="ADTs_in_Prolog">
        <h3>Abstract Data Types in Prolog</h3>
          <?source Luger and Stubblefield: <citetitle class='book'>Algorithms, Data Structures, and Idioms in Prolog, Lisp, and Java</citetitle>, Pearson 2009?>
          <p>Programming, in almost any environment, is enhanced by creating procedural abstractions and by hiding information. Because the set, stack, queue, and priority queue data structures are important support constructs for graph search algorithms, a major component of AI problem solving, we build them in Prolog in the present section.<?see We will use these ADTs in the design of the Prolog search algorithms presented in Chapter 4.?</p>>
          <p>Since lists, recursion, and pattern matching are the primary tools for building and searching graph structures, they are the pieces with which we build our ADTs. All list handling and recursive processing that define the ADT are <q>hidden</q> within the ADT abstraction, quite different than the normal static data structure.</p>
          <section>
        <h4>The Stack ADT in Prolog</h4>
            <p>A stack is a linear structure with access at one end only. Thus all elements must be added to, <dfn>pushed</dfn>, and removed, <dfn>popped</dfn>, from the structure at that access end. The stack is sometimes referred to as a <dfn>last-in-first-out</dfn> (LIFO) data structure. We will see its use with depth-first search<?see in Chapter 4?>. The operators that we will define for a stack are:</p>
            <ul>
              <listitem>1. Test whether the stack is empty.</listitem>
              <listitem>2. Push an element onto the stack.</listitem>
              <listitem>3. Pop or remove, the top element from the stack.</listitem>
              <listitem>4. Peek (often called Top) to see the top element on the stack without popping it.</listitem>
              <listitem>5. Member_stack, checks whether an element is in the stack.</listitem>
              <listitem>6. Add_list_to stack, adds a list of elements to the stack.</listitem>
            </ul>
            <note>Operators 5 and 6 may be built from 1&#x2013;4.</note>
            <p>We now build these operators in Prolog, using the list primitives:</p>
            <ul>
              <listitem>
                <p>1. <kbd>empty_stack([]).</kbd></p>
                <p>This predicate can be used either to test a stack to see whether it is empty or to generate a new empty stack.</p>
              </listitem>
              <listitem>
                <p>2&#x2013;4. <kbd>stack(Top, Stack, [Top | Stack]).</kbd></p>
                <p>This predicate performs the push, pop, and peek predicates depending on the variable bindings of its arguments. For instance, push produces a new stack as the third argument when the first two arguments are bound. Likewise, pop produces the top element of the stack when the third argument is bound to the stack. The second argument will then be bound to the new stack, once the top element is popped. Finally, if we keep the stack as the third argument, the first argument lets us peek at its top element.</p>
              </listitem>
              <listitem>
                <p>5. <kbd>member_stack(Element, Stack) :- member(Element, Stack).</kbd></p>
                <p>This allows us to determine whether an element is a member of the stack. Of course, the same result could be produced by creating a recursive call that peeked at the next element of the stack and then, if this element did not match Element, popped the stack. This would continue until the empty stack predicate was true.</p>
              </listitem>
              <listitem>
                <p>6. <kbd>add_list_to_stack(List, Stack, Result) :- append(List, Stack, Result).</kbd></p>
                <p>List is added to Stack to produce Result, a new stack. Of course, the same result could be obtained by popping List (until empty) and pushing each element onto a temporary stack. We would then pop the temporary stack and push each element onto the Stack until empty_stack is true for the temporary stack.</p>
              </listitem>
            </ul>
            <p>A final predicate for printing a stack in reverse order is <code class="function">reverse_print_stack</code>. This is very useful when a stack has, in reversed order, the current path from the start state to the present state of the graph search.</p>
            <pre>reverse_print_stack(S) :-
  empty_stack(S).
reverse_print_stack(S) :-
  stack(E, Rest, S),
  reverse_print_stack(Rest),
  write(E), nl.</pre>
          </section>
          <section>
        <h4>The Queue ADT in Prolog</h4>
            <p>A queue is a first-in-first-out (FIFO) data structure. It is often characterized as a list where elements are taken off or dequeued from one end and elements are added to or enqueued at the other end. The queue is used for defining breadth-first search.</p>
            <p>The queue operators are:</p>
            <ul>
              <listitem>
                <p>1. <kbd>empty_queue([]).</kbd></p>
                <p>This predicate tests whether a queue is empty or initializes a new empty queue.</p>
              </listitem>
              <listitem>
                <p>2.</p>
                <pre>enqueue(E, [ ], [E]).
enqueue(E, [H | T], [H | Tnew]) :-
enqueue(E, T, Tnew).</pre>
                <p>This recursive predicate adds the element E to a queue, the second argument. The new augmented queue is the third argument.</p>
              </listitem>
              <listitem>
                <p>3. <kbd>dequeue(E, [E|T], T).</kbd></p>
                <p>This predicate produces a new queue, the third argument, which is the result of taking the next element, the first argument, off the original queue, the second argument.</p>
              </listitem>
              <listitem>
                <p>4. <kbd>dequeue(E, [E|T], _).</kbd></p>
                <p>This predicate lets us peek at the next element, E, of the queue.</p>
              </listitem>
              <listitem>
                <p>5. <kbd>member_queue(Element, Queue) :- member(Element, Queue).</kbd></p>
                <p>This tests whether Element is a member of Queue.</p>
              </listitem>
              <listitem>
                <p>6. <kbd>add_list_to_queue(List, Queue, Newqueue) :- append(Queue, List, Newqueue).</kbd></p>
                <p>This predicate enqueues an entire list of elements. Of course, 5 and 6 can be created using 1&#x2013;4.</p>
              </listitem>
            </ul>
          </section>
          <section>
        <h4>The Priority Queue ADT in Prolog</h4>
            <p>A priority queue orders the elements of a regular queue so that each new element added to the priority queue is placed in its sorted order, with the <q>best</q> element first. The <code class="function">dequeue</code> operator removes the <q>best</q> sorted element from the priority queue. We will use the priority queue in the design of the best-first search algorithm<?see in Chapter 4?>.</p>
            <p>Because the priority queue is a sorted queue, many of its operators are the same as the queue operators, in particular, <code class="function">empty_queue</code>, <code class="function">member_queue</code>, and <code class="function">dequeue</code> (the <q>best</q> of the sorted elements will be next for the dequeue). <code class="function">enqueue</code> in a priority queue is the <code class="function">insert_pq operator</code>, as each new item is placed in its proper sorted order.</p>
            <pre>insert_pq(State, [ ], [State]) :- !.
insert_pq(State, [H | Tail], [State, H | Tail]) :-
  precedes(State, H).
insert_pq(State, [H | T], [H | Tnew]) :-
  insert_pq(State, T, Tnew).
precedes(X, Y) :- X &lt; Y. % &lt; depends on problem</pre>
            <p>The first argument of this predicate is the new element that is to be inserted. The second argument is the previous priority queue, and the third argument is the augmented priority queue. The <code class="function">precedes</code> predicate checks that the order of elements is preserved.</p>
            <p>Another priority queue operator is <code class="function">insert_list_pq</code>. This predicate is used to merge an unsorted list or set of elements into the priority queue, as is necessary when adding the children of a state to the priority queue for best-first search<?see Chapter 4?>. <code class="function">insert_list_pq</code> uses <code class="function">insert_pq</code> to put each individual new item into the priority queue:</p>
            <pre>insert_list_pq([ ], L, L).
insert_list_pq([State | Tail], L, New_L) :-
  insert_pq(State, L, L2),
  insert_list_pq(Tail, L2, New_L).</pre>
          </section>
          <section>
        <h4>The Set ADT in Prolog</h4>
            <p>A set is a collection of elements with no element repeated. Sets can be used for collecting all the children of a state or for maintaining the set of all states visited while executing a search algorithm.</p>
            <p>In Prolog a set of elements, e.g., {a,b}, may be represented as a list, <kbd>[a,b]</kbd>, with the order of the list not important. The set operators include <code class="function">empty_set</code>, <code class="function">member_set</code>, <code class="function">delete_if_in</code>, and <code class="function">add_if_not_in</code>. We also include the traditional operators for combining and comparing sets, including <code class="function">union</code>, <code class="function">intersection</code>, <code class="function">set_difference</code>, <code class="function">subset</code>, and <code class="function">equal_set</code>.</p>
            <pre>empty_set([ ]).
member_set(E, S) :-
  member(E, S).
delete_if_in_set(E, [ ], [ ]).
delete_if_in_set(E, [E | T], T) :- !.
delete_if_in_set(E, [H | T], [H | T_new]) :-
  delete_if_in_set(E, T, T_new), !.
add_if_not_in_set(X, S, S) :-
  member(X, S), !.
add_if_not_in_set(X, S, [X | S]).
union([ ], S, S).
union([H | T], S, S_new) :-
  union(T, S, S2),
add_if_not_in_set(H, S2, S_new),!.
subset([], _).
subset([H | T], S) :-
  member_set(H, S),
subset(T, S).
intersection([], _, []).
intersection([H | T], S, [H | S_new]) :-
  member_set(H, S),
  intersection(T, S, S_new), !.
intersection([_ | T], S, S_new) :-
  intersection(T, S, S_new), !.
set_difference([ ], _, [ ]).
set_difference([H | T], S, T_new) :-
  member_set(H, S),
  set_difference(T, S, T_new), !.
set_difference([H | T], S, [H | T_new]) :-
  set_difference(T, S, T_new), !.
equal_set(S1, S2) :-
  subset(S1, S2),
  subset(S2, S1).</pre>
            <p><?see In Chapters 4 and 5 ?>we use many of these abstract data types to build more complex graph search algorithms and meta-interpreters in Prolog. For example, the stack and queue ADTs are used to build the <q>open</q> list that organizes depth-first and breadth-first search. The set ADTs coordinate the <q>closed</q> list that helps prevent cycles in a search.</p>
          </section>
        </section>
        <!-- end of "Abstract Data Types in Prolog" -->
      <!--</section>-->
      <!-- end of "Abstract Data Types and Search" -->
      <section>
        <h2>Depth-, Breadth-, and Best-First Search Using the Production System Design Pattern</h2>
        <section>
        <h3>Production System Search in Prolog</h3>
          <p>The <dfn>production system</dfn> <?see Luger 2009, Section 6.2?> is a model of computation that has proved particularly important in AI, both for implementing search algorithms and for modeling human problem solving behavior. A production system provides pattern-directed control of a problem-solving process and consists of a set of production rules, a working memory, and a recognize&#x2013;act control cycle.</p>
          <p>A production system is defined by:</p>
          <dl>
            <!-- <varlistentry> -->
              <dt>The set of production rules</dt>
              <listitem>These are often simply called productions. A production is a condition&#x2013;action pair and defines a single chunk of problem-solving knowledge. The condition part of the rule is a pattern that determines when that rule may be applied by matching data in the working memory. The action part of the rule defines the associated problem-solving step.</listitem>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>Working memory</dt>
              <listitem>Working memory contains a description of the current state of the world in a reasoning process. This description is a pattern that, in data-driven reasoning, is matched against the condition part of a production to select appropriate problem-solving actions. The actions of production rules are specifically designed to alter the contents of working memory, leading to the next phase of the recognize-act cycle.</listitem>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>The recognize&#x2013;act cycle</dt>
              <listitem>The control structure for a production system is simple: working memory is initialized with the beginning problem description. The current state of the problem solving is maintained as a set of patterns in working memory. These patterns are matched against the conditions of the production rules; this produces a subset of the production rules, called the <dfn>conflict set</dfn>, whose conditions match the patterns in working memory. One of the productions in the conflict set is then selected (<dfn>conflict resolution</dfn>) and the production is fired. After the selected production rule is fired, the control cycle repeats with the modified working memory. The process terminates when the contents of working memory do not match any rule conditions.</listitem>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>Conflict resolution</dt>
              <listitem>Conflict resolution chooses a rule from the conflict set for firing. Conflict resolution strategies may be simple, such as selecting the first rule whose condition matches the state of the world, or may involve complex rule selection heuristics. The pure production system model has no mechanism for recovering from dead ends in the search; it simply continues until no more productions are enabled and halts. Many practical implementations of production systems allow backtracking to a previous state of working memory in such situations.<?see A schematic drawing of a production system is presented in Figure 4.1.?></listitem>
            <!-- </varlistentry> -->
          </dl>
          <section>
        <h4>Example: The Knight's Tour Revisited</h4>
            <p>The 3 x 3 knight's tour problem may be solved with a production system. Each move can be represented as a rule whose condition is the location of the knight on a particular square and whose action moves the knight to another square. Sixteen productions represent all possible moves of the knight.</p>
            <p>We next specify a recursive procedure to implement a control algorithm for the production system. We will use the <a html="recursion_based_graph_search">recursive path algorithm</a><?see of Section 3.1?>, where the third argument of the path predicate is the list of already visited states. Because <kbd>path(Z, Z, L)</kbd> will unify only with predicates whose first two arguments are identical, such as <kbd>path(3, 3, _)</kbd> or <kbd>path(5, 5, _)</kbd>, it defines the desired terminating condition. If <kbd>path(X, X, L)</kbd> does not succeed we look at the production rules for a next state and then recur.</p>
            <p>The general recursive path definition is given by two predicate calculus formulas:</p>
            <pre>path(Z, Z, L).
path(X, Y, L) :-
  move(X, Z), not(member(Z, L)),
  path(Z, Y, [Z | L]).</pre>
            <p>Working memory, represented by the parameters of the recursive path predicate, contains both the current board state and the goal state. The control regime applies rules until the current state equals the goal state and then halts. A simple conflict resolution scheme would fire the first rule that did not cause the search to loop. Because the search may lead to dead ends (from which every possible move leads to a previously visited state and thus a loop), the control regime must also allow backtracking<?see ; an execution of this production system that determines whether a path exists from square 1 to square 2 is charted in Table 4.2?>.</p>
            <p>Production systems are capable of generating infinite loops when searching a state space graph. These loops are particularly difficult to spot in a production system because the rules can fire in any order. That is, looping may appear in the execution of the system, but it cannot easily be found from a syntactic inspection of the rule set.</p>
          </section>
        </section>
        <section id="the_wolf_goat_cabbage_problem">
        <h3>A Production System Solution to the Farmer, Wolf, Goat, Cabbage Problem*</h3>
        </section>
        <section>
        <h3>Designing Alternative Search Strategies</h3>
          <p>As <?see the previous subsection ?>demonstrated, Prolog itself uses depth-first search with backtracking. We now show how alternative search strategies can be implemented in Prolog. Our implementations of depth-first, breadth-first, and best-first search use open and closed lists to record states in the search. The open list contains all potential next states in the search. How the open list is maintained, as a stack, as a queue, or as a priority queue, determines which particular state is next, that is, search is in either depth-first, breadth-first, or as best-first modes. The closed set keeps track of all the states that have been previously visited, and is used primarily to prevent looping in the graph as well as to keep track of the current path through the space.<?see The details of how the open and closed data structures organize a search space can be found in Luger (2009, Chapter 3 and 4).?> When search fails at any point we do not backtrack. Instead, open and closed are updated within the path call and the search continues with these revised values. The cut is used to keep Prolog from storing the old versions of the open and closed lists.</p>
          <section id="depth-first_search_in_prolog">
        <h4>Implementing Depth-first Search in Prolog</h4>
            <p>Because the values of variables are restored when recursion backtracks, the list of visited states in the depth-first path algorithm of the previous section records states only if they are on the current path to the goal. Although testing each <q>new</q> state for membership in this list prevents loops, it still allows branches of the space to be reexamined if they are reached along paths generated earlier but abandoned at that time as unfruitful. A more efficient implementation keeps track of all the states that have ever been encountered. This more complete collection of states made up the members of the set we call <dfn>closed</dfn><?see see Luger 2009, Chapter 3?>, and <kbd>Closed_set</kbd> in the following algorithm.</p>
            <p><kbd>Closed_set</kbd> holds all states on the current path plus the states that were rejected when the algorithm determined they had no usable children; thus, it no longer represents the path from the start to the current state. To capture this path information, we create the ordered pair <kbd>[State, Parent]</kbd> to keep track of each state and its parent; the Start state is represented by <kbd>[Start, nil]</kbd>. These state&#x2013;parent pairs will be used to re-create the solution path from the <kbd>Closed_set</kbd>.</p>
            <p>We now present a shell structure for depth-first search in Prolog, keeping track of both open and closed and checking each new state to be sure it was not previously visited. <kbd>path</kbd> has three arguments, <kbd>the Open_stack</kbd>, <kbd>Closed_set</kbd>, maintained as a set, and the <kbd>Goal state</kbd>. The current state, <kbd>State</kbd>, is the next state on the <kbd>Open_stack</kbd>. The stack and set operators are discussed <a html="ADTs_in_Prolog">here</a>.</p>
            <p>Search starts by calling a <kbd>go</kbd> predicate that initializes the <kbd>path</kbd> call. Note that <kbd>go</kbd> places the <kbd>Start</kbd> state with the <kbd>nil</kbd> parent, <kbd>[Start, nil]</kbd>, alone on <kbd>Open_stack</kbd>; the <kbd>Closed_set</kbd> is empty:</p>
            <pre>go(Start, Goal) :-
  empty_stack(Empty_open),
  stack([Start, nil], Empty_open, Open_stack),
  empty_set(Closed_set),
  path(Open_stack, Closed_set, Goal).</pre>
            <p>The three-argument <kbd>path</kbd> call is:</p>
            <pre>path(Open_stack, _, _) :-
  empty_stack(Open_stack),
  write(&#x2019;No solution found with these rules&#x2019;).
path(Open_stack, Closed_set, Goal) :-
  stack([State, Parent], _, Open_stack),
  State = Goal,
  write(`A Solution is Found!&#x2019;), nl,
  printsolution([State, Parent], Closed_set).
path(Open_stack, Closed_set, Goal) :-
  stack([State, Parent], Rest_open_stack, Open_stack),
  get_children(State, Rest_open_stack, Closed_set, Children),
  add_list_to_stack(Children, Rest_open_stack, New_open_stack),
  union([[State, Parent]], Closed_set, New_closed_set),
  path(New_open_stack, New_closed_set, Goal), !.
get_children(State, Rest_open_stack, Closed_set, Children) :-
  bagof(Child, moves(State, Rest_open_stack, Closed_set, Child), Children).
moves(State, Rest_open_stack, Closed_set, [Next, State]) :-
  move(State, Next),
  not(unsafe(Next)), % test depends on problem
  not(member_stack([Next,_], Rest_open_stack)),
  not(member_set([Next,_], Closed_set)).</pre>
            <p>We assume a set of <kbd>move</kbd> rules appropriate to the problem, and, if necessary, an <kbd>unsafe</kbd> predicate:</p>
            <pre>move(Present_state, Next_state) :- ... % test rules
move(Present_state, Next_state) :- ...
...</pre>
            <p>The first <kbd>path</kbd> call terminates search when the <kbd>Open_stack</kbd> is empty, which means there are no more states on the open list to continue the search. This usually indicates that the graph has been exhaustively searched. The second <kbd>path</kbd> call terminates and prints out the solution path when the solution is found. Since the states of the graph search are maintained as <kbd>[State, Parent]</kbd> pairs, <kbd>printsolution</kbd> will go to the <kbd>Closed_set</kbd> and recursively rebuild the solution path. Note that the solution is printed from start to goal.</p>
            <pre>printsolution([State, nil], _) :- write(State), nl.
printsolution([State, Parent], Closed_set) :-
  member_set([Parent, Grandparent], Closed_set),
  printsolution([Parent, Grandparent], Closed_set),
  write(State), nl.</pre>
            <section id="bagof_and_moves_in_Prolog">
        <h5>Predicates <kbd>bagof</kbd> and <kbd>moves</kbd></h5>
              <p>The third path call uses <kbd>bagof</kbd>, a Prolog built-in predicate standard to most interpreters. <kbd>bagof</kbd> lets us gather all the unifications of a pattern into a single list. The second parameter to <kbd>bagof</kbd> is the pattern predicate to be matched in the database. The first parameter specifies the components of the second parameter that we wish to collect. For example, we may be interested in the values bound to a single variable of a predicate. All bindings of the first parameter resulting from these matches are collected in a list, the <dfn>bag</dfn>, and bound to the third parameter.</p>
              <p>In this program, <kbd>bagof</kbd> collects the states reached by firing all of the enabled production rules. Of course, this is necessary to gather all descendants of a particular state so that we can add them, in proper order, to open. The second argument of <kbd>bagof</kbd>, a new predicate named <kbd>moves</kbd>, calls the <kbd>move</kbd> predicates to generate all the states that may be reached using the production rules. The arguments to <kbd>moves</kbd> are the present state, the open list, the closed set, and a variable that is the state reached by a good move. Before returning this state, moves checks that the new state, <kbd>Next</kbd>, is not a member of either <kbd>rest_open_stack</kbd>, <kbd>open</kbd> once the present state is removed, or <kbd>closed_set</kbd>. <kbd>bagof</kbd> calls <kbd>moves</kbd> and collects all the states that meet these conditions. The third argument of <kbd>bagof</kbd> represents the new states that are to be placed on the <kbd>Open_stack</kbd>.</p>
              <p>For some Prolog interpreters, <kbd>bagof</kbd> fails when no matches exist for the second argument and thus the third argument, <kbd>List</kbd>, is empty. This can be remedied by substituting <kbd>(bagof(X, moves(S, T, C, X), List); List = [ ])</kbd> for the current calls to <kbd>bagof</kbd> in the code.</p>
              <p>Finally, because the states of the search are represented as state&#x2013;parent pairs, member check predicates, e.g., <kbd>member_set</kbd>, must be revised to reflect the structure of pattern matching. We test if a state&#x2013;parent pair is identical to the first element of the list of state&#x2013;parent pairs and then recur if it isn't:</p>
              <pre>member_set([State, Parent], [[State, Parent]|_]).
member_set(X, [_|T]) :- member_set(X, T).</pre>
            </section>
          </section>
          <section id="breadth-first_search_in_prolog">
        <h4>Implementing Breadth-first Search in Prolog</h4>
            <p>We now present the <em>shell</em> of an algorithm for breadth-first search using explicit open and closed lists. This algorithm is called by:</p>
            <pre>go(Start, Goal) :-
  empty_queue(Empty_open_queue),
  enqueue([Start, nil], Empty_open_queue, Open_queue),
  empty_set(Closed_set),
  path(Open_queue, Closed_set, Goal).</pre>
            <p><kbd>Start</kbd> and <kbd>Goal</kbd> have their obvious values. The shell can be used with the move rules and unsafe predicates for any search problem. Again we create the ordered pair <kbd>[State, Parent]</kbd>, as we did with depth-first search, to keep track of each state and its parent; the start state is represented by <kbd>[Start, nil]</kbd>. This will be used by <kbd>printsolution</kbd> to re-create the solution path from the <kbd>Closed_set</kbd>. The first parameter of path is the <kbd>Open_queue</kbd>, the second is the <kbd>Closed_set</kbd>, and the third is the <kbd>Goal</kbd>. Don't care variables, those whose values are not used in a clause, are written as <q><kbd>_</kbd></q>.</p>
            <pre>path(Open_queue, _, _) :-
  empty_queue(Open_queue),
  write(&#x2019;Graph searched, no solution found.&#x2019;).
path(Open_queue, Closed_set, Goal) :-
  dequeue([State, Parent], Open_queue, _),
  State = Goal,
  write(&#x2019;Solution path is: &#x2018;), nl,
  printsolution([State, Parent], Closed_set).
path(Open_queue, Closed_set, Goal) :-
  dequeue([State, Parent], Open_queue, Rest_open_queue),
  get_children(State, Rest_open_queue, Closed_set, Children),
  add_list_to_queue(Children, Rest_open_queue, New_open_queue),
  union([[State, Parent]], Closed_set, New_closed_set),
  path(New_open_queue, New_closed_set, Goal), !.
get_children(State, Rest_open_queue, Closed_set, Children) :-
  bagof(Child, moves(State, Rest_open_queue, Closed_set, Child), Children).
moves(State, Rest_open_queue, Closed_set, [Next, State]) :-
  move(State, Next),
  not(unsafe(Next)), %test depends on problem
  not(member_queue([Next,_], Rest_open_queue)),
  not(member_set([Next,_], Closed_set)).</pre>
            <p>This algorithm is a shell in that no <kbd>move</kbd> rules are given. These must be supplied to fit the specific problem domain, such as the <a html="the_wolf_goat_cabbage_problem">FWGC problem</a>. The queue and set operators have been described <a html="ADTs_in_Prolog">here</a>.</p>
            <p>The first path termination condition is defined for the case that <kbd>path</kbd> is called with its first argument, <kbd>Open_queue</kbd>, empty. This happens only when no more states in the graph remain to be searched and the solution has not been found. A solution is found in the second <kbd>path</kbd> predicate when the head of the <kbd>open_queue</kbd> and the <kbd>Goal</kbd> state are identical. When <kbd>path</kbd> does not terminate, the third call, with <kbd>bagof</kbd> and <kbd>moves</kbd> predicates, gathers all the children of the current state and maintains the queue. (The detailed actions of these two predicates have been described <a html="bagof_and_moves_in_Prolog">here</a>.) In order to recreate the solution path, we saved each state as a state&#x2013;parent pair, <kbd>[State, Parent]</kbd>. The start state has the parent <kbd>nil</kbd>. As already noted, the state&#x2013;parent pair representation makes necessary a slightly more complex pattern matching in the member, <kbd>moves</kbd>, and <kbd>printsolution</kbd> predicates.</p>
          </section>
          <section id="best-first_search_in_prolog">
        <h4>Implementing Best-first Search in Prolog</h4>
            <p>Our shell for best-first search is a modification of the <a html="depth-first_search_in_prolog">breadth-first algorithm</a> in which the open queue is replaced by a priority queue, ordered by heuristic merit, which supplies the current state for each new call to <kbd>path</kbd>. In our algorithm, we attach a heuristic measure permanently to each new state on open and use this measure for ordering the states on open. We also retain the parent of each state. This information is used by <kbd>printsolution</kbd>, as in depth- and breadth-first search, to build the solution path once the goal is found.</p>
            <p>To keep track of all required search information, each state is represented as a list of five elements: the state description, the parent of the state, an integer giving the depth in the graph of the state's discovery, an integer giving the heuristic measure of the state, and the integer sum of the third and fourth elements. The first and second elements are found in the usual way; the third is determined by adding one to the depth of its parent; the fourth is determined by the heuristic measure of the particular problem. The fifth element, used for ordering the states on the <kbd>open_pq</kbd>, is <kbd>f(n) = g(n) + h(n)</kbd>. A justification for using this approach to order states for heuristic search, usually referred to as the <dfn>A Algorithm</dfn>, is presented in Luger (2009, Chapter 4).</p>
            <p>As before, the move rules are not specified; they are defined to fit the specific problem. The ADT operators for set and priority queue are presented in the section on <a html="ADTs_in_Prolog">ADTs</a>. heuristic, also specific to each problem, is a measure applied to each state to determine its heuristic weight, the value of the fourth parameter in its descriptive list.</p>
            <p>This best-first search algorithm has two termination conditions and is called by:</p>
            <pre>go(Start, Goal) :-
  empty_set(Closed_set),
  empty_pq(Open),
  heuristic(Start, Goal, H),
  insert_pq([Start, nil, 0, H, H], Open, Open_pq),
  path(Open_pq, Closed_set, Goal).</pre>
            <p><kbd>nil</kbd> is the parent of <kbd>Start</kbd> and <kbd>H</kbd> is its heuristic evaluation. The code for best-first search is:</p>
            <pre>path(Open_pq, _,_) :-
  empty_pq(Open_pq),
  write(&#x2019;Graph searched, no solution found.&#x2019;).

path(Open_pq, Closed_set, Goal) :-
  dequeue_pq([State, Parent, _, _, _], Open_pq,_),
  State = Goal,
  write(&#x2019;The solution path is: &#x2018;), nl,
  printsolution([State, Parent, _, _, _], Closed_set).
path(Open_pq, Closed_set, Goal) :-
  dequeue_pq([State, Parent, D, H, S], Open_pq, Rest_open_pq),
  get_children([State, Parent, D, H, S], Rest_open_pq, Closed_set, Children, Goal),
  insert_list_pq(Children, Rest_open_pq, New_open_pq),
  union([[State, Parent, D, H, S]], Closed_set, New_closed_set),
  path(New_open_pq, New_closed_set, Goal), !.</pre>
            <p><kbd>get_children</kbd> is a predicate that generates all the children of <kbd>State</kbd>. It uses <kbd>bagof</kbd> and <kbd>moves</kbd> predicates as in the previous searches, with details earlier this section. A set of <kbd>move</kbd> rules, a <kbd>safe</kbd> check for legal moves, and a <kbd>heuristic</kbd> must be specifically defined for each application. The <kbd>member</kbd> check must be specifically designed for five element lists.</p>
            <pre>get_children([State,_,D,_, _],Rest_open_pq, Closed_set,Children,Goal) :-
bagof(Child, moves([State, _, D, _, _],
Rest_open_pq, Closed_set, Child,Goal),
Children).
moves([State, _, Depth, _, _], Rest_open_pq, Closed_set,[Next,State,New_D,H,S], Goal) :-
move(State, Next),
not(unsafe(Next)),
% application specific
not(member_pq([Next, _, _, _, _],Rest_open_pq)),
not(member_set([Next, _, _, _, _],Closed_set)),
New_D is Depth + 1,
heuristic(Next, Goal, H), % application specific
S is New_D + H.</pre>
            <p><kbd>printsolution</kbd> prints the solution path, recursively finding state&#x2013;parent pairs by matching the first two elements in the state description with the first two elements of the five element lists that make up the <kbd>Closed_set</kbd>.</p>
            <pre>printsolution([State, nil, _, _, _], _) :-
  write(State), nl.
printsolution([State, Parent, _, _, _], Closed_set):-
  member_set([Parent, Grandparent, _, _, _], Closed_set),
  printsolution([Parent, Grandparent, _, _, _], Closed_set),
  write(State), nl.</pre>
            <?see In Chapter 5 we further generalize the approach taken so far in that we present a set of built-in Prolog meta-predicates, predicates like bagof, that explicitly manipulate other Prolog predicates. This will set the stage for creating meta-interpreters in Chapter 6.?>
          </section>
        </section>
      </section>
      <section>
        <h2>Special or Advanced Topics in Prolog</h2>
        <section>
        <h3>The Effect of Rule and Goal Ordering</h3>
          <p>Two syntactic issues, irrelevant for logic programs, are important to consider when composing Prolog programs. The rule order, or clause order, of clauses in each procedure must be decided. Also the goal order of goals in the bodies of each clause must be determined. The consequences of these decisions can be immense. There can be orders of magnitude of difference in efficiency in the performance of Prolog programs. In extreme though quite common cases, correct logic programs will fail to give solutions because of <a html="nontermination_in_prolog">nontermination</a>.</p>
          <blockquote>The rule order determines the order in which solutions are found.</blockquote>
          <p>Changing the order of rules in a procedure permutes the branches in any search tree for a goal using that procedure. The search tree is traversed depth-first. So permuting the branches causes a different order of traversal of the search tree, and a different order of finding solutions.</p>
          <section>
        <h4>The Effect of Goal Order in Prolog</h4>
            <p>Goal order is more significant than clause order. It is the principal means of specifying sequential flow of control in Prolog programs.</p>
            <p>We first discuss goal order from the perspective of database programming. The reason that the order of goals in the body of a clause affects the order of solutions to a query is different from the reason that the order of rules in a procedure affects the solution order. Changing rule order does not change the search tree that must be traversed for a given query. The tree is just traversed in a different order. Changing goal order changes the search tree.</p>
            <blockquote>Goal order determines the search tree.</blockquote>
            <p>Goal order affects the amount of searching the program does in solving a query by determining which search tree is traversed.</p>
            <p>The optimal goal order of Prolog programs varies with different uses. Consider the definition of grandparent. There are two possible rules:</p>
            <pre>grandparent(X,Z) :- parent(X,Y), parent(Y,Z),
grandparent(X,Z) :- parent(Y,Z), parent(X,Y).</pre>
            <p>If you wish to find someone's grandson with the <kbd>grandfather/2</kbd> relationship with a query such as <kbd>grandparent (abraham, X)?</kbd>, the first of the rules searches more directly. If looking for someone's grandparent with a query such as <kbd>grandparent (X, isaac) ?</kbd>, the second rule finds the solution more directly. If efficiency is important, then it is advisable to have two distinct relationships, grandparent and grandchild, to be used appropriately at the user's discretion.</p>
            <p>In contrast to rule order, goal order can determine whether computations terminate. Consider the recursive rule for ancestor:</p>
            <pre>ancestor(X,Y) :- parent(X, Z), ancestor(Z,Y).</pre>
            <p>If the goals in the body are swapped, the ancestor program becomes left recursive, and all Prolog computations with ancestor are nonterminating.</p>
          </section>
        </section>
        <section id="nontermination_in_prolog">
        <h3>Non-Termination in Prolog</h3>
          <p>Nontermination arises with recursive rules. Consider a <kbd>friend/2</kbd> predicate. A sample fact would be <kbd>friend(fred,tom)</kbd>. Since this relationship is commutative, we might be tempted to add a rule like <kbd>friend(X,Y) :- friend(Y,X).</kbd>. But if we do so, then no computation involving <kbd>friend/2</kbd> would ever terminate.</p>
          <p>Recursive rules that have the recursive goal as the first goal in the body are known as <dfn>left recursive</dfn> rules. The foregoing rule is an example. Left recursive rules are inherently troublesome in Prolog. They cause nonterminating computations if called with inappropriate arguments.</p>
          <p>The best solution to the problem of left recursion is avoidance. Commutative relationships are best handled differently, by defining a new predicate that has a clause for each permutation of the arguments of the relationship. We might define the relationship <kbd>friend/2</kbd> as a rule whose goals are made up of <kbd>befriend</kbd> predicate, the one used in stating facts about friendship. Thus:</p>
          <pre>befriend(fred, tom).
friend(X,Y) :- befriend(X,Y).
friend(X,Y) :- befriend(Y,X).</pre>
          <p>Unfortunately, it is not generally possible to remove all occurrences of left recursion...</p>
        </section>
      </section>
      <section>
        <h2>Prolog Applications</h2>
        <section id="expert_sys_in_pl">
        <h3><a html="expert_systems">Expert Systems</a> in Prolog</h3>
          <section>
        <h4>Asking the User</h4>
            <p>The ask predicate will have to determine from the user whether or not a given attribute-value pair is true. The program needs to be modified to specify which attributes are askable. This is easily done by making rules for those attributes that call ask.</p>
            <pre>eats(X):- ask(eats, X).
feet(X):- ask(feet, X).
wings(X):- ask(wings, X).
neck(X):- ask(neck, X).
color(X):- ask(color, X).</pre>
            <p>Now if the system has the goal of finding color(white) it will call ask, rather than look in the program. If ask(color, white) succeeds, color(white) succeeds.</p>
            <p>The simplest version of ask prompts the user with the requested attribute and value and seeks confirmation or denial of the proposed information. The code is:</p>
            <pre>ask(Attr, Val):-
write(Attr:Val),
write('? '),
read(yes).</pre>
            <p>The read will succeed if the user answers <kbd>yes</kbd>, and fail if the user types anything else. Now the program can be run without having the data built into the program. The same query to bird starts the program, but now the user is responsible for determining whether some of the attribute-values are true. The following dialog shows how the system runs:</p>
            <pre>?- bird(X).
nostrils : external_tubular? yes.
live : at_sea? yes.
bill : hooked? yes.
size : large? yes.
wings : long_narrow? yes.
color : white? yes.
X = laysan_albatross</pre>
            <p>There is a problem with this approach. If the user answered <kbd>no</kbd> to the last question, then the rule for bird(laysan_albatross) would have failed and backtracking would have caused the next rule for bird(black_footed_albatross) to be tried. The first subgoal of the new rule causes Prolog to try to prove family(albatross) again, and ask the same questions it already asked. It would be better if the system remembered the answers to questions and did not ask again.</p>
          </section>
          <section>
        <h4>Remembering the Answer</h4>
            <p>A new predicate, known/3 is used to remember the user's answers to questions. It is not specified directly in the program, but rather is dynamically asserted whenever ask gets new information from the user.</p>
            <p>Every time ask is called it first checks to see if the answer is already known to be yes or no. If it is not already known, then ask will assert it after it gets a response from the user. The three arguments to known are: yes/no, attribute, and value. The new version of ask looks like:</p>
            <pre>ask(A, V):-
  known(yes, A, V), % succeed if true
  !. % stop looking
ask(A, V):-
  known(_, A, V), % fail if false
  !,
  fail.
ask(A, V):-
  write(A:V), % ask user
  write('? : '),
  read(Y), % get the answer
  asserta(known(Y, A, V)), % remember it
  Y == yes. % succeed or fail</pre>
            <p>The cuts in the first two rules prevent ask from backtracking after it has already determined the answer.</p>
          </section>
          <section>
        <h4>Multi-valued Answers</h4>
            <p>There is another level of subtlety in the approach to known. The ask predicate now assumes that each particular attribute value pair is either true or false. This means that the user could respond with a <q>yes</q> to both color:white and color:black. In effect, we are letting the attributes be multi-valued. This might make sense for some attributes such as voice but not others such as bill, which only take a single value.</p>
            <p>The best way to handle this is to add an additional predicate to the program, which specifies the attributes that are multi-valued:</p>
            <pre>multivalued(voice).
multivalued(feed).</pre>
            <p>A new clause is now added to ask to cover the case where the attribute is not multi-valued (and therefore single-valued) and already has a different value from the one asked for. In this case ask should fail. For example, if the user has already answered yes to size - large then ask should automatically fail a request for size - small without asking the user. The new clause goes before the clause which actually asks the user:</p>
            <pre>ask(A, V):-
not multivalued(A),
known(yes, A, V2),
V \== V2,
!,
fail.</pre>
          </section>
          <section>
        <h4>Menus for the User</h4>
            <p>The user interface can further be improved by adding a menu capability that gives the user a list of possible values for an attribute. It can further enforce that the user enter a value on the menu.</p>
            <p>This can be implemented with a new predicate, menuask. It is similar to ask, but has an additional argument which contains a list of possible values for the attribute. It would be used in the program in an analogous fashion to ask:</p>
            <pre>size(X):-
  menuask(size, X, [large, plump, medium, small]).
flight(X):-
  menuask(flight, X, [ponderous, agile, flap_glide]).</pre>
            <p>The menuask predicate can be implemented using either a sophisticated windowing interface, or by simply listing the menu choices on the screen for the user. When the user returns a value it can be verified, and the user reprompted if it is not a legal value.</p>
            <p>A simple implementation would have initial clauses as in ask, and have a slightly different clause for actually asking the user. That last clause of menuask might look like:</p>
            <pre>menuask(A, V, MenuList) :-
  write('What is the value for'), write(A), write('?'), nl,
  write(MenuList), nl,
  read(X),
  check_val(X, A, V, MenuList),
  asserta( known(yes, A, X) ),
  X == V.
check_val(X, A, V, MenuList) :-
  member(X, MenuList),
  !.
check_val(X, A, V, MenuList) :-
  write(X), write(' is not a legal value, try again.'), nl,
  menuask(A, V, MenuList).</pre>
            <p>The check_val predicate validates the user's input. In this case the test ensures the user entered a value on the list. If not, it retries the menuask predicate.</p>
          </section>
        </section>
        <section>
        <h3>Biology in Prolog</h3>
          <section>
        <h4>Our First Database of Biology in Prolog</h4>
            <p>First <code class="function">belong/2</code> is defined. It will be used instead of <code class="function">member/2</code>. Then some discontiguous predicates are registered. Last, predicates <code class="function">has/2</code> and <code class="function">isa/2</code> are defined. Now we are ready to present some biological facts!</p>
            <pre id="bio0_pl">
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/prolog_code/bio0.pl" parse="text">
                <xi:fallback/>
              </xi:include>
            </pre>
          </section>
        </section>
        <!-- end of "Biology in Prolog" -->
        <section>
        <h3>Electronics in Prolog</h3>
          <section>
        <h4>Combinational Circuits in Prolog</h4>
            <p>Let us first work out how to represent logic gates as predicates. Such predicates shall reflect their truth tables...</p>
            <pre>inv(0,1).
inv(1, 0).
nand(O, 0, 1).
nand(O, 1, 1).
nand(1, 0, 1).
nand(1, 1,0).</pre>
            <p>Circuits may be built up by constructing Prolog procedures containing goals for representing circuit elements. Consider a circuit represented by:</p>
            <informalequation>
            E = nand(nand(<var>A</var>,<var>B</var>),nor(<var>C</var>,<var>D</var>))
          </informalequation>
            <p>Let's call the output of the incoming nand and nor gates <var>t<subscript>1</subscript></var> and <var>t<subscript>2</subscript></var>. Then we may write a prolog rule:</p>
            <pre>circ1(A, B, C, D, E) :-
  nand(A, B, T1),
  nor(C, 0, T2),
  nand(T1, T2, E).</pre>
            <p>Inputs and internal nodes may be shared simply by naming them the same.</p>
          </section>
          <section>
        <h4>Sequential Circuits in Prolog*</h4>
          </section>
        </section>
      </section>
      <!-- end of "Special or Advanced Topics in Prolog" -->
      <section id="pl_implementations">
        <h2>Prolog Compilers and Interpreters</h2>
        <p>On linux, you can choose between:</p>
        <ul>
          <listitem>gprolog,</listitem>
          <listitem>SWI-Prolog, and</listitem>
          <listitem>yap, which is Yet Another Prolog whatever.</listitem>
        </ul>
        <section id="wam">
        <h3>The Warren Abstract Machine</h3>
          <p>The  WAM is  an  abstract machine consisting  of a  memory architecture and in-struction set tailored to Prolog.  It can be realised efficiently on a wide range of hardware, and serves as a target for portable Prolog compilers. It has now become accepted as a standard basis for implementing Prolog. The WAM is perhaps too readily accepted as the standard.Although the WAM is a distillation of a long line of experience in Prolog implementation, it is by no means the only possible point to consider in the design space.  For example, whereas the WAM adopts <dfn>structure copying</dfn> to represent Prolog terms, the <dfn>structure sharing</dfn> representation used in the Marseille and DEC-10 implementations still has much to recommend it.  Be that as it may, the WAM is certainly a good starting point for studying Prolog implementation technology.</p>
        </section>
        <section>
        <h3>Prolog Dialects</h3>
          <section>
        <h4>Edinburgh Prolog*</h4>
          </section>
        </section>
        <section id="swipl">
        <h3>SWI-Prolog</h3>
          <blockquote>
            <p>SWI-Prolog started life in 1986 as a Prolog in the Edinburgh tradition. Its development has been guided from the very beginning by the desire to build large scale applications in Prolog. For this reason it stresses connectivity to the C-language, few system limits, comprehensive memory management, modules, multi-threading, coroutining, constraints and a fast and interactive development environment. Portable libraries for graphics, databases, networking, web-services, XML, RDF and many more complete the system.</p>
            <p>SWI-Prolog is compliant to part one of ISO standard Prolog. In addition it provides functionality compatible to Quintus, SICStus, LPA, Ciao and many more.</p>
            <p>Since version 5 the system and all bundled extensions are distributed under the Lesser General Public License (LGPL) and the system enjoys attention from a large community of academic researchers, students and commercial users.</p>
            <p style="text-align: right">Copyright &#xA9; 1990--2008 , University of Amsterdam</p>
          </blockquote>
          <section>
        <h4>The XPCE GUI system for Prolog</h4>
            <p>The XPCE GUI system for dynamically typed languages has been with SWI-Prolog for a long time. It is developed by Anjo Anjewierden and Jan Wielemaker from the department of SWI, University of Amsterdam. It aims at a high-productive development environment for graphical applications based on Prolog.</p>
            <p>Object oriented technology has proven to be a suitable model for implementing GUIs, which typically deal with things Prolog is not very good at: event-driven control and global state. With XPCE, we designed a system that has similar characteristics that make Prolog such a powerful tool: dynamic typing, meta-programming and dynamic modification of the running system.</p>
            <p>XPCE is an object-system written in the C-language. It provides for the implementation of methods in multiple languages. New XPCE classes may be defined from Prolog using a simple, natural syntax. The body of the method is executed by Prolog itself, providing a natural interface between the two systems. Below is a very simple class definition.</p>
            <pre>:- pce_begin_class(prolog_lister, frame,
                   "List Prolog predicates").

initialise(Self) :-&gt;
        "As the C++ constructor"::
        send_super(Self, initialise, 'Prolog Lister'),
        send(Self, append, new(D, dialog)),
        send(D, append,
             text_item(predicate, message(Self, list, @arg1))),
        send(new(view), below, D).

list(Self, From:name) :-&gt;
        "List predicates from specification"::
        (   catch(term_to_atom(Term, From), _, fail)
        -&gt;  get(Self, member, view, V),
            current_output(Old),
            pce_open(V, write, Fd),
            set_output(Fd),
            listing(Term),
            close(Fd),
            set_output(Old)
        ;   send(Self, report, error, 'Syntax error')
        ).

:- pce_end_class.

test :- send(new(prolog_lister), open).</pre>
            <p>Its 165 built-in classes deal with the meta-environment, data-representation and---of course---graphics. The graphics classes concentrate on direct-manipulation of diagrammatic representations.</p>
            <section>
        <h5>Availability</h5>
              <p>XPCE runs on most Unix&#xAE; platforms, Windows 95/98/ME, Windows NT/2000/XP and MacOS X (using X11). In the past, versions for Quintus- and SICStus Prolog as well as some Lisp dialects have existed. After discontinuing active Lisp development at SWI the Lisp versions have died. Active development on the Quintus and SICStus versions has been stopped due to lack of standardisation in the Prolog community. If adequate standards emerge we are happy to actively support other Prolog implementations.</p>
            </section>
          </section>
          <section>
        <h4>SWI-Prolog's Foreign Language Interface</h4>
            <p>SWI-Prolog offers a powerful interface to <a html="c">C</a>. The main design objectives of the foreign language interface are flexibility and performance.</p>
            <p>A <dfn>foreign predicate</dfn> is a C-function that has the same number of arguments as the predicate represented. C-functions are provided to analyse the passed terms, convert them to basic C-types as well as to instantiate arguments using unification. Non-deterministic foreign predicates are supported, providing the foreign function with a handle to control backtracking.</p>
            <p>C can call Prolog predicates, providing both an query interface and an interface to extract multiple solutions from an non-deterministic Prolog predicate. There is no limit to the nesting of Prolog calling C, calling Prolog, etc. It is also possible to write the <q>main</q> in C and use Prolog as an embedded logical engine.</p>
            <section>
        <h5>Overview of the Interface</h5>
              <p>A special include file called <cite>SWI-Prolog.h</cite> should be included with each C-source file that is to be loaded via the foreign interface. The installation process installs this file in the directory include in the SWI-Prolog home directory (?- current_prolog_flag(home, Home).). This C-header file defines various data types, macros and functions that can be used to communicate with SWI-Prolog. Functions and macros can be divided into the following categories:</p>
              <ul>
                <listitem>Analysing Prolog terms</listitem>
                <listitem>Constructing new terms</listitem>
                <listitem>Unifying terms</listitem>
                <listitem>Returning control information to Prolog</listitem>
                <listitem>Registering foreign predicates with Prolog</listitem>
                <listitem>Calling Prolog from C</listitem>
                <listitem>Recorded database interactions</listitem>
                <listitem>Global actions on Prolog (halt, break, abort, etc.) </listitem>
              </ul>
            </section>
            <section>
        <h5>Linking Foreign Modules</h5>
              <p>Foreign modules may be linked to Prolog in two ways. Using static linking, the extensions, a (short) file defining <code class="function">main()</code> which attaches the extensions calls Prolog and the SWI-Prolog kernel distributed as a C-library are linked together to form a new executable. Using dynamic linking, the extensions are linked to a shared library (.so file on most Unix systems) or dynamic-link library (.DLL file on Microsoft platforms) and loaded into the running Prolog process.77.</p>
              <p class="bridgehead"><i>What linking is provided?</i></p>
              <p>The static linking schema can be used on all versions of SWI-Prolog. Whether or not dynamic linking is supported can be deduced from the Prolog flag <code class="function">open_shared_object</code> (see <code class="function">current_prolog_flag/2</code>). If this Prolog flag yields true, <code class="function">open_shared_object/2</code> and related predicates are defined. See <a html="swipl_shlib">here</a> for a suitable high-level interface to these predicates.</p>
              <p class="bridgehead"><i>What kind of loading should I be using?</i></p>
              <p>All described approaches have their advantages and disadvantages. Static linking is portable and allows for debugging on all platforms. It is relatively cumbersome and the libraries you need to pass to the linker may vary from system to system, though the utility program <command linkend="plld">plld</command> often hides these problems from the user.</p>
              <p>Loading shared objects (DLL files on Windows) provides sharing and protection and is generally the best choice. If a saved-state is created using <code class="function">qsave_program/[1,2]</code>, an <code class="function">initialization/1</code> directive may be used to load the appropriate library at startup.</p>
              <p>Note that the definition of the foreign predicates is the same, regardless of the linking type used.</p>
            </section>
            <section>
        <h5>Dynamic Linking of shared libraries</h5>
              <p>The interface defined in this section allows the user to load shared libraries (.so files on most Unix systems, .dll files on Windows). This interface is portable to Windows as well as to Unix machines providing <command>dlopen(2)</command> (Solaris, Linux, FreeBSD, Irix and many more) or <command>shl_open(2)</command> (HP/UX). It is advised to use the predicates from <a html="swipl_shlib">next section</a> in your application.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">open_shared_object(+File, -Handle)</code>
                  </dt>
                  <listitem>
                    <p>File is the name of a shared object file (called dynamic load library in MS-Windows). This file is attached to the current process and Handle is unified with a handle to the library. Equivalent to <code class="function">open_shared_object(File, [], Handle)</code>. See also <code class="function">load_foreign_library/[1,2]</code>.</p>
                    <p> On errors, an exception <code class="function">shared_object(Action, Message)</code> is raised. Message is the return value from <code class="function">dlerror()</code>.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">open_shared_object(+File, -Handle, +Options)</code>
                  </dt>
                  <listitem>
                    <p>As <code class="function">open_shared_object/2</code>, but allows for additional flags to be passed. Options is a list of atoms. <literal>now</literal> implies the symbols are resolved immediately rather than <literal>lazy</literal> (default). <literal>global</literal> implies symbols of the loaded object are visible while loading other shared objects (by default they are local). Note that these flags may not be supported by your operating system. Check the documentation of <code class="function">dlopen()</code> or equivalent on your operating system. Unsupported flags are silently ignored.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">close_shared_object(+Handle)</code>
                  </dt>
                  <listitem>
                    <p>Detach the shared object identified by Handle.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">call_shared_object_function(+Handle, +Function)</code>
                  </dt>
                  <listitem>
                    <p>Call the named function in the loaded shared library. The function is called without arguments and the return-value is ignored. Normally this function installs foreign language predicates using calls to <code class="function">PL_register_foreign()</code>.</p>
                  </listitem>
                <!-- </varlistentry> -->
              </dl>
            </section>
            <section id="swipl_shlib">
        <h5>Using the library <cite>shlib</cite> for .DLL and .so files</h5>
              <p>This section discusses the functionality of the (autoload) library <cite>shlib.pl</cite>, providing an interface to shared libraries. This library can only be used if the Prolog flag <var>open_shared_object</var> is enabled.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">load_foreign_library(+Lib, +Entry)</code>
                  </dt>
                  <listitem>
                    <p>Search for the given foreign library and link it to the current SWI-Prolog instance. The library may be specified with or without the extension. First, <code class="function">absolute_file_name/3</code> is used to locate the file. If this succeeds, the full path is passed to the low-level function to open the library. Otherwise, the plain library name is passed, exploiting the operating-system defined search mechanism for the shared library. The <code class="function">file_search_path/2</code> alias mechanism defines the alias <var>foreign</var>, which refers to the directories <cite>&lt;plhome&gt;/lib/&lt;arch&gt;</cite> and <cite>&lt;plhome&gt;/lib</cite>, in this order.</p>
                    <p>If the library can be loaded, the function called Entry will be called without arguments. The return value of the function is ignored.</p>
                    <p>The Entry function will normally call <code class="function">PL_register_foreign()</code> to declare functions in the library as foreign predicates.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">load_foreign_library(+Lib)</code>
                  </dt>
                  <listitem>
                    <p>Equivalent to <code class="function">load_foreign_library/2</code>. For the entry-point, this function first identifies the <cite>base-name</cite> of the library, which is defined to be the <cite>file-name</cite> with path [n]or extension. It will then try the entry-point <cite>install-&lt;base&gt;</cite>. On failure it will try to function <code class="function">install()</code>. Otherwise no install function will be called.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">unload_foreign_library(+Lib)</code>
                  </dt>
                  <listitem>
                    <p>If the foreign library defines the function <code class="function">uninstall_&lt;base&gt;()</code> or <code class="function">uninstall()</code>, this function will be called without arguments and its return value is ignored. Next, <code class="function">abolish/2</code> is used to remove all known foreign predicates defined in the library. Finally the library itself is detached from the process.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">current_foreign_library(-Lib, -Predicates)</code>
                  </dt>
                  <listitem>
                    <p>Query the currently loaded foreign libraries and their predicates. Predicates is a list with elements of the form <kbd>Module:Head</kbd>, indicating the predicates installed with <code class="function">PL_register_foreign()</code> when the entry-point of the library was called.</p>
                  </listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>The following program connects a Windows message-box using a foreign function. This example was tested using Windows NT and Microsoft Visual C++ 2.0.</p>
              <pre>#include &lt;windows.h&gt;
#include &lt;SWI-Prolog.h&gt;

static foreign_t
pl_say_hello(term_t to)
{ char *a;

  if ( PL_get_atom_chars(to, &amp;a) )
  { MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);

    PL_succeed;
  }

  PL_fail;
}

install_t
install()
{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);
}</pre>
              <p class="bridgehead"><i>Static Linking</i></p>
              <p>Below is an outline of the files structure required for statically linking SWI-Prolog with foreign extensions. <cite>.../pl</cite> refers to the SWI-Prolog home directory (see the Prolog flag <code class="constant">home</code>). <code class="constant">&lt;arch&gt;</code> refers to the architecture identifier that may be obtained using the Prolog flag arch.</p>
              <pre>.../pl/runtime/&lt;arch&gt;/libpl.a 	SWI-Library
.../pl/include/SWI-Prolog.h 	Include file
.../pl/include/SWI-Stream.h 	Stream I/O include file
.../pl/include/SWI-Exports 	Export declarations (AIX only)
.../pl/include/stub.c 	Extension stub</pre>
              <p>The definition of the foreign predicates is the same as for dynamic linking. Unlike with dynamic linking however, there is no initialisation function. Instead, the file <cite>.../pl/include/stub.c</cite> may be copied to your project and modified to define the foreign extensions. Below is <cite>stub.c</cite>, modified to link the lowercase example described later in this chapter:</p>
              <pre>#include &lt;stdio.h&gt;
#include &lt;SWI-Prolog.h&gt;

extern foreign_t pl_lowercase(term, term);

PL_extension predicates[] =
{
/*{ "name",      arity,  function,      PL_FA_&lt;flags&gt; },*/

  { "lowercase", 2       pl_lowercase,  0 },
  { NULL,        0,      NULL,          0 }     /* terminating line */
};


int
main(int argc, char **argv)
{ PL_register_extensions(predicates);

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_install_readline();                /* delete if not required */

  PL_halt(PL_toplevel() ? 0 : 1);
}</pre>
              <p>Now, a new executable may be created by compiling this file and linking it to <cite>libpl.a</cite> from the runtime directory and the libraries required by both the extensions and the SWI-Prolog kernel. This may be done by hand, or using the <command linkend="plld">plld</command> utility described elsewhere. If the linking is performed <q>by hand</q>, the command-line option <kbd>-dump-runtime-variables</kbd> can be used to obtain the required paths, libraries and linking options to link the new executable.</p>
            </section>
            <section>
        <h5>Interface Data types</h5>
              <p class="bridgehead"><i>Type <code class="classname">term_t</code>: a reference to a Prolog term</i></p>
              <p>The principal data-type is <code class="classname">term_t</code>. Type <code class="classname">term_t</code> is what Quintus calls <code class="classname">QP_term_ref</code>. This name indicates better what the type represents: it is a handle for a term rather than the term itself. Terms can only be represented and manipulated using this type, as this is the only safe way to ensure the Prolog kernel is aware of all terms referenced by foreign code and thus allows the kernel to perform garbage-collection and/or stack-shifts while foreign code is active, for example during a callback from C.</p>
              <p>A term reference is a C <code class="classname">unsigned long</code>, representing the offset of a variable on the Prolog environment-stack. A foreign function is passed term references for the predicate-arguments, one for each argument. If references for intermediate results are needed, such references may be created using <code class="function">PL_new_term_ref()</code> or <code class="function">PL_new_term_refs()</code>. These references normally live till the foreign function returns control back to Prolog. Their scope can be explicitly limited using <code class="function">PL_open_foreign_frame()</code> and <code class="function">PL_close_foreign_frame()</code>/<code class="function">PL_discard_foreign_frame()</code>.</p>
              <p>A <code class="classname">term_t</code> always refers to a valid Prolog term (variable, atom, integer, float or compound term). A term lives either until backtracking takes us back to a point before the term was created, the garbage collector has collected the term or the term was created after a <code class="function">PL_open_foreign_frame()</code> and <code class="function">PL_discard_foreign_frame()</code> has been called.</p>
              <p>The foreign-interface functions can either read, unify or write to term-references. In the this document we use the following notation for arguments of type <code class="classname">term_t</code>:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <kbd>term_t +t</kbd>
                  </dt>
                  <listitem>Accessed in read-mode. The '+' indicates the argument is 'input'.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <kbd>term_t -t</kbd>
                  </dt>
                  <listitem>Accessed in write-mode.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <kbd>term_t ?t</kbd>
                  </dt>
                  <listitem>Accessed in unify-mode.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>Term references are obtained in any of the following ways:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>Passed as argument</dt>
                  <listitem>The C-functions implementing foreign predicates are passed their arguments as term-references. These references may be read or unified. Writing to these variables causes undefined behaviour.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>Created by <code class="function">PL_new_term_ref()</code></dt>
                  <listitem> A term created by <code class="function">PL_new_term_ref()</code> is normally used to build temporary terms or be written by one of the interface functions. For example, <code class="function">PL_get_arg()</code> writes a reference to the term-argument in its last argument.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>Created by <code class="function">PL_new_term_refs(int n)</code></dt>
                  <listitem>This function returns a set of term refs with the same characteristics as <code class="function">PL_new_term_ref()</code>. See <code class="function">PL_open_query()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>Created by <code class="function">PL_copy_term_ref(term_t t)</code></dt>
                  <listitem>Creates a new term-reference to the same term as the argument. The term may be written to.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>Term-references can safely be copied to other C-variables of type <code class="classname">term_t</code>, but all copies will always refer to the same term.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">term_t PL_new_term_ref()</code>
                  </dt>
                  <listitem>
                    <p>Return a fresh reference to a term. The reference is allocated on the local stack. Allocating a term-reference may trigger a stack-shift on machines that cannot use sparse-memory management for allocation the Prolog stacks. The returned reference describes a variable.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">term_t PL_new_term_refs(int n)</code>
                  </dt>
                  <listitem>
                    <p>Return <var>n</var> new term references. The first term-reference is returned. The others are t+1, t+2, etc. There are two reasons for using this function. <code class="function">PL_open_query()</code> expects the arguments as a set of consecutive term references and very time-critical code requiring a number of term-references can be written as:</p>
                    <pre>pl_mypredicate(term_t a0, term_t a1)
    { term_t t0 = PL_new_term_refs(2);
      term_t t1 = t0+1;

      ...
    }</pre>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">term_t PL_copy_term_ref(term_t from)</code>
                  </dt>
                  <listitem>
                    <p>Create a new term reference and make it point initially to the same term as <var>from</var>. This function is commonly used to copy a predicate argument to a term reference that may be written.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_reset_term_refs(term_t after)</code>
                  </dt>
                  <listitem>
                    <p>Destroy all term references that have been created after <var>after</var>, including <var>after</var> itself. Any reference to the invalidated term references after this call results in undefined behaviour.</p>
                  </listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>Note that returning from the foreign context to Prolog will reclaim all references used in the foreign context. This call is only necessary if references are created inside a loop that never exits back to Prolog. See also <code class="function">PL_open_foreign_frame()</code>, <code class="function">PL_close_foreign_frame()</code> and <code class="function">PL_discard_foreign_frame()</code>.</p>
              <p class="bridgehead"><i>Interaction with the garbage collector and stack-shifter</i></p>
              <p>Prolog implements two mechanisms for avoiding stack overflow: garbage collection and stack expansion. On machines that allow for it, Prolog will use virtual memory management to detect stack overflow and expand the runtime stacks. On other machines Prolog will reallocate the stacks and update all pointers to them. To do so, Prolog needs to know which data is referenced by C-code. As all Prolog data known by C is referenced through term references (<code class="classname">term_t</code>), Prolog has all information necessary to perform its memory management without special precautions from the C-programmer.</p>
              <p class="bridgehead"><i>Other foreign interface types</i></p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">atom_t</code>
                  </dt>
                  <listitem>
                    <p>An atom in Prolog's internal representation. Atoms are pointers to an opaque structure. They are a unique representation for represented text, which implies that atom <var>A</var> represents the same text as atom <var>B</var> if-and-only-if <var>A</var> and <var>B</var> are the same pointer.</p>
                    <p>Atoms are the central representation for textual constants in Prolog The transformation of C a character string to an atom implies a hash-table lookup. If the same atom is needed often, it is advised to store its reference in a global variable to avoid repeated lookup.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">functor_t</code>
                  </dt>
                  <listitem>
                    <p>A functor is the internal representation of a name/arity pair. They are used to find the name and arity of a compound term as well as to construct new compound terms. Like atoms they live for the whole Prolog session and are unique.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">predicate_t</code>
                  </dt>
                  <listitem>
                    <p>Handle to a Prolog predicate. Predicate handles live forever (although they can loose their definition).</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">qid_t</code>
                  </dt>
                  <listitem>
                    <p>Query Identifier. Used by <code class="function">PL_open_query()</code>/<code class="function">PL_next_solution()</code>/<code class="function">PL_close_query()</code> to handle backtracking from C.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">fid_t</code>
                  </dt>
                  <listitem>
                    <p>Frame Identifier. Used by <code class="function">PL_open_foreign_frame()</code>/<code class="function">PL_close_foreign_frame()</code>.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">module_t</code>
                  </dt>
                  <listitem>
                    <p>A module is a unique handle to a Prolog module. Modules are used only to call predicates in a specific module.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">foreign_t</code>
                  </dt>
                  <listitem>
                    <p>Return type for a C-function implementing a Prolog predicate.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">control_t</code>
                  </dt>
                  <listitem>
                    <p>Passed as additional argument to non-deterministic foreign functions. See <code class="function">PL_retry*()</code> and <code class="function">PL_foreign_context*()</code>.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">install_t</code>
                  </dt>
                  <listitem>
                    <p>Type for the <code class="function">install()</code> and <code class="function">uninstall()</code> functions of shared or dynamic link libraries.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="classname">int64_t</code>
                  </dt>
                  <listitem>
                    <p>Actually part of the C99 standard rather than Prolog. As of version 5.5.6, Prolog integers are 64-bit on all hardware. The C99 type int64_t is defined in the <cite>stdint.h</cite> standard header and provides platform independent 64-bit integers. Portable code accessing Prolog should use this type to exchange integer values. Please note that <code class="function">PL_get_long()</code> can return FALSE on Prolog integers outside the <kbd>long</kbd> domain. Robust code should not assume any of the integer fetching functions to succeed if the Prolog term is know to be an integer.</p>
                  </listitem>
                <!-- </varlistentry> -->
              </dl>
            </section>
            <section>
        <h5>The Foreign Include File</h5>
              <p class="bridgehead"><i>Argument Passing and Control</i></p>
              <p>If Prolog encounters a foreign predicate at run time it will call a function specified in the predicate definition of the foreign predicate. The arguments <var>1</var>, ... , <var>&lt;arity&gt;</var> pass the Prolog arguments to the goal as Prolog terms. Foreign functions should be declared of type <code class="classname">foreign_t</code>. Deterministic foreign functions have two alternatives to return control back to Prolog:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">(return) foreign_t PL_succeed()</code>
                  </dt>
                  <listitem>Succeed deterministically. PL_succeed is defined as return TRUE.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">(return) foreign_t PL_fail()</code>
                  </dt>
                  <listitem>Fail and start Prolog backtracking. PL_fail is defined as return FALSE.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>Non-deterministic Foreign Predicates</i></p>
              <p>By default foreign predicates are deterministic. Using the PL_FA_NONDETERMINISTIC attribute (see <code class="function">PL_register_foreign()</code>) it is possible to register a predicate as a non-deterministic predicate. Writing non-deterministic foreign predicates is slightly more complicated as the foreign function needs context information for generating the next solution. Note that the same foreign function should be prepared to be simultaneously active in more than one goal. Suppose the <code class="function">natural_number_below_n/2</code> is a non-deterministic foreign predicate, backtracking over all natural numbers lower than the first argument. Now consider the following predicate:</p>
              <pre>quotient_below_n(Q, N) :-
        natural_number_below_n(N, N1),
        natural_number_below_n(N, N2),
        Q =:= N1 / N2, !.</pre>
              <p>In this predicate the function <code class="function">natural_number_below_n/2</code> simultaneously generates solutions for both its invocations.</p>
              <p>Non-deterministic foreign functions should be prepared to handle three different calls from Prolog:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">Initial call (PL_FIRST_CALL)</code>
                  </dt>
                  <listitem>Prolog has just created a frame for the foreign function and asks it to produce the first answer.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">Redo call (PL_REDO)</code>
                  </dt>
                  <listitem>The previous invocation of the foreign function associated with the current goal indicated it was possible to backtrack. The foreign function should produce the next solution.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">Terminate call (PL_CUTTED)</code>
                  </dt>
                  <listitem>The choice point left by the foreign function has been destroyed by a <em>cut</em>. The foreign function is given the opportunity to clean the environment.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>Both the context information and the type of call is provided by an argument of type <code class="classname">control_t</code> appended to the argument list for deterministic foreign functions. The macro <code class="function">PL_foreign_control()</code> extracts the type of call from the control argument. The foreign function can pass a context handle using the <code class="function">PL_retry*()</code> macros and extract the handle from the extra argument using the <code class="function">PL_foreign_context*()</code> macro.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">(return) foreign_t PL_retry(long)</code>
                  </dt>
                  <listitem>The foreign function succeeds while leaving a choice point. On backtracking over this goal the foreign function will be called again, but the control argument now indicates it is a <q>Redo</q> call and the macro <code class="function">PL_foreign_context()</code> returns the handle passed via <code class="function">PL_retry()</code>. This handle is a 30 bits signed value (two bits are used for status indication). Defined as <code class="function">return_PL_retry(n)</code>. See also <code class="function">PL_succeed()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">(return) foreign_t PL_retry_address(void *)</code>
                  </dt>
                  <listitem>As <code class="function">PL_retry()</code>, but ensures an address as returned by <code class="function">malloc()</code> is correctly recovered by <code class="function">PL_foreign_context_address()</code>. Defined as <code class="function">return_PL_retry_address(n)</code>. See also <code class="function">PL_succeed()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_foreign_control(control_t)</code>
                  </dt>
                  <listitem>Extracts the type of call from the control argument. The return values are described above. Note that the function should be prepared to handle the PL_CUTTED case and should be aware that the other arguments are not valid in this case.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function"> long PL_foreign_context(control_t)</code>
                  </dt>
                  <listitem>Extracts the context from the context argument. In the call type is PL_FIRST_CALL the context value is 0L. Otherwise it is the value returned by the last <code class="function">PL_retry()</code> associated with this goal (both if the call type is PL_REDO as PL_CUTTED).</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void * PL_foreign_context_address(control_t)</code>
                  </dt>
                  <listitem>Extracts an address as passed in by <code class="function">PL_retry_address()</code>.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>Note: If a non-deterministic foreign function returns using PL_succeed or PL_fail, Prolog assumes the foreign function has cleaned its environment. No call with control argument PL_CUTTED will follow.</p>
              <p>The following code shows a skeleton for a non-deterministic foreign predicate definition:</p>
              <pre>typedef struct                  /* define a context structure */
{ ...
} context;

foreign_t
my_function(term_t a0, term_t a1, control_t handle)
{ struct context * ctxt;

  switch( PL_foreign_control(handle) )
  { case PL_FIRST_CALL:
        ctxt = malloc(sizeof(struct context));
        ...
        PL_retry_address(ctxt);
    case PL_REDO:
        ctxt = PL_foreign_context_address(handle);
        ...
        PL_retry_address(ctxt);
    case PL_CUTTED:
        ctxt = PL_foreign_context_address(handle);
        ...
        free(ctxt);
        PL_succeed;
  }
}</pre>
              <p class="bridgehead"><i>Atoms and functors</i></p>
              <p>The following functions provide for communication using atoms and functors:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">atom_t PL_new_atom(const char *)</code>
                  </dt>
                  <listitem>Return an atom handle for the given C-string. This function always succeeds. The returned handle is valid as long as the atom is referenced.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">const char* PL_atom_chars(atom_t atom)</code>
                  </dt>
                  <listitem>Return a C-string for the text represented by the given atom. The returned text will not be changed by Prolog. It is not allowed to modify the contents, not even <q>temporary</q> as the string may reside in read-only memory. The returned string becomes invalid if the atom is garbage-collected (see section <a html="atoms_and_atom-garbage_collection">Atoms and atom-garbage collection</a>). Foreign functions that require the text from an atom passed in a <code class="classname">term_t</code> normally use <code class="function">PL_get_atom_chars()</code> or <code class="function">PL_get_atom_nchars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">functor_t PL_new_functor(atom_t name, int arity)</code>
                  </dt>
                  <listitem>Returns a functor identifier, a handle for the name/arity pair. The returned handle is valid for the entire Prolog session.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">atom_t PL_functor_name(functor_t f)</code>
                  </dt>
                  <listitem>Return an atom representing the name of the given functor.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_functor_arity(functor_t f)</code>
                  </dt>
                  <listitem>Return the arity of the given functor.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead" id="atoms_and_atom-garbage_collection"><i>Atoms and atom-garbage collection</i></p>
              <p>With the introduction of atom-garbage collection in version 3.3.0, atoms no longer live as long as the process. Instead, their lifetime is guaranteed only as long as they are referenced. In the single-threaded version, atom garbage collections are only invoked at the call-port. In the multi-threaded version, they appear asynchronously, except for the invoking thread.</p>
              <p>For dealing with atom garbage collection, two additional functions are provided:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_register_atom(atom_t atom)</code>
                  </dt>
                  <listitem>Increment the reference count of the atom by one. <code class="function">PL_new_atom()</code> performs this automatically, returning an atom with a reference count of at least one.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_unregister_atom(atom_t atom)</code>
                  </dt>
                  <listitem>Decrement the reference count of the atom. If the reference-count drops below zero, an assertion error is raised.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>Please note that the following two calls are different with respect to atom garbage collection:</p>
              <pre>PL_unify_atom_chars(t, "text");
PL_unify_atom(t, PL_new_atom("text"));</pre>
              <p>The latter increments the reference count of the atom text, which effectively ensures the atom will never be collected. It is advised to use the <code class="function">*_chars()</code> or <code class="function">*_nchars()</code> functions whenever applicable.</p>
              <p class="bridgehead"><i>Analysing Terms via the Foreign Interface</i></p>
              <p>Each argument of a foreign function (except for the control argument) is of type <code class="classname">term_t</code>, an opaque handle to a Prolog term. Three groups of functions are available for the analysis of terms. The first just validates the type, like the Prolog predicates <code class="function">var/1</code>, <code class="function">atom/1</code>, etc and are called <code class="function">PL_is_*()</code>. The second group attempts to translate the argument into a C primitive type. These predicates take a <code class="classname">term_t</code> and a pointer to the appropriate C-type and return TRUE or FALSE depending on successful or unsuccessful translation. If the translation fails, the pointed-to data is never modified.</p>
              <p class="bridgehead"><i>Testing the type of a term</i></p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_term_type(term_t)</code>
                  </dt>
                  <listitem>
                    <p>Obtain the type of a term, which should be a term returned by one of the other interface predicates or passed as an argument. The function returns the type of the Prolog term. The type identifiers are listed below. Note that the extraction functions <code class="function">PL_ge_t*()</code> also validate the type and thus the two sections below are equivalent.</p>
                    <pre>if ( PL_is_atom(t) )
            { char *s;

              PL_get_atom_chars(t, &amp;s);
              ...;
            }</pre>
                    <p>or</p>
                    <pre>char *s;
            if ( PL_get_atom_chars(t, &amp;s) )
            { ...;
            }</pre>
                    <ul>
                      <listitem><var>PL_VARIABLE</var>: An unbound variable. The value of term as such is a unique identifier for the variable.</listitem>
                      <listitem><var>PL_ATOM</var>: A Prolog atom.</listitem>
                      <listitem><var>PL_STRING</var>: A Prolog string.</listitem>
                      <listitem><var>PL_INTEGER</var>: A Prolog integer.</listitem>
                      <listitem><var>PL_FLOAT</var>: A Prolog floating point number.</listitem>
                      <listitem><var>PL_TERM</var>: A compound term. Note that a list is a compound term ./2.</listitem>
                    </ul>
                    <p>The functions <code class="function">PL_is_&lt;type&gt;</code> are an alternative to <code class="function">PL_term_type()</code>. The test <kbd>PL_is_variable(term)</kbd> is equivalent to <kbd>PL_term_type(term) == PL_VARIABLE</kbd>, but the first is considerably faster. On the other hand, using a switch over <code class="function">PL_term_type()</code> is faster and more readable then using an if-then-else using the functions below. All these functions return either TRUE or FALSE.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_variable(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is a variable.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_ground(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is a ground term. See also <code class="function">ground/1</code>. This function is cycle-safe.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_atom(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is an atom.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_string(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is a string.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_integer(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is an integer.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_float(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is a float.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_compound(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is a compound term.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_functor(term_t, functor_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is compound and its functor is functor. This test is equivalent to <code class="function">PL_get_functor()</code>, followed by testing the functor, but easier to write and faster.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_list(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is a compound term with functor ./2 or the atom [].</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_atomic(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is atomic (not variable or compound).</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_number(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is an integer or float.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_is_acyclic(term_t)</code>
                  </dt>
                  <listitem>Returns non-zero if term is acyclic (i.e. a finite tree).</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>Reading data from a term</i></p>
              <p>The functions <code class="function">PL_get_*()</code> read information from a Prolog term. Most of them take two arguments. The first is the input term and the second is a pointer to the output value or a term-reference.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_atom(term_t +t, atom_t *a)</code>
                  </dt>
                  <listitem>If <var>t</var> is an atom, store the unique atom identifier over <var>a</var>. See also <code class="function">PL_atom_chars()</code> and <code class="function">PL_new_atom()</code>. If there is no need to access the data (characters) of an atom, it is advised to manipulate atoms using their handle. As the atom is referenced by t, it will live at least as long as t does. If longer life-time is required, the atom should be locked using <code class="function">PL_register_atom()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_atom_chars(term_t +t, char **s)</code>
                  </dt>
                  <listitem>If <var>t</var> is an atom, store a pointer to a 0-terminated C-string in <var>s</var>. It is explicitly not allowed to modify the contents of this string. Some built-in atoms may have the string allocated in read-only memory, so <q>temporary manipulation</q> can cause an error.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_string_chars(term_t +t, char **s, int *len)</code>
                  </dt>
                  <listitem>If <var>t</var> is a string object, store a pointer to a 0-terminated C-string in <var>s</var> and the length of the string in <var>len</var>. Note that this pointer is invalidated by backtracking, garbage-collection and stack-shifts, so generally the only safe operations are to pass it immediately to a C-function that doesn't involve Prolog.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_chars(term_t +t, char **s, unsigned flags)</code>
                  </dt>
                  <listitem>
                    <p>Convert the argument term <var>t</var> to a 0-terminated C-string. <var>flags</var> is a bitwise disjunction from two groups of constants. The first specifies which term-types should converted and the second how the argument is stored. Below is a specification of these constants. <code class="constant">BUF_RING</code> implies, if the data is not static (as from an atom), the data is copied to the next buffer from a ring of 16 buffers. This is a convenient way of converting multiple arguments passed to a foreign predicate to C-strings. If <code class="constant">BUF_MALLOC</code> is used, the data must be freed using <code class="function">PL_free()</code> when not needed any longer.</p>
                    <p>With the introduction of wide-characters (see section 2.17.1), not all atoms can be converted into a char*. This function fails if t is of the wrong type, but also if the text cannot be represented. See the REP_* flags below for details.</p>
                    <ul><listitem><code class="constant">CVT_ATOM</code>: Convert if term is an atom</listitem><listitem><code class="constant">CVT_STRING</code>: Convert if term is a string</listitem><listitem><code class="constant">CVT_LIST</code>: Convert if term is a list of integers between 1 and 255</listitem>
    CVT_INTEGER 	Convert if term is an integer (using %d)
    CVT_FLOAT 	Convert if term is a float (using %f)
    CVT_NUMBER 	Convert if term is a integer or float
    CVT_ATOMIC 	Convert if term is atomic
    CVT_VARIABLE	Convert variable to print-name
    CVT_WRITE 	Convert any term that is not converted by any of the other flags using write/1. If no BUF_* is provided, BUF_RING is implied.
    CVT_ALL 	Convert if term is any of the above, except for CVT_VARIABLE and CVT_WRITE
    CVT_EXCEPTION	If conversion fails due to a type error, raise a Prolog type error exception in addition to failure
    BUF_DISCARDABLE 	Data must copied immediately
    BUF_RING 	Data is stored in a ring of buffers
    BUF_MALLOC 	Data is copied to a new buffer returned by PL_malloc(3). When no longer needed the user must call PL_free() on the data.
    REP_ISO_LATIN_1 	(0, default). Text is in ISO Latin-1 encoding and the call fails if text cannot be represented.
    REP_UTF8 	Convert the text to a UTF-8 string. This works for all text.
    REP_MB 	Convert to default locale-defined 8-bit string. Success depends on the locale. Conversion is done using the wcrtomb() C-library function.
                    </ul>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_list_chars(+term_t l, char **s, unsigned flags)</code>
                  </dt>
                  <listitem>Same as <code class="function">PL_get_chars(l, s, CVT_LIST|flags)</code>, provided flags contains none of the <code class="constant">CVT_*</code> flags.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_integer(+term_t t, int *i)</code>
                  </dt>
                  <listitem>If <var>t</var> is a Prolog integer, assign its value over <var>i</var>. On 32-bit machines, this is the same as <code class="function">PL_get_long()</code>, but avoids a warning from the compiler. See also <code class="function">PL_get_long()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_long(term_t +t, long *i)</code>
                  </dt>
                  <listitem>If <var>t</var> is a Prolog integer that can be represented as a long, assign its value over <var>i</var>. If <var>t</var> is an integer that cannot be represented by a C long, this function returns FALSE. If <var>t</var> is a floating point number that can be represented as a long, this function succeeds as well. See also <code class="function">PL_get_int64()</code></listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_int64(term_t +t, int64_t *i)</code>
                  </dt>
                  <listitem>If <var>t</var> is a Prolog integer or float that can be represented as a <code class="classname">int64_t</code>, assign its value over <var>i</var>. Currently all Prolog integers can be represented using this type, but this might change if SWI-Prolog introduces unbounded integers.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_bool(term_t +t, int *val)</code>
                  </dt>
                  <listitem>If <var>t</var> has the value true or false, set <var>val</var> to the C constant TRUE or FALSE and return success. otherwise return failure.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_pointer(term_t +t, void **ptr)</code>
                  </dt>
                  <listitem>In the current system, pointers are represented by Prolog integers, but need some manipulation to make sure they do not get truncated due to the limited Prolog integer range. <code class="function">PL_put_pointer()</code> amd <code class="function">PL_get_pointer()</code> guarantee pointers in the range of <code class="function">malloc()</code> are handled without truncating.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_float(term_t +t, double *f)</code>
                  </dt>
                  <listitem>If <var>t</var> is a float or integer, its value is assigned over <var>f</var>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_functor(term_t +t, functor_t *f)</code>
                  </dt>
                  <listitem>If <var>t</var> is compound or an atom, the Prolog representation of the name-arity pair will be assigned over <var>f</var>. See also <code class="function">PL_get_name_arity()</code> and <code class="function">PL_is_functor()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_name_arity(term_t +t, atom_t *name, int *arity)</code>
                  </dt>
                  <listitem>If <var>t</var> is compound or an atom, the functor-name will be assigned over <var>name</var> and the arity over <var>arity</var>. See also <code class="function">PL_get_functor()</code> and <code class="function">PL_is_functor()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_module(term_t +t, module_t *module)</code>
                  </dt>
                  <listitem>If <var>t</var> is an atom, the system will lookup or create the corresponding module and assign an opaque pointer to it over <var>module</var>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_arg(int index, term_t +t, term_t -a)</code>
                  </dt>
                  <listitem>If <var>t</var> is compound and <var>index</var> is between 1 and arity (including), assign <var>a</var> with a term-reference to the argument.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int _PL_get_arg(int index, term_t +t, term_t -a)</code>
                  </dt>
                  <listitem>Same as <code class="function">PL_get_arg()</code>, but no checking is performed, nor whether <var>t</var> is actually a term, nor whether <var>index</var> is a valid argument-index.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>Exchanging text using length and string</i></p>
              <p>All internal text-representation of SWI-Prolog is represented using <kbd>char *</kbd> plus length and allow for 0-bytes in them. The foreign library supports this by implementing a <code class="function">*_nchars()</code> function for each applicable <code class="function">*_chars()</code> function. Below we briefly present the signatures of these functions. For full documentation consult the <code class="function">*_chars()</code> function.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">PL_get_atom_nchars(term_t t, size_t *len, char **s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_get_atom_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_list_nchars(term_t t, size_t *len, char **s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_get_list_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_nchars(term_t t, size_t *len, char **s, unsigned int flags)</code>
                  </dt>
                  <listitem>See <code class="function">PL_get_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_put_atom_nchars(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_put_atom_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_put_string_nchars(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_put_string_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_put_list_ncodes(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_put_list_codes()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_put_list_nchars(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_put_list_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_atom_nchars(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_unify_atom_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_string_nchars(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_unify_string_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_list_ncodes(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_unify_codes()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_list_nchars(term_t t, size_t len, const char *s)</code>
                  </dt>
                  <listitem>See <code class="function">PL_unify_list_chars()</code>.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p>In addition, the following functions are available for creating and inspecting atoms:</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">atom_t PL_new_atom_nchars(size_t len, const char *s)</code>
                  </dt>
                  <listitem>Create a new atom as <code class="function">PL_new_atom()</code>, but from length <var>len</var> and characters <var>s</var>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">const char * PL_atom_nchars(atom_t a, size_t *len)</code>
                  </dt>
                  <listitem>Extract text and length of an atom.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>Wide character versions</i></p>
              <p>Support for exchange of wide character strings is still under consideration. The functions dealing with 8-bit character strings return failure when operating on a wide character atom or Prolog string object. The functions below can extract and unify both 8-bit and wide atoms and string objects. Wide character strings are represented as C arrays of objects of the type <code class="classname">pl_wchar_t</code>, which is guaranteed to be the same as <code class="classname">wchar_t</code> on platforms supporting this type. For example, on MS-Windows, this represents 16-bit <code class="classname">UCS2</code> characters, while using the GNU C library (glibc) this represents 32-bit <code class="classname">UCS4</code> characters.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">atom_t PL_new_atom_wchars(size_t len, const pl_wchar_t *s)</code>
                  </dt>
                  <listitem>Create atom from wide-character string as <code class="function">PL_new_atom_nchars()</code> does for ISO-Latin-1 strings. If s only contains ISO-Latin-1 characters a normal byte-array atom is created.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">pl_wchar_t* PL_atom_wchars(atom_t atom, int *len)</code>
                  </dt>
                  <listitem>Extract characters from a wide-character atom. Fails (returns NULL) if atom is not a wide-character atom. This is the wide-character version of <code class="function">PL_atom_nchars()</code>. Note that only one of these functions succeeds on a particular atom. Especially, after creating an atom with <code class="function">PL_new_atom_wchars()</code>, extracting the text using <code class="function">PL_atom_wchars()</code> will fail if the atom only contains ISO-Latin-1 characters.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_get_wchars(term_t t, size_t *len, pl_wchar_t **s, unsigned flags)</code>
                  </dt>
                  <listitem>Wide-character version of <code class="function">PL_get_chars()</code>. The <var>flags</var> argument is the same as for <code class="function">PL_get_chars()</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_wchars(term_t t, int type, size_t len, const pl_wchar_t *s)</code>
                  </dt>
                  <listitem>Unify <var>t</var> with a textual representation of the C wide character array <var>s</var>. The <var>argtype</var> argument defines the Prolog representation and is one of <code class="constant">PL_ATOM</code>, <code class="constant">PL_STRING</code>, <code class="constant">PL_CODE_LIST</code> or <code class="constant">PL_CHAR_LIST</code>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_wchars_diff(term_t +t, term_t -tail, int type, size_t len, const pl_wchar_t *s)</code>
                  </dt>
                  <listitem>Difference list version of <code class="function">PL_unify_wchars()</code>, only supporting the types <code class="constant">PL_CODE_LIST</code> and <code class="constant">PL_CHAR_LIST</code>. It serves two purposes. It allows for returning very long lists from data read from a stream without the need for a resizing buffer in C. Also, the use of difference lists is often practical for further processing in Prolog. Examples can be found in <cite>packages/clib/readutil.c</cite> from the source distribution.</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>Reading a list</i></p>
              <p>The functions from this section are intended to read a Prolog list from C. Suppose we expect a list of atoms, the following code will print the atoms, each on a line:</p>
              <pre>foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();      /* variable for the elements */
  term_t list = PL_copy_term_ref(l);    /* copy as we need to write */

  while( PL_get_list(list, head, list) )
  { char *s;

    if ( PL_get_atom_chars(head, &amp;s) )
      Sprintf("%s\n", s);
    else
      PL_fail;
  }

  return PL_get_nil(list);              /* test end for [] */
}</pre>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">PL_get_list(term_t +l, term_t -h, term_t -t)</code>
                  </dt>
                  <listitem>If <var>l</var> is a list and not [] assign a term-reference to the head to <var>h</var> and to the tail to <var>t</var>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">PL_get_head(term_t +l, term_t -h)</code>
                  </dt>
                  <listitem>If <var>l</var> is a list and not [] assign a term-reference to the head to <var>h</var>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">PL_get_tail(term_t +l, term_t -t)</code>
                  </dt>
                  <listitem>If <var>l</var> is a list and not [] assign a term-reference to the tail to <var>t</var>.</listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">PL_get_nil(term_t +l)</code>
                  </dt>
                  <listitem>Succeeds if represents the atom [].</listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>An example: defining <code class="function">write/1</code> in C</i></p>
              <p>The following excerpt shows a simplified definition of <code class="function">write/1</code> to illustrate the described functions. This simplified version does not deal with operators. It is called <code class="function">display/1</code>, because it mimics closely the behaviour of this Edinburgh predicate.</p>
              <pre>foreign_t
pl_display(term_t t)
{ functor_t functor;
  int arity, len, n;
  char *s;

  switch( PL_term_type(t) )
  { case PL_VARIABLE:
    case PL_ATOM:
    case PL_INTEGER:
    case PL_FLOAT:
      PL_get_chars(t, &amp;s, CVT_ALL);
      Sprintf("%s", s);
      break;
    case PL_STRING:
      PL_get_string_chars(t, &amp;s, &amp;len);
      Sprintf("\"%s\"", s);
      break;
    case PL_TERM:
    { term_t a = PL_new_term_ref();

      PL_get_name_arity(t, &amp;name, &amp;arity);
      Sprintf("%s(", PL_atom_chars(name));
      for(n=1; n&lt;=arity; n++)
      { PL_get_arg(n, t, a);
        if ( n &gt; 1 )
          Sprintf(", ");
        pl_display(a);
      }
      Sprintf(")");
      break;
    default:
      PL_fail;                          /* should not happen */
  }

  PL_succeed;
}</pre>
              <p class="bridgehead"><i>Constructing Terms</i></p>
              <p>Terms can be constructed using functions from the <code class="function">PL_put_*()</code> and <code class="function">PL_cons_*()</code> families. This approach builds the term <q>inside-out</q>, starting at the leaves and subsequently creating compound terms. Alternatively, terms may be created <q>top-down</q>, first creating a compound holding only variables and subsequently unifying the arguments. This section discusses functions for the first approach. This approach is generally used for creating arguments for <code class="function">PL_call()</code> and <code class="function">PL_open_query</code>.</p>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_variable(term_t -t)</code>
                  </dt>
                  <listitem>
                    <p>Put a fresh variable in the term. The new variable lives on the global stack. Note that the initial variable lives on the local stack and is lost after a write to the term-references. After using this function, the variable will continue to live.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_atom(term_t -t, atom_t a)</code>
                  </dt>
                  <listitem>
                    <p>Put an atom in the term reference from a handle. See also PL_new_atom() and PL_atom_chars().</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_atom_chars(term_t -t, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Put an atom in the term-reference constructed from the 0-terminated string. The string itself will never be referenced by Prolog after this function.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_string_chars(term_t -t, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Put a zero-terminated string in the term-reference. The data will be copied. See also PL_put_string_nchars().</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_string_nchars(term_t -t, size_t len, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Put a string, represented by a length/start pointer pair in the term-reference. The data will be copied. This interface can deal with 0-bytes in the string. See also section 9.6.19.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_list_chars(term_t -t, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Put a list of ASCII values in the term-reference.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_integer(term_t -t, long i)</code>
                  </dt>
                  <listitem>
                    <p>Put a Prolog integer in the term reference.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_int64(term_t -t, int64_t i)</code>
                  </dt>
                  <listitem>
                    <p>Put a Prolog integer in the term reference <var>t</var>.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_pointer(term_t -t, void *ptr)</code>
                  </dt>
                  <listitem>
                    <p>Put a Prolog integer in the term-reference. Provided ptr is in the `malloc()-area', PL_get_pointer() will get the pointer back.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_float(term_t -t, double f)</code>
                  </dt>
                  <listitem>
                    <p>Put a floating-point value in the term-reference.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_functor(term_t -t, functor_t functor)</code>
                  </dt>
                  <listitem>
                    <p>Create a new compound term from functor and bind t to this term. All arguments of the term will be variables. To create a term with instantiated arguments, either instantiate the arguments using the PL_unify_*() functions or use PL_cons_functor().</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_list(term_t -l)</code>
                  </dt>
                  <listitem>
                    <p>Same as PL_put_functor(l, PL_new_functor(PL_new_atom("."), 2)).</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_nil(term_t -l)</code>
                  </dt>
                  <listitem>
                    <p>Same as PL_put_atom_chars("[]").</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_put_term(term_t -t1, term_t +t2)</code>
                  </dt>
                  <listitem>
                    <p>Make t1 point to the same term as t2.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_cons_functor(term_t -h, functor_t f, ...)</code>
                  </dt>
                  <listitem>
                    <p>Create a term, whose arguments are filled from variable argument list holding the same number of term_t objects as the arity of the functor. To create the term animal(gnu, 50), use:</p>
                    <pre>{ term_t a1 = PL_new_term_ref();
      term_t a2 = PL_new_term_ref();
      term_t t  = PL_new_term_ref();
      functor_t animal2;

      /* animal2 is a constant that may be bound to a global
         variable and re-used
      */
      animal2 = PL_new_functor(PL_new_atom("animal"), 2);

      PL_put_atom_chars(a1, "gnu");
      PL_put_integer(a2, 50);
      PL_cons_functor(t, animal2, a1, a2);
    }</pre>
                    <p>After this sequence, the term-references a1 and a2 may be used for other purposes.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_cons_functor_v(term_t -h, functor_t f, term_t a0)</code>
                  </dt>
                  <listitem>
                    <p>Creates a compound term like PL_cons_functor(), but a0 is an array of term references as returned by PL_new_term_refs(). The length of this array should match the number of arguments required by the functor.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_cons_list(term_t -l, term_t +h, term_t +t)</code>
                  </dt>
                  <listitem>
                    <p>Create a list (cons-) cell in l from the head and tail. The code below creates a list of atoms from a char **. The list is built tail-to-head. The PL_unify_*() functions can be used to build a list head-to-tail.</p>
                    <pre>void
    put_list(term_t l, int n, char **words)
    { term_t a = PL_new_term_ref();

      PL_put_nil(l);
      while( --n &gt;= 0 )
      { PL_put_atom_chars(a, words[n]);
        PL_cons_list(l, a, l);
      }
    }</pre>
                    <p>Note that l can be redefined within a PL_cons_list call as shown here because operationally its old value is consumed before its new value is set.</p>
                  </listitem>
                <!-- </varlistentry> -->
              </dl>
              <p class="bridgehead"><i>Unifying data</i></p>
              <p>The functions of this sections unify terms with other terms or translated C-data structures. Except for <code class="function">PL_unify()</code>, the functions of this section are specific to SWI-Prolog. They have been introduced to make translation of old code easier, but also because they provide for a faster mechanism for returning data to Prolog that requires less term-references. Consider the case where we want a foreign function to return the host name of the machine Prolog is running on. Using the <code class="function">PL_get_*()</code> and <code class="function">PL_put_*()</code> functions, the code becomes:</p>
              <pre>foreign_t pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
  { term_t tmp = PL_new_term_ref();

    PL_put_atom_chars(tmp, buf);
    return PL_unify(name, tmp);
  }

  PL_fail;
}</pre>
              <p>Using <code class="function">PL_unify_atom_chars()</code>, this becomes:</p>
              <pre>foreign_t pl_hostname(term_t name)
{ char buf[100];

  if ( gethostname(buf, sizeof(buf)) )
    return PL_unify_atom_chars(name, buf);

  PL_fail;
}</pre>
              <dl>
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify(term_t ?t1, term_t ?t2)</code>
                  </dt>
                  <listitem>
                    <p>Unify two Prolog terms and return non-zero on success.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_atom(term_t ?t, atom_t a)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with the atom a and return non-zero on success.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_chars(term_t ?t, int flags, size_t len, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>New function to deal with unification of <kbd>char*</kbd> with various encodings to a Prolog representation. The flags argument is a bitwise or specifying the Prolog target type and the encoding of chars. Prolog types is one of <code class="constant">PL_ATOM</code>, <code class="constant">PL_STRING</code>, <code class="constant">PL_CODE_LIST</code> or <code class="constant">PL_CHAR_LIST</code>. Representations is one of <code class="constant">REP_ISO_LATIN_1</code>, <code class="constant">REP_UTF8</code> or <code class="constant">REP_MB</code>. See <code class="function">PL_get_chars()</code> for a definition of the representation types. If <var>len</var> is -1, then <var>chars</var> must be 0-terminated and the length is computed from <var>chars</var> using <code class="function">strlen()</code>.</p>
                    <p>If <var>flags</var> includes <code class="constant">PL_DIFF_LIST</code> and type is one of <code class="constant">PL_CODE_LIST</code> or <code class="constant">PL_CHAR_LIST</code>, the text is converted to a difference list. The tail of the difference list is t+1.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_atom_chars(term_t ?t, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with an atom created from chars and return non-zero on success.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_list_chars(term_t ?t, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a list of ASCII characters constructed from chars.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_unify_string_chars(term_t ?t, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Unify <var>t</var> with a Prolog string object created from the zero-terminated string chars. The data will be copied. See also <code class="function">PL_unify_string_nchars()</code>.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">void PL_unify_string_nchars(term_t ?t, size_t len, const char *chars)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a Prolog string object created from the string created from the len/chars pair. The data will be copied. This interface can deal with 0-bytes in the string.</p> <!-- See also section 9.6.19.-->
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_integer(term_t ?t, long n)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a Prolog integer from n.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_int64(term_t ?t, int64_t n)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a Prolog integer from n.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_float(term_t ?t, double f)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a Prolog float from f.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_pointer(term_t ?t, void *ptr)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a Prolog integer describing the pointer. See also <code class="function">PL_put_pointer()</code> and <code class="function">PL_get_pointer()</code>.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_functor(term_t ?t, functor_t f)</code>
                  </dt>
                  <listitem>
                    <p>If t is a compound term with the given functor, just succeed. If it is unbound, create a term and bind the variable, else fails. Note that this function does not create a term if the argument is already instantiated.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_list(term_t ?l, term_t -h, term_t -t)</code>
                  </dt>
                  <listitem>
                    <p>Unify l with a list-cell (./2). If successful, write a reference to the head of the list to h and a reference to the tail of the list into t. This reference may be used for subsequent calls to this function. Suppose we want to return a list of atoms from a char **. We could use the example described by <code class="function">PL_put_list()</code>, followed by a call to <code class="function">PL_unify()</code>, or we can use the code below. If the predicate argument is unbound, the difference is minimal (the code based on <code class="function">PL_put_list()</code> is probably slightly faster). If the argument is bound, the code below may fail before reaching the end of the word-list, but even if the unification succeeds, this code avoids a duplicate (garbage) list and a deep unification.</p>
                    <pre>foreign_t pl_get_environ(term_t env)
                                    { term_t l = PL_copy_term_ref(env);
                                      term_t a = PL_new_term_ref();
                                      extern char **environ;
                                      char **e;

                                      for(e = environ; *e; e++)
                                      { if ( !PL_unify_list(l, a, l) ||
                                             !PL_unify_atom_chars(a, *e) )
                                          PL_fail;
                                      }

                                      return PL_unify_nil(l);
                                    }</pre>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_nil(term_t ?l)</code>
                  </dt>
                  <listitem>
                    <p>Unify l with the atom [].</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_arg(int index, term_t ?t, term_t ?a)</code>
                  </dt>
                  <listitem>
                    <p>Unifies the index-th argument (1-based) of t with a.</p>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_unify_term(term_t ?t, ...)</code>
                  </dt>
                  <listitem>
                    <p>Unify t with a (normally) compound term. The remaining arguments is a sequence of a type identifier, followed by the required arguments. This predicate is an extension to the Quintus and SICStus foreign interface from which the SWI-Prolog foreign interface has been derived, but has proved to be a powerful and comfortable way to create compound terms from C. Due to the vararg packing/unpacking and the required type-switching this interface is slightly slower than using the primitives. Please note that some bad C-compilers have fairly low limits on the number of arguments that may be passed to a function.</p>
                    <p>Special attention is required when passing numbers. C `promotes' any integral smaller than int to int. I.e. the types char, short and int are all passed as int. In addition, on most 32-bit platforms int and long are the same. Up-to version 4.0.5, only PL_INTEGER could be specified which was taken from the stack as long. Such code fails when passing small integral types on machines where int is smaller than long. It is advised to use PL_SHORT, PL_INT or PL_LONG as appropriate. Similar, C compilers promote float to double and therefore PL_FLOAT and PL_DOUBLE are synonyms.</p>
                    <p>The type identifiers are:</p>
                    <dl>
                    <!-- <varlistentry> -->

                    <dt><code class="constant">PL_VARIABLE</code>: <code class="classname">none</code></dt>
                    <listitem><p>No op. Used in arguments of PL_FUNCTOR.</p></listitem><!-- </varlistentry> --><!-- <varlistentry> -->

                    <dt><code class="constant">PL_BOOL</code>: <code class="classname">int</code></dt>
                    <listitem><p>Unify the argument with true or false.</p></listitem><!-- </varlistentry> --><!-- <varlistentry> -->

                    <dt><code class="constant">PL_ATOM</code>: <code class="classname">atom_t</code></dt>
                    <listitem><p>Unify the argument with an atom, as in PL_unify_atom().</p></listitem><!-- </varlistentry> --><!-- <varlistentry> -->

                    <dt><code class="constant">PL_CHARS</code>: <code class="classname">const char *</code></dt><listitem><p>Unify the argument with an atom, constructed from the C char *, as in PL_unify_atom_chars().</p></listitem><!-- </varlistentry> --><!-- <varlistentry> --><dt><code class="constant">PL_NCHARS</code>: <code class="classname">size_t, const char *</code></dt><listitem><p>Unify the argument with an atom, constructed from length and char* as in PL_unify_atom_nchars().</p></listitem><!-- </varlistentry> -->
    PL_UTF8_CHARS const char *
        Create an atom from a UTF-8 string.
    PL_UTF8_STRING const char *
        Create a packed string object from a UTF-8 string.
                      <!-- <varlistentry> --><dt><code class="constant">PL_MBCHARS</code>: <code class="classname">const char *</code></dt><listitem><p>Create an atom from a multi-byte string in the current locale.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_MBCODES</code>: <code class="classname">const char *</code></dt><listitem><p>Create a list of character codes from a multi-byte string in the current locale.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_MBSTRING</code>: <code class="classname">const char *</code></dt><listitem><p>Create a packed string object from a multi-byte string in the current locale.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_NWCHARS</code>: <code class="classname">size_t, const wchar_t *</code></dt><listitem><p>Create an atom from a length and a wide character pointer.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_NWCODES</code>: <code class="classname">size_t, const wchar_t *</code></dt><listitem><p>Create an list of character codes from a length and a wide character pointer.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_NWSTRING</code>: <code class="classname">size_t, const wchar_t *</code></dt><listitem><p>Create a packed string object from a length and a wide character pointer.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_SHORT</code>: <code class="classname">short</code></dt><listitem><p>Unify the argument with an integer, as in PL_unify_integer(). As short is promoted to int, PL_SHORT is a synonym for PL_INT.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_INTEGER</code>: <code class="classname">long</code></dt><listitem><p>Unify the argument with an integer, as in PL_unify_integer().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_INT</code>: <code class="classname">int</code></dt><listitem><p>Unify the argument with an integer, as in PL_unify_integer().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_LONG</code>: <code class="classname">long</code></dt><listitem><p>Unify the argument with an integer, as in PL_unify_integer().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_INT64</code>: <code class="classname">int64_t</code></dt><listitem><p>Unify the argument with a 64-bit integer, as in PL_unify_int64().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_INTPTR</code>: <code class="classname">intptr_t</code></dt><listitem><p>Unify the argument with an integer with the same width as a pointer. On most machines this is the same as PL_LONG. but on 64-bit MS-Windows pointers are 64-bit while longs are only 32-bits.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_DOUBLE</code>: <code class="classname">double</code></dt><listitem><p>Unify the argument with a float, as in PL_unify_float(). Note that, as the argument is passed using the C vararg conventions, a float must be casted to a double explicitly.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_FLOAT</code>: <code class="classname">double</code></dt><listitem><p>Unify the argument with a float, as in PL_unify_float().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_POINTER</code>: <code class="classname">void *</code></dt><listitem><p>Unify the argument with a pointer, as in PL_unify_pointer().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_STRING</code>: <code class="classname">const char *</code></dt><listitem><p>Unify the argument with a string object, as in PL_unify_string_chars().</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_TERM</code>: <code class="classname">term_t</code></dt><listitem><p>Unify a subterm. Note this may the return value of a PL_new_term_ref() call to get access to a variable.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_FUNCTOR</code>: <code class="classname">functor_t, ...</code></dt><listitem><p>Unify the argument with a compound term. This specification should be followed by exactly as many specifications as the number of arguments of the compound term.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_FUNCTOR_CHARS</code>: <code class="classname">const char *name, int arity, ...</code></dt><listitem><p>Create a functor from the given name and arity and then behave as PL_FUNCTOR.</p></listitem><!-- </varlistentry> -->
                      <!-- <varlistentry> --><dt><code class="constant">PL_LIST</code>: <code class="classname">int length, ...</code></dt>
                      <listitem>
                        <p>Create a list of the indicated length. The following arguments contain the elements of the list. For example, to unify an argument with the term language(dutch), the following skeleton may be used:</p>
                      <pre>static functor_t FUNCTOR_language1;

    static void
    init_constants()
    { FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"), 1);
    }

    foreign_t
    pl_get_lang(term_t r)
    { return PL_unify_term(r,
                           PL_FUNCTOR, FUNCTOR_language1,
                               PL_CHARS, "dutch");
    }

    install_t
    install()
    { PL_register_foreign("get_lang", 1, pl_get_lang, 0);
      init_constants();
    }</pre></listitem><!-- </varlistentry> -->
                    </dl>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">int PL_chars_to_term(const char *chars, term_t -t)</code>
                  </dt>
                  <listitem>
                    <p>Parse the string chars and put the resulting Prolog term into t. chars may or may not be closed using a Prolog full-stop (i.e., a dot followed by a blank). Returns FALSE if a syntax error was encountered and TRUE after successful completion. In addition to returning FALSE, the exception-term is returned in t on a syntax error. See also term_to_atom/2.</p>
                    <p>The following example build a goal-term from a string and calls it.</p>
                    <pre>int call_chars(const char *goal) {
      fid_t fid = PL_open_foreign_frame();
      term_t g = PL_new_term_ref();
      BOOL rval;

      if ( PL_chars_to_term(goal, g) )
        rval = PL_call(goal, NULL);
      else
        rval = FALSE;

      PL_discard_foreign_frame(fid);
      return rval;
    }

      ...
      call_chars("consult(load)");
      ...</pre>
                  </listitem>
                <!-- </varlistentry> -->
                <!-- <varlistentry> -->
                  <dt>
                    <code class="function">char * PL_quote(int chr, const char *string)</code>
                  </dt>
                  <listitem>
                    <p>Return a quoted version of string. If chr is '\'', the result is a quoted atom. If chr is '"', the result is a string. The result string is stored in the same ring of buffers as described with the BUF_RING argument of PL_get_chars();</p>
                    <p>In the current implementation, the string is surrounded by chr and any occurrence of chr is doubled. In the future the behaviour will depend on the character_escapes Prolog flag.</p>
                  </listitem>
                <!-- </varlistentry> -->
              </dl>
              <literallayout>

9.6.6 BLOBS: Using atoms to store arbitrary binary data

SWI-Prolog atoms as well as strings can represent arbitrary binary data of arbitrary length. This facility is attractive for storing foreign data such as images in an atom. An atom is a unique handle to this data and the atom garbage collector is able to destroy atoms that are no longer referenced by the Prolog engine. This property of atoms makes them attractive as a handle to foreign resources, such as Java atoms, Microsoft's COM objects, etc., providing safe combined garbage collection.

To exploit these features safely and in an organised manner the SWI-Prolog foreign interface allows for creating `atoms' with additional type information. The type is represented by a structure holding C function pointers that tell Prolog how to handle releasing the atom, writing it, sorting it, etc. Two atoms created with different types can represent the same sequence of bytes. Atoms are first ordered on the rank number of the type and then on the result of the compare() function. Rank numbers are assigned when the type is registered.
9.6.6.1 Defining a BLOB type

The type PL_blob_t represents a structure with the layout displayed above. The structure contains additional fields at the ... for internal bookkeeping as well as future extension.

typedef struct PL_blob_t
{ unsigned long         magic;          /* PL_BLOB_MAGIC */
  unsigned long         flags;          /* Bitwise or of PL_BLOB_* */
  char *                name;           /* name of the type */
  int                   (*release)(atom_t a);
  int                   (*compare)(atom_t a, atom_t b);
  int                   (*write)(IOSTREAM *s, atom_t a, int flags);
  int                   (*acquire)(atom_t a);
  ...
} PL_blob_t;

For each type exactly one such structure should be allocated. Its first field must be initialised to PL_BLOB_MAGIC. The flags is a bitwise or of the following constants:
              &lt;dl&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;PL_BLOB_TEXT&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;If specified the blob is assumed to contain text and is considered a normal Prolog atom.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;PL_BLOB_UNIQUE&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;If specified the system ensures that the blob-handle is a unique reference for a blob with the given type, length and content. If this flag is not specified each lookup creates a new blob.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;PL_BLOB_NOCOPY&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;By default the content of the blob is copied. Using this flag the blob references the external data directly. The user must ensure the provided pointer is valid as long as the atom lives. If PL_BLOB_UNIQUE is also specified uniqueness is determined by comparing the pointer rather than the data pointed at.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
              &lt;/dl&gt;
              &lt;para&gt;The name field represents the type name as available to Prolog. See also &lt;function&gt;current_blob/2&lt;/function&gt;. The other field are function pointers that must be initialised to proper functions or NULL to get the default behaviour of built-in atoms. Below are the defined member functions:&lt;/para&gt;
              &lt;dl&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void acquire(atom_t a)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;Called if a new blob of this type is created through &lt;function&gt;PL_put_blob()&lt;/function&gt; or &lt;function&gt;PL_unify_blob()&lt;/function&gt;. This callback may be used together with the release hook to deal with reference counted external objects.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int release(atom_t a)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;The blob (atom) a is about to be released. This function can retrieve the data of the blob using &lt;function&gt;PL_blob_data()&lt;/function&gt;. If it returns FALSE the atom garbage collector will not reclaim the atom.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int compare(atom_t a, atom_t b)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;Compare the blobs a and b, both of which are of the type associated to this blob-type. Return values are, as &lt;function&gt;memcmp()&lt;/function&gt;, &amp;lt; 0 if a is less then b, = 0 if both are equal and &amp;gt; 0 otherwise.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int write(IOSTREAM *s, atom_t a, int flags)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;Write the content of the blob a to the stream s and respecting the flags. The flags are a bitwise or of zero or more of the PL_WRT_* flags defined in SWI-Prolog.h. This prototype is available if the undocumented SWI-Stream.h is included before &lt;cite&gt;SWI-Prolog.h&lt;/cite&gt;.&lt;/para&gt;
                    &lt;para&gt;If this function is not provided, &lt;function&gt;write/1&lt;/function&gt; emits the content of the blob for blobs of type PL_BLOB_TEXT or a string of the format &amp;lt;#hex data&amp;gt; for binary blobs.&lt;/para&gt;
                    &lt;para&gt;If a blob type is registered from a loadable object (shared object or DLL) the blob-type must be deregistered before the object may be released.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_unregister_blob_type(PL_blob_t *type)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;Unlink the blob type from the registered type and transform the type of possible living blobs to unregistered, avoiding further reference to the type structure, functions referred by it as well as the data. This function returns TRUE if no blobs of this type existed and FALSE otherwise. PL_unregister_blob_type() is intended for the uninstall() hook of foreign modules, avoiding further references to the module.&lt;/para&gt;
                  &lt;/listitem&gt;
                &lt;/varlistentry&gt;
              &lt;/dl&gt;

9.6.6.2 Accessing blobs

The blob access functions are similar to the atom accessing functions. Blobs being atoms, the atom functions operate on blobs and visa versa. For clarity and possible future compatibility issues however it is not advised to rely on this.

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_is_blob(term_t t, PL_blob_t **type)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Succeeds if t refers to a blob, in which case type is filled with the type of the blob.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_unify_blob(term_t t, void *blob, size_t len, PL_blob_t *type)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Unify t to a new blob constructed from the given data and associated to the given type. See also PL_unify_atom_nchars().
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_put_blob(term_t t, void *blob, size_t len, PL_blob_t *type)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Store the described blob in t. The return value indicates whether a new blob was allocated (FALSE) or the blob is a reference to an existing blob (TRUE). Reporting new/existing can be used to deal with external objects having their own reference counts. If the return is TRUE this reference count must be incremented and it must be decremented on blob destruction callback. See also PL_put_atom_nchars().
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_get_blob(term_t t, void **blob, size_t *len, PL_blob_t **type)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    If t holds a blob or atom get the data and type and return TRUE. Otherwise return FALSE. Each result pointer may be NULL, in which case the requested information is ignored.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void * PL_blob_data(atom_t a, size_t *len, PL_blob_t **type)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Get the data and type associated to a blob. This function is mainly used from the callback functions described in section 9.6.6.1.

9.6.7 Exchanging GMP numbers

If SWI-Prolog is linked with the GNU Multiple Precision Arithmetic Library (GMP, used by default), the foreign interface provides functions for exchanging numeric values to GMP types. To access these functions the header &lt;cite&gt;&amp;lt;gmp.h&amp;gt;&lt;/cite&gt; must be included before &lt;cite&gt;&amp;lt;SWI-Prolog.h&amp;gt;&lt;/cite&gt;. Foreign code using &lt;cite&gt;GMP&lt;/cite&gt; linked to SWI-Prolog asks for some considerations.

    SWI-Prolog normally rebinds the GMP allocation functions using mp_set_memory_functions(). This means SWI-Prolog must be initialised before the foreign code touches any GMP function. You can call PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, TRUE) to force Prolog's GMP initialization without doing the rest of the Prolog initialization. If you do not want Prolog rebinding the GMP allocation, call PL_action(PL_GMP_SET_ALLOC_FUNCTIONS, FALSE) before initializing Prolog.

    On Windows, each DLL has its own memory pool. To make exchange of GMP numbers between Prolog and foreign code possible you must either let Prolog rebind the allocation functions (default) or you must recompile SWI-Prolog to link to a DLL version of the GMP library.

Here is an example exploiting the function mpz_nextprime():
</literallayout>
              <pre>#include &lt;gmp.h&gt;
#include &lt;SWI-Prolog.h&gt;

static foreign_t
next_prime(term_t n, term_t prime)
{ mpz_t mpz;
  int rc;

  mpz_init(mpz);
  if ( PL_get_mpz(n, mpz) )
  { mpz_nextprime(mpz, mpz);

    rc = PL_unify_mpz(prime, mpz);
  } else
    rc = FALSE;

  mpz_clear(mpz);
  return rc;
}

install_t
install()
{ PL_register_foreign("next_prime", 2, next_prime, 0);
}</pre>
              <literallayout>

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_get_mpz(term_t t, mpz_t mpz)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    If t represents an integer mpz is filled with the value and the function returns TRUE. Otherwise mpz is untouched and the function returns FALSE. Note that mpz must have been initialised before calling this function and must be cleared using mpz_clear() to reclaim any storage associated with it.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_get_mpq(term_t t, mpq_t mpq)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    If t is an integer or rational number (term rdiv/2 ) mpq is filled with the normalise rational number and the function returns TRUE. Otherwise mpq is untouched and the function returns FALSE. Note that mpq must have been initialised before calling this function and must be cleared using mpq_clear() to reclaim any storage associated with it.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_unify_mpz(term_t t, mpz_t mpz)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Unify t with the integer value represented by mpz and return TRUE on success. The mpz argument is not changed.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_unify_mpq(term_t t, mpq_t mpq)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Unify t with a rational number represented by mpq and return TRUE on success. Note that t is unified with an integer if the denominator is 1. The mpq argument is not changed.

9.6.8 Calling Prolog from C

The Prolog engine can be called from C. There are two interfaces for this. For the first, a term is created that could be used as an argument to call/1 and next PL_call() is used to call Prolog. This system is simple, but does not allow to inspect the different answers to a non-deterministic goal and is relatively slow as the runtime system needs to find the predicate. The other interface is based on PL_open_query(), PL_next_solution() and PL_cut_query() or PL_close_query(). This mechanism is more powerful, but also more complicated to use.
9.6.8.1 Predicate references

This section discusses the functions used to communicate about predicates. Though a Prolog predicate may defined or not, redefined, etc., a Prolog predicate has a handle that is not destroyed, nor moved. This handle is known by the type predicate_t.

predicate_t PL_pred(functor_t f, module_t m)
    Return a handle to a predicate for the specified name/arity in the given module. This function always succeeds, creating a handle for an undefined predicate if no handle was available. If the module argument m is NULL, the current context module is used.
predicate_t PL_predicate(const char *name, int arity, const char* module)
    Same a PL_pred(), but provides a more convenient interface to the C-programmer.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_predicate_info(predicate_t p, atom_t *n, int *a, module_t *m)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Return information on the predicate p. The name is stored over n, the arity over a, while m receives the definition module. Note that the latter need not be the same as specified with PL_predicate(). If the predicate is imported into the module given to PL_predicate(), this function will return the module where the predicate is defined.

9.6.8.2 Initiating a query from C

This section discusses the functions for creating and manipulating queries from C. Note that a foreign context can have at most one active query. This implies it is allowed to make strictly nested calls between C and Prolog (Prolog calls C, calls Prolog, calls C, etc., but it is not allowed to open multiple queries and start generating solutions for each of them by calling PL_next_solution(). Be sure to call PL_cut_query() or PL_close_query() on any query you opened before opening the next or returning control back to Prolog.

qid_t PL_open_query(module_t ctx, int flags, predicate_t p, term_t +t0)

    Opens a query and returns an identifier for it. This function always succeeds, regardless whether the predicate is defined or not. ctx is the context module of the goal. When NULL, the context module of the calling context will be used, or user if there is no calling context (as may happen in embedded systems). Note that the context module only matters for module_transparent predicates. See context_module/1 and module_transparent/1. The p argument specifies the predicate, and should be the result of a call to PL_pred() or PL_predicate(). Note that it is allowed to store this handle as global data and reuse it for future queries. The term-reference t0 is the first of a vector of term-references as returned by PL_new_term_refs(n).

    The flags arguments provides some additional options concerning debugging and exception handling. It is a bitwise or of the following values:

    PL_Q_NORMAL
        Normal operation. The debugger inherits its settings from the environment. If an exception occurs that is not handled in Prolog, a message is printed and the tracer is started to debug the error.79
    PL_Q_NODEBUG
        Switch off the debugger while executing the goal. This option is used by many calls to hook-predicates to avoid tracing the hooks. An example is print/1 calling portray/1 from foreign code.
    PL_Q_CATCH_EXCEPTION
        If an exception is raised while executing the goal, do not report it, but make it available for PL_exception().
    PL_Q_PASS_EXCEPTION
        As PL_Q_CATCH_EXCEPTION, but do not invalidate the exception-term while calling PL_close_query(). This option is experimental.

    The example below opens a query to the predicate is_a/2 to find the ancestor of for some name.

    char *
    ancestor(const char *me)
    { term_t a0 = PL_new_term_refs(2);
      static predicate_t p;

      if ( !p )
        p = PL_predicate("is_a", 2, "database");

      PL_put_atom_chars(a0, me);
      PL_open_query(NULL, PL_Q_NORMAL, p, a0);
      ...
    }

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_next_solution(qid_t qid)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Generate the first (next) solution for the given query. The return value is TRUE if a solution was found, or FALSE to indicate the query could not be proven. This function may be called repeatedly until it fails to generate all solutions to the query.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_cut_query(qid)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Discards the query, but does not delete any of the data created by the query. It just invalidate qid, allowing for a new call to PL_open_query() in this context.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_close_query(qid)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    As PL_cut_query(), but all data and bindings created by the query are destroyed.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_call_predicate(module_t m, int flags, predicate_t pred, term_t +t0)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Shorthand for PL_open_query(), PL_next_solution(), PL_cut_query(), generating a single solution. The arguments are the same as for PL_open_query(), the return value is the same as PL_next_solution().
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_call(term_t, module_t)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Call term just like the Prolog predicate once/1. Term is called in the specified module, or in the context module if module_t = NULL. Returns TRUE if the call succeeds, FALSE otherwise. Figure 10 shows an example to obtain the number of defined atoms. All checks are omitted to improve readability.

9.6.9 Discarding Data

The Prolog data created and term-references needed to setup the call and/or analyse the result can in most cases be discarded right after the call. PL_close_query() allows for destructing the data, while leaving the term-references. The calls below may be used to destroy term-references and data. See figure 10 for an example.

fid_t PL_open_foreign_frame()
    Created a foreign frame, holding a mark that allows the system to undo bindings and destroy data created after it as well as providing the environment for creating term-references. This function is called by the kernel before calling a foreign predicate.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_close_foreign_frame(fid_t id)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Discard all term-references created after the frame was opened. All other Prolog data is retained. This function is called by the kernel whenever a foreign function returns control back to Prolog.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_discard_foreign_frame(fid_t id)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Same as PL_close_foreign_frame(), but also undo all bindings made since the open and destroy all Prolog data.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_rewind_foreign_frame(fid_t id)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Undo all bindings and discard all term-references created since the frame was created, but does not pop the frame. I.e. the same frame can be rewinded multiple times, and must eventually be closed or discarded.

It is obligatory to call either of the two closing functions to discard a foreign frame. Foreign frames may be nested.
</literallayout>
              <pre>int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
  term_t goal  = PL_new_term_ref();
  term_t a1    = PL_new_term_ref();
  term_t a2    = PL_new_term_ref();
  functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);
  int atoms;

  PL_put_atom_chars(a1, "atoms");
  PL_cons_functor(goal, s2, a1, a2);
  PL_call(goal, NULL);         /* call it in current module */

  PL_get_integer(a2, &amp;atoms);
  PL_discard_foreign_frame(fid);

  return atoms;
}</pre>
              <literallayout>
Figure 10 : Calling Prolog
9.6.10 Foreign Code and Modules

Modules are identified via a unique handle. The following functions are available to query and manipulate modules.

module_t PL_context()
    Return the module identifier of the context module of the currently active foreign predicate.
int PL_strip_module(term_t +raw, module_t *m, term_t -plain)
Utility function. If raw is a term, possibly holding the module construct &lt;var&gt;&amp;lt;module&amp;gt;:&amp;lt;restgt;&lt;/var&gt; this function will make plain a reference to &lt;var&gt;&amp;lt;rest&amp;gt;&lt;/var&gt; and fill module * with &lt;var&gt;&amp;lt;module&amp;gt;&lt;/var&gt;. For further nested module constructs the inner most module is returned via module *. If raw is not a module construct arg will simply be put in plain. If module * is NULL it will be set to the context module. Otherwise it will be left untouched. The following example shows how to obtain the plain term and module if the default module is the user module:
</literallayout>
              <pre>{ module m = PL_new_module(PL_new_atom("user"));
      term_t plain = PL_new_term_ref();

      PL_strip_module(term, &amp;m, plain);
      ...</pre>
              <literallayout>

atom_t PL_module_name(module_t)
    Return the name of module as an atom.
module_t PL_new_module(atom_t name)
    Find an existing or create a new module with name specified by the atom name.

9.6.11 Prolog exceptions in foreign code

This section discusses PL_exception(), PL_throw() and PL_raise_exception(), the interface functions to detect and generate Prolog exceptions from C-code. PL_throw() and PL_raise_exception() from the C-interface to raise an exception from foreign code. PL_throw() exploits the C-function longjmp() to return immediately to the innermost PL_next_solution(). PL_raise_exception() registers the exception term and returns FALSE. If a foreign predicate returns FALSE, while and exception-term is registered a Prolog exception will be raised by the virtual machine.

Calling these functions outside the context of a function implementing a foreign predicate results in undefined behaviour.

PL_exception() may be used after a call to PL_next_solution() fails, and returns a term reference to an exception term if an exception was raised, and 0 otherwise.

If a C-function, implementing a predicate calls Prolog and detects an exception using PL_exception(), it can handle this exception, or return with the exception. Some caution is required though. It is not allowed to call PL_close_query() or PL_discard_foreign_frame() afterwards, as this will invalidate the exception term. Below is the code that calls a Prolog defined arithmetic function (see arithmetic_function/1).

If PL_next_solution() succeeds, the result is analysed and translated to a number, after which the query is closed and all Prolog data created after PL_open_foreign_frame() is destroyed. On the other hand, if PL_next_solution() fails and if an exception was raised, just pass it. Otherwise generate an exception (PL_error() is an internal call for building the standard error terms and calling PL_raise_exception()). After this, the Prolog environment should be discarded using PL_cut_query() and PL_close_foreign_frame() to avoid invalidating the exception term.

static int
prologFunction(ArithFunction f, term_t av, Number r)
{ int arity = f-&gt;proc-&gt;definition-&gt;functor-&gt;arity;
  fid_t fid = PL_open_foreign_frame();
  qid_t qid;
  int rval;

  qid = PL_open_query(NULL, PL_Q_NORMAL, f-&gt;proc, av);

  if ( PL_next_solution(qid) )
  { rval = valueExpression(av+arity-1, r);
    PL_close_query(qid);
    PL_discard_foreign_frame(fid);
  } else
  { term_t except;

    if ( (except = PL_exception(qid)) )
    { rval = PL_throw(except);          /* pass exception */
    } else
    { char *name = stringAtom(f-&gt;proc-&gt;definition-&gt;functor-&gt;name);

                                        /* generate exception */
      rval = PL_error(name, arity-1, NULL, ERR_FAILED, f-&gt;proc);
    }

    PL_cut_query(qid);                  /* donot destroy data */
    PL_close_foreign_frame(fid);        /* same */
  }

  return rval;
}

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_raise_exception(term_t exception)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Generate an exception (as throw/1) and return FALSE. Below is an example returning an exception from foreign predicate:
    </literallayout>
              <pre>foreign_t
    pl_hello(term_t to)
    { char *s;

      if ( PL_get_atom_chars(to, &amp;s) )
      { Sprintf("Hello \"%s\"\n", s);

        PL_succeed;
      } else
      { term_t except = PL_new_term_ref();

        PL_unify_term(except,
                      PL_FUNCTOR_CHARS, "type_error", 2,
                        PL_CHARS, "atom",
                        PL_TERM, to);

        return PL_raise_exception(except);
      }
    }</pre>
              <literallayout>
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_throw(term_t exception)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Similar to PL_raise_exception(), but returns using the C longjmp() function to the innermost PL_next_solution().
term_t PL_exception(qid_t qid)
    If PL_next_solution() fails, this can be due to normal failure of the Prolog call, or because an exception was raised using throw/1. This function returns a handle to the exception term if an exception was raised, or 0 if the Prolog goal simply failed.80.

9.6.12 Catching Signals (Software Interrupts)

SWI-Prolog offers both a C and Prolog interface to deal with software interrupts (signals). The Prolog mapping is defined in section 4.10. This subsection deals with handling signals from C.

If a signal is not used by Prolog and the handler does not call Prolog in any way, the native signal interface routines may be used.

Some versions of SWI-Prolog, notably running on popular Unix platforms, handle SIG_SEGV for guarding the Prolog stacks. If the application wishes to handle this signal too, it should use PL_signal() to install its handler after initialising Prolog. SWI-Prolog will pass SIG_SEGV to the user code if it detected the signal is not related to a Prolog stack overflow.

Any handler that wishes to call one of the Prolog interface functions should call PL_signal() for its installation.

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void (*)() PL_signal(sig, func)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    This function is equivalent to the BSD-Unix signal() function, regardless of the platform used. The signal handler is blocked while the signal routine is active, and automatically reactivated after the handler returns.

    After a signal handler is registered using this function, the native signal interface redirects the signal to a generic signal handler inside SWI-Prolog. This generic handler validates the environment, creates a suitable environment for calling the interface functions described in this chapter and finally calls the registered user-handler.

    By default, signals are handled asynchronously (i.e. at the time they arrive). It is inherently dangerous to call extensive code fragments, and especially exception related code from asynchronous handlers. The interface allows for synchronous handling of signals. In this case the native OS handler just schedules the signal using PL_raise(), which is checked by PL_handle_signals() at the call- and redo-port. This behaviour is realised by or-ing sig with the constant PL_SIGSYNC.81

    Signal handling routines may raise exceptions using PL_raise_exception(). The use of PL_throw() is not safe. If a synchronous handler raises an exception, the exception is delayed to the next call to PL_handle_signals();
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_raise(int sig)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Register sig for synchronous handling by Prolog. Synchronous signals are handled at the call-port or if foreign code calls PL_handle_signals(). See also thread_signal/2.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_handle_signals(void)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Handle any signals pending from PL_raise(). PL_handle_signals() is called at each pass through the call- and redo-port at a safe point. Exceptions raised by the handler using PL_raise_exception() are properly passed to the environment.

    The user may call this function inside long-running foreign functions to handle scheduled interrupts. This routine returns the number of signals handled. If a handler raises an exception, the return value is -1 and the calling routine should return with FALSE as soon as possible.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_get_signum_ex(term_t t, int *sig)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Extract a signal specification from a Prolog term and store as integer signal number in sig. The specification is an integer, lowercase signal name without SIG or the full signal name. These refer to the same: 9, kill and SIGKILL. Leaves a typed, domain or instantiation error if the conversion fails.

9.6.13 Miscellaneous
9.6.13.1 Term Comparison

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_compare(term_t t1, term_t t2)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Compares two terms using the standard order of terms and returns -1, 0 or 1. See also compare/3.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_same_compound(term_t t1, term_t t2)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Yields TRUE if t1 and t2 refer to physically the same compound term and FALSE otherwise.

9.6.13.2 Recorded database

In some applications it is useful to store and retrieve Prolog terms from C-code. For example, the XPCE graphical environment does this for storing arbitrary Prolog data as slot-data of XPCE objects.

Please note that the returned handles have no meaning at the Prolog level and the recorded terms are not visible from Prolog. The functions PL_recorded() and PL_erase() are the only functions that can operate on the stored term.

Two groups of functions are provided. The first group (PL_record() and friends) store Prolog terms on the Prolog heap for retrieval during the same session. These functions are also used by recorda/3 and friends. The recorded database may be used to communicate Prolog terms between threads.

record_t PL_record(term_t +t)
    Record the term t into the Prolog database as recorda/3 and return an opaque handle to the term. The returned handle remains valid until PL_erase() is called on it. PL_recorded() is used to copy recorded terms back to the Prolog stack.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_recorded(record_t record, term_t -t)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Copy a recorded term back to the Prolog stack. The same record may be used to copy multiple instances at any time to the Prolog stack. See also PL_record() and PL_erase().
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_erase(record_t record)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Remove the recorded term from the Prolog database, reclaiming all associated memory resources.

The second group (headed by PL_record_external()) provides the same functionality, but the returned data has properties that enable storing the data on an external device. It has been designed to make it possible to store Prolog terms fast an compact in an external database. Here are the main features:

    Independent of session
    Records can be communicated to another Prolog session and made visible using PL_recorded_external().
    Binary
    The representation is binary for maximum performance. The returned data may contain 0-bytes.
    Byte-order independent
    The representation can be transferred between machines with different byte-order.
    No alignment restrictions
    There are no memory alignment restrictions and copies of the record can thus be moved freely. For example, it is possible to use this representation to exchange terms using shared memory between different Prolog processes.
    Compact
    It is assumed that a smaller memory footprint will eventually outperform slightly faster representations.
    Stable
    The format is designed for future enhancements without breaking compatibility with older records.

char * PL_record_external(term_t +t, size_t *len)
    Record the term t into the Prolog database as recorda/3 and return an opaque handle to the term. The returned handle remains valid until PL_erase_external() is called on it.

    It is allowed to copy the data and use PL_recorded_external() on the copy. The user is responsible for the memory management of the copy. After copying, the original may be discarded using PL_erase_external().

    PL_recorded_external() is used to copy such recorded terms back to the Prolog stack.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_recorded_external(const char *record, term_t -t)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Copy a recorded term back to the Prolog stack. The same record may be used to copy multiple instances at any time to the Prolog stack. See also PL_record_external() and PL_erase_external().
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;int PL_erase_external(char *record)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Remove the recorded term from the Prolog database, reclaiming all associated memory resources.

9.6.13.3 Getting file names

The function PL_get_file_name() provides access to Prolog filenames and its file-search mechanism described with absolute_file_name/3. Its existence is motivated to realise a uniform interface to deal with file-properties, search, naming conventions etc. from foreign code.

int PL_get_file_name(term_t spec, char **name, int flags)
    Translate a Prolog term into a file name. The name is stored in the static buffer ring described with PL_get_chars() option BUF_RING. Conversion from the internal UNICODE encoding is done using standard C library functions. flags is a bit-mask controlling the conversion process. Options are:

    PL_FILE_ABSOLUTE
        Return an absolute path to the requested file.
    PL_FILE_OSPATH
        Return a the name using the hosting OS conventions. On MS-Windows, \ is used to separate directories rather than the canonical /.
    PL_FILE_SEARCH
        Invoke absolute_file_name/3. This implies rules from file_search_path/2 are used.
    PL_FILE_EXIST
        Demand the path to refer to an existing entity.
    PL_FILE_READ
        Demand read-access on the result.
    PL_FILE_WRITE
        Demand write-access on the result.
    PL_FILE_EXECUTE
        Demand execute-access on the result.
    PL_FILE_NOERRORS
        Do not raise any exceptions.

9.6.14 Errors and warnings

PL_warning() prints a standard Prolog warning message to the standard error (user_error) stream. Please note that new code should consider using PL_raise_exception() to raise a Prolog exception. See also section 4.9.

int PL_warning(format, a1, ...)
    Print an error message starting with `[WARNING: ', followed by the output from format, followed by a `]' and a newline. Then start the tracer. format and the arguments are the same as for printf(2). Always returns FALSE.

9.6.15 Environment Control from Foreign Code

int PL_action(int, ...)
    Perform some action on the Prolog system. int describes the action, Remaining arguments depend on the requested action. The actions are listed in table 6.

        PL_ACTION_TRACE 	Start Prolog tracer (trace/0). Requires no arguments.
        PL_ACTION_DEBUG 	Switch on Prolog debug mode (debug/0). Requires no arguments.
        PL_ACTION_BACKTRACE 	Print backtrace on current output stream. The argument (an int) is the number of frames printed.
        PL_ACTION_HALT 	Halt Prolog execution. This action should be called rather than Unix exit() to give Prolog the opportunity to clean up. This call does not return. The argument (an int) is the exit code. See halt/1.
        PL_ACTION_ABORT 	Generate a Prolog abort (abort/0). This call does not return. Requires no arguments.
        PL_ACTION_BREAK 	Create a standard Prolog break environment (break/0). Returns after the user types the end-of-file character. Requires no arguments.
        PL_ACTION_GUIAPP 	Win32: Used to indicate the kernel that the application is a GUI application if the argument is not 0 and a console application if the argument is 0. If a fatal error occurs, the system uses a windows messagebox to report this on a GUI application and simply prints the error and exits otherwise.
        PL_ACTION_WRITE 	Write the argument, a char * to the current output stream.
        PL_ACTION_FLUSH 	Flush the current output stream. Requires no arguments.
        PL_ACTION_ATTACH_CONSOLE 	Attach a console to a thread if it does not have one. See attach_console/0.
        PL_GMP_SET_ALLOC_FUNCTIONS 	Takes and integer argument. If TRUE, the GMP allocation are immediately bound to the Prolog functions. If FALSE, SWI-Prolog will never rebind the GMP allocation functions. See mp_set_memory_functions() in the GMP documentation. The action returns FALSE if there is no GMP support or GMP is already initialised.

    Table 6 : PL_action() options

9.6.16 Querying Prolog

long PL_query(int)
    Obtain status information on the Prolog system. The actual argument type depends on the information required. int describes what information is wanted.82 The options are given in table 7.

        PL_QUERY_ARGC 	Return an integer holding the number of arguments given to Prolog from Unix.
        PL_QUERY_ARGV 	Return a char ** holding the argument vector given to Prolog from Unix.
        PL_QUERY_SYMBOLFILE 	Return a char * holding the current symbol file of the running process.
        PL_MAX_INTEGER 	Return a long, representing the maximal integer value represented by a Prolog integer.
        PL_MIN_INTEGER 	Return a long, representing the minimal integer value.
        PL_QUERY_VERSION 	Return a long, representing the version as 10,000 &#xD7; M + 100 &#xD7; m + p, where M is the major, m the minor version number and p the patch-level. For example, 20717 means 2.7.17.
        PL_QUERY_MAX_THREADS 	Return the maximum number of threads that can be created in this version. Return values of PL_thread_self() are between 0 and this number.
        PL_QUERY_ENCODING 	Return the default stream encoding of Prolog (of type IOENC).
        PL_QUERY_USER_CPU 	Get amount of user CPU time of the process in milliseconds.

    Table 7 : PL_query() options

9.6.17 Registering Foreign Predicates

int PL_register_foreign_in_module(const char *module, const char *name, int arity, foreign_t (*function)(), int flags)
    Register a C-function to implement a Prolog predicate. After this call returns successfully a predicate with name name (a char *) and arity arity (a C int) is created in module module. If module is NULL, the predicate is created in the module of the calling context or if no context is present in the module user.

    When called in Prolog, Prolog will call function. flags forms bitwise or'ed list of options for the installation. These are:

    PL_FA_NOTRACE 	Predicate cannot be seen in the tracer
    PL_FA_TRANSPARENT 	Predicate is module transparent
    PL_FA_NONDETERMINISTIC 	Predicate is non-deterministic. See also PL_retry().
    PL_FA_VARARGS 	Use alternative calling convention.

    Predicates may be registered either before or after PL_initialise(). When registered before initialisation the registration is recorded and executed after installing the system predicates and before loading the saved state.

    Default calling (i.e. without PL_FA_VARARGS) function is passed the same number of term_t arguments as the arity of the predicate and, if the predicate is non-deterministic, an extra argument of type control_t (see section 9.6.1.1). If PL_FA_VARARGS is provided, function is called with three arguments. The first argument is a term_t handle to the first argument. Further arguments can be reached by adding the offset (see also PL_new_term_refs()). The second argument is the arity, which defines the number of valid term-references in the argument vector. The last argument is used for non-deterministic calls. It is currently undocumented and should be defined of type void*. Here is an example:
    </literallayout>
              <pre>static foreign_t
    atom_checksum(term_t a0, int arity, void* context)
    { char *s;

      if ( PL_get_atom_chars(a0, &amp;s) )
      { int sum;

        for(sum=0; *s; s++)
          sum += *s&amp;0xff;

        return PL_unify_integer(a0+1, sum&amp;0xff);
      }

      return FALSE;
    }

    install_t
    install()
    { PL_register_foreign("atom_checksum", 2, atom_checksum, PL_FA_VARARGS);
    }</pre>
              <literallayout>

int PL_register_foreign(const char *name, int arity, foreign_t (*function)(), int flags)
    Same as PL_register_foreign_in_module(), passing NULL for the module.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_register_extensions_in_module(const char *module, PL_extension *e)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Register a series of predicates from an array of definitions of the type PL_extension in the given module. If module is NULL, the predicate is created in the module of the calling context or if no context is present in the module user. The PL_extension type is defined as

    typedef struct PL_extension
    { char          *predicate_name;        /* Name of the predicate */
      short         arity;                  /* Arity of the predicate */
      pl_function_t function;               /* Implementing functions */
      short         flags;                  /* Or of PL_FA_... */
    } PL_extension;

    For details, see PL_register_foreign_in_module(). Here is an example of its usage:

    static PL_extension predicates[] = {
    { "foo",        1,      pl_foo, 0 },
    { "bar",        2,      pl_bar, PL_FA_NONDETERMINISTIC },
    { NULL,         0,      NULL,   0 }
    };

    main(int argc, char **argv)
    { PL_register_extensions_in_module("user", predicates);

      if ( !PL_initialise(argc, argv) )
        PL_halt(1);

      ...
    }

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_register_extensions( PL_extension *e)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Same as PL_register_extensions_in_module() using NULL for the module argument.

9.6.18 Foreign Code Hooks

For various specific applications some hooks re provided.

PL_dispatch_hook_t PL_dispatch_hook(PL_dispatch_hook_t)
    If this hook is not NULL, this function is called when reading from the terminal. It is supposed to dispatch events when SWI-Prolog is connected to a window environment. It can return two values: PL_DISPATCH_INPUT indicates Prolog input is available on file descriptor 0 or PL_DISPATCH_TIMEOUT to indicate a timeout. The old hook is returned. The type PL_dispatch_hook_t is defined as:

    typedef int  (*PL_dispatch_hook_t)(void);

                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_abort_hook(PL_abort_hook_t)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Install a hook when abort/0 is executed. SWI-Prolog abort/0 is implemented using C setjmp()/longjmp() construct. The hooks are executed in the reverse order of their registration after the longjmp() took place and before the Prolog top-level is reinvoked. The type PL_abort_hook_t is defined as:

    typedef void (*PL_abort_hook_t)(void);

int PL_abort_unhook(PL_abort_hook_t)
    Remove a hook installed with PL_abort_hook(). Returns FALSE if no such hook is found, TRUE otherwise.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_on_halt(void (*f)(int, void *), void *closure)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Register the function f to be called if SWI-Prolog is halted. The function is called with two arguments: the exit code of the process (0 if this cannot be determined on your operating system) and the closure argument passed to the PL_on_halt() call. See also at_halt/1.
PL_agc_hook_t PL_agc_hook(PL_agc_hook_t new)
    Register a hook with the atom-garbage collector (see garbage_collect_atoms/0 that is called on any atom that is reclaimed. The old hook is returned. If no hook is currently defined, NULL is returned. The argument of the called hook is the atom that is to be garbage collected. The return value is an int. If the return value is zero, the atom is not reclaimed. The hook may invoke any Prolog predicate.

    The example below defines a foreign library for printing the garbage collected atoms for debugging purposes.
    </literallayout>
              <pre>#include &lt;SWI-Stream.h&gt;
    #include &lt;SWI-Prolog.h&gt;

    static int
    atom_hook(atom_t a)
    { Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));

      return TRUE;
    }

    static PL_agc_hook_t old;

    install_t
    install()
    { old = PL_agc_hook(atom_hook);
    }

    install_t
    uninstall()
    { PL_agc_hook(old);
    }</pre>
              <literallayout>

9.6.19 Storing foreign data

This section provides some hints for handling foreign data in Prolog. With foreign data, we refer to data that is used by foreign language predicates and needs to be passed around in Prolog. Excluding combinations, there are three principal options for storing such data

    Natural Prolog data
    E.i. using the representation one would choose if there was no foreign interface required.
    Opaque packed Prolog data
    Data can also be represented in a foreign structure and stored on the Prolog stacks using PL_put_string_nchars() and retrieved using PL_get_string_chars(). It is generally good practice to wrap the string in a compound term with arity 1, so Prolog can identify the type. portray/1 rules may be used to streamline printing such terms during development.
    Natural foreign data, passing a pointer
    An alternative is to pass a pointer to the foreign data. Again, this functor may be wrapped in a compound term.

The choice may be guided using the following distinctions

    Is the data opaque to Prolog
    With `opaque' data, we refer to data handled in foreign functions, passed around in Prolog, but of which Prolog never examines the contents of the data itself. If the data is opaque to Prolog, the chosen representation does not depend on simple analysis by Prolog, and the selection will be driven solely by simplicity of the interface and performance (both in time and space).
    How big is the data
    Is efficient encoding required? For examine, a boolean array may be expressed as a compound term, holding integers each of which contains a number of bits, or as a list of true and false.
    What is the nature of the data
    For examples in C, constants are often expressed using `enum' or #define'd integer values. If prolog needs to handle this data, atoms are a more logical choice. Whether or not this mapping is used depends on whether Prolog needs to interpret the data, how important debugging is and how important performance is.
    What is the lifetime of the data
    We can distinguish three cases.
        The lifetime is dictated by the accessibility of the data on the Prolog stacks. Their is no way by which the foreign code when the data becomes `garbage', and the data thus needs to be represented on the Prolog stacks using Prolog data-types. (2),
        The data lives on the `heap' and is explicitly allocated and deallocated. In this case, representing the data using native foreign representation and passing a pointer to it is a sensible choice.
        The data lives as during the lifetime of a foreign predicate. If the predicate is deterministic, foreign automatic variables are suitable. if the predicate is non-deterministic, the data may be allocated using malloc() and a pointer may be passed. See section 9.6.1.1.

9.6.19.1 Examples for storing foreign data

In this section, we will outline some examples, covering typical cases. In the first example, we will deal with extending Prolog's data representation with integer-sets, represented as bit-vectors. Finally, we discuss the outline of the DDE interface.

Integer sets with not-too-far-apart upper- and lower-bounds can be represented using bit-vectors. Common set operations, such as union, intersection, etc. are reduced to simple and'ing and or'ing the bit-vectors. This can be done using Prolog's unbounded integers.

For really demanding applications, foreign representation will perform better, especially time-wise. Bit-vectors are naturally expressed using string objects. If the string is wrapped in bitvector/1 , lower-bound of the vector is 0, and the upper-bound is not defined, an implementation for getting and putting the sets as well as the union predicate for it is below.
</literallayout>
              <pre>#include &lt;SWI-Prolog.h&gt;

#define max(a, b) ((a) &gt; (b) ? (a) : (b))
#define min(a, b) ((a) &lt; (b) ? (a) : (b))

static functor_t FUNCTOR_bitvector1;

static int
get_bitvector(term_t in, int *len, unsigned char **data)
{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, in, a);
    return PL_get_string(a, (char **)data, len);
  }

  PL_fail;
}

static int
unify_bitvector(term_t out, int len, const unsigned char *data)
{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )
  { term_t a = PL_new_term_ref();

    PL_get_arg(1, out, a);

    return PL_unify_string_nchars(a, len, (const char *)data);
  }

  PL_fail;
}

static foreign_t
pl_bitvector_union(term_t t1, term_t t2, term_t u)
{ unsigned char *s1, *s2;
  int l1, l2;

  if ( get_bitvector(t1, &amp;l1, &amp;s1) &amp;&amp;
       get_bitvector(t2, &amp;l2, &amp;s2) )
  { int l = max(l1, l2);
    unsigned char *s3 = alloca(l);

    if ( s3 )
    { int n;
      int ml = min(l1, l2);

      for(n=0; n&lt;ml; n++)
        s3[n] = s1[n] | s2[n];
      for( ; n &lt; l1; n++)
        s3[n] = s1[n];
      for( ; n &lt; l2; n++)
        s3[n] = s2[n];

      return unify_bitvector(u, l, s3);
    }

    return PL_warning("Not enough memory");
  }

  PL_fail;
}


install_t
install()
{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);

  FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);
}</pre>
              <literallayout>
The DDE interface (see section 4.42) represents another common usage of the foreign interface: providing communication to new operating system features. The DDE interface requires knowledge about active DDE server and client channels. These channels contains various foreign data-types. Such an interface is normally achieved using an open/close protocol that creates and destroys a handle. The handle is a reference to a foreign data-structure containing the relevant information.

There are a couple of possibilities for representing the handle. The choice depends on responsibilities and debugging facilities. The simplest approach is to using PL_unify_pointer() and PL_get_pointer(). This approach is fast and easy, but has the drawbacks of (untyped) pointers: there is no reliable way to detect the validity of the pointer, not to verify it is pointing to a structure of the desired type. The pointer may be wrapped into a compound term with arity 1 (i.e., dde_channel(&lt;var&gt;&amp;lt;Pointer&amp;gt;&lt;/var&gt;)), making the type-problem less serious.

Alternatively (used in the DDE interface), the interface code can maintain a (preferably variable length) array of pointers and return the index in this array. This provides better protection. Especially for debugging purposes, wrapping the handle in a compound is a good suggestion.
9.6.20 Embedding SWI-Prolog in other applications

With embedded Prolog we refer to the situation where the `main' program is not the Prolog application. Prolog is sometimes embedded in C, C++, Java or other languages to provide logic based services in a larger application. Embedding loads the Prolog engine as a library to the external language. Prolog itself only provides for embedding in the C-language (compatible to C++). Embedding in Java is achieved using JPL using a C-glue between the Java and Prolog C-interfaces.

The most simple embedded program is below. The interface function PL_initialise() must be called before any of the other SWI-Prolog foreign language functions described in this chapter, except for PL_initialise_hook(), PL_new_atom(), PL_new_functor() and PL_register_foreign(). PL_initialise() interprets all the command-line arguments, except for the -t toplevel flag that is interpreted by PL_toplevel().

int
main(int argc, char **argv)
{
#ifdef READLINE /* Remove if you don't want readline */
  PL_initialise_hook(install_readline);
#endif

  if ( !PL_initialise(argc, argv) )
    PL_halt(1);

  PL_halt(PL_toplevel() ? 0 : 1);
}

int PL_initialise(int argc, char **argv)
    Initialises the SWI-Prolog heap and stacks, restores the Prolog state, loads the system and personal initialisation files, runs the at_initialization/1 hooks and finally runs the -g goal hook.

    Special consideration is required for argv[0]. On Unix, this argument passes the part of the command-line that is used to locate the executable. Prolog uses this to find the file holding the running executable. The Windows version uses this to find a module of the running executable. If the specified module cannot be found, it tries the module libpl.dll, containing the Prolog runtime kernel. In all these cases, the resulting file is used for two purposes

        See whether a Prolog saved-state is appended to the file. If this is the case, this state will be loaded instead of the default boot.prc file from the SWI-Prolog home directory. See also qsave_program/[1,2] and section 9.7.
        Find the Prolog home directory. This process is described in detail in section 9.8.

    PL_initialise() returns 1 if all initialisation succeeded and 0 otherwise.bug

    In most cases, argc and argv will be passed from the main program. It is allowed to create your own argument vector, provided argv[0] is constructed according to the rules above. For example:

    int
    main(int argc, char **argv)
    { char *av[10];
      int ac = 0;

      av[ac++] = argv[0];
      av[ac++] = "-x";
      av[ac++] = "mystate";
      av[ac]   = NULL;

      if ( !PL_initialise(ac, av) )
        PL_halt(1);
      ...
    }

    Please note that the passed argument vector may be referred from Prolog at any time and should therefore be valid as long as the Prolog engine is used.

    A good setup in Windows is to add SWI-Prolog's bin directory to your PATH and either pass a module holding a saved-state, or "libpl.dll" as argv[0]. If the Prolog state is attached to a DLL (see the -dll option of plld, pass the name of this DLL.
int PL_is_initialised(int *argc, char ***argv)
    Test whether the Prolog engine is already initialised. Returns FALSE if Prolog is not initialised and TRUE otherwise. If the engine is initialised and argc is not NULL, the argument count used with PL_initialise() is stored in argc. Same for the argument vector argv.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_install_readline()&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Installs the GNU-readline line-editor. Embedded applications that do not use the Prolog top-level should normally delete this line, shrinking the Prolog kernel significantly. Note that the Windows version does not use GNU readline.
int PL_toplevel()
    Runs the goal of the -t toplevel switch (default prolog/0) and returns 1 if successful, 0 otherwise.
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_cleanup(int status)&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    This function performs the reverse of PL_initialise(). It runs the PL_on_halt() and at_halt/1 handlers, closes all streams (except for the `standard I/O' streams which are flushed only), deallocates all memory and restores all signal handlers. The status argument is passed to the various termination hooks and indicates the exit-status.

    This function allows deleting and restarting the Prolog system in the same process. Use it with care, as PL_initialise() is a costly function. Unix users should consider using exec() (available as part of the clib package,).
                &lt;varlistentry&gt;
                  &lt;term&gt;&lt;function&gt;void PL_cleanup_fork()&lt;/function&gt;&lt;/term&gt;
                  &lt;listitem&gt;
                    &lt;para&gt;
    Close file descriptors associated to Prolog streams except for 0,1 and 2. Stop intervaltimer that may be running on behalf of profile/1. The call is intended to be used in combination with fork():

    &lt;pre&gt;if ( (pid=fork()) == 0 )
        { PL_cleanup_fork();
          &amp;lt;some exec variation&amp;gt;
        }&lt;/pre&gt;


    The call behaves the same on Windows, though there is probably no meaningful application.
int PL_halt(int status)
    Cleanup the Prolog environment using PL_cleanup() and calls exit() with the status argument. As PL_cleanup() can only be called from the main thread, this function returns FALSE when called from another thread as the main one.bug

9.6.20.1 Threading, Signals and embedded Prolog

This section applies to Unix-based environments that have signals or multi-threading. The Windows version is compiled for multi-threading and Windows lacks proper signals.

We can distinguish two classes of embedded executables. There are small C/C++-programs that act as an interfacing layer around Prolog. Most of these programs can be replaced using the normal Prolog executable extended with a dynamically loaded foreign extension and in most cases this is the preferred route. In other cases, Prolog is embedded in a complex application that&amp;mdash;like Prolog&amp;mdash;wants to control the process environment. A good example is Java. Embedding Prolog is generally the only way to get these environments together in one process image. Java applications however are by nature multi-threaded and appear to do signal-handling (software interrupts).

To make Prolog operate smoothly in such environments it must be told not to alter the process environment. This is partly done at build-time and partly execution time. At build-time we must specify the use of software stack-overflow rather then the default hardware checks. This is done using

sh configure --disable-segv-handling

The resulting Prolog executable is about 10% slower than the normal executable, but behaves much more reliable in complicated embedded situations. In addition, as the process no longer handles segmentation violations, debugging foreign code linked to it is much easier.

At runtime, it is advised to pass the flag -nosignals, which inhibits all default signal handling. This has a few consequences though:

    It is no longer possible to break into the tracer using an interrupt signal (Control-C).
    SIGPIPE is normally set to be ignored. Prolog uses return-codes to diagnose broken pipes. Depending on the situation one should take appropriate action if Prolog streams are connected to pipes.
    Fatal errors normally cause Prolog to call PL_cleanup() and exit(). It is advised to call PL_cleanup() as part of the exit-procedure of your application.

    </literallayout>
            </section>
            <section id="plld">
        <h5>Linking embedded applications using plld*</h5>
            </section>
            <section>
        <h5>*</h5>
            </section>
            <section>
        <h5>*</h5>
            </section>
            <section>
        <h5>*</h5>
            </section>
          </section>
        </section>
        <!-- end of "SWI-Prolog" -->
        <section>
        <h3><application>yap</application> (Yet Another Prolog)</h3>
          <p><application>yap</application> is reported to be the fastest prolog implementation. Additionally, its command switches allow the user-programmer to:</p>
          <ul>
            <listitem>read or compile a database file (switch <kbd>-l <var>cite</var></kbd>)</listitem>
            <listitem>run a goal <em>before</em> top level (switch <kbd>-g <var>goal</var></kbd>)</listitem>
            <listitem>run a goal <em>a</em> top level (switch <kbd>-z <var>goal</var></kbd>)</listitem>
            <listitem>connect standard streams to a host:port (switch <kbd>-c <var>host_ip</var> <var>port</var></kbd>)</listitem>
          </ul>
        </section>
        <!-- end of "<application>yap</application> (Yet Another Prolog)" -->
        <section>
        <h3>Prolog's Language Bindings</h3>
          <section>
        <h4>GNU Prolog's Language Bindings*</h4>
          </section>
        </section>
        <!-- end of "Prolog&apos;s Language Bindings" -->
      </section>
    </main>
  </body>
</html>
