<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Objects</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="JavaScript Objects (as a Data Type and as a Class)"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a            href="json.html">JavaScript Object Notation</a></p>
        <p><a            href="js.objects.html">JavaScript Objects</a></p>
        <p><a            href="adt-and-objects.html">Abstract Data Types and Objects (JavaScript)</a></p>
        <p><a rel="prev" href="programming.html">Programming</a></p>
        <p><a            href="cpp.html">The C++ Programming Language</a></p>
      </div>

    </nav>

    <main>
      <h1>JavaScript Objects (as a Data Type and as a Class)</h1>
      <!-- start at https://www.w3schools.com/js/js_object_definition.asp -->
      <section id="definitions">
        <h2>Object Definitions</h2>
      </section>

      <section id="prototypes">
        <h2>Object Prototypes</h2>
      </section>

      <section id="inheritance">
        <h2>Inheritance</h2>
        <p>JavaScript&apos;s prototype system makes it possible to create a new class, much like the old class, but with new definitions for some of its properties. The prototype for the new class derives from the old prototype but adds a new definition for, say, the length getter.</p>
        <p>In object-oriented programming terms, this is called <dfn>inheritance</dfn>. The new class inherits properties and behavior from the old class.</p>
        <pre>class LengthList extends List {
#length;

  constructor(value, rest) {
    super(value, rest);
    this.#length = super.length;
  }

  get length() {
    return this.#length;
  }
}

console.log(LengthList.fromArray([1, 2, 3]).length);
// → 3</pre>
        <p>The use of the word <code>extends</code> indicates that this class shouldn&apos;t be directly based on the default <code>Object</code> prototype but on some other class. This is called the <dfn>superclass</dfn>. The derived class is the <dfn>subclass</dfn>.</p>
        <p>To initialize a <var>LengthList</var> instance, the constructor calls the constructor of its superclass through the <code>super</code> keyword. This is necessary because if this new object is to behave (roughly) like a <strong>List</strong>, it is going to need the instance properties that lists have.</p>
        <p>The constructor then stores the list&apos;s length in a private property (<code>#length</code>). If we had written <code>this.length</code> there, the class&apos;s own getter would have been called, which doesn&apos;t work yet, since #length hasn&apos;t been filled in yet. We can use <code>super.<var>something</var></code> to call methods and getters on the superclass&apos;s prototype, which is often useful.</p>
        <section id="instanceof">
          <h3>The <code>instanceof</code> Operator</h3>
          <p>It is occasionally useful to know whether an object was derived from a specific class. For this, JavaScript provides a binary operator called <code>instanceof</code>.</p>
          <pre>console.log(new LengthList(1, null) instanceof LengthList);
// → true
console.log(new LengthList(2, null) instanceof List);
// → true
console.log(new List(3, null) instanceof LengthList);
// → false
console.log([1] instanceof Array);
// → true</pre>
          <p>The operator will see through inherited types, so a LengthList is an instance of List. The operator can also be applied to standard constructors like Array.</p>
          <p>Almost every object is an instance of Object.</p>
        </section>
      </section>

      <section id="methods">
        <h2>Object Methods</h2>
        <pre>// Copies properties from a source object to a target object
Object.assign(target, source)

// Creates an object from an existing object
Object.create(<var>object</var>)

// Returns an array of the key/value pairs of an object
Object.entries(<var>object</var>)

// Creates an object from a list of keys/values
Object.fromEntries()

// Returns an array of the keys of an object
Object.keys(<var>object</var>)

// Returns an array of the property values of an object
Object.values(<var>object</var>)

// Groups object elements according to a function
Object.groupBy(<var>object</var>, <var>callback</var>)</pre>

        <section>
          <h3><code>Object.assign()</code></h3>
          <p>The <code>Object.assign()</code> method copies properties from one or more source objects to a target object.</p>
          <pre>// Create Target Object
const person1 = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};

// Create Source Object
const person2 = {firstName: "Anne",lastName: "Smith"};

// Assign Source to Target
Object.assign(person1, person2);</pre>
        </section>
        <section>
          <h3><code>Object.keys(<var>OBJECT</var>)</code></h3>
          <p>Returns an array of the keys to the properties as strings for objects and as natural numbers or indexes for arrays.</p>
        </section>
        <section>
          <h3><code>Object.entries(<var>OBJECT</var>)</code></h3>
          <p>ECMAScript 2017 added the Object.entries(<var>OBJECT</var>) method to objects.</p>
          <p><code>Object.entries(<var>OBJECT</var>)</code> returns an array of the key/value pairs in an object:</p>
          <p class="bridgehead">Example</p>
          <pre>const person = {
  firstName : "John",
  lastName : "Doe",
  age : 50,
  eyeColor : "blue"
};

let text = Object.entries(person);</pre>
          <p>Object.entries(<var>OBJECT</var>) makes it simple to use objects in loops:</p>
          <p class="bridgehead">Example</p>
          <pre>const fruits = {Bananas:300, Oranges:200, Apples:500};

let text = "";
for (let [fruit, value] of Object.entries(fruits)) {
  text += fruit + ": " + value + "&lt;br&gt;";
}</pre>
          <p>Object.entries(<var>OBJECT</var>) also makes it simple to convert objects to maps:</p>
          <p class="bridgehead">Example</p>
          <pre>const fruits = {Bananas:300, Oranges:200, Apples:500};

const myMap = new Map(Object.entries(fruits));</pre>
          <p><code>Object.entries(<var>OBJECT</var>)</code> is supported in all modern browsers since March 2017:</p>
        </section>
        <section>
          <h3><code>Object.fromEntries()</code></h3>
          <p>The <code>fromEntries()</code> method creates an object from a list of key/value pairs.</p>
          <p class="bridgehead">Example</p>
          <pre>const fruits = [
  ["apples", 300],
  ["pears", 900],
  ["bananas", 500]
];

const myObj = Object.fromEntries(fruits);</pre>
        </section>
        <section>
          <h3><code>Object.values(<var>OBJECT</var>)</code></h3>
          <p><code>Object.values(<var>OBJECT</var>)</code> is similar to Object.entries(<var>OBJECT</var>), but returns a single dimension array of the object values:</p>
          <p class="bridgehead">Example</p>
          <pre>const person = {
  firstName : "John",
  lastName : "Doe",
  age : 50,
  eyeColor : "blue"
};

let text = Object.values(person);</pre>
          <p><code>Object.values(<var>OBJECT</var>)</code> is supported in all modern browsers since March 2017:</p>
        </section>
        <section>
          <h3><code>Object.groupBy()</code></h3>
          <p>ES2024 added the Object.groupBy() method to JavaScript.</p>
          <p>The Object.groupBy() method groups elements of an object according to string values returned from a callback function.</p>
          <p>The <code>Object.groupBy()</code> method does not change the original object.</p>
          <p class="bridgehead">Example</p>
          <pre>// Create an Array
const fruits = [
  {name:"apples", quantity:300},
  {name:"bananas", quantity:500},
  {name:"oranges", quantity:200},
  {name:"kiwi", quantity:150}
];

// Callback function to Group Elements
function myCallback({ quantity }) {
  return quantity &gt; 200 ? "ok" : "low";
}

// Group by Quantity
const result = Object.groupBy(fruits, myCallback);</pre>
        </section>

        <section id="with">
          <h3><code>Object.with(<var>key</var>, <var>value</var>)</code></h3>
          <p>ES2023 added the Array with() method as a safe way to update elements in an array without altering the original array.</p>
          <p>Example</p>
          <pre>const months = ["Januar", "Februar", "Mar", "April"];
const myMonths = months.with(2, "March");</pre>
        </section>

        <section id="spread-and-rest">
          <h3>Spread (...) and Rest</h3>
          <p>The ... operator expands an array into individual elements. This can be used join arrays/objects, as in</p>
          <pre>const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const arr3 = [...arr1, ...arr2];</pre>
          <p>In the example above, ...arr1 expands arr1 into single elements, ...arr2 expands arr2 into single elements, and arr3 is constructed using ...arr1 and ...arr2.</p>
          <hr/>
          <p>The rest operator (...) allows us to destruct an array and collect the leftovers:</p>
          <pre>let a, rest;
const arr1 = [1,2,3,4,5,6,7,8];

[a, ...rest] = arr1;</pre>
          <p>Another example:</p>
          <pre>let a, b, rest;
const arr1 = [1,2,3,4,5,6,7,8];

[a, b, ...rest] = arr1;</pre>
        </section>

        <section>
          <h3>Getters, Setters, and Statics</h3>
          <p>Interfaces often contain plain properties, not just methods. For example, <code>Map</code> objects have a size property that tells you how many keys are stored in them.</p>
          <p>It is not necessary for such an object to compute and store such a property directly in the instance. Even properties that are accessed directly may hide a method call. Such methods are called <dfn>getters</dfn> and are defined by writing <code>get</code> in front of the method name in an object expression or class declaration.</p>
          <pre>let varyingSize = {
  get size() {
    return Math.floor(Math.random() * 100);
  }
};

console.log(varyingSize.size);
// → 73
console.log(varyingSize.size);
// → 49</pre>
          <p>Whenever someone reads from this object&apos;s size property, the associated method is called. You can do a similar thing when a property is written to, using a <dfn>setter</dfn>, which is preceded by keyword <code>set</code>.</p>
          <pre>class Temperature {
  constructor(celsius) {
    this.celsius = celsius;
  }
  get fahrenheit() {
    return this.celsius * 1.8 + 32;
  }
  set fahrenheit(value) {
    this.celsius = (value - 32) / 1.8;
  }

  static fromFahrenheit(value) {
    return new Temperature((value - 32) / 1.8);
  }
}

let temp = new Temperature(22);
console.log(temp.fahrenheit);
// → 71.6
temp.fahrenheit = 86;
console.log(temp.celsius);
// → 30</pre>
          <p>The <code>Temperature</code> class allows you to read and write the temperature in either degrees Celsius or degrees Fahrenheit, but internally it stores only Celsius and automatically converts to and from Celsius in the fahrenheit getter and setter.</p>

          <p>Sometimes you want to attach some properties directly to your constructor function rather than to the prototype. Such methods won&apos;t have access to a class instance but can, for example, be used to provide additional ways to create instances.</p>
          <p>Inside a class declaration, methods or properties that have <code>static</code> written before their name are stored on the constructor. For example, the Temperature class allows you to write <code>Temperature.fromFahrenheit(100)</code> to create a temperature using degrees Fahrenheit.</p>
          <pre>let boil = Temperature.fromFahrenheit(212);
  console.log(boil.celsius);
// → 100</pre>
        </section>

        <section>
          <h3>Stringifying</h3>
          <p>Use <code>JSON.stringify(<var>OBJECT</var>)</code></p>
          <pre></pre>
          <hr/>
          <p>Next, you can store your thus generated string in <strong>local storage</strong>, then retrieve it</p>
          <pre>const myObj = {name: "John", age: 31, city: "New York"};
const myJSON = JSON.stringify(myObj);
localStorage.setItem("testJSON", myJSON);

// Retrieving data:
let text = localStorage.getItem("testJSON");
let obj = JSON.parse(text);
document.getElementById("demo").innerHTML = obj.name;</pre>
        </section>
        <!--
        <section>
          <h3><code></code></h3>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3><code></code></h3>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3><code></code></h3>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3><code></code></h3>
          <p></p>
          <pre></pre>
        </section>
        -->
      </section>

      <section id="properties">
        <h2>Object Properties</h2>
        <section>
          <h3>Checking for Properties: Existence, <code>undefined</code>-ness, <code>null</code>...</h3>
          <section>
            <h4><code>Object.hasOwn(<var>OBJ</var>,<var>PROPERTY</var>)</code> and <code>Object.hasOwnProperty(<var>OBJ</var>,<var>PROPERTY</var>)</code></h4>
            <p>If you want to know if an object physically contains a property (and it is not coming from somewhere up on the prototype chain) then <code>object.hasOwnProperty</code> is the way to go. All modern browsers support it.</p>
            <p>If what you&apos;re looking for is if an object has a property on it that is iterable (when you iterate over the properties of the object, it will appear) then doing: prop in object will give you your desired effect.</p>
            <pre></pre>
            <p></p>
            <pre>const object1 = {
  prop: 'exists'
};

console.log(Object.hasOwn(object1, 'prop'));
// expected output: true
</pre>
            <p></p>
            <pre></pre>
            <p></p>
            <pre></pre>
            <p></p>
            <pre></pre>
            <aside>
              <p><code>Object.hasOwn()</code> is recommended over <code>Object.hasOwnProperty()</code> because it works for objects created using <code>Object.create(null)</code> and with objects that have overridden the inherited <code>hasOwnProperty()</code> method. While it is possible to workaround these problems by calling <code>Object.prototype.hasOwnProperty()</code> on an external object, <code>Object.hasOwn()</code> is more intuitive.</p>
            </aside>
          </section>
        </section>
        <section>
          <h3>Overriding Derived Properties</h3>
          <p>When you add a property to an object, whether it is present in the prototype or not, the property is added to the object itself. If there was already a property with the same name in the prototype, this property will no longer affect the object, as it is now hidden behind the object&apos;s own property.</p>
        </section>
        <section id="private-properties">
          <h3>Private Properties</h3>
          <p>It is common for classes to define some properties and methods for internal use that are not part of their interface. These are called private properties, as opposed to public ones, which are part of the object&apos;s external interface.</p>
          <p>To declare a private method, put a # sign in front of its name. Such methods can be called only from inside the class declaration that defines them.</p>
        </section>
      </section>

      <section id="get-set">
        <h2>Object Get / Set</h2>
      </section>

      <section id="protection">
        <h2>Object Protection*</h2>
      </section>

      <section id="iterator-interface">
        <h2>The Iterator Interface</h2>
        <p>The object given to a for/of loop is expected to be <dfn>iterable</dfn>. This means it has a method named with the <code>Symbol.iterator</code> symbol (a <a target="_blank" href="js.html#symbols">symbol</a> value defined by the language, stored as a property of the <code>Symbol()</code> function).</p>
        <p>When called, that method should return an object that provides a second interface, <code>iterator</code>. This is the actual thing that iterates. It has a <code>next()</code> method that returns the next result. That result should be an object with a <code>value</code> property that provides the next value, if there is one, and a <code>done</code> property, which should be <code>true</code> when there are no more results and <code>false</code> otherwise.</p>
        <p>Note that the next, value, and done property names are plain strings, not symbols. Only <code>Symbol.iterator</code>, which is likely to be added to a lot of different objects, is an actual symbol.</p>
        <p>We can directly use this interface ourselves, say, on a literal string:</p>
        <pre>let okIterator = "OK"[Symbol.iterator]();
console.log(okIterator.next());
// → {value: "O", done: false}
console.log(okIterator.next());
// → {value: "K", done: false}
console.log(okIterator.next());
// → {value: undefined, done: true}</pre>
      </section>

    </main>

  </body>

</html>
