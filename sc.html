<!DOCTYPE html>
<html>
  <head>
    <title>Supercollider</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      -->
    <!--
      <p><a                    href="ANOTHER_PAGE.html">ANOTHER_PAGE</a></p>
      <p><a rel="RELATIONSHIP" href="ANOTHER_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="alternate"    href="VERSION.html">ANOTHER VERSION</a></p>
      <hr/>
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
        <p><a href="csound.html">CSound</a></p>
      -->
      <div>
        <p><a href="h.html">Hydrogen: a Virtual Drum Machine</a></p>
        <p><a rel="prev" href="computing.html">Computing</a></p>
      </div>
    </nav>

    <main>
      <h1>Supercollider</h1>
      <p> Supercollider is a platform for audio synthesis and algorithmic composition, used by musicians, artists and researchers working with sound.</p>
      <p>It&apos;s free and open source software for Windows, MacOS and Linux.</p>
      <h3 class="bridgehead">Features</h3>
      <ul>
        <li><code>scsynth</code> – A real-time audio server</li>
        <li><code>sclang</code> – An interpreted programming language</li>
        <li><code>scide</code> – An editor for sclang with an integrated help system</li>
      </ul>

      <p><a href="https://doc.sccode.org/">Documentation</a> is provided (at https://doc.sccode.org/), and a lot more user examples at <a href="https://sccode.org/">https://sccode.org/</a>. Plus, <cite><a href="https://supercollider.github.io/sc-140">sc-140</a></cite>, an amazing album with code examples!</p>

      <nav>
        <p><a href="#basic">Basic Tutorial</a></p>
        <p><a href="#classes-and-methods">Supercollider&apos;s Classes and Methods</a></p>
        <p><a href="#randomness">Randomness</a></p>
        <p><a href="#conditional-logic">Conditional Logic</a></p>
        <p><a href="#iteration">Iteration</a></p>
        <p><a href="#essentials-making-sound">Essentials of Making Sound</a></p>
        <p><a href="#envelopes">Envelopes</a></p>
        <p><a href="#multichannel">Multichannel Signals</a></p>
        <p><a href="#SynthDef-and-Synth"><code>SynthDef</code> and <code>Synth</code></a></p>
        <p><a href="#other-freq-and-amp">Alternate Expression of Frequency and Amplitude</a></p>
        <p><a href="#synthesis">Synthesis</a></p>
        <p><a href="#sampling">Sampling</a></p>
        <p><a href="#sequencing">Sequencing</a></p>
        <!--
        <p><a href="#"></a></p>
        <p><a href="#"></a></p>
        <p><a href="#"></a></p>
        <p><a href="#"></a></p>
        <p><a href="#"></a></p>
        -->
      </nav>


      <section id="basic">
        <h2>Basic Tutorial</h2>
        <p>Type</p>
        <pre>4.squared</pre>
        <p>then, making sure your mouse cursor is placed somewhere on this line, press [shift]+[return], which tells the interpreter to execute the current line. You&apos;ll see a brief flash of color over the code, and the number 16 will appear in the post window.</p>
        <p>Alternatively, type:</p>
        <pre>squared(4)</pre>
        <hr/>
        <p>The parentheses used to contain the receiver are one type of <dfn>enclosure</dfn> in SC. Others include [square brackets], {curly braces}, <q>double quotes,</q> and ‘single quotes.&apos; Each type of enclosure has its own significance, and some have multiple uses.</p>
        <p>The semicolon is the statement terminator.</p>
        <hr/>
        <p>Further, you can combine multiple methods into a single statement, using two different syntax styles:</p>
        <pre>4.squared.reciprocal;</pre>
        <p>or</p>
        <pre>reciprocal(squared(4));</pre>
        <p>Or even, for a two-argument function:</p>
        <pre>3.pow(4);</pre>
        <p>instead of just:</p>
        <pre>pow(3, 4);</pre>
        <h3 class="bridgehead">Posting a Value</h3>
        <p>The postln method has the effect of printing its receiver to the post window, followed by a new line.</p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>

        <section>
        <h3 class="bridgehead">Variables</h3>
        <p>Variables declared using a var statement are <dfn>local variables</dfn>; they are local to the evaluated code of which they are a part. This means that once evaluation is complete, variables created in this way will no longer exist.</p>
        <p>If we want to retain a variable, to be used again in the future as part of a separate code evaluation, we can use an <dfn>environment variable</dfn>, created by preceding the variable name with a tilde character (~). Alternatively, we can use one of the twenty-six lowercase alphabetic characters, which are reserved as <dfn>interpreter variables</dfn>. Both environment and interpreter variables can be used without a local declaration, and both behave with global scope, that is, they will retain their value (even across multiple code documents) as long as the interpreter remains active.</p>
        </section>

        <section>
          <h3 class="bridgehead">The Class Browser</h3>
          <p>The class browser is a graphical tool for browsing the class tree. The browse method can be applied to any class name (e.g. <code>Array.browse</code>), which invokes the browser and displays information for that class.</p>
        </section>

      </section>

      <section id="classes-and-methods">
        <h2>Introduction to Supercollider&apos;s Classes and Methods</h2>

        <section>
        <h3 class="bridgehead">Integers and Floats</h3>
        <p>The <code>Integer</code> and <code>Float</code> classes represent numerical values. Some programming languages are quite particular about the distinction between integers and floats, balking at certain operations that attempt to combine them, but SC is flexible, and will typically convert automatically as needed. Integers and floats are closely related on the class tree and therefore share many methods, but there are a few methods which apply to one and not the other.</p>
        <p>We&apos;ll begin our tour by introducing the <code>class</code> method, which returns the class of its receiver. This method is not exclusive to integers and floats; in fact, every object knows how to respond to it! However, it&apos;s relevant here in showing the classes to which different numbers belong.</p>
        <pre>4.class; // -> Integer
4.0.class; // -> Float</pre>
        <p>There are many methods that perform mathematical operations with numbers. Those that perform an operation involving two values are called binary operators, while those that perform an operation on a single receiver, like taking the square root of a number, are called unary operators.</p>
        <table border="1">
          <tr> <td><code>abs(<var>x</var>)</code></td> <td>Absolute value. Non-negative value of x, i.e., distance from zero. </td> </tr>
          <tr> <td><code>ceil(<var>x</var>)</code></td> <td>Round up to the nearest greater whole number.</td> </tr>
          <tr> <td><code>floor(<var>x</var>)</code></td> <td>Round up to the nearest smaller whole number.</td> </tr>
          <tr> <td><code>neg(<var>x</var>)</code></td> <td>Negation. Positive numbers become negative and vice-versa. </td> </tr>
          <tr> <td><code>reciprocal(<var>x</var>)</code></td> <td>Return 1 divided by x.</td> </tr>
          <tr> <td><code>sqrt(<var>x</var>)</code></td> <td>Return the square root of x. </td> </tr>
          <tr> <td><code>squared(<var>x</var>)</code></td> <td>Return x raised to the power of 2.</td> </tr>
        </table>

        <table border="1">
          <tr> <td><code><var>x</var> + <var>y</var></code></td> <td></td> </tr>
          <tr> <td><code><var>x</var> - <var>y</var></code></td> <td></td> </tr>
          <tr> <td><code><var>x</var> * <var>y</var></code></td> <td></td> </tr>
          <tr> <td><code><var>x</var> / <var>y</var></code></td> <td>Division</td> </tr>
          <tr> <td><code><var>x</var> ** <var>y</var></code> or <code><var>x</var>.pow(<var>y</var>)</code></td> <td>Return x raised to the power of y</td> </tr>
          <tr> <td><code><var>x</var> % <var>y</var></code> or <code><var>x</var>.mod(<var>y</var>);</code></td> <td>modulo</td> </tr>
          <tr> <td><code><var>x</var>.round(<var>y</var>)</code></td> <td></td> </tr>
        </table>
        </section>

        <section>
        <h3 class="bridgehead">Precedence of operations</h3>
        <pre>// symbolic operators have equal precedence, applied left-to-right:
4 + 2 * 3; // -> 18
// parentheses have precedence over symbolic operators:
4 + (2 * 3); // -> 10
// methods have precedence over symbolic operators:
4 + 2.pow(3); // -> 12
// parentheses have precedence over methods:
(4 + 2).pow(3); // -> 216
// parentheses first, then methods, then binary operators:
1 + (4 + 2).pow(3); // -> 217</pre>

        </section>
        <section>
        <h3 class="bridgehead">Strings</h3>
        <p>A string is an ordered sequence of characters, delineated by an enclosure of double quotes. A string can contain any text, including letters, numbers, symbols, and even non-printing characters like tabs and new lines.</p>
        <h5>Examples of strings and usage of the escape character</h5>
        <pre> // a typical string
"Click the green button to start.";
// using the escape character to include quotation marks
"The phrase \"practice makes perfect\" is one I try to remember.";
// using the escape character to include new lines
"This string\nwill print on\nmultiple lines.";</pre>
        <h5>Common string methods and operations</h5>
        <pre>"Hello" + "there!"; // -> "Hello there!"
"Some" ++ "times"; // -> "Sometimes"
"I'm a string.".size; // return the number of characters in the string
"I'm a string.".reverse; // reverse the order of the characters
"I'm a string.".scramble; // randomize the order of the characters
"I'm a string.".drop(2); // remove the first two characters
"I'm a string.".drop(-2); // remove the last two characters</pre>

        </section>

        <section>
        <h3 class="bridgehead">Symbols</h3>
        <p>A <dfn>symbol</dfn> is like a string, in that it&apos;s composed of a sequence of characters and commonly used to name or label things. Where a string is used, a symbol can often be substituted, and vice-versa. A symbol is written in one of two ways: by preceding the sequence of characters with a backslash (e.g., <code>\freq</code>), or by enclosing it in single quotes (e.g., <code>'freq'</code>). These styles are largely interchangeable, but the quote enclosure is the safer option of the two. Symbols that begin with or include certain characters will trigger syntax errors if using the backslash style.</p>
        <p>Unlike a string, a symbol is an irreducible unit; it is not possible to access or manipulate the individual characters in a symbol, and all symbols return zero in response to the size method. It is, however, possible to convert back and forth between symbols and strings using the methods <code>asSymbol</code> and <code>asString</code> (<i>see</i> below). Symbols, being slightly more optimized than strings, are the preferable choice when used as names or labels for objects.</p>
        <pre>"hello".asSymbol.class; // -> Symbol
\hello.asString.class; // -> String</pre>
        </section>

        <section>
        <h3 class="bridgehead">Booleans</h3>
        <p>There are exactly two instances of the Boolean class: <code>true</code> and <code>false</code>.</p>
        <p>Common binary operators that return Boolean values:</p>
        <pre><var>x</var> == <var>y</var>
<var>x</var> != <var>y</var>
<var>x</var> &gt; <var>y</var>
<var>x</var> &lt; <var>y</var>
<var>x</var> &gt;= <var>y</var>
<var>x</var> &lt;= <var>y</var></pre>
        </section>

        <section>
        <h3 class="bridgehead"><code>nil</code></h3>
        <p>Like true and false, <code>nil</code> is a reserved keyword in the SC language, and is the singular instance of the <code>Nil</code> class. Most commonly, it represents the value of a variable that hasn&apos;t been given a value assignment, or something that doesn&apos;t exist. We rarely use <code>nil</code> explicitly, but it shows up frequently, so it&apos;s helpful to be familiar. The <code>isNil</code> method can be useful for confirming whether a variable has a value (attempting to call methods on an uninitialized variable is a common source of error messages).</p>
        <pre>(
var num;
num.isNil.postln; // check the variable — initially, it's nil
num = 2; // make an assignment
num.isNil.postln; // check again — it's no longer nil
)</pre>
        </section>

        <section>
        <h3 class="bridgehead">Arrays</h3>
        <p>An array is an ordered collection of objects. Syntactically, objects stored in an array are separated by commas and surrounded by an enclosure of square brackets. Arrays are like strings in that both are ordered lists, but while strings can only contain text characters, an array can contain anything. In fact, arrays can (and often do) contain other arrays. Arrays are among the most frequently used objects, because they allow us to express an arbitrarily large collection as a singular unit. Arrays have lots of musical applications; we might use one to contain pitch information for a musical scale, a sequence of rhythmic values, and so on.</p>
        <p>We can access an item stored in an array by using the at method and providing the numerical index. Indices begin at zero. As an alternative, we can follow an array with a square bracket enclosure containing the desired index.</p>
        <pre>x = [4, "freq", \note, 7.5, true];
x.at(3); // -> 7.5 (return the item stored at index 3)
x[3]; // alternate syntax</pre>
        <p>Most unary and binary operators defined for numbers can also be applied to arrays, if they contain numbers. Several examples appear below. If we apply a binary operator to a number and an array, the operation is applied to the number and each item in the array, and the new array is returned. A binary operation between two arrays of the same size returns a new array of the same size in which the binary operation has been applied to each pair of items. If the arrays are different sizes, the operation is applied to corresponding pairs of items, but the smaller array will repeat itself as many times as needed to accommodate the larger array (this behavior is called <q>wrapping</q>).</p>
        <pre>[50, 60, 70].squared; // -> [2500, 3600, 4900]
1 + [50, 60, 70]; // -> [51, 61, 71]
[1, 2, 3] + [50, 60, 70]; // -> [51, 62, 73]
[1, 2] + [50, 60, 70]; // -> [51, 62, 71]</pre>

        <p>The <code>dup</code> method, defined for all objects, returns an array of copies of its receiver. An integer, provided as an argument, determines the size of the array. The exclamation mark can also be used as a symbolic shortcut.</p>
        <pre>7.dup; // -> [7, 7] (default size is 2)
7.dup(4); // -> [7, 7, 7, 7]
7 ! 4; // -> [7, 7, 7, 7] (alternate syntax)</pre>
        <p>Arrays are a must-learn feature, rich with many convenient methods and uses</p>
        </section>

        <section>
        <h3 class="bridgehead">Functions</h3>
        <p>A function is delineated by an enclosure of curly braces. Once a function is defined, we can evaluate it with <code>value</code>, or by following it with a period and a parenthetical enclosure. When evaluated, a function returns the value of the last expression it contains.</p>
        <pre>(
  f = {
   var num = 4;
   num = num.squared;
   num = num.reciprocal;
  };
)
f.value; // -> 0.0625
f.(); // alternate syntax for evaluating</pre>
        <p>Defining and evaluating a function with an argument:</p>
        <pre>(
f = {
 arg input = 4;
 var num;
 num = input.squared;
 num = num.reciprocal;
};
)
f.(5); // -> 0.04 (evaluate, passing in a different value as the input)
f.(); // -> 0.0625 (evaluate using the default value)</pre>
        <p>The code example below shows a syntax alternative that replaces the <code>arg</code> keyword with an enclosure of vertical bar characters (sometimes called <q>pipes</q>) and declares multiple arguments, converting the code  into a function. When executing a function with multiple arguments, the argument values must be separated by commas, and will be interpreted in the same order as they appear in the declaration.</p>
        <pre>(
g = { |thingA = 7, thingB = 5|
 var result;
 thingA = thingA.squared;
 thingB = thingB.reciprocal;
 result = thingA + thingB;
};
)
g.(3, 2); // -> 9.5 (thingA = 3, thingB = 2);</pre>
        <h3 class="bridgehead">Arguments and Variables</h3>
        <p>In some respects, arguments and variables are similar: each is a named container that holds a value. Variables are ordinary, named containers that provide the convenience of storing and referencing data. An argument, on the other hand, can only be declared at the very beginning of a function, and serves the specific purpose of allowing some input that can be passed or routed into the function during execution. Variable declarations can only occur at the beginning of a parenthetically enclosed multi-line code block, or at the beginning of a function. If a function declares arguments and variables, the argument declaration must come first. It&apos;s not possible to spontaneously declare additional variables or arguments somewhere in the middle of your code.</p>
        <h3 class="bridgehead">Getting and Setting Attributes</h3>
        <p>Objects have attributes. As a simplified real-world example, a car has a color, a number of doors, a transmission that may be manual or automatic, etc. In SC, we interact with an object&apos;s attributes by applying methods to that object. Retrieving an attribute is called getting, and changing an attribute is called setting. To get an attribute, we simply call the method that returns the value of that attribute. For setting an attribute, there are two options: we can follow the getter method with an equals symbol to assign a new value to it, or we can follow the getter method with an underscore and the new value enclosed in parentheses.</p>
        <p>The following pseudo-code demonstrates essential syntax styles for getting and setting. Note that an advantage of the underscore syntax is that it allows us to chain multiple setter calls into a single expression.</p>
        <pre>x = Car.new; // make a new car
x.color = "red"; // set the color
x.numDoors_(4).transmission_("manual"); // set two more attributes
x.numDoors; // get the number of doors (returns 4)</pre>
        </section>

        <section>
        <h3 class="bridgehead">Literals</h3>
        <p></p>
        <pre>x = House.new(30, 40); // create a house with specific dimensions
x.color_("blue"); // set the color
x.hasGarage_(true); // set whether it has a garage</pre>
        <p>We don&apos;t have to type <code>Float.new(5.2)</code> or <code>Symbol.new(\freq)</code>. Instead, we just type the object as is. Classes like these, which have a direct, syntactical representation through code, are called <dfn>literals</dfn>. When we type the number seven, it is literally the number seven. But an object like a house can&apos;t be directly represented with code; there is no <q>house</q> symbol in our standard character set. So, we must use the more abstract approach of typing x = House.new, while its literal representation remains in our imagination.</p>
        <p>Integers, floats, strings, symbols, Booleans, and functions are all examples of literals. Arrays, for the record, exist in more of a grey area; they have a direct representation via square brackets, but we may sometimes create one with <code>Array.new</code> or a related method. There is also a distinction between literal arrays and non-literal arrays, but which is not relevant here. The point is that many of the objects we&apos;ll encounter in this pages are not literals and require creation via some method call to their class.</p>
        <h3 class="bridgehead">Omitting the <code>new</code> Method</h3>
        <p>The <code>new</code> method is so commonly used for creating new instances of classes that we can usually omit it, and the interpreter will make the right assumption. For example, using our imaginary <q>house</q> class, we could write <code>x = House(30, 40)</code> instead of <code>x = House.new(30, 40)</code>. However, if creating a new instance without providing any arguments, we can omit <code>new</code> but cannot omit the parentheses, even if they are empty. For example, <code>x = House.new()</code> and <code>x = House()</code> are both valid, but <code>x = House</code> will be problematic. In this third case, the interpreter will store the house class, instead of a new house instance.</p>
        </section>

      </section>

      <section id="randomness">
        <h2>Randomness</h2>
      </section>  <!-- end of "Randomness" -->

      <section id="conditional-logic">
        <h2>Conditional Logic</h2>

        <section>
        <h3 class="bridgehead"><code>if</code></h3>
        <p>One of the most common conditional methods is if, which includes three components: (1) an expression that represents the test condition, which must return a Boolean value, (2) a function to be evaluated if the condition is true, and (3) an optional function to be evaluated if false.</p>
        <p>The code example below demonstrates the use of conditional logic to model a coin flip (a value of 1 represents <q>heads</q>), in three styles that vary in syntax and whitespace. The second style tends to be preferable to the first, because it places the <q>if</q> at the beginning of the expression, mirroring how the sentence it represents would be spoken in English.</p>
        <p>Because the entire expression is somewhat long, the multi-line approach can improve readability. Note that in the first expression, the parentheses around the test condition are required to give precedence to the binary operator == over the if method. Without parentheses, the if method is applied to the number 1 instead of the full Boolean expression, which produces an error</p>
        <pre>// "receiver-dot-method" syntax:
([0, 1].choose == 1).if({\heads.postln}, {\tails.postln});
// "method(receiver)" syntax:
if([0, 1].choose == 1, {\heads.postln}, {\tails.postln});
// structured as a multi-line block:
(
if(
 [0, 1].choose == 1,
 {\heads.postln},
 {\tails.postln}
);
)</pre>
        </section>

        <section>
        <h3 class="bridgehead">And/Or</h3>
        <p>The methods and and or (representable using binary operators &amp;&amp; and ||), allow us to check multiple conditions. For example, if ice cream is on sale, and they have chocolate, then I&apos;ll buy two. The code example below models a two-coin flip in which both must be <q>heads</q> for the result to be considered true. Again, parentheses around each conditional test are required to ensure correct order of operations.</p>
        <pre>(
if(
 ([0, 1].choose == 1) &amp;&amp; ([0, 1].choose == 1),
 {"both heads".postln},
 {"at least one tails".postln}
);
)</pre>
        </section>

        <section>
        <h3 class="bridgehead">Case and Switch</h3>
        <p>Say we roll a six-sided die and want to perform one of six unique actions depending on the outcome. A single <code>if</code> statement is insufficient because it envisions only two outcomes. If we insisted on using if, we&apos;d need to <q>nest</q> several if&apos;s inside of each other. Even with a small handful of possible outcomes, the code quickly spirals into an unreadable mess.</p>
        <p>Alternatively, a <code>case</code> statement (<i>see</i> below) accepts an arbitrary number of function pairs. The first function in each pair must contain a Boolean expression, and the second function contains code to be evaluated if its partner function is true. If a test condition is false, the interpreter moves onto the next pair and tries again. As soon as a test returns true, the interpreter executes the partner function and exits the case block, abandoning any remaining conditional tests. If all tests are false, the interpreter returns <code>nil</code>.</p>
        <pre>(
var roll = rrand(1, 6);
case(
 {roll == 1}, {\red.postln},
 {roll == 2}, {\orange.postln},
 {roll == 3}, {\yellow.postln},
 {roll == 4}, {\green.postln},
 {roll == 5}, {\blue.postln},
 {roll == 6}, {\purple.postln}
);
)</pre>
        <p>A switch statement is similar to case, but with a slightly different syntax, shown in Code Example 1.27. We begin with some value—not necessarily a Boolean—and provide an arbitrary number of value-function pairs. The interpreter will check for equality between the starting value and each of the paired values. For the first comparison that returns true, the corresponding function is evaluated.</p>
        <pre>(
var roll = rrand(1, 6);
switch(
 roll,
 1, {\red.postln},
 2, {\orange.postln},
 3, {\yellow.postln},
 4, {\green.postln},
 5, {\blue.postln},
 6, {\purple.postln}
);
)</pre>
        </section>
      </section>

      <section id="iteration">
        <h2>Iteration</h2>
        <p>One of the most attractive aspects of computer programming is its ability to handle repetitive tasks. <dfn>Iteration</dfn> refers to techniques that allow a repetitive task to be expressed and executed concisely. Music is full of repetitive structures and benefits greatly from iteration. More generally, if you ever find yourself typing a nearly identical chunk of code many times over, or relying heavily on copy/paste, this could be a sign that you should be using iteration.</p>
        <p>Two general-purpose iteration methods, <code>do</code> and <code>collect</code>, often make good choices for iterative tasks. Both are applied to some collection—usually an array—and both accept a function as their sole argument. The function is evaluated once for each item in the collection. A primary difference between these two methods is that <code>do</code> returns its receiver, while <code>collect</code> returns a modified collection of the same size, populated using values returned by the function. Thus, <code>do</code> is a good choice when we don&apos;t care about the values returned by the function, and instead simply want to <q>do</q> some action a certain number of times. On the other hand, collect is a good choice when we want to modify or interact with an existing collection and capture the result.</p>
        <p>At the beginning of an iteration function, we can optionally declare two arguments, which represent each item in the collection and its index as the function is repeatedly executed. By declaring these arguments, we give ourselves access to the collection items within the function.</p>
        <p>In code example (a), we iterate over an array of four items, and for each item, we post a string. In this case, the items in the array are irrelevant; the result will be the same as long as the size of the array is four. Performing an action some number of times is so common, that <code>do</code> is also defined for integers. When do is applied to some integer <var>n</var>, the receiver will be interpreted as the array [0, 1, … n-1], thus providing a shorter alternative, depicted in code example (b). In code example (c), we declare two arguments and post them, to visualize the values of these arguments.</p>
        <pre>(a) [30, 40, 50, 60].do({"this is a test".postln});
(b) 4.do({"this is a test".postln});
(c) [30, 40, 50, 60].do({|item, index| [item, index].postln});</pre>
        <hr/>
        <p>A simple usage of <code>collect</code> is shown right below. We iterate over the array, and for each item, return the item multiplied by its index. <code>collect</code> returns this new array.</p>
        <pre>x = [30, 40, 50, 60].collect({|item, index| item * index});
// -> the array [0, 40, 100, 180] is now stored in x</pre>
        <p>Numerous other iteration methods exist, several of which are depicted next. The <code>isPrime</code> method is featured here, which returns true if its receiver is a prime number, and otherwise returns false.</p>
        <pre>x = [101, 102, 103, 104, 105, 106, 107];
// return the subset of the array for which the function returns true:
x.select({ |n| n.isPrime }); // -> [101, 103, 107]
// return the first item for which the function returns true:
x.detect({ |n| n.isPrime }); // -> 101
// return true if the function returns true for at least one item:
x.any({ |n| n.isPrime }); // -> true
// return true if the function returns true for every item:
x.every({ |n| n.isPrime }); // -> false
// return the number of items for which the function returns true:
x.count({ |n| n.isPrime }); // -> 3</pre>
      </section>

      <section id="essentials-making-sound">
        <h2>Essentials of Making Sound</h2>
        <p>Once you&apos;re all set, you can launch the server by evaluating:</p>
        <pre>s.boot;</pre>
        <p>By default, the keyboard shortcut <kbd>[cmd]+[b]</kbd> will also boot the server.</p>
        <p>As you run this line, information will appear in the post window. If the boot is successful, the numbers in the server status bar in the bottom-right corner of the IDE will turn green.</p>
        <p>If the server numbers don&apos;t turn green, the server has not successfully booted. Boot failures are relatively uncommon, but when they do occur, they are rarely cause for alarm and almost always quickly rectifiable. For example, if you&apos;re using separate hardware devices for audio input/output, the server will not boot if these devices are running at different sample rates. Alternatively, if a running server is unexpectedly interrupted (e.g., if the USB cable for your audio interface becomes unplugged), an attempt to reboot may produce an error that reads <q>Exception in World_OpenUDP: unable to bind udp socket,</q> or <q>ERROR: server failed to start.</q> This message appears because there is likely a hanging instance of the audio server application that must be destroyed, which can be done by evaluating <code>Server.killAll</code> before rebooting. In rarer cases, a boot failure may be resolved by recompiling the SC class library, quitting and reopening the SC environment, or—as a last resort—restarting your computer.</p>

        <p>Assuming you&apos;ve already booted the server, you can check the sample rate and block size by evaluating the following expressions:</p>
        <pre>s.sampleRate;
s.options.blockSize;</pre>

        <section>
          <h3>Unit Generators</h3>
          <p><dfn>Unit generators</dfn> (UGens) are objects that represent digital signal calculations on the audio server. They are the basic building blocks for sound processes, akin to modules on an analog synthesizer. Each UGen performs a specific task, like generating a sawtooth wave, applying a low-pass filter, playing back an audio file, and so on. The following displays a roughly categorized list of some of the simplest and most commonly used UGens. The purposes of some UGens are obvious from their names (WhiteNoise generates white noise), while others, like Dust, are more cryptic. The documentation includes a guide file titled <cite>Tour of UGens</cite>.</p>
          <table border="1">
            <thead> <tr> <td>Catagory</td> <td>Ugens</td> </tr> </thead>
              <tr> <td>Oscillators</td> <td>SinOsc, Pulse, Saw, Blip, LFPulse, LFSaw, LFTri, VarSaw</td> </tr>
              <tr> <td>Noise Generators</td> <td>LFNoise0, LFNoise1, PinkNoise, WhiteNoise</td> </tr>
              <tr> <td>Envelopes</td> <td>Line, XLine, EnvGen</td> </tr>
              <tr> <td>Filters</td> <td>LPF, HPF, BPF, BRF</td> </tr>
              <tr> <td>Triggers</td> <td>Impulse, Dust, Trig</td> </tr>
              <tr> <td>Sound File Players</td> <td>PlayBuf, BufRd</td> </tr>
              <tr> <td>Stereo Panners</td> <td>Pan2, Balance2</td> </tr>
          </table>
          <p>Musical fluency doesn&apos;t demand intimate familiarity with every UGen. UGens are a means to an end, so you&apos;ll only need to get acquainted with those that help achieve your goals.</p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section>
          <h3>UGen Rates</h3>
          <p>A UGen runs at a particular rate, depending on the class method used to create the instance. Instead of using <code>new</code> to create a UGen instance, we use <code>ar</code>, <code>kr</code>, or <code>ir</code>, which represent audio rate, control rate, and initialization rate.</p>
          <p>An audio rate UGen produces output values at the sample rate, which is the highest-resolution signal available to us. If you want to hear a signal through your speakers, it must run at the audio rate. Generally, if you require a high frequency signal, a fast-moving signal, or anything you want to monitor directly, you should use <code>ar</code>.</p>
          <p>Control rate UGens run at the <dfn>control rate</dfn>. This rate is equal to sample rate divided by block size. If the sample rate is 48,000 and the block size is 64, then the control rate calculates 48,000 ÷ 64 = 750 samples per second, outputting one at the start of each control cycle. Control rate UGens have a lower resolution but consume less processing power. They are useful when you need a relatively slow-moving signal, like a gradual envelope or a low-frequency oscillator. Because the control rate is a proportionally reduced sample rate, the Nyquist frequency is similarly reduced. In this case, the highest control rate frequency that can be faithfully represented is 750 ÷ 2 = 375 Hz. Therefore, if you require an oscillator with a frequency higher than 375 Hz, <code>kr</code> is a poor choice. In fact, signal integrity degrades as the frequency of a signal approaches the Nyquist frequency, so ar is a good choice even if a UGen&apos;s frequency is slightly below the Nyquist frequency.</p>
          <p>Consider a sine oscillator with a frequency of 1 Hz, used to control the cutoff frequency of a filter. It&apos;s possible to run this oscillator at the audio rate, but this would provide more resolution than we need. If using the control rate instead, we&apos;d calculate 750 samples per cycle, which is more than enough to visually represent one cycle of a sine wave. In fact, as few as 20 or 30 points would probably be enough to <q>see</q> a sinusoidal shape. This is an example in which we can take advantage of control rate UGens to reduce the server&apos;s processing load, without sacrificing sound quality.</p>
          <p>If you&apos;re unsure of which rate to use in a particular situation, <code>ar</code> is usually the safer choice.</p>
          <p><dfn>Initialization rate</dfn> UGens are the rarest of the three. In fact, many UGens won&apos;t understand the <code>ir</code> method. A UGen at the initialization rate produces exactly one sample when created and holds that value indefinitely. So, the initialization rate is not really a rate at all; it&apos;s simply a means of initializing a UGen so that it behaves like a constant. The CPU savings ir provides are obvious, but what&apos;s the point of a signal that&apos;s stuck on a specific value? There are a few situations in which this choice makes sense. One example is the SampleRate UGen, a UGen that outputs the sample rate of the server. In some signal algorithms, we need to perform a calculation involving the sample rate, which may vary from one system to another. Generally, the sample rate does not (and should not) change while the server is booted, so it&apos;s inefficient and unnecessary to repeatedly calculate it.</p>
        </section>
        <section>
          <h3>UGen Arguments</h3>
          <p>As already discussed, some methods, like <code>pow</code>, require arguments to function correctly. UGens are no different. The expression <code>SinOsc.ar()</code> produces no errors, but questions remain. What is the frequency of this sine oscillator? What is its amplitude? The specific arguments that <code>ar</code>, <code>kr</code>, and <code>ir</code> accept, and their default values, depend on the type of UGen.</p>
          <p>In the <cite>Class Methods</cite> section of the SinOsc help file, we read that this UGen can run at the audio or control rate, and the arguments are the same for both methods. Four input values are expected: <var>freq</var>, <var>phase</var>, <var>mul</var>, and <var>add</var>. <var>freq</var> determines the frequency of the oscillator, measured in Hz. <var>phase</var> controls an offset amount, measured in radians, used to make the oscillator begin at a specific point within its cycle. <var>mul</var> is a value that is multiplied by every sample in the output signal, and <var>add</var> is a value added to every sample in the output signal.</p>
          <hr/>
          <p>In the case of SinOsc, one cycle is equal to 2π radians. In SC, we use the special keyword <code>pi</code> to represent π. Expressions such as <code>pi/4</code>, <code>3pi/2</code>, etc., are valid.</p>
          <hr/>
          <p>The discussion of mul brings up important considerations regarding monitoring level and loudness. When using SC (or any digital audio platform, really), it&apos;s smart to calibrate your system volume before you start creating. First, turn your system volume down so it&apos;s almost silent, then run the following line of code, which plays a two-channel pink noise signal:</p>
          <pre>{PinkNoise.ar(mul: 1) ! 2}.play;</pre>
          <p>As the noise plays, slowly turn up your system volume until the noise sounds strong and healthy. It shouldn&apos;t be painful, but it should be unambiguously loud, perhaps even slightly annoying. Once you&apos;ve set this volume level, consider your system <q>calibrated</q> and don&apos;t modify your hardware levels again. This configuration will encourage you to create signal levels in SC that are comfortable and present a minimal risk of distorting.</p>
          <p>By contrast, a bad workflow involves setting your system volume too low, which encourages compensation with higher mul values. This configuration gives the misleading impression that your signal levels are low, when they&apos;re actually quite high, with almost no headroom. In this setup, you&apos;ll inevitably find yourself in the frustrating situation of having signals that seem too quiet, but with levels that are constantly <q>in the red.</q></p>
        </section>
        <section>
          <h3>Playing and Stopping Simple Sounds</h3>
          <p><var>Function</var>-dot-play refers to a simple code structure that allows us to quickly make sound. This construct involves a function that contains one or more UGens and receives the play method. In the example below we have an audio rate sine UGen with user-specified arguments. If you evaluate this line, you should hear a 300 Hz tone in your left speaker.</p>
          <pre>{SinOsc.ar(300, 0, 0.1, 0)}.play;</pre>
          <p>Press <kbd>[cmd]+[period]</kbd> to stop the sound. Take a moment to memorize this keyboard shortcut!</p>
          <p>In the example, since listening to sound in only one speaker can be uncomfortable, particularly on headphones. SC interprets an array of UGens as a multichannel signal. So, if the function contains an array of two SinOsc UGens, the first signal will be routed to the left speaker, and the second to the right. The duplication shortcut, as shown in the example, is a quick way to create such an array. Multichannel signals will be explored later on.</p>
          <pre>{SinOsc.ar(300, 0, 0.1, 0) ! 2}.play;</pre>
          <p>The following code shows an alternative, using a more verbose style:</p>
          <pre>{SinOsc.ar(freq: 300, phase: 0, mul: 0.1, add: 0) ! 2}.play;</pre>
          <p>This longer but more descriptive approach of specifying argument values applies to all methods, not just those associated with UGens.</p>
        </section>
        <section>
          <h3>Changing a Sound While Playing</h3>
          <p>Suppose we want to change the frequency of an oscillator while it&apos;s playing. To enable real-time changes to a sound, we need to make a few changes to the examples in the previous section. First, we must declare an argument at the beginning of the UGen function (just as we did with ordinary functions in the previous chapter) and incorporate it into the appropriate UGen. Argument names are flexible, and don&apos;t have to match the name of the UGen argument for which they&apos;re being used. However, <q>freq</q> is certainly a good choice, because it&apos;s short and meaningful at a glance. It&apos;s also wise to provide a default value in the declaration.</p>
          <p>When calling <code>play</code>, we must assign the resulting sound process to a variable, so that we can communicate with it later. While the sound is playing, we can alter it using the <code>set</code> method and providing the name and value of the parameter we want to change. Next you can see this sequence of actions.</p>
          <pre>(
x = { |freq = 300|
 SinOsc.ar(freq, mul: 0.1) ! 2;
}.play;
)
x.set(\freq, 400); // change the frequency</pre>
          <p>We can declare as many arguments as we need. Now we shall add a second argument that controls signal amplitude and demonstrate a variety of <code>set</code> messages.</p>
          <pre>(
x = { |freq = 300, amp = 0.1|
 SinOsc.ar(freq, mul: amp) ! 2;
}.play;
)
x.set(\freq, 400, \amp, 0.4); // modify both arguments
x.set(\amp, 0.05, \freq, 500); // order of name/value pairs doesn't matter
x.set(\freq, 600); // modify only one argument</pre>
          <hr/>
          <p>It&apos;s often desirable to separate creating and playing a UGen function into two discrete actions. Next we shall define a UGen function and store it in the interpreter variable <var>f</var>. Then, we play it, storing the resulting sound process in the interpreter variable <var>x</var>. The former is simply the object that defines the sound, while the latter is the active sound process that understands set messages. It&apos;s important not to confuse the two.</p>
          <pre>(
// define the sound
f = { |freq = 300, amp = 0.1|
 SinOsc.ar(freq, mul: amp) ! 2;
};
)
x = f.play; // play the sound
x.set(\freq, 400, \amp, 0.3); // change the sound
f.set(\freq, 500, \amp, 0.05); // no effect if applied to the function</pre>
          <p>Even if arguments in a UGen function have default values, we can override them when playing the function. The play method has an args argument, which accepts an array of name-value pairs, shown below:</p>
          <pre>(
f = { |freq = 300, amp = 0.1|
 SinOsc.ar(freq, mul: amp) ! 2;
};
)
x = f.play(args: [freq: 800, amp: 0.2]); // override default arguments
x.set(\freq, 600, \amp, 0.05); // set messages work normally</pre>
        </section>

        <section>
          <h3>Other Ways to Stop a Sound</h3>
          <p>The [cmd]+[period] shortcut is useful for stopping sound, but it&apos;s indiscriminate. As an alternative, we can <code>free</code> a sound process. With this method, we can have multiple sound processes playing simultaneously, and remove them one-by-one (<i>see</i> below). This example also highlights the value of defining a function and playing it separately; specifically, we can spawn multiple sound processes from one function.</p>
          <pre>(
f = { |freq = 300, amp = 0.1|
 SinOsc.ar(freq, mul: amp) ! 2;
};
)
x = f.play(args: [freq: 350]);
y = f.play(args: [freq: 450]);
y.free;
x.free;</pre>
          <p>Like [cmd]+[period], freeing a sound process also results in a hard stop, which may not be what we want. When using function-dot-play, we can also use <code>release</code> to create a gradual fade, optionally providing a fade duration measured in seconds</p>
          <pre>(
f = { |freq = 300, amp = 0.1|
 SinOsc.ar(freq, mul: amp) ! 2;
};
)
x = f.play;
x.release(2);</pre>
        </section>
        <section>
          <h3>Math Operations with UGens</h3>
          <p>We&apos;ve already established that a UGen is essentially a sequence of numbers, therefore most math operations defined for floats and integers can also be applied to UGens. Signal summation, for example, is a fundamental technique that forms the basis of audio mixing and additive synthesis. When two signals are summed, their corresponding samples are summed, and the result is a new waveform in which both signals can usually be perceived. Let&apos;s add a sine wave and pink noise together.</p>
          <pre>(
x = {
 var sig;
 sig = SinOsc.ar(300, mul: 0.15);
 sig = sig + PinkNoise.ar(mul: 0.1);
 sig = sig ! 2;
}.play;
)
x.release(2);</pre>
          <p>When a binary operator is used between a number and a UGen, the operation is applied to the number and every sample value produced by the UGen. This being the case, multiplication and addition can be used instead of providing argument values for <code>mul</code> and <code>add</code>.</p>
          <pre>(
x = {
 var sig;
 sig = SinOsc.ar(300) * 0.15;
 sig = sig + (PinkNoise.ar * 0.1);
 sig = sig ! 2;
}.play;
)
x.release(2);</pre>
        </section>
        <section>
          <h3>A UGen Function Plays the Last Expression</h3>
          <p>Just as ordinary functions return the value of their last expression when evaluated, the output signal from a UGen function is also determined by its last expression. In the first of the following two functions, we&apos;ll only hear pink noise, despite creating a sine wave. In the second function, the last expression is the sum of both signals, which is what we hear.</p>
          <pre>(
{
 var sig0, sig1;
 sig0 = SinOsc.ar(300, mul: 0.15) ! 2;
 sig1 = PinkNoise.ar(mul: 0.1) ! 2;
}.play;
)
(
{
 var sig0, sig1;
 sig0 = SinOsc.ar(300, mul: 0.15) ! 2;
 sig1 = PinkNoise.ar(mul: 0.1) ! 2;
 sig0 + sig1;
}.play;
)</pre>
          <p>Multiplying one signal by another is also common. We shall be multiplying pink noise by a low-frequency sine wave, producing a sound like ocean waves. This is a simple example of signal modulation, which involves the use of one signal to influence some aspect of another. A phase value of 3π/2 causes the sine oscillator to begin at the lowest point in its cycle, and the multiplication/addition values scale and shift the output values to a new range between 0 and 0.2.</p>
          <pre>(
x = {
 var sig, lfo;
 lfo = SinOsc.kr(freq: 1/5, phase: 3pi/2, mul: 0.1, add: 0.1);
 sig = PinkNoise.ar * lfo;
 sig = sig ! 2;
}.play;
)
x.release(2);</pre>
          <p>When we want a UGen&apos;s output to range between some arbitrary minimum and maximum, using mul/add sometimes involves cumbersome mental math. Even worse, the actual range of the UGen isn&apos;t immediately clear from looking at the code. A better approach involves using one of several range-mapping methods, such as <code>range</code>. This method lets us explicitly provide a minimum and maximum, avoiding the need to deal with mul/add. The table below lists some common range-mapping methods.</p>
          <pre>(
x = {
 var sig, lfo;
 lfo = SinOsc.kr(freq: 0.2, phase: 3pi/2).range(0, 0.2);
 sig = PinkNoise.ar * lfo;
 sig = sig ! 2;
}.play;
)
x.release(2);</pre>
          <table border="1">
            <thead> <tr> <td>Method</td> <td>Description</td> </tr> </thead>
              <tr> <td><code>.range(x, y)</code></td> <td>Linearly map the output range between x and y</td> </tr>
              <tr> <td><code>.exprange(x, y)</code></td> <td>Exponentially map the output range between x and y. Arguments must be either both positive or both negative, and neither can be 0.</td> </tr>
              <tr> <td><code>.curverange(x, y, n)</code></td> <td>Map the output range between <var>x</var> and <var>y</var> using a custom warp value <var>n</var>. Positive values create exponential-like behavior, negative values create logarithmic-like behavior.</td> </tr>
              <tr> <td><code>.unipolar(x)</code></td> <td>Map the output range between 0 and x.</td> </tr>
              <tr> <td><code>.bipolar(x)</code></td> <td>Map the output range between ±x.</td> </tr>
          </table>
        </section>
        <section>
          <h3>Range-mapping vs. mul/add</h3>
          <p>Range-mapping methods are designed as alternatives to mul/add arguments, and they assume the range of the UGen to which they apply has not been previously altered. You can specify a UGen&apos;s range using one approach or the other, but you should never apply both approaches at the same time. If you do, a range-mapping operation will be applied twice in a row, producing erroneous numbers and possibly startling sound!</p>
          <p>As you start exploring UGen functions of your own, remember that just because a math operation can be used doesn&apos;t necessarily mean it should. Dividing one signal by another, for example, is dangerous! This calculation may involve division by some extremely small value (or even zero), which is likely to generate a dramatic amplitude spike, or something similarly unpleasant. Experimentation is encouraged, but you should proceed with purpose and mindfulness. Mute or turn your system volume down first before you try something unpredictable.</p>
        </section>
      </section>

      <section id="envelopes">
        <h2>Envelopes</h2>
        <p>If we play a function containing some oscillator or noise generator, and then step away for a coffee, we&apos;d return sometime later to find that sound still going. In music, an infinite-length sound isn&apos;t particularly useful. Instead, we usually like sounds to have definitive beginnings and ends, so that we can structure them in time.</p>
        <p>An envelope is a signal with a customizable shape and duration, typically constructed from individual line segments joined end-to-end. Envelopes are often used to control the amplitude of another signal, enabling fades instead of abrupt starts and stops. By using release, we&apos;ve already been relying on a built-in envelope that accompanies the function-dot-play construct. When controlling signal amplitude, an envelope typically starts at zero, ramps up to some positive value, possibly stays there for a while, and eventually comes back down to zero. The first segment is called the <dfn>attack</dfn>, the stable portion in the middle is the <dfn>sustain</dfn>, and the final descent is the <dfn>release</dfn>. Many variations exist; an <q>ADSR</q> envelope, for example, has a <dfn>decay</dfn> segment between the attack and sustain.</p>
        <p>It&apos;s important to recognize that the ADSR envelope is just one specific example that happens to be useful for modeling envelope characteristics of many real-world sounds. Ultimately, an envelope is just a signal with a customizable shape, which can be used to control any aspect of a signal algorithm, not just amplitude.</p>


        <section>
          <h3><code>Line</code> and <code>XLine</code></h3>
          <p>The UGens <code>Line</code> and <code>XLine</code> provide simple envelope shapes. <code>Line</code> generates a signal that travels linearly from one value to another over a duration in seconds. <code>XLine</code> is similar but features an exponentially curved trajectory. Like the <code>exprand</code> and <code>exprange</code> methods, the start and end values for <code>XLine</code> must have the same sign and neither can be zero. Note that <code>XLine</code> cannot end at zero, but it can get close enough that the difference is unnoticeable.</p>
          <pre>(
{
 var sig, env;
 env = Line.kr(start: 0.3, end: 0, dur: 0.5);
 sig = SinOsc.ar(350) * env;
 sig = sig ! 2;
}.play;
)
(
{
 var sig, env;
 env = XLine.kr(start: 0.3, end: 0.0001, dur: 0.5);
 sig = SinOsc.ar(350) * env;
 sig = sig ! 2;
}.play;
)</pre>
        </section>
        <section>
          <h3><code>DoneAction</code></h3>
          <p>Line and XLine include an argument, named <code>doneAction</code>, which appears in UGens that have an inherently finite duration. In SC, a doneAction represents an action that the audio server takes when the UGen that contains the doneAction has finished. These actions can be specified by integer, and a complete list of available actions and their meanings appears in the help file for the Done UGen. Most of the descriptions in this table may look completely meaningless to you, but if so, don&apos;t worry. In practice, we rarely employ a doneAction other than zero (do nothing) or two (free the enclosing synth). The default doneAction is zero, and while taking no action sounds harmless, it carries consequences. To demonstrate, evaluate either of the two code examples below many times in a row. As you do, you&apos;ll notice your CPU usage will gradually creep upwards.</p>
          <p>Why does this happen? Because a doneAction of zero tells the server to do nothing when the envelope is complete, the envelope remains active on the server and continues to output its final value indefinitely. These zero or near-zero values are multiplied by the sine oscillator, which results in a silent or near-silent signal. The server is indifferent to whether a sound process is silent; it only knows that it was instructed to do nothing when the envelope finished. If you evaluate this code over and over, you&apos;ll create more and more non-terminating sound processes. Eventually, the server will become overwhelmed, and additional sounds will start glitching (if you&apos;ve followed these instructions and ramped up your CPU numbers, now is a good time to press [cmd]+[period] to remove these <q>ghost</q> sounds).</p>
          <p>From a practical perspective, when our envelope reaches its end, we consider the sound to be totally finished. So, it makes sense to specify 2 for the doneAction. When running the code in Code Example 2.15, the server automatically frees the sound when the envelope is done. Evaluate this code as many times as you like, and although it won&apos;t sound any different, you&apos;ll notice that CPU usage will not creep upwards as it did before.</p>
          <pre>(
{
 var sig, env;
 env = XLine.kr(start: 0.3, end: 0.0001, dur: 0.5, doneAction: 2);
 sig = SinOsc.ar(350) * env;
 sig = sig ! 2;
}.play;
)</pre>
          <p>Knowing which doneAction to specify is an important skill, essential for automating the cleanup of stale sounds and optimizing usage of the audio server&apos;s resources.</p>
        </section>

        <section>
          <h3><code>Env</code> and <code>EnvGen</code></h3>
          <p>Lines are useful for simple envelopes, but don&apos;t provide much flexibility. Once a Line or XLine starts, it cannot be restarted, modified, or looped; it merely travels from start to end, and triggers a <code>doneAction</code> when finished. In most cases, it&apos;s preferable to use the more flexible <code>EnvGen</code>. The shape of an EnvGen is determined by an instance of a language-side class called <code>Env</code>, provided as the envelope signal&apos;s first argument. An instance of Env created with <code>new</code> expects three arguments: an array of level values, an array of segment durations, and an array of curve specifications. We can also plot an Env to visualize its shape.</p>
          <pre>(
e = Env.new(
 levels: [0, 1, 0],
 times: [1, 3],
 curve: [0, 0]
);
e.plot;
)</pre>
          <p>Let&apos;s unpack the meaning of the numbers in the previous code. The first array contains envelope levels, which are values that the envelope signal will visit as time progresses: the envelope starts at 0, travels to 1, and returns to 0. The second array specifies durations of the segments between these levels: the attack is 1 second long, and the release is 3 seconds. The final array determines segment curvatures. Zero represents linearity, while positive/negative values will <q>bend</q> the segments. Note that when an Env is created this way, the size of the first array is always one greater than either of the other two arrays. Take a moment to modify the code from the example, to better understand how the numbers influence the envelope&apos;s shape. This example illustrates how <code>EnvGen</code> and <code>Env</code> work together to create an envelope signal in a UGen function. Keywords are used for clarity. Because it is inherently finite, <code>EnvGen</code> accepts a <code>doneAction</code>. As before, it makes sense to specify a doneAction of 2 to automate the cleanup process.</p>
          <hr/>
          <p>When using numbers to specify segment curves, it can be hard to remember how a segment will bend depending on the sign of the number. The rule is: positive values cause a segment to be more horizontal at first, and more vertical toward the end. Negative values cause the segment to be more vertical at first, becoming more horizontal toward the end.</p>
          <p>Certain symbols can also be used to specify a segment curve, such as \lin, \exp, \sin, and others. A table of valid options appears in the Env help file, under the section that explains the class method new.</p>
          <pre>(
{
 var sig, env;
 env = EnvGen.kr(
 envelope: Env.new(
 levels: [0, 1, 0],
 times: [1, 3],
 curve: [0, 0]
 ),
 doneAction: 2
 );
 sig = SinOsc.ar(350) * 0.3;
 sig = sig * env;
 sig = sig ! 2;
}.play;
)</pre>
          <p>Envelopes can be divided into two categories: those with fixed durations, and those that can be sustained indefinitely. The envelopes we&apos;ve seen so far belong to the first category, but in the real world, many musical sounds have amplitude envelopes with indefinite durations. When a violinist bows a string, we won&apos;t know when the sound will stop until the bow is lifted. An envelope that models this behavior is called a <dfn>gated envelope</dfn>. It has a parameter, called a <q>gate</q>, which determines how and when the envelope signal progresses along its trajectory. When the gate value transitions from zero to positive, the envelope begins and sustains at a point along the way. When the gate becomes zero again, the envelope continues from its sustain point and finishes the rest of its journey. Like a real-world gate, we describe this parameter as being open (positive) or closed (zero).</p>
          <p>To create a sustaining envelope, we can add a fourth argument to <code>Env.new()</code>: an integer representing an index into the levels array, indicating the value at which the envelope will sustain. In SC terminology, this level is called the <dfn>release node</dfn>. In the example, the release node is 2, which means the envelope signal will sustain at a level of 0.2 while the gate remains open. Because gate is a parameter we&apos;d like to change while the sound is playing, it must be declared as an argument, and supplied to the EnvGen. In effect, this example creates an ADSR envelope: the attack travels from 0 to 1 over 0.02 seconds, the decay drops to a level of 0.2 over the next 0.3 seconds, and the signal remains at 0.2 until the gate closes, which triggers a one-second release.</p>
          <pre>(
f = { |gate = 1|
 var sig, env;
 env = EnvGen.kr(
 envelope: Env.new(
 [0, 1, 0.2, 0],
 [0.02, 0.3, 1],
 [0, -1, -4],
 2
 ),
 gate: gate,
 doneAction: 2
 );
 sig = SinOsc.ar(350) * 0.3;
 sig = sig * env;
 sig = sig ! 2;
};
)
x = f.play;
x.set(\gate, 0);</pre>
          <p>In some cases, we may want to retrigger an envelope, opening and closing its gate at will, to selectively allow sound to pass through. If so, a doneAction of 2 is a poor choice, because we don&apos;t necessarily want the sound process to be destroyed if the envelope reaches its end. Instead, a 0 doneAction (the default) is the correct choice, as demonstrated next, which causes the envelope to <q>idle</q> at its end point until it is retriggered.</p>
          <p>It&apos;s worth being extra clear about the specific behavior of an envelope in response to gate changes when a release node has been specified:</p>
          <ul>
            <li>A zero-to-positive gate transition causes the envelope to move from its current level to the second level in the levels array, using its first duration and first curve value. Note that the envelope never revisits its first level, which is only used for initialization.</li>
            <li>A positive-to-zero gate transition causes the envelope to move from its current value to the value immediately after the release node, using the duration and curve values at the same index as the release node.</li>
          </ul>
          <pre>(
f = { |gate = 1|
var sig, env;
env = EnvGen.kr(
Env.new(
[0, 1, 0.2, 0],
[0.02, 0.3, 1],
[0, -1, -4],
2
),
gate
);
sig = SinOsc.ar(350) * 0.3;
sig = sig * env;
sig = sig ! 2;
};
)
x = f.play;
x.set(\gate, 0); // fade to silence but do not free
x.set(\gate, 1); // reopen the gate to restart the envelope
x.set(\gate, 0); // fade to silence again
x.free; // free when finished</pre>
          <p>This retriggering ability may also be useful for fixed-duration envelopes. It&apos;s possible but clumsy to retrigger a fixed-duration envelope with a standard gate argument, because it requires manually closing the gate before reopening. As a solution, we can precede the gate argument name with <code>t_</code>, which transforms it into a <q>trigger-type</q> argument, which responds differently to set messages. When a trigger-type argument is set to a non-zero value, it holds that value for a single control cycle, and then almost immediately <q>snaps</q> back to zero. It&apos;s like a real-world gate that&apos;s been augmented with a powerful spring, slamming shut immediately after being opened. Below we demonstrate the use of trigger-type arguments. Note that the default gate value is zero, which means the envelope will idle at its starting level (zero) until the gate is opened.</p>
          <pre>(
x = { |t_gate = 0|
 var sig, env;
 env = EnvGen.kr(
 Env.new(
 [0, 1, 0],
 [0.02, 0.3],
 [0, -4],
 ),
 t_gate,
 );
 sig = SinOsc.ar(350) * 0.3;
 sig = sig * env;
 sig = sig ! 2;
}.play;
)
x.set(\t_gate, 1); // evaluate repeatedly
x.free; // free when finished</pre>
          <p>EnvGen, in partnership with Env, is one of the more complex UGens in the class library, with many variations and subtleties. Both help files contain additional information.</p>
        </section>
      </section>

      <section id="multichannel">
        <h2>Multichannel Signals*</h2>
        <!--
        <section>
          <h3></h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3></h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        -->
      </section>  <!-- end of "Multichannel Signals" -->

      <section id="SynthDef-and-Synth">
        <h2><code>SynthDef</code> and <code>Synth</code></h2>
        <!--
        <section>
          <h3></h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        <section>
          <h3></h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>
        -->
      </section>  <!-- end of "<code>SynthDef</code> and <code>Synth</code>" -->

      <section>
        <h2>Alternate Expression of Frequency and Amplitude</h2>
        <p>Oscillators with a frequency parameter expect a value in Hertz. When thinking about musical pitch, Hertz isn&apos;t always the preferred unit of measurement. Using MIDI note numbers can be a convenient alternative. In this system, 60 corresponds to middle C (roughly 261.6 Hz), and an increment/decrement of one corresponds to a semitone shift in 12-tone equal temperament. We can convert from MIDI to Hertz using <code>midicps</code> and convert in the other direction with <code>cpsmidi</code>. Non-integer MIDI note numbers are valid and represent a pitch proportionally between two equal-tempered semitones.</p>
        <pre>60.midicps; // -> 261.6255653006
500.cpsmidi; // -> 71.213094853649</pre>
        <p><code>midiratio</code> and <code>ratiomidi</code> are similarly useful methods that convert back and forth between an interval, measured in semitones, and the frequency ratio that interval represents. For example, 3.midiratio represents the ratio between an F and the D immediately below it, because these two pitches are three semitones apart. Negative semitone values represent pitch movement in the opposite direction.</p>
        <pre>// the ratio that raises a frequency by one semitone
1.midiratio; // -> 1.0594630943591
// the ratio 8/5 is slightly more than 8 equal-tempered semitones
(8/5).ratiomidi // -> 8.1368628613517</pre>
        <p>Similarly, when expressing signal amplitude, a normalized range between zero and one isn&apos;t always the most intuitive choice. The <code>ampdb</code> method converts a normalized amplitude to a decibel value and <code>dbamp</code> does the opposite. A value of zero dB corresponds to a nominal amplitude value of one. If your audio system is properly calibrated, a decibel value around -20 dB should produce a comfortable monitoring level, and a typical signal will become inaudible around -80 dB.</p>
        <pre>-15.dbamp; // -> 0.17782794100389
0.3.ampdb; // -> -10.457574905607</pre>
        <p>For efficiency reasons, it is preferable not to build these methods into a <code>SynthDef</code>, and instead call them when creating or modifying a <code>Synth</code>, so that the server does not have to repeatedly perform these calculations.</p>
        <pre>(
SynthDef.new(\test, {
arg freq = 350, amp = 0.2, atk = 0.01, dec = 0.3,
slev = 0.4, rel = 1, gate = 1, out = 0;
var sig, env;
env = EnvGen.kr(
Env.adsr(atk, dec, slev, rel),
gate,
doneAction: 2
);
sig = SinOsc.ar(freq + [0, 1]);
sig = sig * env;
sig = sig * amp;
Out.ar(out, sig);
}).add;
)
x = Synth(\test, [freq: 60.midicps, amp: -20.dbamp]);
x.set(\freq, 62.midicps); // increase pitch by 2 semitones
x.set(\amp, -12.dbamp); // increase level by 8 dB
x.set(\gate, 0);</pre>
      </section>  <!-- end of "Alternate Expression of Frequency and Amplitude" -->

      <section id="synthesis">
        <h2>Synthesis*</h2>
        <p>Synthesis refers to creative applications of combining and interconnecting signal generators, typically relying on oscillators and noise, with a goal of building unique timbres and textures. This section explores synthesis categories.</p>
        <section>
          <h3>Additive Synthesis*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
        </section>
        <section>
          <h3>Modulation Synthesis*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
        </section>
        <section>
          <h3>Wavetable Synthesis*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
        </section>
        <section>
          <h3>Filters and Subtractive Synthesis*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
        </section>
        <section>
          <h3>Modal Synthesis*</h3>
          <p>Physical objects vibrate when disturbed. Common musical examples include plucking a string or striking something with a mallet. The vibrational patterns of some objects, like bells and chimes, are composed of a complex sum of sinusoidal vibrations that decay over a relatively long duration. Other objects, like blocks of wood, exhibit periodic vibrations that decay almost instantly. Modal synthesis refers to the practice of creating (or recreating) the sound of a physical object by simulating its natural modes of vibration. Superficially, this technique is like additive synthesis, but involves injecting excitation signals into resonant filters, rather than summing sine generators.</p>
          <p><code>Resonz</code> and <code>Ringz</code><!--, demonstrated in Code Example 3.26,--> are resonant filters that provide an entryway into modal synthesis. <code>Resonz</code> is a band-pass filter with a constant gain at zero decibels. This means that as the bandwidth decreases, the sense of resonance increases, but spectral content at the center frequency will remain at its input level, while surrounding content is attenuated. It virtually indistinguishable from BPF in terms of usage and sound. <code>Ringz</code>, on the other hand, has a variable gain that depends on the bandwidth, specified indirectly as a 60 dB decay time. As this decay time increases, bandwidth narrows, a sense of resonance increases, and spectral content at the center frequency undergoes a potentially dramatic increase in amplitude. The difference between Resonz and Ringz is subtle but has significant consequences.</p>
          <p>In terms of practical usage, because of its variable-gain design, <code>Ringz</code> is intended to be driven by single-sample impulses. Even an excitation signal a few samples long has the potential to overload <code>Ringz</code> and produce a distorted output signal. Longer signals, such as sustained noise, can technically be fed to an instance of <code>Ringz</code>, but the amplitude of the excitation signal and/or the output signal must be drastically reduced in order to compensate for the increase in level, particularly if the decay time is long. <code>Resonz</code>, by contrast, is designed to accept sustained excitation signals and is more likely to need an amplitude boost to compensate for low levels, particularly in narrow bandwidth situations. Feeding single-sample impulses into <code>Resonz</code> is fine, but the level of the output signal will likely be quite low.</p>
          <pre>(
{
var sig, exc;
exc = Impulse.ar(1);
sig = Ringz.ar(
in: exc,
freq: 800,
decaytime: 1/3
);
sig = sig * 0.2 ! 2;
}.play;
)
(
{
var sig, exc;
exc = PinkNoise.ar(1);
sig = Resonz.ar(
in: exc,
freq: 800,
bwr: 0.001,
mul: 1 / 0.001.sqrt
);
sig = sig * 0.5 ! 2;
}.play;
)</pre>
          <p><code>Klank</code> and <code>DynKlank</code> encapsulate fixed and dynamic banks of <code>Ringz</code> resonators, offering a slightly more convenient and efficient option than applying multichannel expansion to an instance of Ringz (<i>see below</i>). These UGens require a <code>Ref</code> array containing internal arrays of frequencies, amplitudes, and decay times of simulated resonances. The frequencies can be scaled and shifted, and the decay times can also be scaled.</p>
          <pre>(
{
var sig, exc, freqs, amps, decays;
freqs = [211, 489, 849, 857, 3139, 4189, 10604, 15767];
amps = [0.75, 0.46, 0.24, 0.17, 0.03, 0.019, 0.002, 0.001];
decays = [3.9, 3.4, 3.3, 2.5, 2.2, 1.5, 1.3, 1.0];
exc = Impulse.ar(0.5);
sig = Klank.ar(
`[freqs, amps, decays], // &lt;- note the backtick character
exc,
);
sig = sig * 0.25 ! 2;
}.play;
)</pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
        </section>
        <section>
          <h3>Waveform Distortion*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
        </section>
      </section>  <!-- end of "Synthesis" -->

      <section>
        <h2>Sampling*</h2>
        <p>Sampling refers to creative practices that rely on recorded sound, typically involving modified playback of audio files stored in blocks of memory on the audio server. In a sense, sampling and <a href="#synthesis">synthesis</a> are two sides of the same signal-generating coin. Synthesis relies on mathematical algorithms, while sampling is based on the use of content that has already been produced and captured. Most sound sources found throughout creative audio practices are rooted in one of these two categories.</p>
        <p>Sampling opens a door to a world of sound that is difficult or impossible to create using synthesis techniques alone. Anything captured with a microphone and rendered to a file instantly becomes a wellspring of creative potential: a recording of wildlife can become a surreal ambient backdrop, or a recording of a broken elevator can be chopped into weird percussion samples. Instead of using dozens of sine waves or filters to simulate a gong, why not use the real thing?</p>
        <p>Before loading sampled audio files into software, it&apos;s wise to practice good sample hygiene. Unnecessary silence should be trimmed from the beginnings and ends of the files, samples should be as free as possible from background noise and other unwanted sounds, and the peak amplitudes of similar samples should be normalized to a consistent level. Normalization level is partly a matter of personal preference, but –12 dBFS is usually a reasonable target, which makes good use of available bit depth while reserving ample headroom for mixing with other sounds.</p>
        <pre></pre>
        <p></p>
        <pre></pre>

        <section>
          <h3>Overview*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section>
          <h3>*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section>
          <h3>*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section>
          <h3>*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

        <section>
          <h3>*</h3>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
        </section>

      </section>  <!-- end of "Sampling" -->

      <section id="sequencing">
        <h2>Sequencing</h2>

        <section>
          <h3>Overview</h3>
          <p>A musical composition can be viewed as a sequence of sections, a section as a sequence of phrases, and a phrase as a sequence of notes. Thinking in this modular way, that is, conceptualizing a project as smaller sequential units that can be freely combined, is an excellent way to approach large-scale projects in SC, and in programming languages more generally.</p>
          <p>SC provides a wealth of sequencing options. The Pattern library, for example, is home to hundreds of classes that define many types of sequences, which can be nested and combined to form complex, composite structures. The <code>Stream</code> class is also a focal point, which provides sequencing infrastructure through its subclasses, notably <code>Routine</code> and <code>EventStreamPlayer</code>. <code>Clock</code> classes provide an implicit musical grid on which events can be scheduled, and play a central role in sequencing as well.</p>
          <p>It&apos;s important to make a distinction between processes that define sequences, and processes that perform sequences. As an analogy, consider the difference between a notated musical score and a live musical performance of that score. The score provides detailed performance instructions, and the sound of the music can even be imagined by studying it. However, the score is not the same thing as a performance. One score can spawn an infinite number of performances, which may be slightly or significantly different from each other. In SC, a pattern or function can be used to define a sequence, while some type of stream is used to perform it.</p>
        </section>

        <section>
          <h3>Routines and Clocks</h3>
          <p>When we evaluate a function, the encapsulated code statements are executed in order, but these executions occur so quickly that they seem to happen all at once. When the function in the listing below is evaluated, three tones are produced, and we hear a chord.</p>
          <pre>s.boot;
(
~eventA = {SinOsc.ar(60.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
~eventB = {SinOsc.ar(70.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
~eventC = {SinOsc.ar(75.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
f = {
~eventA.play;
~eventB.play;
~eventC.play;
};
)
f.();</pre>
          <p>How would we play these tones one-by-one, to create a melody? The <code>Routine</code> class, introduced next, provides one option for timed sequences. A <dfn>routine</dfn> is a special type of state-aware function, capable of pausing and resuming mid-execution. A routine encapsulates a function, and within this function, either the <code>yield</code> or <code>wait</code> method designates a pause (<code>yield</code> is used throughout this section, but these methods are synonymous when applied to a number). Once a routine is created, we can manually step through it by calling next on the routine. On each next, the routine begins evaluation, suspends when it encounters a pause, and continues from that point when another next is received. If a routine has reached its end, next returns <code>nil</code>, but a routine can be reset at any time, which effectively <q>rewinds</q> it to the beginning.</p>
          <pre>(
  ~eventA = {SinOsc.ar(60.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
  ~eventB = {SinOsc.ar(70.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
  ~eventC = {SinOsc.ar(75.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
  f = {
    ~eventA.play;
    1.yield;
    ~eventB.play;
    1.yield;
    ~eventC.play;
    1.yield;
  };
  r = Routine(f);
)
r.next; // evaluate repeatedly
r.reset; // return to the beginning at any time</pre>
          <p>Note that yield must be called from within a routine, so the function <code>f</code> in the code above cannot be evaluated by itself:</p>
          <pre>f.(); // -&gt; ERROR: yield was called outside of a routine.</pre>
          <hr/>
          <p>The convenience method <code>r</code> can be applied to a function and will return a routine that contains that function. Thus, a routine can be written in any of the following ways:</p>
          <pre>Routine({"hello".postln; 1.yield;});
{"hello".postln; 1.yield;}.r;
r({"hello".postln; 1.yield;});</pre>
          <p>When stepping through a routine, each <code>yield</code> returns its receiver, in the same way that calling <code>value</code> on a function returns its last expression. Thus, the returned value from each next call is equal to each yielded item (this is also why each next causes the number one to appear in the post window). In the foregoing code, the thing we yield is irrelevant, and we have no interest in it. It could be any object; the number one is chosen arbitrarily. In this example, we are more interested in the actions that occur between yields, specifically, the production of sound.</p>
          <p>However, the ability of a routine to return values illustrates another usage. Suppose we want a process that generates MIDI note numbers that start at 48 and increment by a random number of semitones between one and four, until the total range exceeds three octaves. We can do so by defining an appropriate function and yielding values of interest. A <code>while</code> loop is useful, as it allows us to repeatedly apply an increment until our end condition is met (<i>see</i> below).</p>
          <h5>Using a routine and while loop to generate randomly incremented MIDI note numbers</h5>
          <pre>(
  ~noteFunc = {
    var num = 48;
    while({num &lt; 84}, {
      num.yield;
      num = num + rrand(1, 4);
    });
  };
  ~noteGen = Routine(~noteFunc);
)
~noteGen.next; // evaluate repeatedly</pre>
          <p>Note that this sequence is not predetermined, because each <code>next</code> performs a new application of the <code>rrand</code> function. Thus, if <code>~noteGen</code> is reset, it will generate a new random sequence, probably different than the previous.</p>
          <p>We often want a routine to advance on its own. A routine will execute automatically in response to <code>play</code>, as shown next. In this case, <code>yield</code> values are treated as pause durations (measured in seconds, under default conditions).</p>
          <p>Iteration, demonstrated afterwards, is a useful tool for creating timed repetitions.</p>
          <pre>(
  ~eventA = {SinOsc.ar(60.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
  ~eventB = {SinOsc.ar(70.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
  ~eventC = {SinOsc.ar(75.midicps ! 2) * Line.kr(0.1, 0, 1, 2)};
  f = {
    ~eventA.play;
    1.yield;
    ~eventB.play;
    1.yield;
    ~eventC.play;
    1.yield;
  };
  r = Routine(f);
)
r.play;</pre>
          <h5>Using iteration inside a routine to create repetitions</h5>
          <pre>(
  ~playTone = { |freq|
  {SinOsc.ar(freq ! 2) * Line.kr(0.1, 0, 1, 2)}.play;
  };
  f = {
    3.do({
    ~playTone.(72.midicps);
    0.2.yield;
    ~playTone.(62.midicps);
    0.4.yield;
    });
  };
  r = Routine(f);
)
r.play;</pre>
          <p>When using iteration in a routine, <code><var>number</var>.do</code> can be replaced with <code>loop</code> or <code>inf.do</code> (a special keyword that represents infinity) to repeat a block of code indefinitely, as illustrated. A playing routine can be stopped at any time using stop—particularly important to keep in mind if a routine has no end! Stopping all routines is also one of the side-effects of pressing [cmd]+[period]. Once a routine is stopped, it cannot be resumed with <code>play</code> or <code>next</code> unless it is first reset.</p>
          <h5>An infinite-length routine.</h5>
          <pre>(
  ~playTone = { |freq|
    {SinOsc.ar(freq ! 2) * Line.kr(0.1, 0, 0.2, 2)}.play;
  };
  r = Routine({
    loop({
      ~playTone.(72.midicps);
      0.4.yield;
      [62, 63, 64].do({ |n|
        ~playTone.(n.midicps);
        (0.4 / 3).yield;
      });
    });
  });
)
r.play;
r.stop;</pre>
          <h4>The Danger of Infinite Loops</h4>
          <p>When using <code>play</code> or <code>next</code> on an infinite-length routine, make sure there&apos;s at least one <code>yield</code>/<code>wait</code>! Executing an infinite routine with no built-in pauses will immediately overwhelm your CPU and may even crash the language. While stuck in a loop, SC will struggle to receive even the most basic types of input, like pressing [cmd]+[period] or clicking drop-down menus, and a forced quit may be necessary. Some versions of SC may attempt to auto-recover unsaved code in the event of a crash, but it&apos;s not wise to rely too heavily on this feature.</p>
          <p>When a routine is played, the resulting process exists in its own temporal space, called a <dfn>thread</dfn>, which is independent from the parent thread in which it was created. Thus, when multiple routines are played using back-to-back code statements (as they are in <code>~r_parallel</code>), each exists independently, unaware of the others&apos; existences. However, when serial behavior is desired, <code>embedInStream</code> can be used instead of <code>play</code>, which situates the subroutine in the parent thread. In this case, the parent routine and the two subroutines are all part of the same thread and exist along one temporal continuum. Thus, each subroutine begins only when the previous subroutine has finished.</p>
          <h5>Nesting routines inside of other routines so that they play in parallel or in series</h5>
          <pre>(
  ~playTone = { |freq|
    {SinOsc.ar(freq ! 2) * Line.kr(0.1, 0, 0.2, 2)}.play;
  };
  ~sub0 = {
    2.do({
      ~playTone.(67.midicps);
      0.15.yield;
      ~playTone.(69.midicps);
      0.15.yield;
    });
    0.5.yield;
  };
  ~sub1 = {
    3.do({
      ~playTone.(75.midicps);
      0.5.yield;
    });
    1.yield;
  };
  ~r_parallel = Routine({
    Routine(~sub0).play;
    Routine(~sub1).play;
  });
  ~r_series = Routine({
    Routine(~sub0).embedInStream;
    Routine(~sub1).embedInStream;
  });
)
~r_parallel.play; // subroutines execute simultaneously
~r_series.play; // subroutines play one after the other</pre>
          <p>Modular thinking is important and valuable. Before setting out to build some glorious routines, take a moment to conceptualize the musical structure they&apos;ll represent. Break down your structures into the simpler units, build subroutines (perhaps sub-subroutines), and combine them appropriately. A large, unwieldy, irreducible routine is usually harder to debug than one built from modular parts.</p>
          <section>
            <h4>TempoClock</h4>
            <p>Previously, yield values were interpreted as durations, measured in seconds. Unless you&apos;re working at a tempo of 60 (or perhaps 120) beats per minute, specifying durations in seconds is inconvenient, and requires extra math. To determine the duration of an eighth note at 132 bpm, for example, we first divide 60 by the tempo to produce a value that represents seconds per beat. If a quarter note is considered one beat, we then divide by two to get the duration of an eighth note:</p>
            <pre>(60 / 132 / 2).yield; // an eighth rest at 132 bpm</pre>
            <p>Manual calculation of durations based on tempo is cluttered and does not do a good job of visually conveying metric structure. <code>TempoClock</code>, one of three clock objects (its siblings are <code>SystemClock</code> and <code>AppClock</code>), provides an elegant solution. These three clocks handle the general task of scheduling things at specific times. <code>AppClock</code> is the least accurate of the three, but it can schedule certain types of actions that its siblings cannot, notably, interacting with graphical user interfaces. <code>SystemClock</code> and <code>TempoClock</code> are more accurate, but <code>TempoClock</code> has the additional benefit of being able to express time in terms of beats at a particular tempo. When the interpreter is launched or rebooted, a default instance of <code>TempoClock</code> is automatically created:</p>
            <pre>TempoClock.default;</pre>
            <p>The default <code>TempoClock</code> runs at 60 bpm, and the current beat can be retrieved via the <code>beats</code> method:</p>
            <p>TempoClock.default.beats; // evaluate repeatedly</p>
            <p>When a routine is played, it is scheduled on a clock. If no clock is specified, it plays on the default <code>TempoClock</code>. This is why, throughout the previous section, <code>yield</code> values can be treated as durations, even though they technically specify a number of beats.</p>
            <p>When creating your own instance of <code>TempoClock</code>, the first argument is interpreted as a value in beats per second. If you want to specify tempo in beats per minute, divide that value by 60:</p>
            <pre>t = TempoClock(132/60); // a TempoClock running at 132 bpm
t.beats; // evaluate repeatedly to get the current beat</pre>
            <p>A routine can be scheduled on a specific clock by providing that clock as the first argument for <code>play</code>. In the code below, <code>yield</code> times represent beat values, relative to the clock on which the routine plays. The tempo of a <code>TempoClock</code> can be changed at any time using the <code>tempo</code> method, also depicted in this same example. Note that <code>tempo</code> only affects durations between onsets and has no effect on the durations of the notes themselves (which in this case are determined by <code>Line</code>).</p>
            <h5>A routine that plays three notes in sequence, with timings based on beat durations at a specific tempo</h5>
            <pre>(
  t = TempoClock(132/60);
  ~playTone = { |freq|
    {SinOsc.ar(freq ! 2) * Line.kr(0.1, 0, 1, 2)}.play;
  };
  r = Routine({
    [60, 70, 75].do({ |n|
      ~playTone.(n.midicps);
      (1/2).yield;
    });
  });
)
r.play(t);
t.tempo = 112/60;
r.reset.play(t); // now eighth notes at 112 bpm</pre>
            <p>We often want to synchronize several timed processes, so that they begin together and/or exist in rhythmic alignment. Manual attempts to synchronize a routine with one that&apos;s already playing will rarely succeed. Even if both routines are played on the same clock, their performances are not guaranteed to align with each other. By default, when a routine is played on a clock, it begins immediately. To schedule a routine to begin on a certain beat, we can specify <code>quant</code> information along with the clock, as shown below.</p>
            <pre>(
  t = TempoClock(132/60);
  ~playTone = { |freq|
    {SinOsc.ar(freq ! 2) * Line.kr(0.1, 0, 0.2, 2)}.play;
  };
  ~r0 = Routine({
    loop({
      [60, 63, 65, 67].do({ |n|
        ~playTone.(n.midicps);
        (1/2).yield;
      });
    });
  });
  ~r1 = Routine({
    loop({
      [70, 72, 75, 77].do({ |n|
        ~playTone.(n.midicps);
        (1/2).yield;
      });
    });
  });
)
~r0.play(t, quant: 4); // begin playing on next beat multiple of four
~r1.play(t, quant: 4); // will be beat-aligned with ~r0</pre>
            <p>In some cases, you may want a rhythmic process to be quantized to a particular beat but shifted in time to begin some number of beats after or before that beat. In this case, an array of two values can be provided for <code>quant</code>, as demostrated below. The first value represents a beat multiple, and the second value represents a number of beats to shift along the timeline. Negative values result in earlier scheduling.</p>
            <pre>~r0.reset.play(t, quant: [4, 0]); // plays on the next beat multiple of four
~r1.reset.play(t, quant: [4, 1]); // plays one beat after the next beat multiple of four</pre>
            <p>As an alternative to stopping all routines individually, all actions scheduled on a TempoClock can be removed by calling clear on the clock:</p>
            <pre>t.clear;</pre>
            <p>When a large-scale routine is constructed as a singular entity composed of subroutines, there is less of a need to control quantization information, because the timing aspects can be configured in advance. However, quantization is essential for real-time applications, such as live coding, in which new components may be added spontaneously.</p>
            <p>There is generally no harm in allowing a <code>TempoClock</code> to continue existing in the background (any outstanding clocks are destroyed when quitting SC), but a <code>TempoClock</code> can be stopped at any time with <code>stop</code>. This is a hard stop that destroys the clock, after which resuming or querying the current beat is no longer possible. To resume, a new clock must be created. By default, <kbd>[cmd]+[period]</kbd> will destroy all user-created clocks, but a clock can be configured to survive <code>[cmd]+[period]</code> by setting its <code>permanent</code> attribute to <code>true</code>:</p>
            <pre>t = TempoClock(132/60).permanent_(true);
// press [cmd]+[period]…
t.beats; // the clock remains
t.permanent = false;
// press [cmd]+[period]…
t.beats; // the clock is destroyed</pre>
          </section>  <!-- end of "TempoClock" -->
        </section>

        <section>
          <h3>Patterns</h3>
          <p>Patterns, which exist as a family of classes that all begin with capital P, provide flexible, concise tools for expressing musical sequences. A pattern defines a sequence but does not perform that sequence. To retrieve a pattern&apos;s output, we can use <code>asStream</code> to return a routine, which can then be evaluated with <code>next</code>. In contrast to creating such routines ourselves, patterns are simpler, pre-packaged units with known behaviors, and tend to save time.</p>
          <p>Patterns are, in a sense, a language of their own within the SC language, and it takes time to get familiar. At first, it can be difficult to find the right pattern (or combination of patterns) to express an idea. But, when learning a foreign language, you don&apos;t need to memorize the dictionary to become fluent. You only need to learn a small handful of important words, enough to form a few coherent, useful sentences, and the rest will follow with practice and exposure. Patterns are among the most thoroughly documented classes, and there are multiple tutorials built into the help browser.</p>
          <section>
            <h4>Value Sequences</h4>
            <p>Many patterns define sequences of values. Often, these values are numbers, but may be any type of data. Consider <code>Pseries</code>, demonstrated below, which represents an arithmetic sequence that begins at 50, repeatedly adds 7, and generates a total of six values. Creating this stream from scratch using a routine, shown before, requires considerably more labor.</p>
            <h5>A pattern-generated arithmetic sequence</h5>
            <pre>( ~pat = Pseries(start: 50, step: 7, length: 6);
  ~seq = ~pat.asStream;
)
~seq.next; // evaluate repeatedly</pre>
            <h5>A routine-generated arithmetic sequence</h5>
            <pre>(
  ~pat = {
    var num = 50, inc = 7, count = 0;
    while({count &lt; 6}, {
      num.yield;
      num = num + inc;
      count = count + 1;
    });
  };
  ~seq = Routine(~pat);
)
~seq.next; // evaluate repeatedly</pre>
            <p>Patterns are described as <q>stateless.</q> They represent a sequence but are distinct from and completely unaware of its actualization. To emphasize, observe the result when trying to extract values directly from a pattern:</p>
            <pre>~pat = Pseries(50, 7, 6);
~pat.next; // -> returns "a Pseries"</pre>
            <p><code>nextN</code> returns an array of values from a sequence, and <code>all</code> returns an array containing all of them. To demonstrate, we also introduce <code>Pwhite</code>, which defines a sequence of random values selected from a range with a uniform distribution. Like <code>rrand</code>, <code>Pwhite</code> defines a sequence of integers if its boundaries are integers, and floats if either boundary is a float.</p>
            <h5>Retrieving an array of multiple values from a sequence</h5>
            <pre>(
  ~pat = Pwhite(lo: 48, hi: 72, length: 10);
  ~seq = ~pat.asStream;
)
~seq.nextN(4); // evaluate repeatedly
~seq.reset;
~seq.all;</pre>
            <p>Infinite-length sequences are possible, as shown below, created by specifying <code>inf</code> for the pattern length or number of repeats. Here, we introduce <code>Prand</code>, which randomly selects an item from an array.</p>
            <pre>(
  ~pat = Prand(list: [4, 12, 17], repeats: inf);
  ~seq = ~pat.asStream;
)
~seq.next; // an inexhaustible supply</pre>
          </section>
          <section>
            <h4>Calling <code>all</code> on an Infinite-length Stream</h4>
            <p>Like playing an infinite-length routine with no yields, calling all on an infinite-length stream will crash the program!</p>
            <p>The following table provides a list of commonly encountered patterns used to generate numerical sequences. Note that some patterns, like <code>Pseries</code> and <code>Pwhite</code>, can only define sequences with numerical output, while others, like <code>Pseq</code> and <code>Prand</code>, output items from an array and can therefore define sequences that output any kind of data.</p>
            <table border="1">
              <thead> <tr> <td>Pattern</td> <td>Description</td> </tr> </thead>
                      <tr> <td><code>Pseq(list, repeats, offset)</code></td> <td>Sequentially outputs values from list array, with an optional offset to a specific index.</td> </tr>
                      <tr> <td><code>Pwhite(lo, hi, length)</code></td> <td>Random values between lo and hi with a uniform distribution.</td> </tr>
                      <tr> <td><code>Pexprand(lo, hi, length)</code></td> <td>Random values between lo and hi with an exponential distribution.</td> </tr>
                      <tr> <td><code>Pbrown(lo, hi, step, length)</code></td> <td>Random values between lo and hi, but never deviating from the previous value by more than ±step.</td> </tr>
                      <tr> <td><code>Prand(list, repeats)</code></td> <td>Randomly outputs values from list array.</td> </tr>
                      <tr> <td><code>Pxrand(list, repeats)</code></td> <td>Randomly outputs values from list array, but never selects the same item twice in a row.</td> </tr>
                      <tr> <td><code>Pwrand(list, weights, repeats)</code></td> <td>Randomly outputs values from list array, according to a second array of weights that must sum to one.</td> </tr>
                      <tr> <td><code>Pseries(start, step, length)</code></td> <td>Arithmetic series. Begins at start and incrementally adds step.</td> </tr>
                      <tr> <td><code>Pgeom(start, grow, length)</code></td> <td>Geometric series. Begins at start and repeatedly multiplies by grow.</td> </tr>
            </table>
            <p>Mathematical operations and methods that apply to numbers can also be applied to patterns that specify numerical sequences. Imagine creating a sequence that outputs random values between ±1.0, but also wanting that sequence to alternate between positive and negative values. One solution involves multiplying one pattern by another, as shown next. The result is a composite pattern that defines a sequence in which corresponding pairs of output values are multiplied. The example afterwards offers another solution, involving nesting patterns inside of another. When an array-based pattern (such as <code>Pseq</code> or <code>Prand</code>) encounters another pattern as part of its output, it embeds the entire output of that pattern before moving on to its next item (similar to the <code>embedInStream</code> method for routines).</p>
            <h5>Multiplication of one pattern by another</h5>
            <pre>(
  ~pat = Pwhite(0.0, 1.0, inf) * Pseq([-1, 1], inf);
  ~seq = ~pat.asStream.nextN(8);
)</pre>
            <h5>Nesting patterns inside other patterns</h5>
            <pre>(
  ~pat = Pseq([
    Pwhite(-1.0, 0.0, 1),
    Pwhite(0.0, 1.0, 1)
  ], inf);
  ~seq = ~pat.asStream.nextN(10);
)</pre>
          </section>
          <section>
            <h4>The Event Model</h4>
            <p>Value patterns are useful for generating sequences of numbers and other data types, but more is required to generate sequences of sound. <code>Pbind</code>, introduced in the next section, is a pattern capable of defining sound sequences, which relies on the <code>Event</code> class, discussed only briefly before as a storage device for buffers. As a reminder, an <code>Event</code> is a type of unordered collection in which each item is paired with a <q>key,</q> specified as a symbol. An <code>Event</code> can be created with the <code>new</code> method, or with an enclosure of parentheses. The following code statements use an <code>Event</code> to model quantity and type of fish in an aquarium. We begin with five guppies and eight goldfish:</p>
            <pre>a = (guppy: 5, goldfish: 8);</pre>
            <p>If we acquire three fish of a new breed, we can update the <code>Event</code> by adding a new key-value association:</p>
            <pre>a[\clownfish] = 3;</pre>
            <p>If a sixth guppy appears, we can update the value at that key. Because each key in an <code>Event</code> is unique, this expression overwrites the previous key, rather than creating a second identical key:</p>
            <pre>a[\guppy] = 6;</pre>
            <p>To retrieve the number of goldfish, we access the item stored at the appropriate key:</p>
            <pre>a[\goldfish]; // -> 8</pre>
            <p>An Event is not just a storage device; it is commonly used to model an action taken in response to a play message, in which its key-value pairs represent parameters and values necessary to that action. Often, this action is the creation of a new <code>Synth</code>, but Events model other actions, like musical rests, set messages, or sending MIDI data. There are numerous pre-made Event types that represent useful actions, each pre-filled with sensible default values. A complete list of built-in Event types can be retrieved by evaluating:</p>
            <pre>Event.eventTypes.keys.postcs;\</pre>
          </section>
          <section>
            <h4>Post Window Techniques</h4>
            <p><code>postcs</code> (short for <q>post compile string</q>) is useful for printing the entirety of a large body of text in the post window. By contrast, <code>postln</code> truncates its receiver if deemed too long. Additionally, by appending the empty symbol (a single backslash) after the semicolon, we can suppress the <q>double-posting</q> that sometimes occurs as a result of the interpreter always posting the result of the last evaluated statement. Compare the following four expressions:</p>
            <pre>(0..999).postln; // truncated double-post
(0..999).postln;\ // truncated single-post
(0..999).postcs; // non-truncated double-post
(0..999).postcs;\ // non-truncated single-post (ideal!)</pre>
            <p>postcs is also useful for visualizing the internals of a function:</p>
            <pre>(
  ~func = { |input|
   input = input + 2;
};
)
~func.postcs;\ // print the entire function definition
~func.postln;\ // only prints "a Function"</pre>
            <p>Each Event type represents a different type of action and thus expects a unique set of keys. Most Event types are rarely used and largely irrelevant for creative applications. The most common, by far, is the note Event, which models the creation of a <code>Synth</code>. This is the default Event type if unspecified. The components and behaviors of the note Event are given default values that are so comprehensive, that even playing an empty Event generates a <code>Synth</code> and produces a sound, if the server is booted:</p>
            <p>().play;</p>
            <p>On evaluation, the post window displays the resulting Event, which looks roughly like this:</p>
            <pre>-&gt; ('instrument': default, 'msgFunc': a Function, 'amp': 0.1, 'server': localhost, 'sustain': 0.8, 'isPlaying': true, 'freq': 261.6255653006, 'hasGate': true, 'id': [1000])</pre>
            <p>The default note Event includes a freq key with a value of approximately 261.6 (middle C), an amp key with a value of 0.1, and a few other items that are relatively unimportant at the moment. We can override these default values by providing our own. For example, we can specify a higher and slightly louder pitch:</p>
            <pre>(freq: 625, amp: 0.4).play;</pre>
            <p>Where does this sound come from? The instrument key specifies the <code>SynthDef</code> to be used, and there is a <code>\default SynthDef</code>, automatically added when the server boots. This default <code>SynthDef</code> is primarily used to support code examples in pattern help files, and can be found in the Event source code within the <code>makeDefaultSynthDef</code> method. When a <code>SynthDef</code> name is provided for an Event&apos;s instrument key, that <code>SynthDef</code>&apos;s arguments also become meaningful Event keys. Event keys that don&apos;t match <code>SynthDef</code> arguments and aren&apos;t part of the Event definition will have no effect. For example, the default <code>SynthDef</code> has a pan position argument, but no envelope parameters. Thus, in the following line, pan will shift the sound toward the left, but atk does nothing:</p>
            <pre>(freq: 625, amp: 0.3, pan: -0.85, atk: 0.5).play;</pre>
            <p>The default <code>SynthDef</code> is rarely used for anything beyond simple demonstrations. In the following excerpt an Event creates a Synth using a SynthDef adapted from other code.</p>
            <h5>Using an Event to play a sound using a custom SynthDef. On creation, key-value pairs in the Event are supplied as Synth arguments</h5>
            <pre>(
  SynthDef(\bpf_brown, {
    arg atk = 0.02, rel = 2, freq = 800,
      rq = 0.005, pan = 0, amp = 1, out = 0;
    var sig, env;
    env = Env([0, 1, 0], [atk, rel], [1, -2]).kr(2);
    sig = BrownNoise.ar(0.8);
    sig = BPF.ar(sig, freq, rq, 1 / rq.sqrt);
    sig = Pan2.ar(sig, pan, amp) * env;
    Out.ar(out, sig);
  }).add;
)
(instrument: \bpf_brown, freq: 500, atk: 2, rel: 4, amp: 0.6).play;</pre>
            <p>A few additional details about internal Event mechanisms are worth discussing. Throughout earlier sections, the argument names <code>freq</code> and <code>amp</code> were regularly used to represent the frequency and amplitude of a sound. We can technically name these parameters whatever we like, but these specific names are chosen to take advantage of a flexible system of pitch and volume specification built into the Event paradigm. In addition to specifying amplitude via amp, we can also specify amplitude as a value in decibels, using the db key:</p>
            <pre>(instrument: \bpf_brown, db: -3).play;
(instrument: \bpf_brown, db: -20).play;</pre>
            <p>How is this possible? Despite the fact that db is not one of our SynthDef arguments, the Event knows how to convert and apply this value correctly. We can understand this behavior more clearly by examining some internals of the Event paradigm:</p>
            <pre>Event.parentEvents.default[\db]; // default db value = -20.0
Event.parentEvents.default[\amp].postcs; // -> the function {~db.dbamp}</pre>
            <p>In the absence of user-provided values, the default db value of -20.0 is converted to a normalized amplitude of 0.1. If a db value is provided, that value is converted to an amplitude. If an amp value is directly provided, it <q>intercepts</q> the conversion process, temporarily overwriting the function that performs the conversion, such that the amp value is directly provided to the Synth. It&apos;s important to remember that this flexibility is only available if the SynthDef includes an argument named <q>amp</q> that is used in the conventional sense (as a scalar that controls output level). If, for example, our SynthDef used a variable named <q>vol</q> for amplitude control, then neither amp nor db would have any effect on the sound if provided in the Event, akin to misspelling a SynthDef argument name when creating a Synth. In this case, our only option for level control would be <q>vol,</q> and we would not have access to this two-tier specification structure. To specify level as a decibel value, we would have to perform the conversion ourselves, for example:</p>
            <pre>(vol: -20.dbamp).play;</pre>
            <p>The situation with freq is similar, but with more options. If <q>freq</q> is declared as a SynthDef argument that controls pitch, then four layers of pitch specification become available. These four options are somewhat intertwined, but are roughly expressible as follows:</p>
            <ul>
              <li>1. <q>degree,</q> along with <q>scale</q> and <q>mtranspose,</q> allows modal expression of pitch as a scale degree, with the possibility of modal transposition.</li>
              <li>2. <q>note,</q> along with <q>root,</q> <q>octave,</q> <q>gtranspose,</q> <q>stepsPerOctave,</q> and <q>octaveRatio,</q> allows specification of pitch as a scale degree within an equal-tempered framework, with a customizable octave ratio and arbitrary number of divisions per octave.</li>
              <li>3. <q>midinote,</q> along with <q>ctranspose</q> and <q>harmonic,</q> allows specification of pitch as MIDI note numbers (non-integers are allowed), with the option for chromatic transposition and specification of a harmonic partial above a fundamental.</li>
              <li>4. <q>freq,</q> along with <q>detune,</q> allows specification of a frequency value measured in Hertz, with an optional offset amount added to this value.</li>
            </ul>
            <h5>Use of four different pitch specifications to play middle C, followed by the D immediately above it.</h5>
            <pre>(degree: 0).play;
(degree: 1).play; // modal transposition by scale degree
(note: 0).play;
(note: 2).play; // chromatic transposition by semitones
(midinote: 60).play;
(midinote: 62).play; // MIDI note numbers
(freq: 261.626).play;
(freq: 293.665).play; // Hertz</pre>
            <h5>Flats and Sharps with Scale Degrees</h5>
            <p>The degree key has additional flexibility for specifying pitch. Altering a degree value by ±0.1 produces a transposition by one semitone, akin to notating a sharp or flat symbol on a musical score:</p>
            <pre>(degree: 0).play;
(degree: 0.1).play; // sharp</pre>
            <p>Similarly, <q>s</q> (for sharp) and <q>b</q> (for bemol or flat) can be appended to an integer, which has the same result:</p>
            <pre>(degree: 0).play;
(degree: 0b).play; // flat</pre>
            <p>Again, these pitch options are only available if an argument named <q>freq</q> is declared in the SynthDef and used conventionally. In doing so, pitch information is specifiable at any of these four tiers, and calculations propagate through these tiers from <q>degree</q> to <q>detunedFreq.</q> The functions that perform these calculations can also be examined:</p>
            <pre>Event.parentEvents.default[\degree]; // default = 0
Event.parentEvents.default[\note].postcs;
Event.parentEvents.default[\midinote].postcs;
Event.parentEvents.default[\freq].postcs;
Event.parentEvents.default[\detunedFreq].postcs;</pre>
            <p>Lastly, we shall demonstrate an interesting feature of Events. If a SynthDef includes a gated envelope, we must manually close the gate when creating a Synth, but the gate closes automatically when playing an Event.</p>
            <pre>(
  SynthDef(\bpf_brown, {
    arg atk = 0.02, rel = 2, gate = 1, freq = 800,
      rq = 0.005, pan = 0, amp = 1, out = 0;
    var sig, env;
    env = Env.asr(atk, 1, rel).kr(2, gate);
    sig = BrownNoise.ar(0.8);
    sig = BPF.ar(sig, freq, rq, 1 / rq.sqrt);
    sig = Pan2.ar(sig, pan, amp) * env;
    Out.ar(out, sig);
  }).add;
)
x = Synth(\bpf_brown, [freq: 500, amp: 0.2]);
x.set(\gate, 0); // manual gate closure
(instrument: \bpf_brown, freq: 500, amp: 0.2).play; // automatic gate closure</pre>
            <p>The default note Event includes a sustain key, which represents a duration after which a (\gate, 0) message is automatically sent to the Synth. The sustain value is measured in beats, the duration of which is determined by the clock on which the Event is scheduled (if no clock is specified, the default TempoClock is used, which runs at 60 bpm). This mechanism assumes the SynthDef has an argument named <q>gate,</q> used to release some sort of envelope with a terminating doneAction. If this argument has a different name or is used for another purpose, the Synth will become stuck in an <q>on</q> state, probably requiring <kbd>[cmd]+[period]</kbd>. The backend of the Event paradigm is complex, and perplexing situations (e.g., stuck notes) may arise from time to time.</p>
            <p><!--The Companion Code that follows the next section attempts to demystify common pitfalls. -->Although the Event paradigm runs deeper than discussed here, this general introduction should be enough to help you get started with Event sequencing using the primary Event pattern, Pbind. For readers seeking more detailed information on Event features and behaviors, the Event help file provides additional information, particularly in a section titled <cite>Useful keys for notes</cite>. Relatedly, the code below can be evaluated to print a list of keys that are built into the Event paradigm.</p>
            <pre>(
  Event.partialEvents.keys.do({ |n|
    n.postln;
    Event.partialEvents[n].keys.postln;
    \.postln;
  });\
)</pre>
            <h5>Event Sequences with Pbind</h5>
            <p>Pbind combines value patterns with Events, establishing a high-level framework for expressing musical sequences. A Pbind contains a list of pairs, each of which consists of an Event key and value pattern. When a stream is generated from a Pbind, and asked to perform its output, the result is a sequence of Events. Each Event contains keys from the Pbind, and each key is paired with the next value defined by its corresponding value pattern. This behavior of <q>binding</q> values to keys is what gives Pbind its name. The code below provides an example. To perform the Events, we convert the pattern to a stream, call <code>next</code> to yield an Event, and play it to generate a Synth. The only difference between this example and the stream examples from previous sections is that here, we must provide an empty starting Event to be populated (hence the additional set of parentheses inside of <code>next</code>).</p>
            <pre>(
  p = Pbind(
    \midinote, Pseq([55, 57, 60], 2),
    \db, Pwhite(-20.0, -10.0, 6),
    \pan, Prand([-0.5, 0, 0.5], 6)
  );
)
~seq = p.asStream;
~seq.next(()).play; // evaluate repeatedly, returns nil when finished
~seq.reset; // can be reset at any time</pre>
            <p>In the foregoing code, each internal value pattern specifies exactly six values, so the stream produces six Events. Because the Pbind does not specify otherwise, the created Events are note-type Events that use the default SynthDef. The <q>midinote</q> and <q>db</q> keys undergo internal calculations to yield <q>freq</q> and <q>amp</q> values, which are supplied to each Synth.</p>
            <p>Manually extracting and playing Events one-by-one is rarely done, intended here as only an illustrative example. More commonly, we play a Pbind, which returns an EventStreamPlayer, a type of stream that performs an Event sequence. As demonstrated next, an EventStreamPlayer works by automating the Event extraction process, and scheduling the Events to be played on a clock, using the default TempoClock if unspecified, thus generating a timed musical sequence.</p>
            <pre>(
  p = Pbind(
    \midinote, Pseq([55, 57, 60], 2),
    \db, Pwhite(-20.0, -10.0, 6),
    \pan, Prand([-0.5, 0, 0.5], 6)
  );
  ~seq = p.play;
)</pre>
            <h5>Debugging Pattern Values</h5>
            <p>Visualizing a Pbind&apos;s output can be helpful for debugging code that doesn&apos;t work properly, and also for understanding pattern behavior in general. postln does not work in this context. Instead, trace can be applied to any pattern, which prints its output to the post window as a stream performs it:</p>
            <pre>(
  p = Pbind(
    \midinote, Pseq([55, 57, 60], 2).trace,
  );
  ~seq = p.play;
)</pre>
            <p>The onset of each Synth occurs one second after the preceding onset. But where does this timing information originate? Timing information is typically provided using the dur key, which specifies a duration in beats and has a default value of one:</p>
            <pre>Event.partialEvents.durEvent[\dur]; // -&gt; 1.0</pre>
            <p>We can provide our own timing information, which may be a value pattern, as shown below:</p>
            <pre>(
  p = Pbind(
    \dur, Pseq([0.75, 0.25, 0.75, 0.25, 0.5, 0.5], 1),
    \midinote, Pseq([55, 57, 60], 2),
    \db, Pwhite(-20.0, -10.0, 6),
    \pan, Prand([-0.5, 0, 0.5], 6)
  );
  ~seq = p.play;
)</pre>

            <p>Pbind can specify an infinite-length Event stream. If each internal value pattern is infinite, the Event stream will also be infinite. If at least one internal value pattern is finite, the length of the Event stream will be equal to the length of the shortest value pattern. If an ordinary number is provided for one of Pbind&apos;s keys, it will be interpreted as an infinite-length value stream that repeatedly outputs that number. An EventStreamPlayer can be stopped at any time with <code>stop</code>. Unlike routines, a stopped EventStreamPlayer can be resumed with <code>resume</code>, causing it to continue from where it left off. The following code demonstrates these concepts: the midinote pattern is the only finite value pattern, which produces 24 values and thus determines the length of the Event stream. The db value −15 is interpreted as an infinite stream that repeatedly yields −15.</p>
            <pre>(
  p = Pbind(
    \dur, Pseq([0.75, 0.25, 0.75, 0.25, 0.5, 0.5], inf),
    \midinote, Pseq([55, 57, 60], 8),
    \db, -15
  );
  ~seq = p.play;
)
~seq.stop;
~seq.resume;</pre>
            <p>In a Pbind, only values or value patterns should be paired with Event keys. It may be tempting to use a method like rrand to generate random values for a key. However, this will result in a random value being generated once when the Pbind is created and used for every Event in the output stream, as demonstrated next, whereas the correct approach is to use the pattern or pattern combination that represents the desired behavior (in this case, Pwhite).</p>
            <h5>An incorrect approach for creating randomness in an Event stream.</h5>
            <pre>(
  p = Pbind(
    \dur, 0.2,
    \midinote, rrand(50, 90), // &lt;- should use Pwhite(50, 90) instead
  );
  ~seq = p.play;
)</pre>
            <p>Recalling techniques already introduced, an EventStreamPlayer can be scheduled on a specific TempoClock and quantized to a particular beat:</p>
            <h5>Rhythmically quantizing two EventStreamPlayers on a custom TempoClock</h5>
            <pre>(
  t = TempoClock(90/60);
  p = Pbind(
    \dur, 0.25,
    \midinote, Pwhite(48, 60, inf),
  );
  q = Pbind(
    \dur, 0.25,
    \midinote, Pwhite(72, 84, inf),
  );
)
~seq_p = p.play(t, quant:4); // scheduled on next beat multiple of 4
~seq_q = q.play(t, quant:4); // synchronizes with ~seq_p</pre>
            <p>Combined with a general understanding of Events, patterns, and streams, Pbind unlocks an endless supply of ideas for musical sequences.</p>
          </section>
        </section>

        <section>
          <h3>Additional Techniques for Pattern Composition</h3>
          <p>As you explore musical sequences, you&apos;ll inevitably find yourself wanting to build larger ideas from smaller, individual patterns. This section covers a few relevant features of patterns, aiming to facilitate expression of more complex sequences.</p>

          <h4>The Rest Event</h4>
          <p>There are many types of pre-made Events, but so far, we&apos;ve only been using note Events. In some cases, the note Event by itself is insufficient and awkward. Consider, for example, a musical phrase which begins with a rest. How should we represent this phrase with patterns?</p>
          <pre>t = TempoClock.new(112/60);
(
  Pbind(
    \dur, Pseq([1/2, 1/2, 1/2, 1/4, 1/2, 1/2, 1/2], 1),
    \sustain, 0.1,
    \degree, Pseq([4, 5, 7, 4, 5, 7, 8], 1),
  ).play(t);
)</pre>
          <p>This code is a poor choice, because it treats the phrase as if it begins on its first eighth note. Rhythmic misalignment would likely occur if we tried to quantize this pattern. A better approach involves using rest Events. A rest Event does exactly what its name suggests: when played, it does nothing for a specific number of beats. Event types are specified using the type key, and providing the type name as a symbol. A two-beat rest Event, for example, looks like this:</p>
          <pre>(type: \rest, dur: 2).play;</pre>
          <p>To employ rests in an Event sequence, we can embed instances of the Rest class in a Pbind&apos;s dur pattern. Each rest is given a duration, measured in beats:</p>
          <pre>t = TempoClock.new(112/60);
(
  Pbind(
    \dur, Pseq([
      Pseq([Rest(1/4), 1/4], 4), // bar 1
      Pseq([1/4, Rest(1/4), 1/4, Rest(1/4), 1/4, Rest(3/4)]) // bar 2
    ], 1),
    \sustain, 0.1,
    \degree, Pseq([
      0, 4, 0, 5, 0, 7, 0, 4, // bar 1
      5, 0, 7, 0, 8, 0, 0, 0 // bar 2
      ], 1),
  ).play(t);
)</pre>
          <p>When this code is quantized, the true downbeat of the phrase occurs on the target beat. Note that the pitch values nicely resemble the metric layout of the notated pitches. The pitch values that align with rest Events are ultimately meaningless since they do not sound. Zeroes are used for visual clarity, but any value is fine.</p>
          <p>Other options exist for expressing a sequential mix of notes and rests. Rest Events can be generated by using a pattern to determine type values. This approach lets us use a constant dur value equal to the smallest beat subdivision necessary to express the rhythm, and the type pattern handles the determination of Event type (<i>see</i> next). Another option involves supplying symbols for a pitch-related pattern (such as degree, note, midinote, or freq). If the pitch value of a note Event is a symbol, the Event becomes a rest Event. The simplest option is to use the empty symbol, expressed as a single backslash (<i>see</i> example after next).</p>
          <h5>Pattern manipulation of the type key to express a musical phrase</h5>
          <pre>t = TempoClock.new(112/60);
(
  Pbind(
    \type, Pseq([
      Pseq([\rest, \note], 4), // bar 1
      Pseq([\note, \rest], 2), \note, Pseq([\rest], 3) // bar 2
    ], 1),
    \dur, 1/4,
    \sustain, 0.1,
    \degree, Pseq([
      0, 4, 0, 5, 0, 7, 0, 4, // bar 1
      5, 0, 7, 0, 8, 0, 0, 0 // bar 2
    ], 1),
  ).play(t);
)</pre>
          <h5>Using symbols in a pitch pattern to express the same musical phrase</h5>
          <pre>t = TempoClock.new(112/60);
(
  Pbind(
    \dur, 1/4,
    \sustain, 0.1,
    \degree, Pseq([
      \, 4, \, 5, \, 7, \, 4, // bar 1
      5, \, 7, \, 8, \, \, \ // bar 2
    ], 1),
  ).play(t);
)</pre>
          <p>Though it&apos;s possible to achieve a similar result by strategically providing zeroes in an amplitude pattern, this is less efficient. In this case, every Event will produce a Synth, and every Synth consumes some processing power, regardless of its amplitude.</p>

          <h4>Limiting Pattern Output with Pfin/Pfindur</h4>
          <p>It&apos;s sometimes convenient to define an infinite length pattern but specify a finite output at performance time, therefore avoiding the need to manually stop the stream. The example below shows the use of <code>Pfin</code> to limit the number of values a pattern will output. <code>Pfindur</code> is similar, but instead of constraining based on Event quantity, <code>Pfindur</code> limits a stream based on the number of beats that have elapsed, shown after next. The duration of one beat is, as usual, governed by the clock on which the stream plays.</p>
          <h5>Using Pfin to limit the output of an Event stream to 16 Events</h5>
          <pre>(
  p = Pbind(
    \dur, 1/8,
    \sustain, 0.02,
    \freq, Pexprand(200, 4000, inf),
  );
  q = Pfin(16, p);
  ~seq = q.play; // stops after 16 events
)</pre>
          <h5>Using Pfindur to limit the output of an Event stream to three beats.</h5>
          <pre>(
  p = Pbind(
    \dur, 1/8,
    \sustain, 0.02,
    \freq, Pexprand(200, 4000, inf),
  );
q = Pfindur(3, p);
~seq = q.play; // stops after 3 beats
)</pre>
          <p>Pfin and Pfindur are helpful in allowing us to focus on the finer musical details of a pattern during the compositional process, working in an infinite mindset and not concerning ourselves with total duration. When the sound is just right, we can simply wrap the pattern in one of these limiters to constrain its lifespan as needed.</p>
          <h5>Composite Patterns with Pseq/Ppar/Ptpar</h5>
          <p>Once you have several Pbinds that represent musical phrases, a logical next step involves combining them into composite structures that represent longer musical phrases, large-scale sections, and perhaps eventually, an entire musical composition. Consider the code below, which represents a four-note sequence, and this same sequence shifted up by two scale degrees:</p>
          <pre>(
  ~p0 = Pbind(
    \dur, 1/6,
    \degree, Pseq([0, 2, 3, 5], 1),
    \sustain, 0.02,
  );
  ~p1 = Pbind(
    \dur, 1/6,
    \degree, Pseq([2, 4, 5, 7], 1),
    \sustain, 0.02,
  );
)</pre>
          <p>Suppose we wanted to play these phrases twice in sequence, for a total of four phrases. Pseq provides an elegant solution, shown next, which demonstrates its ability to sequence Events, and not just numerical values. A composite pattern need not be deterministic; any value pattern that retrieves items from an array can be used for this purpose. If <code>Prand([~p0, ~p1], 4)</code> is substituted for <code>Pseq</code>, for example, the Event stream will play four phrases, randomly chosen from these two.</p>
          <pre>(
  ~p_seq = Pseq([~p0, ~p1], 2);
  ~player = ~p_seq.play;
)</pre>
          <p>To play these two phrases, we could simply enclose <code>~p0.play</code> and <code>~p1.play</code> in the same block and evaluate them with one keystroke, but this approach only sounds the patterns together—it does not express these two patterns as a singular unit. <code>Ppar</code> (<i>see</i> below) is a better option, which takes an array of several Event patterns, and returns one Event pattern in which the individual patterns are essentially superimposed into a single sequence. Like Pseq, Ppar also accepts a repeats value. Ptpar is similar (<i>see</i> example afterwards) but allows us to specify a timing offset for each individual pattern used to compose the parallel composite pattern.</p>
          <h5>Use of Ppar to play Event patterns in parallel. This example relies on the two patterns previously created</h5>
          <pre>(
  ~p_par = Ppar([~p0, ~p1], 3);
  ~seq = ~p_par.play;
)</pre>
          <h5>Use of Ptpar to play Event patterns in parallel with individual timing offsets. The second pattern begins one-twelfth of a beat after the first. This example relies on the two patterns already created</h5>
          <pre>(
  p = Ptpar([
    0, Pseq([~p1], 3),
    1/12, Pseq([~p0], 3)
    ], 1);
  ~seq = p.play;
)</pre>
          <p>As you may be able to guess from the previous examples, the composite patterns returned by Pseq, Ppar, and Ptpar retain the ability to be further sequenced into even larger composite patterns. In some cases, the final performance structure of a composition involves a parent Pseq, which contains Pseq/Ppar patterns that represent large-scale sections, which contain Pseq/Ppar patterns that represent sub-sections, and so forth, all the way down to note-level details. <!--Companion Code 5.3 focuses on an example of how such a project might take shape. -->The central idea is that patterns should be treated as modular building blocks, which can be freely combined and may represent all sequential aspects of a composition. Conceptualizing time-based structures within the pattern framework provides great flexibility, allowing complex sequential ideas to be expressed and performed relatively easily.</p>

          <h4>Real-Time Pattern Control</h4>
          <p>Real-time control is an essential feature for performing electronic music. We&apos;ve seen a simple example in previous sections: a Synth argument can be <q>set</q> while it is running, which can influence its sound and behavior. It&apos;s also possible to manipulate characteristics of an <code>EventStreamPlayer</code> while it&apos;s playing, by swapping out one value pattern for another. This ability mostly relies on a handful of pattern objects that revolve around the concept of proxies. In SC, a <dfn>proxy</dfn> is a placeholder that references a piece of data we want to be able to change dynamically. Proxies enable fluid musical transitions and allow us to make spontaneous decisions on-the-fly, helping us avoid the need to prepare extensive sequential structures in advance.</p>
          <p>The <code>PatternProxy</code> class provides core functionality for real-time pattern control, but in practice, we typically use one of its subclasses, such as <code>Pdefn</code>, <code>Pdef</code>, or <code>Pbindef</code>. These classes are part of a larger <q>def-type</q> family that includes <code>Ndef</code>, <code>Tdef</code>, <code>MIDIdef</code>, <code>OSCdef</code>, and others. These proxies share a common syntax by which they are created and referenced. On creation, a def-type object includes a name (provided as a symbol), followed by its data. The data can be dynamically overwritten and can be referenced by name. Next a pseudo-code example is provided. Proxies are the core element of live coding in SC<!--, more fully explored in Chapter 12-->.</p>
          <pre>ThingDef(\name, data); // create proxy and provide initial data
ThingDef(\name, newData); // overwrite proxy with new data
ThingDef(\name); // reference current proxy data</pre>

          <h5>Pdefn</h5>
          <p>Pdefn serves as a proxy for a single value pattern, deployed by wrapping it around the desired pattern. In the example, it serves as a placeholder for the degree pattern. While the EventStreamPlayer ~seq is playing, the pitch information can be dynamically changed by overwriting the proxy data with a new value pattern.</p>
          <pre>(
  p = Pbind(
    \dur, 0.2,
    \sustain, 0.02,
    \degree, Pdefn(\deg0, Pwhite(-4, 8, inf)),
  );
  ~seq = p.play;
)
Pdefn(\deg0, Pseq([0, 2, 3], inf));</pre>
          <p>Note that if an infinite value pattern is replaced with a finite one, the EventStreamPlayer to which that pattern belongs also becomes finite. One practical application of this feature, exemplified below, is to fade out an EventStreamPlayer by replacing its amplitude pattern with one that gradually decreases to silence or near-silence over a finite period of time.</p>
          <pre>(
  p = Pbind(
    \dur, 0.2,
    \sustain, 0.02,
    \degree, Pwhite(-4, 8, inf),
    \db, Pdefn(\db0, -20),
    );
    ~seq = p.play;
)
Pdefn(\db0, Pseries(-20, -1, 40));</pre>
          <p>Multiple Pdefn objects can be independently used and manipulated in the context of one Pbind. In this case, care should be taken to ensure that no two Pdefns share the same name. If they do, one will overwrite the other, much in the same way that an Event cannot contain two different pieces of data at the same key. It&apos;s also possible to deploy one Pdefn in several different places. A change to a Pdefn propagates through all its implementations, as demonstrated below.</p>
          <pre>(
  Pdefn(\deg0, Pseq([0, 4, 1, 5], inf));
  p = Pbind(
    \dur, 0.2,
    \sustain, 0.02,
    \degree, Pdefn(\deg0),
  );
  q = Pbind(
    \dur, 0.2,
    \sustain, 0.02,
    \degree, Pdefn(\deg0) + 2,
  );
  ~seq = Ppar([p, q]).play;
)
Pdefn(\deg0, Pseq([-3, -2, 0],inf));</pre>

          <p>Pdefn can be quantized using techniques similar to those previously discussed, but the syntax is slightly different, demonstrated beñpw. Instead of specifying quant as an argument, each Pdefn has its own <q>quant</q> attribute, accessible by applying the quant method to the Pdefn and setting a desired value.</p>
          <pre>(
  t = TempoClock(128/60);
  p = Pbind(
    \dur, 1/4,
    \sustain, 0.02,
    \note, Pdefn(\note0, Pseq([0, \, \, \, 1, 2, 3, 4], inf)),
  );
  ~seq = p.play(t, quant: 4);
)
(
  Pdefn(\note0,
    Pseq([7, \, 4, \, 1, \, \, \], inf)
  ).quant_(4);
)</pre>
          <p>Pdefn <q>remembers</q> its quantization value, so it&apos;s unnecessary (but harmless) to re-specify this information for subsequent Pdefn changes meant to adhere to the same value. We can nullify a quant value by setting it to <code>nil</code>.</p>
          <p>The example below shows a few additional techniques. Pdefn&apos;s data can be queried with <code>source</code> (optionally appending <code>postcs</code> for verbosity), and a <code>Pdefn</code>&apos;s data can be erased with <code>clear</code>. We can also iterate over all <code>Pdefn</code> objects to erase each one.</p>
          <pre>Pdefn(\note0).source; // -> a Pseq
Pdefn(\note0).source.postcs; // -> full Pseq code
Pdefn(\note0).clear; // erase Pdefn data
Pdefn(\note0).source; // -> nil
Pdefn.all.do({ |n| n.clear });</pre>

          <h5>Pdef</h5>
          <p>Pdef, demonstrated below, is similar to Pdefn, and features many of the same techniques. The primary difference is that Pdef is a proxy for an Event pattern, rather than a value pattern. Typically, the data of a Pdef is a Pbind, but may also be a Pseq or Ppar that represents a composite of several Pbinds. When an Event pattern is encapsulated within a Pdef, any part of it can be changed while the Pdef is playing, without interruption of the Event stream. Pdef is generally useful in that it avoids the need to create multiple, independent Pdefns within a Pbind.</p>
          <pre>(
  t = TempoClock(128/60);
  Pdef(\seq,
    Pbind(
      \dur, 0.25,
      \sustain, 0.02,
      \degree, Pseq([0, 2, 4, 5], inf),
    )
  ).clock_(t).quant_(4);
  Pdef(\seq).play;
)
(
  Pdef(\seq, // swap the old Pbind for a new one
    Pbind(
      \dur, Pseq([0.5, 0.25, 0.25, 0.5, 0.5], inf),
      \sustain, 0.5,
      \degree, Pxrand([-4, -2, 0, 2, 3], inf),
    )
  );
)</pre>
          <p>In the foregoing code, note that we set clock and quant attributes for the Pdef before playing it, which are retained and remembered whenever the Pdef&apos;s source changes. All the Pdefn methods shown are valid for Pdef as well.</p>

          <h5>Pbindef</h5>
          <p>Pbindef is nearly the same as Pdef; it&apos;s a proxy for Event patterns, and it retains all the same methods and attributes of Pdef (in fact, Pbindef is a subclass of Pdef). These two classes even share the same namespace in which their data is stored, in other words, <code>Pdef(\x)</code> and <code>Pbindef(\x)</code> refer to the same object. The difference between these two classes is that Pbindef allows key-value pairs in its Event pattern to be modified on an individual basis, instead of requiring the entire <code>Pbind</code> source code to be present when a change is applied. Instead of placing a Pbind inside a proxy pattern, the syntax of a Pbindef involves <q>merging</q> Pdef and Pbind into a single entity, much in the same way that their names form a portmanteau. The example below demonstrates various features of Pbindef, including changing one or more value-patterns in real-time, adding new value patterns, and substituting a finite value pattern to create a fade-out. Although this example does not use the quant and clock attributes, they can be applied to Pbindef using the same techniques that appeared before.</p>
          <pre>(
  Pbindef(\seqA,
    \dur, Pexprand(0.05, 2, inf),
    \degree, Prand([0, 1, 2, 4, 5], inf),
    \mtranspose, Prand([-7, 0, 7], inf),
    \sustain, 4,
    \amp, Pexprand(0.02, 0.1, inf),
  ).play;
)
// change degree pattern:
Pbindef(\seqA, \degree, Prand([0, 1, 3.1, 4.1, 5], inf));
// change dur and sustain pattern in one expression:
Pbindef(\seqA, \dur, 0.3, \sustain, Pseq([2, 0.02], inf));
// add a new value pattern:
Pbindef(\seqA, \pan, Pwhite(-0.8, 0.8, inf));
// fade out with finite amp pattern:
Pbindef(\seqA, \amp, Pgeom(0.05, 0.85, 30));</pre>
          <p>In the code above, a finite Pgeom modifies the Event stream so that it ends after 30 Events. However, it&apos;s possible to restart the stream by playing the Pbindef again. In this case, it remembers its key-value pairs, and will generate another thirty Events with the same decreasing amp pattern. Of course, we can replace the amplitude pattern with an infinite value pattern before restarting playback, and the Event stream will continue indefinitely once more. The semi-permanence of Pbindef&apos;s key-value pairs can be a source of confusion, particularly if switching between different pitch or amplitude tiers. Consider the Pbindef in the code below. It begins with explicit freq values, which override internal calculations that propagate upward from degree values. As a result, if we try to dynamically switch from frequency to degrees, the degree values will have no effect, because the Pbindef <q>remembers</q> the original frequency values. Thus, if we want to switch to specifying pitch in degrees, we also need to set the old frequency pattern to <code>nil</code>.</p>
          <pre>(
  Pbindef(\seqB,
    \dur, 0.2,
    \sustain, 0.02,
    \freq, Pexprand(500, 1200, inf)
  ).play;
)
// degree values are ignored:
Pbindef(\seqB, \degree, Pwhite(0, 7, inf));
// degree values take effect
Pbindef(\seqB, \freq, nil, \degree, Pwhite(0, 7, inf));</pre>
        </section>

      </section>  <!-- end of "Sequencing" -->


      <!--
      <section>
        <h2></h2>
          <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <h3 class="bridgehead"></h3>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <h3 class="bridgehead"></h3>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
      </section>
      -->


    </main>

  </body>

</html>
