<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>STL Containers</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a href="cpp.stl.html">C++ Standad Template Library (STL)</a></p>
      -->
      <div>
        <p> <a            href="cpp.templates.html">C++ Generics (Templates)</a> </p>
        <p> <a            href="cpp.iterators.html">Iterators: Pointers for STL Containers</a> </p>
        <p> <a rel="prev" href="cpp.stl.html">The C++ Standard Template Library</a> </p>
        <p> <a            href="cpp.function-object.html">C++ Function Objects</a></p>
        <p> <a            href="cpp.stl.emplacing.html">STL Emplacing</a></p>
        <p> <a            href="cpp.html">The C++ Programming Language</a> </p>
      </div>
      <div>
        <p> <a href="cpp.generics.concepts.html">C++ Concepts in Generic Programming</a> </p>
        <p> <a href="cpp.exceptions.html">C++ Exceptions</a> </p>
        <p> <a href="cpp.classes.html">OOP in C++: Classes</a> </p>
        <p> <a href="cpp.type_traits.html">Handling Type with <code>&lt;type_traits&gt;</code></a> </p>
      </div>
    </nav>
    <main>
      <h1>The C++ Standad Template Library (STL) Containers</h1>
      <p><dfn>Containers</dfn> implement Abstract Data Types such as arrays, queues, linked lists, and so on. They are classified into:</p>
      <ol>
        <li><a target="_blank" href="cpp.sequence-containers.html">Sequence containers</a>, such as <code>vector</code>&apos;s (1-dimensional arrays), <code><code>deque</code></code>&apos;s (double ended queues), <code>list</code>&apos;s (doubly linked lists), and so on. They provide access to sequences of elements.</li>
        <li><a target="_blank" href="cpp.associative-containers.html">Associative containers</a>: <code>std::set</code>, <code>std::multiset</code><code>std::map</code> and <code>std::multimap</code>. <code>std::map</code> and <code>std::multimap</code> provide lookup based on a key.</li>
      </ol>
      <aside>STL containers acquire elements by copy, therefore they take <em>const</em> references.</aside>
      <p>Each container has its own advantages and disadvantages. Some aspects are:</p>
      <ol>
        <li>ease of insertion and deletion not at the back: lists perform best, whereas <code>std::vector</code>&apos;s perform worst</li>
        <li>access by index: only array-like containers (<code>std::vector</code>, <code>std::deque</code>, <code>std::array</code>) support it</li>
      </ol>
      <section>
        <h2>Not-Quite Containers</h2>
        <p>In addition, the standard library provides types of objects that hold elements while not offering all of the facilities of sequence containers or associative containers:</p>
        <ol>
          <li><a href="#container_adaptors">Container adaptors</a> provide specialized access to underlying containers. They are</li>
          <ol>
            <li>
              <a href="#stack">stack</a>
            </li>
            <li>
              <a href="#queue">queue</a>
            </li>
            <li>
              <a href="#prority_queue">prority queue</a>
            </li>
          </ol>
          <li>
            <a href="#bitmap">bitmaps</a>
          </li>
          <li>
            <!--<a href="#valarray">valarrays</a>-->
            valarrays
          </li>
        </ol>
      </section>

      <section>
        <h2>The (Mostly) Common Containers Interface</h2>
        <p>Each container class makes some type definitions of integer types (size and index types etc), and pointer, iterator and reference types. Some common ones are:</p>
        <ol>
          <li><code>size_type</code>: Some integral type roughly equivalent to size_t.</li>
          <li><code>difference_type</code>: Can represent the difference between two addresses.</li>
          <li><code>value_type</code>: The same type as the type of the values stored in a container object (i.e., the same as <code>T</code> for sequential containers and container adaptors, but <code>pair&lt;const KType, VType&gt;</code> for stl::map and stl::multimap.</li>
          <li><code>reference</code> (<code>const_reference</code>): A (constant) reference to an element.</li>
          <li><code>pointer</code> (<code>const_pointer</code>): A (constant) pointer to a component of a (first-class) container object (i.e., same as <kbd>T*</kbd>, where <kbd>T</kbd> is the component type of the container object).</li>
          <li><code>iterator</code>: An iterator.</li>
          <li><code>const_iterator</code>: A const iterator.</li>
          <li><code>reverse_iterator</code>: A reverse iterator.</li>
          <li><code>const_reverse_iterator</code>: A const reverse iterator.        </li>
          <li><code>allocator_type</code>: The type of the allocator used for the container class (Allocators are the most infrequently used feature of the STL by the average C++ programmer. It is almost always OK to go with the default allocator for whatever container you are using.)</li>
        </ol>
        <p>Additionally, container adaptors <code>stack</code>, <code>queue</code>, and <code>priority_queue</code> define <code>container_type</code>. The associative containers (<code>set</code>, <code>multiset</code>, <code>map</code>, and <code>multimap</code>) define <code>key_type</code> and <code>key_compare</code>. Only <code>map</code> and <code>multimap</code> define <code>mapped_type</code>, whereas <code>set</code> and <code>multiset</code> define <code>value_compare</code>.</p>
        <p>Elements held in containers are meant to be accessed sequentally through <a target="_blank" href="cpp.iterators.html">iterators</a>, which are generalizations of pointers and support as much iterator arithmetic as makes sense. Each container defines functions producing an iterators pointing to the first element and to the element past the last one:</p>
        <ol>
          <li><code class="function">begin()</code> and <code class="function">rbegin()</code> produce an iterator to the first element and a reverse iterator to the last element, and</li>
          <li>
            <p><code class="function">end()</code> and <code class="function">rend()</code> produce an iterator to a would-be element past the last one or a reverse iterator to another before the first one. They are meant to be used like this in <kbd>for</kbd> loops and such:</p>
            <pre>for(iterator it = begin(); it != end(); ++it) {
  // body of the for-loop
}</pre>
          </li>
        </ol>
        <p>Other members commonly found in STL containers are:</p>
        <ol>
          <li>default, copy and range constructors (<code class="function"><replaceable>container</replaceable>(iterator beg, iterator past_end)</code>);</li>
          <li><code class="function">void clear()</code> and bool <code class="function">empty()</code> for making a container empty or finding if it is empty;</li>
          <li>
            <p><code class="function">insert(...)</code> and <code class="function">erase(...)</code> member functions for inserting an element given an element or range of elements and an iterator to its destination, or a destination iterator and a reference. These are some common prototypes:</p>
            <pre>iterator insert(iterator i, const T &amp;val = T( ));
void insert(iterator i, size_type num, const T &amp; val);
template &lt;class InIter&gt; void insert(iterator i, InIter start, InIter end);</pre>
            <p><strong>Warning:</strong> Random-access insertions and deletions are slow in containers based on C arrays, such as <code>std::vector</code> and <code>std::deque</code>.</p>
          </li>
          <li><code class="function">size()</code> and <code class="function">max_size()</code> return the current number of elements and the maximum number of elements that can be held;</li>
          <li><code>std::vector</code> and <code>std::string</code> provide a <code class="function">capacity()</code> member function that returns how many elements the container can hold before resizing and thereby invalidating references to its members or underlying C-array, which we are not advised to take anyway; we can anticipate this by calling <code class="function">reserve(size_type n=0)</code>, though;</li>
          <li><code class="function">swap(const <code>container_type</code>&amp;)</code> exchanges the container&apos;s elements and those of its parameter, a facility that is used by some algorithms.</li>
        </ol>

        <section>
          <h3>The Iterator Interface</h3>
          <p>STL containers are meant to be handled through <a target="_blank" href="cpp.iterators.html">iterators</a>. For a new, alternative way, <i>see</i> <a target="_blank" href="cpp.range.html">Ranges (C++20)</a>.</p>
          <p>Several <code>typedef</code>&apos;s are provided: <code>iterator</code>, <code>const_iterator</code>, <code>reverse_iterator</code>, <code>const_reverse_iterator</code> and <code>difference_type</code></p>
          <p>Functions returning iterators are provided, too: <code>begin()</code> and <code>end()</code>, their reverse versions <code>rbegin()</code> and <code>rend()</code>, and the constant versions of all preceding four: <code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code> and <code>crend()</code></p>
          <section>
            <h3>Global <code>std::begin(<var>CONT</var>)</code> and <code>std::end(<var>CONT</var>)</code></h3>
            <p>Globals functions <code>std::begin(<var>CONT</var>)</code> and <code>std::end(<var>CONT</var>)</code> return the begin and end interator of their container parameter.</p>
            <p>They are also (partially-)specialized for C-style arrays.</p>
          </section>
        </section>

        <section id="compare">
          <h3>Requirement <code class="interfacename">Compare</code></h3>
          <p>Compare is a set of requirements expected by some of the standard library facilities from the user-provided function object types.</p>
          <p>The return value of the function call operation applied to an object of a type satisfying <code class="interfacename">Compare</code>, when contextually converted to bool, yields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise.</p>
          <p>As with any BinaryPredicate, evaluation of that expression is not allowed to call non-const functions through the dereferenced iterators.</p>
          <p>The associative containers <code>std::set</code>, <code>std::map</code>, <code>std::multiset</code>, and <code>std::multimap</code> as well as <code>std::priority_queue</code> expect a <code class="interfacename">Compare</code> type.</p>
          <p>The following standard library functions or algorithms expect a <code class="interfacename">Compare</code> type, too:</p>
          <dl>
            <!-- <varlistentry> -->
              <dt>sort</dt>
              <dd>
                   sorts a range into ascending order
                   (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>sort</dt>
              <dd>
                   sorts the elements
                   (public member function of std::forward_list&lt;T,Allocator&gt;)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>sort</dt>
              <dd>
                     sorts the elements
                     (public member function of std::list&lt;T,Allocator&gt;)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>stable_sort</dt>
              <dd>
                       sorts a range of elements while preserving order between equal elements
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>partial_sort</dt>
              <dd>
                       sorts the first N elements of a range
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>partial_sort_copy</dt>
              <dd>
                       copies and partially sorts a range of elements
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>is_sorted (C++11)</dt>
              <dd>

                       checks whether a range is sorted into ascending order
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>is_sorted_until (C++11)</dt>
              <dd>
                       finds the largest sorted subrange
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>nth_element</dt>
              <dd>
                       partially sorts the given range making sure that it is partitioned by the given element
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>lower_bound</dt>
              <dd>
                       returns an iterator to the first element not less than the given value
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>upper_bound</dt>
              <dd>
                       returns an iterator to the first element greater than a certain value
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>binary_search</dt>
              <dd>
                       determines if an element exists in a certain range
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>equal_range</dt>
              <dd>
                       returns range of elements matching a specific key
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>merge</dt>
              <dd>
                       merges two sorted ranges
                       (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>merge</dt>
              <dd>
                       merges two sorted lists
                       (public member function of std::forward_list&lt;T,Allocator&gt;)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>merge</dt>
              <dd>
                         merges two sorted lists
                         (public member function of std::list&lt;T,Allocator&gt;)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>inplace_merge</dt>
              <dd>
                           merges two ordered ranges in-place
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>includes</dt>
              <dd>
                           returns true if one set is a subset of another
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>set_difference</dt>
              <dd>
                           computes the difference between two sets
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>set_intersection</dt>
              <dd>
                           computes the intersection of two sets
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>set_symmetric_difference</dt>
              <dd>
                           computes the symmetric difference between two sets
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>set_union</dt>
              <dd>
                           computes the union of two sets
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>push_heap</dt>
              <dd>
                           adds an element to a max heap
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>pop_heap</dt>
              <dd>
                           removes the largest element from a max heap
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>make_heap</dt>
              <dd>
                           creates a max heap out of a range of elements
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>sort_heap</dt>
              <dd>
                           turns a max heap into a range of elements sorted in ascending order
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>is_heap (C++11)</dt>
              <dd>
                           checks if the given range is a max heap
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>is_heap_until (C++11)</dt>
              <dd>
                           finds the largest subrange that is a max heap
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>max</dt>
              <dd>
                           returns the greater of the given values
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>max_element</dt>
              <dd>
                           returns the largest element in a range
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>min</dt>
              <dd>
                           returns the smaller of the given values
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>min_element</dt>
              <dd>
                           returns the smallest element in a range
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>minmax (C++11)</dt>
              <dd>
                           returns the smaller and larger of two elements
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>minmax_element (C++11)</dt>
              <dd>
                           returns the smallest and the largest elements in a range
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>lexicographical_compare</dt>
              <dd>
                           returns true if one range is lexicographically less than another
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>next_permutation</dt>
              <dd>
                           generates the next greater lexicographic permutation of a range of elements
                           (function template)</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>prev_permutation</dt>
              <dd>
                           generates the next smaller lexicographic permutation of a range of elements
                           (function template)</dd>
            <!-- </varlistentry> -->
          </dl>
        </section>

      </section>

      <section id="container_adaptors">
        <h2>Container Adaptors</h2>
        <p>These are based on another, full container and reduce or adapt their capabilities to suite an interface.</p>
        <section id="stack">
          <h3>Stack</h3>
          <p>A <code>stack</code> implements a stack or FILO (First In Last Out) queue and is based on a <code>deque</code> by default, although it might use a <code>vector</code> just as well.</p>
        </section>

        <section id="queue">
          <h3>Queue</h3>
          <p>A <code>queue</code> implements a (First In Last Out) queue and is based on a <code>deque</code> by default, although it might use a <code>vector</code> just as well.</p>
        </section>

        <section id="prority_queue">
          <h3>Prority Queue</h3>
          <p>A <code>prority_queue</code> keeps its elements sorted and produces the smallest element according to some comparison function object. It is otherwise called a <dfn>heap</dfn> and is based on a <code>vector</code> by default because it requires random access and   swapping elements.</p>
          <p>You can write a customized priority queue by availing yourself of the following STL algorithms, which rely on random-access iterators, as found in <code>vector</code> and <code>queue</code>:</p>
          <pre>template &lt;class RandIter&gt;
void make_heap(RandIter start, RandIter end);
template &lt;class RandIter, class Comp&gt;
void make_heap(RandIter start, RandIter end, Comp cmpfn);
//
template &lt;class RandIter&gt;
void push_heap(RandIter start, RandIter end);
template &lt;class RandIter, class Comp&gt;
void push_heap(RandIter start, RandIter end, Comp cmpfn);
//
template &lt;class RandIter&gt;
void pop_heap(RandIter start, RandIter end);
template &lt;class RandIter, class Comp&gt;
void pop_heap(RandIter start, RandIter end, Comp cmpfn);</pre>
          <p>Or you can turn a sequence into a heap all at once by calling:</p>
          <pre>template &lt;class RandIter&gt;
void sort_heap(RandIter start, RandIter end);
template &lt;class RandIter, class Comp&gt;
void sort_heap(RandIter start, RandIter end, Comp cmpfn);</pre>
        </section>

      </section>





      <section id="sequence_containers">
        <h2>Sequence Containers</h2>
        <section id="lists">
          <h3>Lists with <code>std::list</code> and <code>std::forward_list</code></h3>
          <p>A list is a sequence optimized for insertion and deletion of elements. When you insert into a list or delete an element from a list , the locations of other elements of the list are not affected. In particular, iterators referring to other elements are not affected.</p>
          <p>The STL provides two linked-list types:</p>
          <ol>
            <li>list: a doubly-linked list, and</li>
            <li><a href="#forward_list">forward_list</a>: a singly-linked list introduced in recent revisions (C++11)</li>
          </ol>
          <p>These are implemented in container <code>std::list&lt;&gt;</code>.</p>
          <p id="list_shared_members">With the exception of subscripting, capacity management, and <code class="function">size()</code> for <code>forward_list</code>, the STL lists provide the member types and operations offered by <code>vector&lt;&gt;</code>. In addition, <code>list&lt;&gt;</code> and <code>forward_list&lt;&gt;</code> provide specific list member functions:</p>
          <section id="list">
            <h4>Doubly-Linked Lists with <code>std::list</code></h4>
            <table>
              <tbody>
                <tr>
                  <td>st.push_front(x)</td>
                  <td>Add x to lst (using copy or move) before the first element</td>
                </tr>
                <tr>
                  <td><var>lst</var>.pop_front()</td>
                  <td>Remove the first element from lst</td>
                </tr>
                <tr>
                  <td><var>lst</var>.emplace_front(args)</td>
                  <td>Add T{args} to lst before the first element</td>
                </tr>
                <tr>
                  <td><var>lst</var>.remove(v)</td>
                  <td>Remove all elements of lst with value v</td>
                </tr>
                <tr>
                  <td><var>lst</var>.remove_if(f)</td>
                  <td>Remove all elements of lst for which f(x)==true</td>
                </tr>
                <tr>
                  <td><var>lst</var>.unique()</td>
                  <td>Remove adjacent duplicate elements of lst</td>
                </tr>
                <tr>
                  <td><var>lst</var>.unique(f)</td>
                  <td>Remove adjacent duplicate elements of lst using f for equality</td>
                </tr>
                <tr>
                  <td><var>lst</var>.merge(lst2)</td>
                  <td>Merge the ordered lists lst and lst2 using &lt; as the order; lst2 is merged into lst and emptied in the process</td>
                </tr>
                <tr>
                  <td><var>lst</var>.merge(lst2,f)</td>
                  <td>Merge the ordered lists lst and lst2 using f as the order; lst2 is merged into lst and emptied in the process</td>
                </tr>
                <tr>
                  <td><var>lst</var>.sort()</td>
                  <td>Sort lst using &lt; as the order</td>
                </tr>
                <tr>
                  <td><var>lst</var>.sort(f)</td>
                  <td>Sort lst using f as the order</td>
                </tr>
                <tr>
                  <td><var>lst</var>.reverse()</td>
                  <td>Reverse the order of the elements of lst ; noexcept</td>
                </tr>
              </tbody>
            </table>
          </section>
          <section id="forward_list">
            <h4>Singly-Linked Lists with <code>std::forward_list</code>*</h4>
          </section>
        </section>

        <section id="vector">
          <h3>Vectors</h3>
          <p>std::<code>vectors</code> are automatic arrays which keep track of their <dfn>size</dfn>, that is how many places have been occupied (pressumably in an integer variable), as well as their <dfn>capacity</dfn>, which is the total number of objects of the given type that they can accomodate. Further, when they have filled up, they reallocate their sequence of objects in a larger chunk of memory, the start of this run of memory is updated (in a pointer variable), and the new, larger capacity is updated, too. This means that indeces into the array-like structure remain valid, but pointers are invalidated, so they must never be taken in the first place.</p>
          <p>Unlike with linked lists, insertions (or deletions) are either meaningless or demand that all objects after the one inserted be shifted one place, which is done in linear time, whereas lists perform insertions and deletions in constant time. Furthermore, insertions and deletions would invalidate all subsequent indeces...</p>
        </section>

        <section id="deque">
          <h3>Deques</h3>
          <p>A <code>deque</code> (pronounced "deck") is very similar to a vector. It manages its elements with a dynamic array, provides random access, and has almost the same interface as a vector. The difference is that with a <code>deque</code> the dynamic array is open at both ends. Thus, a <code>deque</code> is fast for insertions and deletions at both the end and the beginning.</p>
          <p>Deques have the following differences compared with the abilities of vectors:</p>
          <ol>
            <li>Inserting and removing elements is fast both at the beginning and at the end (for vectors it is only fast at the end). These operations are done in amortized constant time.</li>
            <li>The internal structure has one more indirection to access the elements, so element access and iterator movement of <code>deque</code>&apos;s are usually a bit slower.</li>
            <li>Iterators must be smart pointers of a special type rather than ordinary pointers because they must jump between different blocks.</li>
            <li>In systems that have size limitations for blocks of memory (for example, some PC systems), a <code>deque</code> might contain more elements because it uses more than one block of memory. Thus, max_size() might be larger for <code>deque</code>'s.</li>
            <li>Deques provide no support to control the capacity and the moment of reallocation. In particular, any insertion or deletion of elements other than at the beginning or end invalidates all pointers, references, and iterators that refer to elements of the <code>deque</code>.</li>
            <li>However, reallocation may perform better than for vectors, because according to their typical internal structure, <code>deque</code>&apos;s don&apos;t have to copy all elements on reallocation.</li>
            <li>Blocks of memory might get freed when they are no longer used, so the memory size of a <code>deque</code> might shrink (however, whether and how this happens is implementation specific).</li>
          </ol>
        </section>

        <section id="bitmap">
          <h3>Bitmap's*</h3>
        </section>

      </section>









      <section>
        <h2>Random Access Returning Reference</h2>
        <p>Sequence containers based on an array offer access through indeces. They will declare:</p>
        <pre>reference operator[](size_type idx);
const_reference operator[](size_type idx) const;</pre>
        <p>These are fast but do not perform bound checking. Trying to access beyond the end of the underlying array may, well, crash the program or yield the wrong result. If unsure, use:</p>
        <pre id="bounds_checking_at">      reference at(size_type idx);
const_reference at(size_type idx) const;</pre>
        <p>Member function <code class="function">at(size_type idx)</code> returns a <code>reference</code> or <code>const_reference</code> all right, but will throw an <code>out_of_range</code> exception. Use <code class="function">at(size_type idx)</code> inside a <kbd>try {...}</kbd> block.</p>
        <p>If you write a container in the STL tradition that returns references to elements of an array, write the body of your <code class="function">at(size_type idx)</code> like this:</p>
        <pre>if(idx &gt;= size())
  throw out_of_range("Container::at() used with idx past the end");
else
  return the_array[idx];</pre>
      </section>

      <section>
        <h2>Find and Replace Operations</h2>
        <p>Functions <code class="function">find(...)</code> returns a <kbd>size_type</kbd> variable, actually an integer representing an index to the element found. A <code>string</code>&apos;s <code class="function">find()</code> operation may return <kbd>npos</kbd>, for <q>no position</q>, which should be defined as <inlineequation>-1</inlineequation>.</p>
      </section>

      <section>
        <h2>Some Prototypes for Sequence and Associative Containers</h2>
        <p>This is the prototype of a would-be <code>sequence_container</code> class to derive containers from. There are no private members since this class is used as an interface.</p>
        <pre>template &lt;class T, class Allocator=allocator&lt;T&gt; &gt;
class sequence_container {
public:
  // some type definitions:
  typedef unsigned int size_type;
  typedef T value_type;
  typedef       T *       iterator;
  typedef const T * const_iterator;
  typedef       T &amp;       reference;
  typedef const T &amp; const_reference;
  // this is the type of function that compares two values:
  typedef bool (*) (const T&amp;, const T&amp;) value_compare;
  // some more obscure type definitions:
  typedef       T *       reverse_iterator;
  typedef const T * const_reverse_iterator;
  typedef Allocator allocator_type;
  // some iterator-related member functions:
  iterator       begin();
  const_iterator begin() const;
  iterator       end();
  const_iterator end()   const;
  reverse_iterator       rbegin();
  const_reverse_iterator rbegin() const;
  reverse_iterator       rend();
  const_reverse_iterator rend()   const;
  // some other member functions:
  size_type size() const;
  reference       front();
  const_reference front() const;
  void pop_back();
  void push_back(const T&amp; val);
  void clear();
  bool empty() const;
  allocator_type get_allocator() const;
  // constructors:
  sequence_container(const Allocator &amp;ca = Allocator()));
  sequence_container(size_type num, const T&amp; val = T(), const Allocator &amp;ca = Allocator()));
  sequence_container(const sequence_container&lt;T,Allocator&gt;&amp; obj);
  template &lt;class InIter&gt;
  sequence_container(InIter start, InIter end, const Allocator&amp; ca = Allocator());
};</pre>
      </section>

      <section>
        <h2>Pushing and Emplacing</h2>
        <p>These are two slightly different ways of adding an element to a container such as a <code>std::vector</code>. Whereas <a href="#push">pushing</a> entails copying a value, <a href="#emplace">emplacing</a> causes the value to be constructed in place from some arguments that are passed in.</p>
        <section id="push">
          <h3>Pushing (<code>push_back()</code>)</h3>
          <p>Prototype:</p>
          <pre>
void push_back (const value_type&amp; val);
void push_back (value_type&amp;&amp; val);
          </pre>
        </section>
        <section id="emplace">
          <h3>Emplacing</h3>
          <p>The <code class="function">emplace()</code> operation inserts a new element, which is constructed in place using <var>args</var> as the arguments for its constructor.</p>
          <pre>
template &lt;class... <var>Args</var>&gt;
void emplace_back (Args&amp;&amp;... <var>args</var>);

template &lt;class... <var>Args</var>&gt;
iterator emplace (const_iterator position, Args&amp;&amp;... args);
          </pre>
          <p>Now, the second prototype (<code>iterator emplace (const_iterator position, Args&amp;&amp;... args);</code>) constructs the new element <em>after</em> <var>position</var>.</p>
          <p>Emplacing is used when it is either notationally awkward or potentially inefficient to first create an object and then copy (or move) it into a container, as is the case with <a href="#push">pushing</a>.</p>

          <aside>
            <p>With vectors, which use an array as their underlying storage, inserting elements in positions other than the vector end causes the container to shift all the elements that were after position by one to their new positions. This is generally an inefficient operation compared to the one performed by other kinds of sequence containers (such as <code>std::list</code> or <code>forward_list</code>).</p>
          </aside>

        </section>
      </section>

    </main>
  </body>
</html>
