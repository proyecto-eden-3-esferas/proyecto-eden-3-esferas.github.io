<!DOCTYPE html>
<html>
  <head>
    <title>Multithreading in C++</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Brief Introduction to the (Formidable) C++ Programming Language"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel="next" href="cpp.multithreading.advanced.html">Advanced Multithreading in C++</a></p>
        <p><a rel="prev" href="cpp.html">The C++ Programming Language</a></p>
      </div>
      <div>
        <p><a target="_blank" href="https://www.modernescpp.com/index.php/multithreading-in-modern-c/"><cite>Multithreading in Modern C++</cite>, by Rainer Grimm, 2023</a></p>
        <p><a href="cpp.core-types.html">C++ Core Types</a></p>
        <p><a href="cpp.initialization-of-vars.html">Initialization of Variables in C++</a></p>
        <p><a href="cpp.functions.html">Functions in C++</a></p>
        <p><a href="cpp.exceptions.html">C++ Exceptions</a></p>
        <p><a href="cpp.memory.html">Memory Management in C++</a></p>
        <p><a href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a href="cpp.stl.html">C++ Standard Template Library (STL)</a></p>
      </div>
      <div>
        <p><a href="https://github.com/proyecto-eden-3-esferas/Cpp">Code Examples (Files)</a></p>
        <p><a href="cpp.core-guidelines.html">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup (<em>local</em>)</p>
      </div>
      <div>
        <p><a href="linkage-and-scope.html">Linkage and Scope (focus on C/C++)</a></p>
        <p><a href="cpp.separate_compilation.html">Separate Compilation</a></p>
        <p><a href="cpp.modules.html">C++ Modules</a></p>
        <p><a href="cpp.separate_compilation.templates.html">Separate Compilation of Templates</a></p>
        <p><a href="cpp.linking-c-object-files-in.html">Linking C++ and C Object Files Together</a></p>
        <p><a href="c-and-cpp.html">C and C++</a></p>
      </div>
      <div>
        <p><a href="cpp.cpp20.html">C++20</a></p>
      </div>
      <div>
        <p><a href="cpp.platform-specific.html">Platform-Specific Features in C++</a></p>
        <!--
        <p><a href="cpp.boost.geometry.html.bak">C++ Boost Geomety (<code>.bak</code>)</a></p>
        <p><a href="cpp.boost.graph.html.old">C++ Boost Graph (<code>.old</code>)</a></p>
        -->
      </div>
      <div>
        <p><a            href="computing.html">Computing</a></p>
        <p><a            href="programming.html">Programming Computers</a></p>
        <p><a            href="index.en.html">Home</a></p>
      </div>
    </nav>

    <main>
      <h1>Multithreading in C++</h1>
      <p style="text-align: right">(Partly from <a target="_blank" href="https://www.modernescpp.com/index.php/multithreading-in-modern-c/">https://www.modernescpp.com/index.php/multithreading-in-modern-c/</a>)</p>
      <p>The <a target="_blank" href="cpp.cpp11.html">2011 published standard</a> defines how a C++ program has to behave in the presence of multiple threads. These capabilities are composed of two components:</p>
      <ol>
        <li>the <a target="_blank" href="cpp.multithreading.advanced.html#memory-model">memory model</a>, and</li>
        <li>the standardized <a target="_blank" href="cpp.multithreading.advanced.html#threading-interface">threading interface</a>.</li>
      </ol>
      <hr/>
      <p>The headers supporting atomic and thread are:</p>
      <ul>
        <li>&lt;atomic&gt;</li>
        <li>&lt;thread&gt;</li>
        <li>&lt;mutex&gt;</li>
        <li>&lt;condition_variable&gt;</li>
        <li>&lt;future&gt;</li>
      </ul>

      <section id="thread">
        <h2>Threads as Subprocesses</h2>
        <p style="text-align: right">(Heavily from <a target="_blank" href="https://www.geeksforgeeks.org/cpp/multithreading-in-cpp/">https://www.geeksforgeeks.org/cpp/multithreading-in-cpp/</a>)</p>
        <p>The &lt;thread&gt; header in C++ provides a simple and powerful interface for managing threads. Below are some of the most common operations performed on threads:</p>
        <section>
          <h3>Create a Thread</h3>
          <p>The <code>std::thread</code> class represents the thread. Instantiating an instance of this class will create a thread with the given callable as its task.</p>
          <pre>thread thread_name(<var>callable</var>);</pre>
          <p>where,</p>
          <ul>
            <li><var>thread_name</var> is an object of the <code>thread</code> class, and</li>
            <li><var>callable</var> is a callable object such as a function pointer, function object, or a lambda.</li>
          </ul>
          <p>Example:</p>
          <pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

// Function to be run by the thread
void func() {
  cout &lt;&lt; "Hello from the thread!" &lt;&lt; endl;
}

int main() {

  // Create a thread that runs
  // the function func
  thread t(func);

  // Main thread waits for 't' to finish
  t.<a href="#join">join()</a>;
  cout &lt;&lt; "Main thread finished.";
  return 0;
}</pre>
          <p>Output</p>
          <pre>Hello from the thread!
Main thread finished.</pre>
          <p><strong>Explanation</strong>: In the above program we have created a thread <var>t</var> that prints <q>Hello from the thread!</q> and this thread is <a href="#join">joined</a> with the main thread so that the main thread waits for the completion of this thread. Once the thread <var>t</var> is finished the main thread resumes its execution and prints <q>Main thread finished</q>.</p>
        </section>
        <section id="join">
          <h3>Joining a Thread</h3>
          <p>Before joining a thread it is preferred to check if the thread can be joined using the <code>joinable()</code> method, which checks whether the thread is in a state suitable for joining.</p>
          <pre><var>thread_name</var>.joinable();</pre>
          <p>(The <code>joinable()</code> method returns true if the thread is joinable, else returns false.)</p>
          <hr/>
          <p>Joining two threads in C++ blocks the current thread until the thread associated with the <code>std::thread</code> object finishes execution. To join two threads in C++ we use the <code>join()</code> function, which is called inside the body of the thread to which the specified thread is to be joined.</p>
          <pre><var>thread_name</var>.join();</pre>
          <p>The <code>join()</code> function throws <code>std::system_error</code> if the thread is not joinable.</p>
          <p><strong>Note</strong>: Joining two non-main threads is risky as it may lead to race condition or logic errors.</p>
        </section>
        <section id="detach">
          <h3>Detaching a Thread</h3>
          <p>A joined thread can be detached from the calling thread using the <code>std::thread::detach()</code> member function. When a thread is detached, it runs independently in the background, and the other thread does not waits for it to finish.</p>
          <pre>thread_name.detach();</pre>
        </section>
        <section id="get_id">
          <h3>Getting Thread ID</h3>
          <p>Each thread in C++ has a unique ID which can be obtained by using the <code>get_id()</code> function.</p>
          <pre>thread_name.get_id();</pre>
          <p>The <code>get_id()</code> function returns an object representing the thread&apos;s ID</p>
        </section>
        <section>
          <h3>Example Program Using the Operations Above</h3>
          <pre>#include &lt;iostream>
#include &lt;thread>
#include &lt;chrono>

using namespace std;

void task1() {
    cout &lt;&lt; "Thread 1 is running. ID: " &lt;&lt; this_thread::get_id() &lt;&lt; "\n";
}

void task2() {
    cout &lt;&lt; "Thread 2 is running. ID: " &lt;&lt; this_thread::get_id() &lt;&lt; "\n";
}

int main() {

    thread t1(task1);
    thread t2(task2);

    // Show thread IDs
    cout &lt;&lt; "t1 ID: " &lt;&lt; t1.get_id() &lt;&lt; "\n";
    cout &lt;&lt; "t2 ID: " &lt;&lt; t2.get_id() &lt;&lt; "\n";

    // Join t1 if joinable
    if (t1.joinable()) {
        t1.join();
        cout &lt;&lt; "t1 joined\n";
    }

    // Detach t2
    if (t2.joinable()) {
        t2.detach();
        cout &lt;&lt; "t2 detached\n";
    }

    cout &lt;&lt; "Main thread sleeping for 1 second...\n";
    this_thread::sleep_for(chrono::seconds(1));
    cout &lt;&lt; "Main thread awake.\n";

    return 0;

}</pre>
        </section>
        <section id="this_thread">
          <h3>The <code>std::this_thread</code></h3>
          <p>This namespace groups a set of functions that access the current thread.</p>
          <table>
            <caption>Functions</caption>
            <tr>
              <td><code>thread::id get_id() noexcept;</code></td>
              <td>
                <p>Returns the thread id of the calling thread. This value uniquely identifies the thread.</p>
                <pre>// thread::get_id / this_thread::get_id
#include &lt;iostream&gt;       // std::cout
#include &lt;thread&gt;         // std::thread, std::thread::id, std::this_thread::get_id
#include &lt;chrono&gt;         // std::chrono::seconds

std::thread::id main_thread_id = std::this_thread::get_id();

void is_main_thread() {
  if ( main_thread_id == std::this_thread::get_id() )
    std::cout &lt;&lt; "This is the main thread.\n";
  else
    std::cout &lt;&lt; "This is not the main thread.\n";
}

int main()
{
  is_main_thread();
  std::thread th (is_main_thread);
  th.join();
}</pre>
                <p>Output:</p>
                <pre>This is the main thread.
This is not the main thread.</pre>
              </td> </tr>
            <tr>
              <td><code>void yield() noexcept;</code></td>
              <td>
                <p>Yield to other threads. The calling thread yields, offering the implementation the opportunity to reschedule. This function shall be called when a thread waits for other threads to advance without blocking.</p>
                <pre>// this_thread::yield example
#include &lt;iostream&gt;       // std::cout
#include &lt;thread&gt;         // std::thread, std::this_thread::yield
#include &lt;atomic&gt;         // std::atomic

std::atomic&lt;bool&gt; ready (false);

void count1m(int id) {
  while (!ready) {             // wait until main() sets ready...
    std::this_thread::yield();
  }
  for (volatile int i=0; i&lt;1000000; ++i) {}
  std::cout &lt;&lt; id;
}

int main ()
{
  std::thread threads[10];
  std::cout &lt;&lt; "race of 10 threads that count to 1 million:\n";
  for (int i=0; i&lt;10; ++i) threads[i]=std::thread(count1m,i);
  ready = true;               // go!
  for (auto&amp; th : threads) th.join();
  std::cout &lt;&lt; '\n';

  return 0;
}</pre>
                <p>Possible output (last line may vary):</p>
                <pre>race of 10 threads that count to 1 million...
6189370542</pre>
              </td> </tr>
            <tr>
              <td><code>sleep_until</code></td>
              <td>
                <pre>template &lt;class Clock, class Duration&gt;
void sleep_until (const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);</pre>
                <p>Output (after an avg. of 30 seconds):</p>
                <pre>Current time: 11:52:36
Waiting for the next minute to begin...
11:53:00 reached!</pre>
              </td> </tr>
            <tr>
              <td><code>sleep_for</code></td>
              <td>
                <pre>template &lt;class Rep, class Period&gt;  void sleep_for (const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</pre>
                <p>The execution of the current thread is stopped until at least <var>rel_time</var> has passed from now. Other threads continue their execution.</p>
                <p>Example:</p>
                <pre>// this_thread::sleep_for example
#include &lt;iostream&gt;       // std::cout, std::endl
#include &lt;thread&gt;         // std::this_thread::sleep_for
#include &lt;chrono&gt;         // std::chrono::seconds

int main()
{
  std::cout &lt;&lt; "countdown:\n";
  for (int i=10; i &gt; 0; --i) {
    std::cout &lt;&lt; i &lt;&lt; std::endl;
    std::this_thread::sleep_for (std::chrono::seconds(1));
  }
  std::cout &lt;&lt; "Lift off!\n";

  return 0;
}</pre>
                <p>Output (after 10 seconds):</p>
                <pre>countdown:
10
9
8
7
6
5
4
3
2
1
Lift off!</pre>
              </td> </tr>
          </table>
        </section>
      </section>
      <section>
        <h2>Callables in Multithreading</h2>
        <p>A <strong>callable</strong> (such as a function, lambda, or function object) is passed to a thread. The callable is executed in parallel by the thread when it starts. For instance, <code>thread t(func);</code> creates a thread that runs the <var>func</var> callable.</p>
        <p>Moreover, we can also pass parameters along with callable, like this <code>thread t(func, param1, param2);</code></p>
        <p>There are four categories of Callables in C++:</p>
        <ul>
          <li><a href="#function-call">Function</a></li>
          <li><a href="#lambda-call">Lambda Expression</a></li>
          <li><a href="#function-obj-call">Function Object</a></li>
          <li><a href="#member-function-call">Non-Static or static Member Function</a></li>
        </ul>
        <section id="function-call">
          <h3>Function Pointer</h3>
          <p>A function can be a callable object to pass to the thread constructor for initializing a thread.</p>
          <pre>#include &lt;bits/stdc++.h&gt;

using namespace std;

// Function to be run
// by the thread
void func(int n) {
  cout &lt;&lt; n;
}

int main() {

  // Create a thread that runs
  // the function func:
  thread t(func, 4);

  // Wait for thread to finish
  t.join();

  return 0;

}</pre>
          <p>Output</p>
          <pre>4</pre>
        </section>
        <section id="lambda-call">
          <h3>Lambda Expression</h3>
          <p>A thread object can also be initialized with a lambda expression as a callable. This can be passed directly inside the thread object:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;

int main() {

  int n = 3;

  // Create a thread that runs
  // a lambda expression
  thread t([](int n){
      cout &lt;&lt; n;
  }, n);

  // Wait for the thread to complete
  t.join();

  return 0;

}</pre>
          <p>Output</p>
          <pre>3</pre>
        </section>
        <section id="function-obj-call">
          <h3>Function Objects</h3>
          <p>Function Objects or Functors can also be passed into a thread as a callable. To make functors callable, we need to overload the operator parentheses or <code>operator()</code>.</p>
          <pre>#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;

// Define a function object (functor)
class SumFunctor {
public:
  int n;
  SumFunctor(int a) : n(a) {}

  // Overload the operator() to
  // make it callable
  void operator()() const {
    cout &lt;&lt; n;
  };
};

int main() {

  // Create a thread using
  // the functor object
  thread t(SumFunctor(3));

  // Wait for the thread to
  // complete
  t.join();

  return 0;

}</pre>
          <p>Output</p>
          <pre>3</pre>
        </section>
        <section id="member-function-call">
          <h3>Non-Static and Static Member Function</h3>
          <p>We can also use thread using the non-static or static member functions of a class. For non-static member function, we need to create an object of a class, but this is not necessary with static member functions.</p>
          <pre>#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std;

class MyClass {
public:
  // Non-static member function
  void f1(int num) {
    cout &lt;&lt; num &lt;&lt; endl;
  };​

  // Static member function that takes one parameter
  static void f2(int num) {
      cout &lt;&lt; num;
  };
};

int main() {

  // Member functions
  // requires an object
  MyClass obj;

  // Passing object and parameter
  thread t1(&amp;MyClass::f1, &amp;obj, 3);

  t1.join();

  // Static member function can
  // be called without an object
  thread t2(&amp;MyClass::f2, 7);

  // Wait for the thread to finish
  t2.join();

  return 0;

}</pre>
          <p>Output</p>
          <pre>3
7</pre>
        </section>
      </section>  <!-- end of "Threads as Subprocesses" -->

      <section id="thread-management-funs-and-methods">
        <h2>Thread Management</h2>
        <p>In the C++ thread library, various classes and functions are defined to manage threads that can be used to perform multiple tasks. Some of them are listed below:</p>
        <table border="0">
          <thead>
          <tr> <th>Class/Function</th> <th>Description</th> </tr>
          </thead>
          <tr> <td><code>join()</code></td> <td>It ensures that the calling thread waits for the specified thread to complete its execution.</td> </tr>
          <tr> <td><code>detach()</code></td> <td>Allows the thread to run independently of the main thread, meaning the main thread does not need to wait.</td> </tr>
          <tr> <td><code>mutex</code></td> <td>A mutex is used to protect shared data between threads to prevent data races and ensure <a href="#thread-synchronization">synchronization</a>.</td> </tr>
          <tr> <td><code><a href="#lock_guard">lock_guard</a></code></td> <td>A wrapper for mutexes that automatically locks and unlocks the mutex in a scoped block.</td> </tr>
          <tr> <td><code>condition_variable</code></td> <td>Used to synchronize threads, allowing one thread to wait for a condition before proceeding.</td> </tr>
          <tr> <td><code>atomic</code></td> <td>Manages shared variables between threads in a thread-safe manner without using locks.</td> </tr>
          <tr> <td><code>sleep_for()</code></td> <td>Pauses the execution of the current thread for a specified duration.</td> </tr>
          <tr> <td><code>sleep_until()</code></td> <td>Pauses the execution of the current thread until a specified time point is reached.</td> </tr>
          <tr> <td><code>hardware_concurrency()</code></td> <td>Returns the number of hardware threads available for use, allowing you to optimize the use of system resources.</td> </tr>
          <tr> <td><code>get_id</code></td> <td>Retrieves the unique ID of the current thread, useful for logging or debugging purposes.</td> </tr>
        </table>
        <section id="mutex">
          <h3><code>std::mutex</code>*</h3>
        </section>
        <section id="lock_guard">
          <h3><code>std::lock_guard</code></h3>
          <p><code>lock_guard</code> is a simple class that is used to manage the locking and unlocking of a mutex. Its main purpose is to automatically lock a mutex when it is created and automatically unlock it when the <code>lock_guard</code> object goes out of scope. Following is the syntax to use lock_guard in C++:</p>
          <pre>lock_guard&lt;mutex&gt; name(myMutex);</pre>
          <p>where,</p>
          <ul>
            <li><strong>name:</strong> name assigned to the shared_lock object</li>
            <li><strong>myMutex:</strong> a placeholder for the actual type of the mutex.</li>
          </ul>
          <p>Example. The following program illustrates the use of <code>lock_guard</code> in C++:</p>
          <pre>// C++ Program using std::lock_guard
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
using namespace std;

// Global mutex to protect shared_data
mutex mtx;

// Shared data variable
int shared_data = 0;

// Function to increment shared_data
void increment_data() {
  // Create a lock_guard object which locks the mutex
  lock_guard&lt;mutex&gt; lock(mtx);

  // Critical section: safely modify shared_data
  shared_data+=2;

  // Lock is automatically released when 'lock' goes out of scope
}

int main() {
  // Create two threads that run the increment_data function
  thread t1(increment_data);
  thread t2(increment_data);

  // Wait for both threads to finish
  t1.join();
  t2.join();

  // Output the value of shared_data
  cout &lt;&lt; "Value of shared variable: " &lt;&lt; shared_data;

  return 0;
}</pre>
          <p>Output</p>
          <pre>Value of shared variable: 4</pre>
          <hr/>
          <p>Some key features of <code>unique_lock</code>:</p>
          <ul>
            <li><strong>Simplicity:</strong> lock_guard is very simple to use with minimal overhead.</li>
            <li><strong><a target="_blank" href="cpp.RAII.html">RAII(Resource Acquisition Is Initialization)</a>:</strong> Ensures that mutex is released when the lock_guard goes out of scope.</li>
            <li><strong>No Unlocking:</strong> Does not support manual unlocking before the end of its scope.</li>
          </ul>
          <p>These are the use cases when you should consider using lock_guard:</p>
          <ul>
            <li>When you need simple lock that automatically unlocks when the scope ends. The locking operation is straightforward and does not require unlocking before scope ends.</li>
            <li>You prioritize minimal overhead and simplicity.</li>
          </ul>
        </section>
        <section id="unique_lock">
          <h3><code>std::unique_lock</code></h3>
          <p><code>unique_lock</code> offers more flexibility than <code>lock_guard</code>. It provides features like manual locking and unlocking, deferred locking, and ownership transfer. Unlike <code>lock_guard</code>, which automatically locks and unlocks the mutex, <code>unique_lock</code> requires explicit calls to lock and unlock.</p>
          <p>The following is the syntax to use unique_lock in C++:</p>
          <pre>shared_lock&lt;mutex&gt; <var>Name</var>(
  <var>myMutex</var>,
  <var>lockingBehavior</var>);</pre>
          <p>where,</p>
          <ul>
            <li><strong>name:</strong> Name assigned to the shared_lock object</li>
            <li><strong>myMutex:</strong> a placeholder for the actual type of the mutex</li>
            <li><strong>lockingBehavior:</strong> (optional) determines how the mutex is locked and managed</li>
          </ul>
          <p>Example. The following program illustrates the use of <code>unique_lock</code> in C++:</p>
          <pre>// C++ Program using std::unique_lock

#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
using namespace std; ​

// Global mutex to protect shared_data
mutex mtx; ​

// Shared data variable
int shared_data = 0;
​
// Function to increment shared_data
void increment_data() {
  // Create a unique_lock object, but defer locking the mutex
  unique_lock&lt;mutex&gt; ulck(mtx, defer_lock);

  // Explicitly acquire the lock
  ulck.lock();

  // Critical section: safely modify shared_data:
  shared_data += 2;

  // Manually release the lock:
  ulck.unlock();
} ​

int main() {

  // Create two threads that run the increment_data function
  thread t1(increment_data);
  thread t2(increment_data);

  // Wait for both threads to finish
  t1.join();
  t2.join();

  // Output the value of shared_data
  cout &lt;&lt; "Value of shared variable: " &lt;&lt; shared_data;

  return 0;

}</pre>
          <p>Output</p>
          <pre>Value of shared variable: 4</pre>
          <hr/>
          <p>These are the key features of <code>unique_lock</code>:</p>
          <ul>
            <li><strong>Flexibility:</strong> can lock and unlock multiple times within its scope</li>
            <li><strong>Deferred Locking:</strong> This can be constructed without locking the mutex immediately</li>
            <li><strong>Timed Locking:</strong> Supports times and try-locking operations</li>
            <li><strong>Ownership Transfer:</strong> It allows transferring mutex ownership to another unique_lock</li>
          </ul>
          <hr/>
          <p>These are some use cases when you should consider using unique_lock:</p>
          <ul>
            <li>You need more control over the locking mechanism including ability to lock and unlock manually.</li>
            <li>You need to defer locking or conditionally lock a mutex.</li>
            <li>You require timed locking to prevent blocking indefinitely.</li>
            <li>You need to transfer lock ownership between different scopes or threads.</li>
          </ul>
        </section>
        <section id="atomic">
          <h3><code>std::atomic</code>*</h3>
          <p style="text-align: right">(From <cite><a target="_blank" href="https://cplusplus.com/reference/atomic/">https://cplusplus.com/reference/atomic/</a></cite>)</p>
          <p><dfn>Atomic types</dfn> are types that encapsulate a value whose access is guaranteed to not cause data races and can be used to synchronize memory accesses among different threads.</p>
          <p>This header declares two C++ classes, <code>atomic</code> and <code>atomic_flag</code>, that implement all the features of atomic types in self-contained classes. The header also declares an entire set of C-style types and functions compatible with the atomic support in C.</p>

          <section>
            <h4>Class <code>std::atomic</code></h4>
            <pre>template &lt;class T&gt; struct atomic;</pre>
            <p>The main characteristic of atomic objects is that access to this contained value from different threads cannot cause data races (i.e., doing that is well-defined behavior, with accesses properly sequenced). Generally, for all other objects, the possibility of causing a data race for accessing the same object concurrently qualifies the operation as undefined behavior.</p>
            <p>Additionally, atomic objects have the ability to synchronize access to other non-atomic objects in their threads by specifying different memory orders.</p>
            <table>
              <caption>Public Member Functions </caption>
              <tr> <td>(constructor)</td> <td></td> </tr>
              <tr> <td><code>operator=</code></td>
                   <td>
                     <pre>T operator= (T val) noexcept;T operator= (T val) volatile noexcept;
atomic&amp; operator= (const atomic&amp;)          = delete;
atomic&amp; operator= (const atomic&amp;) volatile = delete;</pre>
                     <p>Replaces the stored value by <var>val</var>.</p>
                     <p>This operation is atomic and uses sequential consistency (<code>memory_order_seq_cst</code>). To modify the value with a different memory ordering, see <code>atomic::store</code>.</p>
                     <p><code><a href="#atomic">atomic</a></code> objects have no copy assignment defined, but note that they are implicitly convertible to <code>T</code>.</p>
                   </td> </tr>
              <tr> <td><code>std::atomic::is_lock_free()</code></td>
                   <td>
                     <pre>bool is_lock_free() const volatile noexcept;
bool is_lock_free() const noexcept;</pre>
                     <p>A lock-free object does not cause other threads to be blocked when accessed (possibly using some sort of transactional memory for the type).</p>
                   </td>
              </tr>
              <tr> <td><code>store(<var>VALUE</var>)</code></td>
                   <td>
                     <p>Modify contained value</p>
                     <pre>void store (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;
void store (T val, memory_order sync = memory_order_seq_cst) noexcept;</pre>
                   </td> </tr>
              <tr> <td><code>load</code></td>
                   <td>
                     <p>Read contained value</p>
                     <pre>T load (memory_order sync = memory_order_seq_cst) const volatile noexcept;
T load (memory_order sync = memory_order_</pre>
                   </td> </tr>
              <tr> <td><code>operator T</code></td>
                   <td>
                     <pre>operator T() const volatile noexcept;
operator T() const noexcept;</pre>
                     <p>Returns the stored value by val.</p>
                     <p>This is a type-cast operator: evaluating an atomic object in an expression that expects a value of its contained type (T), calls this member function, accessing the contained value.</p>
                     <p>This operation is atomic and uses sequential consistency (memory_order_seq_cst). To retrieve the value with a different memory ordering, see atomic::load.</p>
                    </td> </tr>
              <tr> <td><code>exchange</code></td>
                   <td>
                     <pre>T exchange (T val, memory_order sync = memory_order_seq_cst) volatile noexcept;
T exchange (T val, memory_order sync = memory_order_seq_cst) noexcept;</pre>
                     <p>Replaces the contained value by val and returns the value it had immediately before.</p>
                     <p>The entire operation is atomic (an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function.</p>
                   </td> </tr>
              <tr> <td><code>compare_exchange_weak</code></td>
                   <td>
                     <p>Compare and exchange contained value (weak)</p>
                     <pre>
bool compare_exchange_weak (T&amp; expected, T val,
                            memory_order sync = memory_order_seq_cst)
                            volatile noexcept;
bool compare_exchange_weak (T&amp; expected, T val,
                            memory_order sync = memory_order_seq_cst)
                            noexcept;

bool compare_exchange_weak (T&amp; expected, T val,
                            memory_order success,
                            memory_order failure)
                            volatile noexcept;
bool compare_exchange_weak (T&amp; expected, T val,
                            memory_order success,
                            memory_order failure)
                            noexcept;</pre>
                     <p>Compares the contents of the atomic object&apos;s contained value with expected:</p>
                     <ul>
                       <li>if true, it replaces the contained value with <var>val</var> (like <code>store</code>).</li>
                       <li>if false, it replaces expected with the contained value.</li>
                     </ul>
                     <p>The function always accesses the contained value to read it, and -if the comparison is true- it then also replaces it. But the entire operation is atomic: the value cannot be modified by other threads between the instant its value is read and the moment it is replaced.</p>
                     <hr/>
                     <p>The <a href="#memory-orders">memory order</a> used in the second set of prototypes depends on the result of the comparison: if true, it uses success; if false, it uses failure.</p>
                     <p>Note that this function compares directly the physical contents of the contained value with the contents of expected; This may result in failed comparisons for values that compare equal using <code>operator==</code> (if the underlying type has padding bits, trap values, or alternate representations of the same value), although this comparison shall converge rapidly in a loop that preserves expected.</p>
                     <hr/>
                     <p>Unlike <code>compare_exchange_strong</code>, this weak version is allowed to fail spuriously by returning false even when expected indeed compares equal to the contained object. This may be acceptable behavior for certain looping algorithms, and may lead to significantly better performance on some platforms. On these spurious failures, the function returns false while not modifying expected.</p>
                     <p>For non-looping algorithms, compare_exchange_strong is generally preferred.</p>
                   </td> </tr>
              <tr> <td><code>compare_exchange_strong</code></td>
                   <td>
                     <p>Compare and exchange contained value (strong)</p>
                     <p>Operation completely analogous to its twin <code>compare_exchange_weak</code> save for the fact that this strong version is required to always return true when expected indeed compares equal to the contained object, not allowing spurious failures.</p>
                     <p>However, on certain machines, and for certain algorithms that check this in a loop, <code>compare_exchange_weak</code> may lead to significantly better performance.</p>
                   </td> </tr>
            </table>
            <section>
              <h5>Template Specializations of Class <code>std::atomic&lt;T&gt;</code></h5>
              <p>The <code>atomic</code> class template is fully specialized for all fundamental integral types (except bool), and any extended integral types needed for the typedefs in &lt;cstdint&gt;.</p>
              <p>Besides, aliases are provided like <code>typedef atomic&lt;char&gt; atomic_char</code>, that is, prefix <code>atomic_</code> is added.</p>
              <p>These specializations have the following additional member functions listed below.</p>
              <p>Each of these functions accesses the contained value, apply the proper operator and return the value the contained value had immediately before the operation; all in a single atomic operation that cannot be affected by other threads.</p>
              <ul>
                <li><code>atomic::fetch_add</code></li>
                <li><code>atomic::fetch_sub</code></li>
                <li><code>atomic::fetch_and</code></li>
                <li><code>atomic::fetch_or</code></li>
                <li><code>atomic::fetch_xor</code></li>
                <li><code>atomic::operator++</code></li>
                <li><code>atomic::operator--</code></li>
                <li>
                  <p><code>operator<var>?</var>=(<var>SOMETHING</var>)</code></p>
                  <pre>T operator+= (T val) volatile noexcept;
T operator+= (T val) noexcept;
T operator-= (T val) volatile noexcept;
T operator-= (T val) noexcept;
T operator&amp;= (T val) volatile noexcept;
T operator&amp;= (T val) noexcept;
T operator|= (T val) volatile noexcept;
T operator|= (T val) noexcept;
T operator^= (T val) volatile noexcept;

T operator+= (ptrdiff_t val) volatile noexcept;
T operator+= (ptrdiff_t val) noexcept;
T operator-= (ptrdiff_t</pre>
                </li>
              </ul>
            </section>
          </section>

          <section>
            <h4>Global Functions</h4>

            <table border="0">
              <tr> <td><code>kill_dependency</code></td> <td>Kill dependency</td> </tr>
              <tr> <td><code>atomic_thread_fence</code></td> <td>Thread fence</td> </tr>
              <tr> <td><code>atomic_signal_fence</code></td> <td>Signal fence</td> </tr>
            </table>

            <table border="0">
              <caption>Functions for atomic objects (C-style)</caption>
              <tr> <td><code>atomic_is_lock_free</code></td> <td>Is lock-free</td> </tr>
              <tr> <td><code>atomic_init</code></td> <td>Initialize atomic object</td> </tr>
              <tr> <td><code>atomic_store</code></td> <td>Modify contained value</td> </tr>
              <tr> <td><code>atomic_store_explicit</code></td> <td>Modify contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_load</code></td> <td>Read contained value</td> </tr>
              <tr> <td><code>atomic_load_explicit</code></td> <td>Read contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_exchange</code></td> <td>Read and modify contained value</td> </tr>
              <tr> <td><code>atomic_exchange_explicit</code></td> <td>Read and modify contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_compare_exchange_weak</code></td> <td>Compare and exchange contained value (weak)</td> </tr>
              <tr> <td><code>atomic_compare_exchange_weak_explicit</code></td> <td>Compare and exchange contained value (weak, explicit)</td> </tr>
              <tr> <td><code>atomic_compare_exchange_strong</code></td> <td>Compare and exchange contained value (strong)</td> </tr>
              <tr> <td><code>atomic_compare_exchange_strong_explicit</code></td> <td>Compare and exchange contained value (strong, explicit)</td> </tr>
              <tr> <td><code>atomic_fetch_add</code></td> <td>Add to contained value</td> </tr>
              <tr> <td><code>atomic_fetch_add_explicit</code></td> <td>Add to contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_fetch_sub</code></td> <td>Subtract from contained value</td> </tr>
              <tr> <td><code>atomic_fetch_sub_explicit</code></td> <td>Subtract from contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_fetch_and</code></td> <td>Apply bitwise AND to contained value</td> </tr>
              <tr> <td><code>atomic_fetch_and_explicit</code></td> <td>Apply bitwise AND to contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_fetch_or</code></td> <td>Apply bitwise OR to contained value</td> </tr>
              <tr> <td><code>atomic_fetch_or_explicit</code></td> <td>Apply bitwise OR to contained value (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_fetch_xor</code></td> <td>Apply bitwise XOR to contained value</td> </tr>
              <tr> <td><code>atomic_fetch_xor_explicit</code></td> <td>Apply bitwise XOR to contained value (explicit memory order)</td> </tr>
            </table>

            <table border="0">
              <caption>Functions for atomic flags (C-style)</caption>
              <tr> <td><code>atomic_flag_test_and_set</code></td> <td>Test and set atomic flag</td> </tr>
              <tr> <td><code>atomic_flag_test_and_set_explicit</code></td> <td>Test and set atomic flag (explicit memory order)</td> </tr>
              <tr> <td><code>atomic_flag_clear</code></td> <td>Clear atomic flag</td> </tr>
              <tr> <td><code>atomic_flag_clear_explicit</code></td> <td>Clear atomic flag (explicit memory order)</td> </tr>
            </table>

            <table border="0">
              <caption>Macro Functions</caption>
              <tr> <td><code>ATOMIC_VAR_INIT</code></td> <td>Initialization of atomic variable (macro)</td> </tr>
              <tr> <td><code>ATOMIC_FLAG_INIT</code></td> <td>Initialization of atomic flag (macro)</td> </tr>
            </table>

          </section>

          <section>
            <h4><code>struct atomic_flag</code></h4>
            <p>Atomic flags are boolean atomic objects that support two operations: test-and-set and clear.</p>
            <p>Atomic flags are lock-free (this is the only type guaranteed to be lock-free on all library implementations).</p>
            <p>Member Functions</p>
            <table>
              <tr> <td><var>(constructor)</var></td> <td>Construct atomic flag</td> </tr>
              <tr> <td><code>test_and_set</code></td> <td>Test and set flag</td> </tr>
              <tr> <td><code>clear</code></td> <td>Clear flag</td> </tr>
            </table>
            <p>Example:</p>
            <pre>// using atomic_flag as a lock
#include &lt;iostream&gt;       // std::cout
#include &lt;atomic&gt;         // std::atomic_flag
#include &lt;thread&gt;         // std::thread
#include &lt;vector&gt;         // std::vector
#include &lt;sstream&gt;        // std::stringstream

std::atomic_flag lock_stream = ATOMIC_FLAG_INIT;
std::stringstream stream;

void append_number(int x) {
  while (lock_stream.test_and_set()) {}
  stream &lt;&lt; "thread #" &lt;&lt; x &lt;&lt; '\n';
  lock_stream.clear();
}

int main ()
{
  std::vector&lt;std::thread&gt; threads;
  for (int i=1; i&lt;=10; ++i) threads.push_back(std::thread(append_number,i));
  for (auto&amp; th : threads) th.join();

  std::cout &lt;&lt; stream.str();
  return 0;
}</pre>
            <p>Possible output (order of lines may vary):</p>
            <pre>thread #1
thread #2
thread #3
thread #4
thread #5
thread #6
thread #7
thread #8
thread #9
thread #10</pre>
          </section>

        </section>

        <section id="memory-orders">
          <h3>Memory Ordering with <code>memory_order</code>*</h3>
          <p>Used as an argument to functions that conduct atomic operations to specify how other operations on different threads are synchronized.</p>
          <p>It is defined as:</p>
          <pre>typedef enum memory_order {
    memory_order_relaxed,   // relaxed
    memory_order_consume,   // consume
    memory_order_acquire,   // acquire
    memory_order_release,   // release
    memory_order_acq_rel,   // acquire/release
    memory_order_seq_cst    // sequentially consistent
} memory_order;</pre>
          <p>All <a href="#atomic">atomic</a> operations produce well-defined behavior with respect to an atomic object when multiple threads access it: each atomic operation is entirely performed on the object before any other atomic operation can access it. This guarantees no data races on these objects, and this is precisely the feature that defines atomicity.</p>
          <p>Still, each thread may perform operations on memory locations other than the atomic object itself: and these other operations may produce visible side effects on other threads. Arguments of this type allow to specify a memory order for the operation that determines how these (possibly non-atomic) visible side effects are synchronized among threads, using the atomic operations as synchronization points:</p>
          <dl>
            <dt><code>memory_order_relaxed</code></dt>
            <dd>
              <p>The operation is ordered to happen atomically at some point.</p>
              <p>This is the loosest memory order, providing no guarantees on how memory accesses in different threads are ordered with respect to the atomic operation.</p>
            </dd>
            <dt><code>memory_order_consume</code></dt>
            <dd>
              <p>[Applies to loading operations]</p>
              <p>The operation is ordered to happen once all accesses to memory in the releasing thread that carry a dependency on the releasing operation (and that have visible side effects on the loading thread) have happened.</p>
            </dd>
            <dt><code>memory_order_acquire</code></dt>
            <dd>
              <p>[Applies to loading operations]</p>
              <p>The operation is ordered to happen once all accesses to memory in the releasing thread (that have visible side effects on the loading thread) have happened.</p>
            </dd>
            <dt><code>memory_order_release</code></dt>
            <dd>
              <p>[Applies to storing operations]</p>
              <p>The operation is ordered to happen before a consume or acquire operation, serving as a synchronization point for other accesses to memory that may have visible side effects on the loading thread.</p>
            </dd>
            <dt><code>memory_order_acq_rel</code></dt>
            <dd>
              <p>[Applies to loading/storing operations]</p>
              <p>The operation loads acquiring and stores releasing (as defined above for memory_order_acquire and memory_order_release).</p>
            </dd>
            <dt><code>memory_order_seq_cst</code></dt>
            <dd>
              <p>The operation is ordered in a sequentially consistent manner: All operations using this memory order are ordered to happen once all accesses to memory that may have visible side effects on the other threads involved have already happened.</p>
              <p>This is the <em>strictest</em> memory order, guaranteeing the least unexpected side effects between thread interactions though the non-atomic memory accesses.</p>
              <p>For consume and acquire loads, sequentially consistent store operations are considered releasing operations.</p>
            </dd>
          </dl>
        </section>

      </section>

      <section>
        <h2>Problems with Multithreading</h2>
        <p>Multithreading improves the performance and utilization of CPU, but it is also subject to several problems:</p>
        <ul>
          <li><a href="#deadlock">Deadlock</a></li>
          <li><a href="#race-conditions">Race Condition</a></li>
          <li><a href="#starvation">Starvation</a></li>
        </ul>
        <dl>
          <dt>Deadlock</dt>
          <dd id="deadlock">A <dfn>deadlock</dfn> occurs when two or more threads are blocked forever because they are each waiting for shared resources that the other threads hold. This creates a cycle of waiting, and none of the threads can go ahead.</dd>
          <dt>Race Conditions</dt>
          <dd id="race-conditions">A <dfn>race condition</dfn> occurs when two or more threads access shared resources at the same time, and at least one of them modifies the resource. Since the threads are competing to read and write the data, the final result depends on the order in which the threads execute, leading to unpredictable or incorrect results.</dd>
          <dt>Starvation</dt>
          <dd id="starvation">Starvation occurs when a thread is continuously unable to access shared resources because other threads enjoy a higher priority, effectively preventing it from executing and making progress.</dd>
        </dl>
      </section>

      <section id="thread-synchronization">
        <h2>Thread Synchronization</h2>
        <p>In multithreading, <dfn>synchronization</dfn> is the way to control the access of multiple threads to shared resources, ensuring that only one thread can access a resource at a time to prevent data corruption or inconsistency. This is typically done using tools like mutexes, locks, and condition variables.</p>
        <section id="mutex">
          <h3>Mutexes with <code>std::mutex</code></h3>
          <p>Mutex is a synchronization primitive that locks the access to the shared resource if some thread is already accessing it.</p>
          <p>An example where a mutex is used to achieve synchronization:</p>
          <pre>// C++ program to illustrate the use of mutex locks to
// synchronize the threads
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std; ​

// data shared and lockable:
double val = 0; ​

// mutex:
mutex m; ​

int cnt = 0; ​

void add(double num) {
    m.lock();
    val += num;
    cnt++;
    cout &lt;&lt; "Thread " &lt;&lt; cnt &lt;&lt; ": " &lt;&lt; val &lt;&lt; endl;
    m.unlock();
} ​

// driver code
int main() {

    thread t1(add, 300);
    thread t2(add, 600);

    t1.join();
    t2.join();

    cout &lt;&lt; "After addition : " &lt;&lt; val &lt;&lt; endl;

    return 0;

}</pre>
          <p>Output:</p>
          <pre>Thread 1: 300
Thread 2: 900
After addition : 900</pre>
          <p>or</p>
          <pre>Thread 1: 600
Thread 2: 900
After addition : 900</pre>
          <p><strong>Note:</strong> In the above code after applying mutex we can get any of the two outputs as shown above. This is because, after applying mutex we have prevented both the threads from entering inside the add() function together, but, either thread t1 or thread t2 enters the add() function first and therefore the output varies with respect to that.</p>
        </section>
        <section id="condition_variable">
          <h3>Condition Variables with <code>std::condition_variable</code></h3>
          <p>The condition variable is another such synchronization primitive. It is mainly used to notify the threads about the state of the shared data. It is used with the mutex locks to create processes that automatically wait and notify the state of the resource to each other.</p>
          <p>Example:</p>
          <pre>// C++ program to illustrate the use of condition variable

#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

using namespace std;

// condition variable and mutex to be locked
condition_variable cv;
mutex m;

// shared resource
int val = 0; ​

void add(int num) {
  lock_guard&lt;mutex&gt; lock(m);
  val += num;
  cout &lt;&lt; "After addition: " &lt;&lt; val &lt;&lt; endl;
  cv.notify_one();
}
​
void sub(int num) {
  unique_lock&lt;mutex&gt; ulock(m);
  cv.wait(ulock,
          [] { return (val != 0) ? true : false; });
  if (val &gt;= num) {
      val -= num;
      cout &lt;&lt; "After subtraction: " &lt;&lt; val &lt;&lt; endl;
  } else {
      cout &lt;&lt; "Cannot Subtract now!" &lt;&lt; endl;
  }
  cout &lt;&lt; "Total number Now: " &lt;&lt; val &lt;&lt; endl;
} ​

// driver code:
int main() {

  thread t2(sub, 600);
  thread t1(add, 900);

  t1.join();
  t2.join();

  return 0;

}</pre>
          <p>Output</p>
          <pre>After addition: 900
After subtraction: 300
Total number Now: 300</pre>
          <p><strong>Explaination:</strong></p>
          <p>In the foregoing program we first created two threads and then we tried to perform addition first followed by subtraction. But as we can see in the above program, we passed thread <var>t2</var> first and then <var>t1</var>. Assuming thread <var>t2</var> goes to the <code>sub()</code> function first, it first locks the mutex and then checks the condition whether the val is 0 or not. As the <var>val</var> is 0 initially, the predicate returns false and as soon as it returns false, it releases the mutex and waits for the condition to be true i.e., val!=0. Now as the mutex is released, addition is performed in the <code>add()</code> function and after that <code>notify_one()</code> gets executed which notifies the waiting thread which in turn tries to get the lock and again checks the condition. This way the process continues.</p>
          <p>One of the best use case of condition variable is Producer-Consumer Problem.</p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>

        </section>
        <section id="promises-and-futures">
          <h3>Promises and Futures with <code>std::future</code> and <code>std::promise</code></h3>
          <p>The <code>std::future</code> and <code>std::promise</code> are used to return data from a task executed on the other thread. The <code>std::promise</code> is used to send the data and the <code>std::future</code> is used to receive the data on the main process. The <code>std::future::get()</code> method can be used to retrieve the data returned by the process and is able to hold the current process till the value is returned.</p>
          <p>This method is generally preferred over the condition variable when we only want the task to be executed once.</p>
          <p>Example</p>
          <pre>// C++ program to illustrate the use of std::future and
// std::promise in thread synchronization.

#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std; ​

// callable:
void EvenNosFind(promise&lt;int&gt;&amp;&amp; EvenPromise,
                 int begin,
                 int end) {
  int evenNo = 0;
  for (int i = begin; i &lt;= end; i++) {
    if (i % 2 == 0) {
      evenNo += 1;
    }
  }
  EvenPromise.set_value(evenNo);
}
​
// driver code
int main() {

  int begin = 0, end = 1000;

  promise&lt;int&gt; evenNo;
  future&lt;int&gt; evenFuture = evenNo.get_future();
  cout &lt;&lt; "My thread is created !!!" &lt;&lt; endl;

  thread t1(EvenNosFind, move(evenNo), begin, end);
  cout &lt;&lt; "Waiting..........." &lt;&lt; endl;
​

  // getting the data
  cout &lt;&lt; "The no. of even numbers are : "
       &lt;&lt; evenFuture.get() &lt;&lt; endl;

  t1.join();

  return 0;

}</pre>
          <p>Output</p>
          <pre>My thread is created !!!
Waiting...........
The no. of even numbers are : 501</pre>
          <p>In the program above, we try to find the number of even numbers in the given range. We first create a promise object and then we create a future object from that promise object. We send the promise object to the thread and then once we are ready with the value (after the function has been executed) ,we set the promise object. Then we create a future object from that promise. Finally we get the output from the future object to get our answer.</p>
        </section>
        <!--
        <section id="*">
          <h3> with <code></code></h3>
          <p></p>
        </section>
        <section id="*">
          <h3> with <code></code></h3>
          <p></p>
        </section>
        <section id="*">
          <h3> with <code></code></h3>
          <p></p>
        </section>
        -->
      </section>

    </main>

  </body>

</html>
