<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>Prolog</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>

    <link rel="alternate" hreflang="x-default" href="http://www.example.com/"/>
    <link rel="alternate" hreflang="es" href="http://es.example.com/"/>
    <link rel="alternate" hreflang="de" href="http://de.example.com/"/>

    <link rel="author" href="https://plus.google.com/ExampleProfile"/>
    <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      <p><a                    href="ANOTHER_PAGE.html">ANOTHER_PAGE</a</p>>
      <p><a rel="RELATIONSHIP" href="ANOTHER_PAGE.html">LINK_TEXT</a</p>>
      <p><a rel="alternate"    href="VERSION.html">ANOTHER VERSION</a</p>>
      <hr/>
      <p><a href="A_PAGE.html">LINK_TEXT</a</p>>
      <p><a href="ANOTHER_PAGE.html">LINK_TEXT</a</p>>
      <p><a rel="prev" href="PREVIOUS_PAGE.html">LINK_TEXT</a</p>>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a</p>>
      -->
      <div>
        <p> <a rel="next" href="prolog.compilers-and-interpreters.html">Prolog Compilers and Interpreters</a></p>
        <p> <a rel="prev" href="ai.html">Artificial Intelligence</a> </p>
        <p> <a            href="lisp.html">Lisp: The List Processing Language</a> </p>
        <p> <a            href="expert-systems.html">Expert Systems</a> </p>
        <p> <a            href="knowledge-representation.html">Knowledge Representation</a> </p>
      </div>
      <div>
        <p> <a href="ai.html">Artificial Intelligence</a> </p>
        <p> <a href="gai.html">Generative Artificial Intelligence</a> </p>
        <p> <a href="knowledge-representation.html">Knowledge Representation</a> </p>
        <p> <a href="ann.html">Artificial Neural Networks</a> </p>
        <p> <a href="machine_learning.html">Machine Learning</a> </p>
      </div>
    </nav>
    <main>
      <h1>Prolog: Symbolic Programming or <i>Programation Logique</i></h1>
      <p><q>Prolog</q> stands for <i lang="fr">Programation Logique</i>.</p>
      <p>Prolog is a general-purpose logic programming language associated with <a href="ai.html">artificial intelligence</a> and computational linguistics. Prolog has its roots in first-order logic, which is a formal logic, and unlike many other programming languages, Prolog is intended as primarily a <em>declarative</em> programming language: the program logic is expressed in terms of relations, represented as facts and rules. A computation is initiated by running a query over these relations.</p>
      <p>Prolog implements the predicate calculus via <a href="#Horn_clauses_in_prolog">Horn clauses</a>. The inference mechanism of Prolog is based upon Robinson's resolution principle (1965) together with mechanisms for extracting answers proposed by Green (1968). These ideas came together forcefully with the advent of linear resolution procedures. Explicit goal-directed linear resolution procedures, such as those of Kowalski and Kuehner (1971) and Kowalski (1974), gave impetus to the development of a general purpose logic programming system.</p>
      <p>A logic program is a set of axioms, or rules, defining relations between objects. A <dfn>computation</dfn> of a logic program is a deduction of consequences of the program. A program defines a set of consequences, which is its meaning. The art of logic programming is constructing concise and elegant programs that have the desired meaning.</p>
      <p>The <dfn>meaning</dfn> of a logic program <var>P</var>, <code class="function">M(<var>P</var>)</code>, is the set of ground goals deducible from <var>P</var>.</p>
      <hr/>
      <p>Prolog was one of the first logic programming languages, and remains the most popular among such languages today, with several free and commercial <a href="prolog.compilers-and-interpreters.html">implementations</a> available. The language has been used for theorem proving, <a href="#expert_sys_in_pl">expert systems</a>, term rewriting, type inference, and automated planning, as well as its original intended field of use, natural language processing. Modern Prolog environments support the creation of graphical user interfaces, as well as administrative and networked applications.</p>
      <p>Prolog is well-suited for specific tasks that benefit from rule-based logical queries such as searching databases, voice control systems, and filling templates.</p>
      <section>
        <h2>Why Prolog?</h2>
        <p>Much has been written about the wonders of Prolog as a declarative programming language and its strength as a language for implementing artificial intelligence (AI) applications. A look under the hood of both AI and Prolog reveals why.</p>
        <p>Prolog features a collection of search and pattern- matching algorithms. This, it turns out, is the essence of much AI programming. A chess program searches for patterns in the game, a natural language program searches for patterns in lists of words, and a diagnostic program searches for rules that match symptoms. Prolog is very good at pattern matching and search.</p>
        <p>Two features in a programming language that make pattern-matching easier are 1) support for symbols as a primitive data type that can be manipulated without the need to call special functions, and 2) dynamic memory management so the developer can simply use the symbols without worrying about memory allocation issues. Languages that have these features, such as Prolog and LISP, are called <dfn>symbolic languages</dfn>.</p>
        <hr/>
        <p>Consider, for example, a simple control loop that reads a command from a user and then does something. In <a target="_blank" href="c.html">C</a> that code might look like</p>
        <pre>void main()
{
  char buf[20];
  do {
     gets(buf);
     if (0 == strcmp(buf, "open")) ...
     else if (0 == strcmp(buf, "add")) ...
     else if (0 == strcmp(buf, "delete")) ...
  } while (strcmp(buf, "quit"));
  printf("done");
}</pre>
        <p>In Prolog, dynamically allocated symbols are used instead of character strings, so the equivalent code looks like</p>
        <pre>

    main :-
      repeat,
      read(X),
      do(X),
      X == quit,
      write(done).

    do(open) :- ...
    do(add) :- ...
    do(delete) :- ...

</pre>
        <p>Notice the lack of data definition statements or string compares. The difference is not significant in a simple example such as this, but in applications where the bulk of the work is comparing symbols, it becomes quite significant.</p>
        <p>In addition to dynamically allocated symbols, Prolog has, as an integral part of the language, a sophisticated pattern matching algorithm, called <dfn>unification</dfn>, and a search mechanism, called <dfn>backtracking</dfn>.</p>
        <p>These can both be seen in the code fragment above. The pattern <kbd>do(X)</kbd> is unified against the first of the three <kbd>do</kbd> rules, defined by the <kbd>:-</kbd> symbol meaning <q>if</q>. If the user entered <kbd>open</kbd> then the first clause, as it's called, would match and the code on the right of the <kbd>:-</kbd> would be executed. If the user entered something other than <kbd>open</kbd>, Prolog would <em>backtrack</em> and continue to look for a <kbd>do</kbd> rule that does match the user's input.</p>
        <p>Similarly, the use of the <kbd>repeat</kbd> and <kbd>X == quit</kbd> in the <kbd>main</kbd> rule causes the sample section of code to <em>loop</em> until the user types <kbd>quit</kbd>. The Prolog programmer doesn't write <q>if-then-elses</q>, <q>calls</q>, <q>whiles</q>, or other flow-of-control constructs, however, between unification and backtracking the programmer can induce any flow-of-control behavior in a Prolog program that can be achieved in any other language.</p>
        <p>Symbols, unification, backtracking, and dynamic memory management, all tend to eliminate procedural code a programmer normally needs to write. It is no surprise that what is left looks much more declarative than conventional code and is often a fraction of the size. For example, Prolog can be used to analyze simple English sentences. In fact Prolog was originally designed for working with language. As such it is well suited for not just natural language work, but for implementing and/or experimenting with formal languages as well.</p>
        <p>One common use in this line is to build shells for implementing expert systems. The shells use their own language to represent the knowledge for a particular type of problem. Diagnostic systems, for example, work differently from configuration systems.</p>
        <p>A tax application in Prolog is simply a collection of rules that specify how to fill out each line of the form. Prolog's search and unification do the work of linking related lines of the form together so the program code winds up looking very much like the tax form itself. Business applications such as customer order entry are expressed as relationships describing the various transactions and constraints. Pricing and configuration, two difficult components of such a system, are relatively straight-forward when coded in Prolog.</p>
        <p>While <a target="_blank" href="c.html">C</a> can be used to write anything written in Prolog, Prolog code, for the applications it does best, is much less complex. For this reason, the Prolog developer can manage and maintain a greater degree of complexity in an application, thus providing a greater degree of sophistication to the user of an application.</p>
        <p>For commercial applications, this leads to a competive edge, but the real benefit applies to any application-- Prolog is simply fun.</p>
      </section>
      <section>
        <h2>How Prolog is Used</h2>
        <p>The examples above provide insight into how a Prolog program is used. The grammar rules, for example, are a Prolog program. They are queried with lists of words. All Prolog programs are similar collections of rules, and are similarly activated by being queried, much the same way a <a href="database.html">database</a> is queried.</p>
        <p>This is true even of stand-alone compiled Prolog programs. In that case there is usually a single query, <code class="function">main</code>, used to start the program. <code class="function">main</code> is the name of a rule which then queries other rules which query other rules and so on. For example, the following Prolog program could be compiled and executed, with a classic result.</p>
        <pre>main :- write('Hello World').</pre>
        <p>It could also be loaded and run from an interpreter.</p>
        <pre>?- main.
Hello World</pre>
      </section>

      <section>
        <h2>Starting Prolog</h2>
        <p>Consider the following problem description:</p>
        <blockquote id="three_different_friends">
          <p>Three friends come first, second, and third in a tournament. Each of them has a different first name, likes a different sport and has a different nationality.</p>
          <p>Michael likes basketball and did better than the American. Simon, the Israeli, did better than the tennis player. The cricket player came first.</p>
        </blockquote>
        <p>A prolog shell may be started for the user-programmer to work interactively. Alternatively, you may cause a shell to read a <dfn>database</dfn> file, for instance by issueing <kbd>consult(<cite>my_database</cite>).</kbd> Alternatively, type <kbd>[<cite>my_database</cite>].</kbd></p>
        <p class="warning"><strong>Warning:</strong> The database name must be stripped of its extension</p>
      </section>
      <section>
        <h2>The Building Blocks of a Prolog Program</h2>
        <section>
          <h3>Facts</h3>
          <p>We first discuss facts about objects. Suppose we want to tell Prolog the fact that <q>John likes Mary</q>. This fact consists of two objects, called <q>Mary</q> and <q>John</q>, and a relationship or <dfn>predicate</dfn>, called <q>likes</q>. In Prolog, we need to write facts in a standard form, like this:</p>
          <pre>likes(john, mary).</pre>
          <p>The following things are important:</p>
          <ul>
            <li>The names of all relationships and objects must begin with a lower-case letter. For example, <kbd>likes</kbd>, <kbd>john</kbd>, <kbd>mary</kbd>.</li>
            <li>The relationship is written first, and the objects are written separated by commas and enclosed in round brackets.</li>
            <li>The dot character <q>.</q> must come at the end of a fact. The dot is what some people also call a <q>period</q> or a <q>full stop</q>.</li>
          </ul>
        </section>
        <section>
          <h3>Questions</h3>
          <p>Once we have some facts, we can ask some questions about them. In Prolog, a question looks just like a fact, except that we put a special symbol before it. The special symbol is written as a question mark followed by a hyphen. Consider the question:</p>
          <pre>?- owns(mary, book).</pre>
          <p>If we interpret <kbd>mary</kbd> to be a person called Mary, and <kbd>book</kbd> to be some particular book, this question is asking <q>Does Mary own the book?</q>, or <q>Is it a fact that Mary owns the book?</q> We are not asking whether she owns all books, or books in general, because the first letter of <kbd>book</kbd> is lower case.</p>
          <p>When a question is asked of a Prolog system, it will search through the database. It looks for facts that unify the fact in the question. Two facts <dfn>unify</dfn> if their predicates are the same (spelled the same way), and if their corresponding arguments each are the same. If Prolog finds a fact that unifies with the question, Prolog will respond <samp>yes</samp>. If no such fact exists in the database, Prolog will respond <samp>no</samp>.</p>
        </section>
        <section xml.id="pl_rules">
          <h3>Rules</h3>
          <p>In Prolog, rules are used when you want to say that a fact depends on a group of other facts. Rules are also used to express definitions. A rule is a general statement about objects and their relationships. For example, we can say that <q>Fred is a bird</q> if <var>Fred</var> is an animal and <var>Fred</var> has feathers, and we can also say that <var>Bertram</var> is a bird if <var>Bertram</var> is an animal and <var>Bertram</var> has feathers. So, we can allow a variable to stand for a different object in each different use of the rule.</p>
          <!-- <p class="bridgehead"/> -->
          <p>In Prolog, a rule consists of a <dfn>head</dfn> and a <dfn>body</dfn>. The head and body are connected by the symbol <q>:-</q>, which is made up of a colon and a hyphen. The <q>:-</q> is pronounced <q>if</q>.</p>
          <p>That John likes whoever likes wine is written in Prolog as:</p>
          <pre>likes(john, X) :- likes(X, wine).</pre>
          <p>Notice that rules also end with a dot (actually a <q>period</q> or <q>full stop</q> character). The head of this rule is <kbd>likes(john, X)</kbd>. The head of the rule describes what fact the rule is intended to define. The body, in this case <kbd>likes(X, wine)</kbd>, describes the conjunction of goals that must be satisfied, one after the other, for the head to be true. For example, we can make John more choosy about whom he likes, simply by adding more goals onto the body, separated by commas:</p>
          <pre>likes(john, X) :- likes(X, wine), likes(X, food).</pre>
          <p>or, in words, John likes anyone who likes wine and food. Or, suppose John likes any female who likes wine:</p>
          <pre>likes(john, X) :- female(X), likes(X, wine).</pre>
          <p>And so on.</p>
        </section>
        <section>
          <h3>Input, Output, and Input-Output Arguments to Predicates in Prolog</h3>
          <p>An argument may be either of them three and change its role according to the situation, for there is nothing in the syntax of prolog to indicate which.</p>
        </section>
        <section>
          <h3>Functors or <q>Structures</q></h3>
          <p>A structure is written in Prolog by specifying its <dfn>functor</dfn> and its components. The functor names the general kind of structure, and corresponds to a datatype in an ordinary programming language. The components are enclosed in round brackets and separated by commas. The functor is written just before the opening round bracket. Consider the following fact, that John owns the book called Wuthering Heights, by Emily Bronte:</p>
          <pre>owns(john, book(wuthering_heights, bronte)).</pre>
          <p>Inside the <kbd>owns</kbd> fact we have a structure by the name of <kbd>book</kbd>, which has two components, a title and an author. Since the book structure appears inside the fact as one of the fact's arguments, it is acting as an object, taking part in a relationship. If we like, we can also have another structure for the author's name, because there were three Bronte writers we wish to distinguish:</p>
          <pre>owns(john, book(wuthering_heights, author(emily, bronte))).</pre>
          <p>Structures may participate in the process of question-answering using variables. For example, we may ask if John owns any book by any of the Bronte sisters:</p>
          <pre>?- owns(john, book(X, author(Y, bronte))).</pre>
          <p>And so on.</p>
          <p>If you have guessed that the syntax for structures is the same as for Prolog facts, you are correct. A predicate (used in facts and rules) is actually the functor of a structure. The arguments of a fact or rule are actually the components of a structure. There are many advantages to representing Prolog programs themselves as structures. It is not important to know why just now, but do keep in mind that all parts of Prolog, even Prolog programs themselves, are made up of constants, variables, and structures.</p>
        </section>
        <section id="Horn_clauses_in_prolog">
          <h3>Horn Clauses</h3>
          <blockquote>
            <p>In mathematical logic and logic programming, a <dfn>Horn clause</dfn> is a logical formula of a particular rule-like form which gives it useful properties for use in logic programming, formal specification, and model theory. Horn clauses are named for the logician Alfred Horn, who first pointed out their significance in 1951.</p>
            <p style="text-align: right">The Wikipedia</p>
          </blockquote>
          <p>In logic programming, a <dfn>Horn clause</dfn> is an implication from a conjunction of none, one or several goals.</p>
          <blockquote>Jess will come <em>if</em> it is sunny <em>AND</em> her car starts, <em>AND</em> her mother is <em>not</em> ill.</blockquote>
          <p>This might be coded in prolog like this:</p>
          <pre>come(jess) :- sunny, start(car(jess)), not ill(mother(jess)).</pre>
        </section>
        <section>
          <h3>A Simple Database of Prolog Facts and Rules</h3>
          <p>This is a simple database to establish if two people are friends:</p>
          <pre>friends(X,Y) :- likes(X,Z), likes(Y,Z).
likes(john,gin).
likes(peter,gin).
likes(andy,beer).</pre>
          <section>
            <h4>Symmetric Relationships in Prolog</h4>
            <p>The following database and program lead off to infinite loops when consulted (<kbd>has_met(X,a).</kbd>):</p>
            <pre>% database:
has_met(a,b).
has_met(a,c).
% rules:
has_met(X,Y) :- has_met(Y,X).</pre>
            <p>The following one, though, behaves well:</p>
            <pre>% forward 'has_met' data base:
has_met_fwd(a,b).
has_met_fwd(a,c).
has_met(X,Y) :- has_met_fwd(X,Y) ; has_met_fwd(Y,X).</pre>
            <p>Alternatively:</p>
            <pre>% forward 'has_met' data base:
has_met_fwd(a,b).
has_met_fwd(a,c).
% rules:
has_met(X,Y) :- has_met_fwd(X,Y).
has_met(X,Y) :- has_met_fwd(Y,X).</pre>
            <p>Which obligingly yields:</p>
            <pre>| ?- has_met(X,a).
X = b ? ;
X = c
yes</pre>
          </section>
          <section>
            <h4>Transitivity</h4>
            <p>Here is a slightly more complicated example which codes some transitivity.</p>
            <pre>% database:
tr(a,b).
tr(b,c).
tr(c,d).
tr(bb,c).
tr(d,e).
tr(e,f).
% rules:
transitive(X,Y) :-           tr(X,Y).
transitive(X,Z) :-           tr(X,Y), transitive(Y,Z).</pre>
            <p>And this is the result of a difficult query:</p>
            <pre>| ?- transitive(X,f).
X = e ? ;
X = a ? ;
X = b ? ;
X = c ? ;
X = bb ? ;
X = d ? ;
no
</pre>
          </section>
          <section>
            <h4>Equivalence</h4>
            <p>Next, we would like to code an equivalence relationship.</p>
            <pre/>
            <p>...</p>
            <pre/>
            <p>...</p>
            <pre/>
            <p>...</p>
          </section>
        </section>
        <section id="lists_in_prolog">
          <h3>Lists in Prolog</h3>
          <p>Writing a list to standard output is a nice exercise for understanding both lists and recursive control:</p>
          <pre>writelist([]).
writelist([H|T]) :- write(H),nl,writelist(T).</pre>
          <section id="member_in_prolog">
            <h4>Membership in Prolog</h4>
            <p>Membership is established through recursion. I don't like it, though.</p>
            <pre>member(X,[X|_]).
member(X,[_|T] :- member(X,T).</pre>
          </section>
          <section>
            <h4>Appending</h4>
            <p>The arguments to non-built-in <code class="function">append/3</code> predicate are the initial sublist and the remaining sublist of a list, which is the third argument. It may be defined as:</p>
            <pre>append([], X, X).
append([A|B], C, [A|D]) :- append(B, C, D).</pre>
            <p>Here is an example of execution of a query (find the lists X and Y such that the concatenation of X and Y is [a,b]):</p>
            <pre>
| ?- append(X,Y,[a,b,c]).
X = []
Y = [a,b,c] ? ;
X = [a]
Y = [b,c] ? a % here the user presses a to compute all remaining solutions
X = [a,b]
Y = [c]
X = [a,b,c]
Y = []
no</pre>
          </section>
        </section>
      </section>
      <section>
        <h2>Backtracking: Cuts and Repeats</h2>
        <p>We can imagine a conjunction of goals to be arranged from left to right, separated by commas. When handling such a conjunction of goals, Prolog attempts to satisfy each goal in turn, working from left to right. If a goal becomes satisfied, Prolog leaves a place-marker in the database that is associated with the goal. Think of this as drawing an arrow from the goal to the place in the database where the solution is. Furthermore, any variables previously uninstantiated might now be instantiated. If a variable becomes instantiated, all its occurrences in the question become instantiated, too. Prolog then attempts to satisfy the goal's right-hand neighbour, starting from the top of the database.</p>
        <p>As each goal in turn becomes satisfied, it leaves behind a place-marker in the database (draws another arrow from the goal to the unifying fact), in case the goal needs to be re-satisfied at a later time. Any time a goal fails (cannot find a unifying fact), Prolog goes back and attempts to satisfy its left-hand neighbour, starting from its place-marker. Furthermore, Prolog must <q>uninstantiate</q> any variables that became instantiated at this goal. In other words, Prolog must <q>undo</q> all the variables when it re-satisfies a goal. If each goal, upon being entered from its right, cannot be re-satisfied, then the failures will cause Prolog to gradually creep to the left as each goal fails. If the first goal (the left-most goal) fails, then, since it does not have a left-hand neighbour it can attempt to re-satisfy, the entire conjunction fails. This behaviour, where Prolog repeatedly attempts to satisfy and re-satisfy goals in a conjunction, is called <dfn>backtracking</dfn>.</p>
        <section id="prolog_cut_operator">
          <h3>The Use of Cut to Prevent Backtracking in Prolog</h3>
          <p>Sometimes it is desirable to selectively turn off backtracking. Prolog provides a predicate that performs this function. It is called the cut, represented by an exclamation mark (!).</p>
          <p>The cut effectively tells Prolog to freeze all the decisions after it occurs in a predicate. That is, if required to backtrack, Prolog will automatically fail without trying other alternatives.</p>
          <p>The following database and query seems to fail:</p>
          <pre>related(X,Y) :- related(X,Z), related(Z,Y).
related(phil, roxanne).
related(roxanne, carol).
related(carol, alex).</pre>
          <p>Followed by the query:</p>
          <pre>related(phil,carol).</pre>
          <!-- <p class="bridgehead"/> -->
          <p>Performance is the main reason to use the cut. This separates the logical purists from the pragmatists. Various arguments can also be made as to its effect on code readability and maintainability. It is often called the <q>goto</q> of logic programming.</p>
          <p>You will most often use the cut when you know that at a certain point in a given predicate, Prolog has either found the only answer, or if it hasn't, then there is no answer. In this case you insert a cut in the predicate at that point.</p>
          <p>Similarly, you will use it when you want to force a predicate to fail in a certain situation, and you don't want it to look any further.</p>
        </section>
        <section>
          <h3>Some Examples of the Use of Cuts</h3>
          <p>The following program defines the <code class="function">minimum</code> predicate with cuts:</p>
          <pre>minimum(X, Y, X) :- X =&lt; Y, !.
minimum(X,Y,Y) :- X &gt; Y, !.</pre>
          <note>Predicate <code class="function">maximum</code> can be defined analogously.</note>
          <p>...</p>
        </section>
        <section>
          <title>
            <kbd>repeat</kbd>
          </title>
          <p>The built-in predicate <kbd>repeat</kbd> is provided as an extra way to generate multiple solutions through backtracking. Although it is built-in, it can be thought of as behaving as though defined as follows:</p>
          <pre>repeat.
repeat :- repeat.</pre>
          <p>What is the effect of this if we put <kbd>repeat</kbd> as a goal in one of our rules? First of all, the goal will succeed, because of the fact which is the first clause of repeat. Secondly, if backtracking reaches this point again, Prolog will be able to try an alternative: the rule that is provided as the second clause of <kbd>repeat</kbd>. When it uses this rule, another goal <kbd>repeat</kbd> is generated. Since this matches the first fact, we have succeeded again. If backtracking reaches here again, Prolog will again use the rule where it used the fact before. To satisfy the extra goal generated, it will again pick the fact as the first option. And so on. In fact, the goal <kbd>repeat</kbd> will be able to succeed infinitely many times on backtracking. Note the importance of the order of the clauses here. (What would happen if the fact appeared after the rule?).</p>
          <p>Why is it useful to generate goals that will always succeed again on backtracking? The reason is that they allow one to build &#x2014; from rules that have no choices in them &#x2014; rules that <em>do</em> have choices. And we can make them generate different values each time.</p>
          <p class="bridgehead">
            <i>Loops with <kbd>repeat/0</kbd></i>
          </p>
          <p>Furthermore, a clause body with a repeat/O followed by fail/O will go back and forth forever. This is one way to write an endless loop in Prolog.</p>
          <p>A repeat/O followed by some intermediate goals followed by a test condition will loop until the test condition is satisfied. It is equivalent to a <q>do until</q> in other languages.</p>
          <pre>command_loop :-
  repeat,
  write('Enter command (end to exit): '),
  read(X),
  write(X), nl,
  X = end.</pre>
        </section>
      </section>
      <section>
        <h2>Unification, the Engine for Predicate Matching and Evaluation</h2>
        <p>When queried, a prolog program  performs a series of resolutions on its database entries, rather than sequentally evaluating statements and expressions like a traditional language. This has an important ramification: variables are bound (assigned values, instantiated,...) by <dfn>unification</dfn> and <em>not</em> by evaluation unless an evaluation is <a href="#prolog_is_operator">explicitly</a> requested.</p>
        <p>One consequence of this is the relaxation of the requirement to specify variables (function parameters) as input or output.</p>
        <p>Unification is a powerful technique for rule-based and frame-based expert systems, where it matches case-specific data to the rules that best meet these specifications. All production systems require a form of this matching, and it is often necessary to write a unification algorithm in languages that don't provide one.</p>
        <section id="prolog_is_operator">
          <h3>Forcing Evaluation with Operator <code class="command">is</code></h3>
          <p>An important difference between unification-based computing and the use of more traditional languages is that unification performs syntactic matches (with appropriate parameter substitution) on structures. It does <em>not</em> evaluate expressions.</p>
          <p>Prolog provides an operator, <code class="command">is</code>, that performs arithmetic evaluation. It evaluates the expression on its right-hand side and attempts to unify the result with the object on its left. Thus,</p>
          <pre>X is Y + Z</pre>
          <p>unifies <var>X</var> with the value of <var>Y</var> added to <var>Z</var>. Because it performs arythmetic evaluation:</p>
          <ul>
            <li>If <var>Y</var> and <var>Z</var> do not have values (are not bound at execution time) evaluation of the <code class="command">is</code> causes a run-time error. Therefore</li>
            <li><kbd>X is Y + Z</kbd> cannot (as one might think with a declarative programming language) assign a value to <var>Y</var> when <var>X</var> and <var>Z</var> are bound.</li>
            <li>Programs must use <code class="command">is</code> to evaluate expressions containing arithmetic operators, +, -, *, /, and <code class="command">mod</code>.</li>
          </ul>
          <p>Finally, as in the predicate calculus, variables in prolog may have one and only one binding. Once given a value, through local assignment or unification, they can never take on a new value, except through a backtrack in the and/or search space of the current interpretation. Thus, <code class="command">is</code> does not function like a traditional assignment operator; an expression such as <kbd>X is X + 1</kbd> will always fail.</p>
        </section>
      </section>
      <section>
        <h2>Conjunction, disjunction, if-then</h2>
        <p>These are realized through operators <kbd>,</kbd>, <kbd>;</kbd>, and <kbd>-&gt;</kbd>.</p>
        <p class="bridgehead">
          <i>The Gory Details</i>
        </p>
        <p><kbd>Goal1 , Goal2</kbd> executes <var>Goal1</var> and, in case of success, executes <var>Goal2</var>.</p>
        <p><kbd>Goal1 ; Goal2</kbd> first creates a choice-point and executes <var>Goal1</var>. On backtracking <var>Goal2</var> is executed.</p>
        <p><kbd>Goal1 -&gt; Goal2</kbd> first executes <var>Goal1</var> and, in case of success, removes all choice-points created by <var>Goal1</var> and executes <var>Goal2</var>. This control construct acts like an if-then (<var>Goal1</var> is the test part and <var>Goal2</var> the then part). Note that if <var>Goal1</var> fails then <kbd>-&gt;/2</kbd> fails also. <kbd>-&gt;/2</kbd> is often combined with <kbd>;/2</kbd> to define an if-then-else as follows: <kbd>Goal1 -&gt; Goal2 ; Goal3</kbd>. Note that <kbd>Goal1 -&gt; Goal2</kbd> is the first argument of the <kbd>(;)/2</kbd> and <var>Goal3</var> (the else part) is the second argument. Such an if-then-else control construct first creates a choice-point for the else-part (intuitively associated with <kbd>;/2</kbd>) and then executes <var>Goal1</var>. In case of success, all choice-points created by <var>Goal1</var> together with the choice-point for the else-part are removed and <var>Goal2</var> is executed. If <var>Goal1</var> fails then <var>Goal3</var> is executed.</p>
      </section>
      <section>
        <h2>Negation by Failure in Prolog</h2>
        <p>A goal <var>G</var> fails (or <kbd>not g</kbd> succeeds), if <var>G</var> cannot be derived from the consulted database.</p>
        <p>Here is how we might define operator <kbd>not</kbd>:</p>
        <pre>not X :- X, !, fail.
not X.</pre>
        <p>...</p>
      </section>
      <section>
        <h2>Prolog Programming Styles</h2>
        <p>There are two basic styles of developing logic programs: defining a logical database, and manipulating data structures.</p>
        <p>A logic database comprises a set of facts and rules. A set of facts can define relations, as in relational databases. And rules can define complex relational queries, as in relational algebra.</p>
        <p>Data structures in Prolog are based on <a href="#lists_in_prolog">lists</a>.</p>
      </section>
      <section>
        <h2>Prolog Operators</h2>
        <p>Sometimes it is convenient to write some functors as <dfn>operators</dfn>. This is a form of syntax that makes some structures easier to read. For example, arithmetic operations are commonly written as operators. When we write the arithmetic expression <inlineequation>x + y * z</inlineequation>, we call the <q>plus</q> sign and the <q>multiply</q> sign <em>operators</em>. If we had to write the arithmetic expression <inlineequation>x + y*z</inlineequation> in the normal way for structures, it would look like this: <kbd>+(x,*(y,z))</kbd>, and this would be a legal Prolog term.</p>
        <p>The operators are sometimes easier to use, however, because we have grown accustomed to using them in arithmetic expressions ever since our schooldays. Also, the structure form requires that round brackets be placed around the functor's components, which may be awkward at times.</p>
        <p>It is important to note that the operators do not <em>cause</em> any arithmetic to be carried out. So in Prolog, <kbd>3+4</kbd> does not mean the same thing as <kbd>7</kbd>. The term <kbd>3+4</kbd> is another way to write the term <kbd>+(3,4)</kbd>, which is a data structure.</p>
        <p>First we need to know how to read arithmetic expressions that have operators in them. To do this, we need to know three things about each operator: its <em>position</em>, its <em>precedence</em>, and its <em>associativity</em>. In this section we will describe how to use Prolog operators with these three things in mind, but we will not go into very much detail. Although many different kinds of operators can be made up, we shall deal only with the familiar atoms +, -, *, and /.</p>
        <p>The <dfn>precedence</dfn> of an operator is used to indicate which operation is carried out first. Each operator that is used in Prolog has a precedence class associated with it. The precedence class is an integer that is associated with an operator. The exact value of the integer depends on the particular version of Prolog you are using. However, it is always true that an operator with a higher precedence has a precedence class that is closer to 1. If precedence classes range from 1 to 255, then an operator in the first precedence class is carried out first, before operators belonging to the 129th (say) precedence class. In Prolog the multiplication and division operators are in a higher precedence class than addition and subtraction, so the term <kbd>a-b/c</kbd> is the same as the term <kbd>-(a,/(b,c))</kbd>. The exact association of operators to precedence classes is not important at the moment, but it is worth remembering the relative order in which operations are carried out.</p>
        <p>Finally, consider how different operators associate. How they associate comes to our attention when we have several operators of the same precedence. When we see the expression <inlineequation>8/2/2</inlineequation>, does this mean <inlineequation>(8/2)/2</inlineequation> or <inlineequation>8/(2/2)</inlineequation>? In the first case, the expression could be interpreted to mean <inlineequation>2</inlineequation>, and in the second case, <inlineequation>8</inlineequation>. To be able to distinguish between these two cases, we must be able to tell whether an operator is left associative or right associative. A <dfn>left associative</dfn> operator must have the same or lower precedence operations on the left, and lower precedence operations on the right. For example, all the arithmetic operations (add, subtract, multiply, and divide) are left associative. This means that expressions like <kbd>8/4/4</kbd> are parsed as <inlineequation>(8/4)/4</inlineequation>. Also, <kbd>5+8/2/2</kbd> is read as <inlineequation>5+((8/2)/2)</inlineequation>.</p>
        <note>Remember that a structure made up of arithmetic operators is like any other structure. No arithmetic is actually carried out until commanded by the <q>is</q> predicate.</note>
        <section id="equality_and_unification">
          <h3>Equality and Unification</h3>
          <blockquote>There really is no equivalent of the assignment in prolog, and you should <em>not</em> use the dynamic database for this purpose.</blockquote>
          <p>One noteworthy built-in predicate is equality, which is an infix operator written as <kbd>=</kbd>. When an attempt is made to satisfy the goal</p>
          <pre>?- X = Y.</pre>
          <p>(pronounced <q>X equals Y</q>), Prolog attempts to unify <var>X</var> and <var>Y</var>, and the goal succeeds if they unify. We can think of this act as <em>trying to make X and Y equal</em>. The equality predicate works as though it were defined by the following fact:</p>
          <pre>X = X.</pre>
          <section id="strict_equality_in_prolog">
            <h4>Strict Equality (<kbd>X == Y</kbd>)</h4>
            <p>The predicate <kbd>==</kbd> represents a much stricter equality test than <kbd>=</kbd>. That is, if <kbd>X == Y</kbd> ever succeeds then <kbd>X = Y</kbd> does as well. On the other hand, this is not so the other way round. The way that <kbd>==</kbd> is more strict is by the way it considers variables. The <kbd>=</kbd> predicate will consider an uninstantiated variable to be equal to anything, because it will match anything. On the other hand, <kbd>==</kbd> will only consider an uninstantiated variable to be equal to another uninstantiated variable that is already sharing with it. Otherwise the test will fail. So we get the following behaviour:</p>
            <pre>?- X == Y.
no
?- X == X.
X = _23
?- X=Y, X==Y.
X = _23, Y = _23
?- append([A|B], C) == append(X, Y).
no
?- append([A|B], C) == append([A|B], C).
A = _23, B = _24, C = _25</pre>
          </section>
          <section>
            <title>
              <kbd/>
            </title>
          </section>
          <section>
            <title>
              <kbd/>
            </title>
          </section>
        </section>
        <section><h3>Arithmetic in Prolog</h3><p>Arithmetic can be used for calculating. For example, if we know the population and ground area of a country, we can calculate the population density of the country. The population density tells us how crowded the country would be if all the people were evenly spread throughout the country. Consider the following database about the population and area of various countries in 1976. We will use the predicate <kbd>population</kbd> to represent the relationship between a country and its population. Nowadays, the populations of countries are generally quite large numbers. So, we will represent population figures in millions: <kbd>population(X, Y)</kbd> means <q>the population of country X is about Y million people</q>. The predicate <kbd>area</kbd> will denote the relationship between a country and its area (in millions of square miles). The numbers given here are not exact, but they will do for the purpose of demonstrating arithmetic:</p><pre>population(usa, 203).
population(india, 548).
population(china, 800).
population(brazil, 108).
area(usa, 3).
area(india, 1).
area(china, 4).
area(brazil, 3).</pre><p>Now to find the population density of a country, we must use the rule that the density is the population divided by the area. This can be represented as the predicate <kbd>density</kbd>, where the goal <kbd>density(X,Y)</kbd> succeeds for country X having Y as the population density of that country. A Prolog rule for this is:</p><pre>density(C, Y) :-
  population(C, P),
  area(C, A),
  Y is P / A.</pre><p>We need to use built-in infix predicator <kbd>is</kbd> to cause evaluation and then unification.</p><p class="bridgehead"><i>Standard Arithmetic Operators in Prolog</i></p><p>Depending on what computer you use, various arithmetic operators can be used</p>
          on the right-hand side of the <kbd>is</kbd> operator. All Standard Prolog systems, however, will have the following, as well as many more:
          <ul><li><kbd>X + Y</kbd>: the sum of X and Y</li><li><kbd>X - Y</kbd>: the difference of X and Y</li><li><kbd>X * Y</kbd>: the product of X and Y</li><li><kbd>X / Y</kbd>: the quotient of X divided by Y</li><li><kbd>X // Y</kbd>: the integer quotient of X divided by Y</li><li><kbd>X mod Y</kbd>: the remainder of X divided by Y</li></ul>
        </section>
        <!-- end of "Arithmetic in Prolog" -->
        <section>
          <h3>Numerical Comparison Operators in Prolog</h3>
          <p>Given two numbers, we can tell whether one number is equal to the other, or less than the other, or greater than the other. Prolog provides certain built-in predicates for comparing numbers. Actually these predicates evaluate terms that are treated as arithmetic expressions. The arguments could be variables instantiated to integers, or they could be integers written as constants, or they could be more general expressions. Here we will use these predicates just for comparing numbers, but later we'll use them in general arithmetic expressions. Note that we are allowed to write them as infix operators:</p>
          <ul>
            <li><kbd>X =:= Y</kbd>: X and Y stand for the same number</li>
            <li><kbd>X =\= Y</kbd>: X and Y stand for different numbers</li>
            <li><kbd>X &lt; Y</kbd>: X is less than Y</li>
            <li><kbd>X &gt; Y</kbd>: X is greater than Y</li>
            <li><kbd>X =&lt; Y</kbd>: X is less than or equal to Y</li>
            <li><kbd>X &gt;= Y</kbd>: X is greater than or equal to Y</li>
          </ul>
          <p>Note that the <q>less than or equal to</q> symbol is <em>not</em> written as <q>&lt;=</q> as in many programming languages. This is done so that the Prolog programmer is free to use the <q>&lt;=</q> atom, which looks like an arrow, for other purposes.</p>
          <section>
            <title>
              <kbd>X=Y</kbd>
            </title>
            <p>The <a href="#equality_and_unification">equality</a> predicate, when applied on numbers, succeeds when two number arguments are the same. However, if one of the arguments is a variable, the equality predicate will cause the variable to be instantiated because the equality predicate performs a unification of its two arguments. In many numeric calculations, this is not desirable. Instead, Prolog makes available predicates specifically for comparing equality and inequality of numbers. In all of the following predicates, both arguments must be instantiated, or an error occurs. Using these predicates for numeric calculation can also cause the program to be executed more efficiently.</p>
          </section>
          <section>
            <title>
              <kbd>=:=</kbd>
            </title>
            <p>This numeric equality predicate succeeds when the left-hand number argument is equal to the right-hand number argument.</p>
          </section>
          <section>
            <title>
              <kbd>=\=</kbd>
            </title>
            <p>This numeric equality predicate succeeds when the left-hand number argument is <em>not</em> equal to the right-hand number argument.</p>
          </section>
        </section>
        <!-- end of "Numerical Comparison Operators in Prolog" -->
        <section>
          <h3>Comparing Arbitrary Terms</h3>
          <p>They start with character <kbd>@</kbd>: <kbd>@&lt;</kbd>, <kbd>@&gt;</kbd>, <kbd>@&gt;=</kbd>, and <kbd>@=&lt;</kbd>.</p>
          <p>Here are the principles that determine whether one term is considered less than another:</p>
          <ul>
            <li>All uninstantiated variables are less than all floating-point numbers, which are less than all integers, which are less than all atoms, which are less than all structures.</li>
            <li>For two non-sharing uninstantiated variables, one will be less than the other (which one is less may be different in different Prolog implementations). A floating point number is less than another floating point number or an integer is less than anothe integer in the expected way.</li>
            <li>One atom is less than another if it would come earlier than it in the normal dictionary ordering. To be precise, the ordering depends on the character codes, but these are usually ordered as one would expect, at least for alphabetic characters.</li>
            <li>One structure is less than another if its functor has a lower arity. If two structures have the same arity, one is less than the other if its functor is less than the other (using the ordering for atoms). If two structures have the same arity and functor, they are ordered by considering the arguments in turn &#x2013; for the first corresponding arguments that differ, the order of the structures is the order of the relevant arguments.</li>
          </ul>
        </section>
        <section>
          <h3>Declaring Operators with Predicate <kbd>op/3</kbd></h3>
          <p>In Prolog, if we wish to declare that an operator with a given position, precedence class, and associativity is to be recognised when terms are read and written, we use the built-in predicate <kbd>op</kbd>. If <var>Name</var> is the desired operator (the atom that we want to be an operator), <var>Prec</var> the precedence class (an integer within the appropriate range), and <var>Spec</var> the position/associativity specifier (one of the above atoms), then the operator is declared by providing the following goal:</p>
          <pre>?- op(Prec, Spec, Name).</pre>
          <p>As an example of declaring operators, the following is a list of the most important operators that are already defined in Standard Prolog:</p>
          <pre>?- op( 1200, xfx, &amp;apos;:-&amp;apos; ).
?- op( 1200, fx, '?-' ).
?- op( 1200, fx, ':-' ).
?- op( 1100, xfy, ';' ).
?- op( 1000, xfy, ',' ).
?- op( 900, fy, '\+' ).
?- op( 700, xfx, '=').
?- op( 700, xfx,\=).
?- op( 700, xfx, '==' ).
?- op( 700, xfx, \== ).
?- op( 700, xfx, '=..' ).
?- op( 700, xfx, '&lt;' ).
?- op( 700, xfx, '&gt;' ).
?- op( 700, xfx, '=&lt;' ).
?- op( 700, xfx, '&gt;=' ).
?- op( 700, xfx, '@&lt;' ).
?- op( 700, xfx, '@=&lt;' ).
?- op( 700, xfx, '@&gt;' ).
?- op( 700, xfx, '@&gt;=' ).
?- op( 700, xfx, 'is' ).
?- op( 500, yfx, '+' ).
?- op( 500, yfx, '-' ).
?- op( 400, yfx, '*' ).
?- op( 400, yfx, '//' ).
?- op( 400, yfx, '/' ).
?- op( 400, yfx, 'mod' ).
?- op( 200, fy, '-').</pre>
          <p>...</p>
          <p>An operator declared <kbd>yfx</kbd> is left associative. Similarly, an operator declared xfy is right associative.</p>
          <p>Note that the meanings of <kbd>x</kbd> and <kbd>y</kbd> (in terms of what other operators can appear unbracketed in the relevant position) are the same in all the other cases as well. This means that, for instance, the sequence</p>
          <pre>not not a</pre>
          <p>is legal syntactically if not is declared as <kbd>fy</kbd>, but is illegal if it is declared <kbd>fx</kbd>.</p>
          <p>...</p>
        </section>
      </section>
      <!-- end of "Prolog Operators" -->
      <section>
        <h2>File I/O in Prolog</h2>
        <section>
          <h3>Prolog Input and Output</h3>
          <p>Here are some predicates for reading from <em>the</em> input stream and writing to <em>the</em> output stream:</p>
          <section>
            <h4>Reading and writing one character</h4>
            <p>The goal <kbd>get_char(<var>X</var>)</kbd> succeeds if <var>X</var> can be matched with the next character encountered on the current input stream. <kbd>get_char</kbd> succeeds only once (it cannot be re-satisfied). The operation of moving to the next character is not undone on backtracking, because there is no way to put a character back onto the current input stream.</p>
            <p>The goal <kbd>put_char(<var>X</var>)</kbd> writes the character <var>X</var> on the current output stream. <kbd>put_char</kbd> succeeds only once. An error occurs if <var>X</var> is not instantiated.</p>
          </section>
          <section>
            <h4>Reading and Writing a Term</h4>
            <p>The goal <kbd>read(X)</kbd> reads the next term from the current input stream and matches it with <var>X</var>. A read succeeds only once. The term must be followed by a dot <q>.</q>, which does not become a part of the term, and at least one non-printing character. The dot is removed from the current input stream</p>
            <p>The goal <kbd>write(X)</kbd> writes the term <var>X</var> to the current output stream. <kbd>write</kbd> succeeds only once. Any uninstantiated variables in <var>X</var> are written as uniquely numbered variables beginning with an underscore, such as <q>_239</q>. Co-referring variables within the same argument to write have the same number when they are printed out. The predicate <kbd>write</kbd> takes account of current operator declarations when it prints a term. Thus an infix operator will be printed out between its arguments, for instance.</p>
            <p>The predicate <kbd>write_canonical</kbd> works in exactly the same way as <kbd>write</kbd>, except that it ignores any operator declarations. When <kbd>write_canonical</kbd> is used, any structure is printed out in prefixed notation with the functor first and the arguments in brackets afterwards.</p>
          </section>
          <section>
            <h4>Effecting a New Line</h4>
            <p>The goal <kbd>nl</kbd> writes a control sequence to the current output stream that causes a <q>new line</q>. On a computer display, all characters after the use of <kbd>nl</kbd> appear on the next line of the page. <kbd>nl</kbd> succeeds only once.</p>
          </section>
        </section>
        <section>
          <h3>Handling Files</h3>
          <p>The following predicates open and close files, get file handles, and set current input and output streams.</p>
          <section>
            <title>
              <kbd>open(X, Y, Z)</kbd>
            </title>
            <p>This goal opens a file whose name is <var>X</var> (an atom). If <var>Y</var> is <kbd>read</kbd> then the file is opened for reading; otherwise if <var>Y</var> is <kbd>write</kbd> then the file is opened for writing. <var>Z</var> is instantiated to a special term naming the stream that must be referred to when the file is accessed later. An error occurs if <var>X</var> is not instantiated, or if <var>X</var> names a file that does not exist.</p>
          </section>
          <section>
            <title>
              <kbd>close(X)</kbd>
            </title>
            <p>This is used when <var>X</var> is a term naming a stream. The stream is closed and can no longer be used.</p>
          </section>
          <section>
            <title>
              <kbd>set_input(X)</kbd>
            </title>
            <p>Sets the current input to the stream whose name is provided by <var>X</var>. <var>X</var> will be a term returned in the third argument of <kbd>open</kbd>, or the atom <kbd>user_input</kbd>, which specifies that input is to come from the keyboard.</p>
          </section>
          <section>
            <title>
              <kbd>set_output(X)</kbd>
            </title>
            <p>Sets the current output to the stream whose name is provided by <var>X</var>. <var>X</var> will be a term returned in the third argument of <kbd>open</kbd>, or the atom <kbd>user_output</kbd>, which specifies that output is to go to the computer display.</p>
          </section>
          <section>
            <title>
              <kbd>current_input(X)</kbd>
            </title>
            <p>This goal succeeds if the name of the current input stream matches with <var>X</var>, and fails otherwise.</p>
          </section>
          <section>
            <title>
              <kbd>current_output(X)</kbd>
            </title>
            <p>This goal succeeds if <var>X</var> matches with the name of the current output stream, and fails otherwise.</p>
          </section>
        </section>
      </section>
      <!-- end of "File I/O in Prolog" -->
      <section>
        <h2>Prolog Meta-Predicates</h2>
        <p>These predicates query and manipulate other predicates rather than the terms or objects that the other, non-meta predicates denote. Some of them are:</p>
        <ul>
          <li><code class="command">var(<var>X</var>)</code>, which succedes only when <var>X</var> is an unbound variable;</li>
          <li><code class="command">nonvar(<var>X</var>)</code>, which succedes only when <var>X</var> is bound to a nonvariable term;</li>
          <li><code class="command">=..</code>, which creates a list from a predicate term; for instance, <kbd>jump(tick,3)=..X</kbd> unifies <var>X</var> with <kbd>[jump,tick,3]</kbd>;</li>
          <li><a href="#prolog_functor_predicate"><code class="command">functor(A,B,C)</code></a> succeeds with <var>A</var> a term whose principal functor has name <var>B</var> and arity <var>C</var>; this predicate can be used to produce a predicate or to to produce all the terms with a given name and/or arity.</li>
          <li><a href="#prolog_clause_predicate"><code class="command">clause(A,B)</code></a> unifies <var>B</var> with the body of a clause whose head unifies with <var>A</var>;</li>
          <li><code class="command">any_predicate(...,P,...) :- P</code> executes a predicate <var>P</var>, the argument of an arbitrary predicate: a predicate, here <var>P</var>, may be passed as a parameter and executed at any desired time in the computation;</li>
          <li><a href="#prolog_call_predicate"><code class="command">call(C)</code></a>, where <var>C</var> is a clause, also succeeds with the execution of predicate <var>C</var>;</li>
        </ul>
        <p>Next some of these predicates will be explained further:</p>
        <section id="prolog_clause_predicate">
          <title>
            <kbd>clause(X,Y)</kbd>
          </title>
          <p>Satisfying a goal of the form <kbd>clause(X, Y)</kbd> causes <var>X</var> and <var>Y</var> to be matched with the head and body of an existing clause (for a <q>public</q> predicate) in the database. When an attempt is made to satisfy the goal, <var>X</var> must be instantiated enough so that the main predicate of the clause is known. If there are no clauses for the predicate, the goal just fails. If there is more than one clause that matches, Prolog will choose the first one. In this case, if an attempt is made to re-satisfy the goal, the other matching clauses will be chosen, one at a time.</p>
          <p>Notice that, although <kbd>clause</kbd> always has an argument for the body of a clause, not every clause actually has a body. If a clause does not have a body, it is considered to have the dummy body <kbd>true</kbd>. We have been calling such clauses <q>facts</q>. By providing <var>X</var>'s and <var>Y</var>'s that are more or less instantiated, you can look for either all the clauses for a given predicate and number of arguments, or all the ones that match some pattern.</p>
        </section>
        <section id="prolog_functor_predicate">
          <title>
            <kbd>functor(T, F, N)</kbd>
          </title>
          <p>The predicate <kbd>functor</kbd> is defined in such a way that <kbd>functor(<var>T</var>,<var>F</var>,<var>N</var>)</kbd> means, <q><var>T</var> is a structure with functor [name] <var>F</var> and arity (number of arguments) <var>N</var></q>. It can be used in basically two ways. In the first way, <var>T</var> is already instantiated. The goal fails if <var>T</var> is not an atom or a structure. If <var>T</var> is an atom or structure, <var>F</var> is matched with the functor and <var>N</var> is matched with the integer giving the arity (number of arguments) of the functor. Note that in this context, an atom is considered to be like a structure with arity 0.</p>
          <p>Here are some examples of goals involving functor:</p>
          <pre>?- functor(f(a, b, g(Z)), F, N).
Z = _23, F = f, N = 3
?- functor(a + b, F, N).
F = +, N = 2
?- functor([a, b, c], F, N).
F = ., N = 2
?- functor(apple, F, N).
F = apple, N = 0
?- functor([a, b, c], '.', 3).
no
?- functor([a, b, c], a, Z).
no</pre>
          <p>There is a second use to <kbd>functor</kbd>. This occurs when the first argument of the goal (<var>T</var>) is uninstantiated. In this case, both of the others must be instantiated: specifying a functor and a number of arguments respectively. A goal of this form will always succeed, and as a result <var>T</var> will become instantiated to a structure with the functor and number of arguments provided. So this is a way of constructing arbitrary structures, given a specification in terms of a functor [name] and its number of arguments. The arguments of such a structure constructed by <code class="function">functor</code> are uninstantiated variables. Hence the structure will match any other structure with the same <code class="function">functor</code> and number of arguments.</p>
          <p class="bridgehead">
            <i>Copying an Existing Structure with <kbd>function/3</kbd></i>
          </p>
          <p>A common use of functor to create a structure is when we wish to make a <q>copy</q> of an existing structure with new variables as the arguments of the principal functor. We can encapsulate this use in the definition of a predicate <kbd>copy</kbd>, as follows:</p>
          <pre>copy(Old, New) :- functor(Old, F, N), functor(New, F, N).</pre>
          <p>Here, two functor goals occur adjacently. If the copy goal has the first argument instantiated and the second uninstantiated, then the following will happen. The first functor goal will involve the first possible use of the predicate (because the first argument will be instantiated). Hence <var>F</var> and <var>N</var> will become instantiated to the functor and number of arguments of this existing structure. The second functor goal uses the predicate in the second way. This time the first argument is uninstantiated, and the information in <var>F</var> and <var>N</var> is used to construct the structure <var>New</var>. This is a structure involving the same functor and number of arguments as <var>Old</var>, but with variables as its components. Thus we would get interactions like:</p>
          <pre>?- copy(sentence(np(n(john)), v(eats)), X).
X = sentence(_23, _24)</pre>
        </section>
        <section>
          <h3>Accessing Arguments in a Structure Through <kbd>arg(N,T,A)</kbd></h3>
          <p>The predicate <kbd>arg</kbd> must always be used with its first two arguments instantiated. It is used to access a particular argument of a structure. The first argument of <kbd>arg</kbd> specifies which argument is required. The second specifies the structure that the argument is to be found inside. Prolog finds the appropriate argument and then tries to match it with the third argument. Thus <kbd>arg(N, T, A)</kbd> succeeds if the Nth argument of <var>T</var> is <var>A</var>. Let us look at some goals involving <kbd>arg</kbd>.</p>
          <pre>?- arg(2, related(john, mother(jane)), X).
X = mother(jane)
?- arg(1, a+(b+c), X).
X=a
?- arg(2, [a,b,c], X).
X = [b,c]
?- arg(1, a+(b+c), b).
no</pre>
          <!-- <p class="bridgehead"/> -->
          <p>Sometimes we will want to use functor and arg when the possible structures <em>are</em> known. This is because there may be so many arguments that it is inconvenient to specify them every time. Consider an example where we use structures to represent books. We might have a component for the title, the author, the publisher, the date of publication, and so on. Let us say that the resulting structures have fourteen components. We might write the following useful definitions:</p>
          <pre>is_a_book(book(_,_,_,_,_,_,_,_,_,_,_,_,_,_)).
title(book(T,_,_,_,_,_,_,_,_,_,_,_,_,_), T).
author(book(_,A,_,_,_,_,_,_,_,_,_,_,_,_), A).</pre>
          <p>In fact, we can write these much more compactly as:</p>
          <pre>is_a_book(X) :- functor(X, book, 14).
title(X, T) :- is_a_book(X), arg(1, X, T).
author(X, A) :- is_a_book(X), arg(2, X, T).</pre>
        </section>
        <section id="prolog_univ_predicate">
          <title>
            <kbd>X =.. L</kbd>
          </title>
          <p>The predicates <kbd>functor</kbd> and <kbd>arg</kbd> provide one way of creating and accessing arguments of arbitrary structures. The predicate <kbd>=..</kbd> (pronounced <q>univ</q> for historical reasons) provides an alternative way, which is useful if you want to obtain the arguments of a structure all together, or if you want to construct a structure, given a list of arguments.</p>
          <p>The goal <kbd>X =.. L</kbd> means, <q><var>L</var> is the list consisting of the functor of <var>X</var> followed by the arguments of <var>X</var>.</q></p>
          <p>Such a goal can be used in two ways, in the same way that a <kbd>functor</kbd> goal can. If <var>X</var> is instantiated, Prolog constructs the appropriate list and tries to match it with <var>L</var>. Alternatively, if <var>X</var> is uninstantiated, the list will be used to construct an appropriate structure for <var>X</var> to stand for. In this case, the head of <var>L</var> must be an atom (it will become the functor of <var>X</var>). Here are some examples of <kbd>=..</kbd> goals:</p>
          <pre>?- foo(a,b,c) =.. X.
X = [foo,a,b,c]
?- [a,b,c,d] =.. L.
L = ['.',a,[b,c,d]].
?- (a+b) =.. L.
L = [+,a,b].
?- (a+b) =.. [+,X,Y].
X = a, Y = b.
?- [a,b,c,d] =.. [X|Y].
X = '.', Y = [a,[b,c,d]]
?- X =.. [a,b,c,d].
X = a(b,c,d)</pre>
        </section>
        <section id="prolog_call_predicate">
          <title>
            <kbd>call(<var>X</var>)</kbd>
          </title>
          <p>It is assumed that <var>X</var> is instantiated to a term that can be interpreted as a goal. The <kbd>call(X)</kbd> goal succeeds if an attempt to satisfy <var>X</var> succeeds. The <kbd>call(X)</kbd> goal fails if an attempt to satisfy <var>X</var> fails. At first sight, this predicate may seem redundant, because one might ask why the argument of call shouldn't simply appear by itself as a goal?</p>
          <p>For instance, the goal</p>
          <pre>..., call(member(a, X)),...</pre>
          <p>can always be replaced by</p>
          <pre>..., member(a, X),...</pre>
          <p>However, if we are constructing goals by using the <kbd>=..</kbd> predicate or <kbd>functor</kbd> and <kbd>arg</kbd>, then it is possible to call goals that have a functor that is unknown at the time you type in your program.</p>
          <p>Assuming that <var>P</var>, <var>X</var>, and <var>Y</var> are instantiated to a functor and arguments appropriately, <kbd>call</kbd> can be used as follows:</p>
          <pre>..., Z =.. [P,X,Y], call(Z),...</pre>
        </section>
        <section id="prolog_not_predicate">
          <h3>Negating with <kbd>\+ X</kbd></h3>
          <p>The <kbd>\+</kbd> predicate (pronounced <q>not</q>) is declared as a prefix operator. It is assumed that <var>X</var> is instantiated to a term that can be interpreted as a goal. The <kbd>\+ X</kbd> goal succeeds if an attempt to satisfy <var>X</var> fails. The <kbd>\+ X</kbd> goal fails if an attempt to satisfy <var>X</var> succeeds. In this way, <kbd>\+</kbd> is rather like <a href="#prolog_call_predicate"><kbd>call</kbd></a>, except that the success or failure of the argument, interpreted as a goal, is reversed.</p>
        </section>
        <section>
          <h3>Adding and Removing Rules</h3>
          <p>You use <kbd>assert</kbd>, <kbd>asserta</kbd>, <kbd>assertz</kbd> and <kbd>retract</kbd> to add and remove rules. They will only work on the definitions of predicates which have been declared <q>dynamic</q> . The intention again is to prevent accidental unplanned changing of definitions. A predicate foo/4 can be declared as <q>dynamic</q> by including the following in the relevant program file (before the definition of <kbd>foo/4</kbd> or, if there is no definition, before the code that uses asserta etc.):</p>
          <pre>:- dynamic foo/4.</pre>
          <p>Several predicates can be declared as dynamic on one line by separating them with commas, e.g:</p>
          <pre>:- dynamic foo/4, baz/3.</pre>
          <p class="warning"><strong>Warning:</strong> These commands are deprecated because they create and remove global structures, introduce side effects and may cause other problems associated with poorly structured programs.</p>
        </section>
        <section>
          <h3>Working with Characters</h3>
          <p>The following two predicates compose and decompose an atom into its characters.</p>
          <section>
            <h4>atom_chars(A,L)</h4>
            <p>Predicate <kbd>atom_chars</kbd> relates an atom to the list of characters (atoms with one element) that make it up. This can be used either to find the characters for a given atom, or to find the atom that has some given characters. The goal <kbd>atom_chars(A,L)</kbd> means that <q>the characters for the atom <var>A</var> are the members of the list <var>L</var></q>. If the argument <var>A</var> is instantiated, Prolog creates the list of characters and tries to match them with <var>L</var>. Otherwise Prolog uses the list <var>L</var> to make an atom for <var>A</var> to stand for. Example uses of <kbd>atom_chars</kbd> are as follows:</p>
            <pre>?- atom_chars(apple, X).
X = [a,p,p,l,e]
?- atom_chars(X, [a,p,p,l,e]).
X = apple</pre>
          </section>
          <section>
            <title>
              <kbd>number_chars(A,L)</kbd>
            </title>
            <p>This predicate is just like <kbd>atom_chars</kbd> except that it works with numbers, rather than atoms. Notice that in:</p>
            <pre>?- atom_chars(X, ['1' ,'2', '3']).</pre>
            <p>the variable <var>X</var> will be instantiated to the atom '123'. If we want it to be a number instead, we need to use <kbd>number_chars</kbd>. Here are some uses of <kbd>number_chars</kbd>:</p>
            <pre>?- number_chars(123.5, X).
X = ['1', '2', '3', '.', '5']
?- number_chars(X, ['1', '2', '3']).
X = 123</pre>
          </section>
        </section>
      </section>
      <section>
        <h2>Recursive Control Loop</h2>
        <p>The purity of logic programming is undermined by the asserts and retracts of the database. Using these makes code unpredictable, since the behavior of the code depends on global data whose value might change.</p>
        <p>Because logical variables cannot have their values changed by assignment, the commands must take two arguments representing the old state and the new state. The repeat-fail control structure will not let us repeatedly change the state in this manner, so we need to write a recursive control structure that recursively sends the new state to itself.</p>
        <p>This style of Prolog programming is logically purer, and lends itself to certain types of applications. It also avoids the difficulties often associated with global data. On the other hand, it requires more complexity in dealing with state information in arguments, and the multiple lists and recursive routines can be confusing to debug. You will have to decide which approach to use for each application you write.</p>
        <p>There could be serious performance problems with this approach. Prolog uses a stack to keep track of the levels of predicate calls. In the case of a recursive predicate, the stack grows at each recursive call. The stack could easily be consumed in a short period of time by the recursive control structure.</p>
        <p>Fortunately, there is a performance feature built into most Prologs that makes these programs behave efficiently.</p>
        <section>
          <h3>Tail Recursion</h3>
          <p>There are actually two kinds of recursive routines. In a true recursive routine, each level must wait for the information from the lower levels in order to return an answer. This means that Prolog must build a stack with a new entry for each level.</p>
          <p>This is in contrast to iteration, which is more common in conventional languages. Each pass through the iteration updates the variables and there is no need for building a stack.</p>
          <p>There is a type of recursion called <dfn>tail recursion</dfn> that, while written recursively, behaves iteratively. In general, if the recursive call is the last call, and there are no computations based on the information from the lower levels, then a good Prolog interpreter can implement the predicate iteratively, without growing the stack.</p>
          <p>One classic example of tail recursion is the factorial predicate. First we'll write it using normal recursion. Note that the variable <var>FF</var>, which is returned from the lower level, is used in the top level.</p>
          <pre>factorial_1 (1,1).
factorial_1 (N,F):-
  N &gt; 1,
  NN is N - 1,
  factorial_1 (NN,FF),
  F is N * FF.</pre>
          <p>It works as expected.</p>
          <pre>?- factorial_1 (5,X).
x = 120</pre>
          <p>By introducing a new second argument to keep track of the result so far, we can rewrite factorial tail-recursively. The new argument is initially set to 1. Each recursive call builds on the second argument. When the boundary condition is reached, the third argument is bound to the second argument.</p>
          <pre>factorial_2(1,F,F).
factorial_2(N, T, F) :-
  N &gt;1,
  TT is N * T,
  NN is N - 1,
  factorial_2(N N, TT, F).</pre>
          <p>It gives the same results as the previous version, but because the recursive call is the last call in the second clause, its arguments are not needed at each level.</p>
          <pre>7- factorial_2(5,1,X).
x = 120</pre>
          <!-- <p class="bridgehead"/> -->
          <p>By introducing a new second argument which will accumulate the partial answer through levels of recursion, we can rewrite reverse. It turns out that the partial answer is already reversed when it reaches the boundary condition.</p>
          <pre>reverse{[], Rev, Rev).
reverse([HIT], Temp, Rev) :-
  reverse(T ,[H ITemp], Rev).</pre>
          <p>We can now try the second reverse.</p>
          <pre>?- reverse([ants, mice, zebras], [], X).
X = [zebras, mice, ants]</pre>
        </section>
      </section>
      <section>
        <h2>Abstract Data Types and Search</h2>
        <section id="recursion_based_graph_search">
          <h3>Recursion-Based Graph Search</h3>
          <p>We next introduce the 3 x 3 knight's tour problem, create a predicate calculus based representation of problem states, and a recursive search of its state space. The chess knight can move on a restricted board as on any regular chessboard: two squares one direction (horizontally or vertically) and one in the other (vertically or horizontally). Thus, the knight can go from square 1 to either square 6 or 8 or from square 9 to either 2 or 4. We ask if the knight can generate a sequence on legal moves from one square to another on this restricted chessboard, from square 1 to 9, for example. The knight's moves are represented in Prolog using <kbd>move</kbd> facts.</p>
          <p>The <kbd>path</kbd> predicate defines an algorithm for a path between its two arguments, the present state, X, and the goal that it wants to achieve, Y. To do this it first tests whether it is where it wants to be, <kbd>path(Z, Z)</kbd>, and if not, looks for a state, W, to move to.</p>
          <p>The Prolog search defined by <kbd>path</kbd> is a recursive, depth-first, left-to-right, tree walk. As shown before, <kbd>assert</kbd> is a built-in Prolog predicate that always succeeds and has the side effect of placing its argument in the database of specifications. The <kbd>been</kbd> predicate is used to record each state as it is visited and then <kbd>not(been(X))</kbd> determines, with each new state found whether that state has been previously visited, thus avoiding looping within the search space.</p>
          <pre>path(Z, Z).
path(X, Y) :-
  move(X, W), not(been(W)), assert(been(W)),
  path(W, Y).</pre>
          <p>This use of the <kbd>been</kbd> predicate violates good programming practice in that it uses global side-effects to control search. <kbd>been(3)</kbd>, when asserted into the database, is a fact available to any other predicate and, as such, has global extension. We created <kbd>been</kbd> to modify the program execution.</p>
          <p>A more sophisticated method for control of search is to create a list that keeps track of visited states. We create this list and make it the third argument of the <kbd>path</kbd> predicate. As each new state is encountered, the <kbd><a href="#member_in_prolog">member</a></kbd> predicate<?see Section 2.3,?> checks whether or not it is already a visited state. If the state is not a member of the list we put it on this list in the order in which it was encountered, the most recent state encountered the head of the list. If the new state is on the list of already visited states, the path predicate backtracks looking for new non-visited states. This approach remedies the problems of using global <kbd>been(W)</kbd>. The following clauses implement depth-first left-to right graph search with backtracking.</p>
          <pre>path(Z, Z, L).
path(X, Y, L) :-
  move(X, Z), not(member(Z, L)),
  path(Z, Y, [Z|L]).</pre>
          <para/>
        </section>
        <section id="ADTs_in_Prolog">
          <h3>Abstract Data Types in Prolog</h3>
          <?source Luger and Stubblefield: <citetitle class='book'>Algorithms, Data Structures, and Idioms in Prolog, Lisp, and Java</citetitle>, Pearson 2009?>
          <p>Programming, in almost any environment, is enhanced by creating procedural abstractions and by hiding information. Because the set, stack, queue, and priority queue data structures are important support constructs for graph search algorithms, a major component of AI problem solving, we build them in Prolog in the present section.<?see We will use these ADTs in the design of the Prolog search algorithms presented in Chapter 4.?</p>>
          <p>Since lists, recursion, and pattern matching are the primary tools for building and searching graph structures, they are the pieces with which we build our ADTs. All list handling and recursive processing that define the ADT are <q>hidden</q> within the ADT abstraction, quite different than the normal static data structure.</p>
          <section>
        <h4>The Stack ADT in Prolog</h4>
            <p>A stack is a linear structure with access at one end only. Thus all elements must be added to, <dfn>pushed</dfn>, and removed, <dfn>popped</dfn>, from the structure at that access end. The stack is sometimes referred to as a <dfn>last-in-first-out</dfn> (LIFO) data structure. We will see its use with depth-first search<?see in Chapter 4?>. The operators that we will define for a stack are:</p>
          <ul>
            <li>1. Test whether the stack is empty.</li>
            <li>2. Push an element onto the stack.</li>
            <li>3. Pop or remove, the top element from the stack.</li>
            <li>4. Peek (often called Top) to see the top element on the stack without popping it.</li>
            <li>5. Member_stack, checks whether an element is in the stack.</li>
            <li>6. Add_list_to stack, adds a list of elements to the stack.</li>
          </ul>
          <note>Operators 5 and 6 may be built from 1&#x2013;4.</note>
          <p>We now build these operators in Prolog, using the list primitives:</p>
          <ul>
            <li>
              <p>1. <kbd>empty_stack([]).</kbd></p>
              <p>This predicate can be used either to test a stack to see whether it is empty or to generate a new empty stack.</p>
            </li>
            <li>
              <p>2&#x2013;4. <kbd>stack(Top, Stack, [Top | Stack]).</kbd></p>
              <p>This predicate performs the push, pop, and peek predicates depending on the variable bindings of its arguments. For instance, push produces a new stack as the third argument when the first two arguments are bound. Likewise, pop produces the top element of the stack when the third argument is bound to the stack. The second argument will then be bound to the new stack, once the top element is popped. Finally, if we keep the stack as the third argument, the first argument lets us peek at its top element.</p>
            </li>
            <li>
              <p>5. <kbd>member_stack(Element, Stack) :- member(Element, Stack).</kbd></p>
              <p>This allows us to determine whether an element is a member of the stack. Of course, the same result could be produced by creating a recursive call that peeked at the next element of the stack and then, if this element did not match Element, popped the stack. This would continue until the empty stack predicate was true.</p>
            </li>
            <li>
              <p>6. <kbd>add_list_to_stack(List, Stack, Result) :- append(List, Stack, Result).</kbd></p>
              <p>List is added to Stack to produce Result, a new stack. Of course, the same result could be obtained by popping List (until empty) and pushing each element onto a temporary stack. We would then pop the temporary stack and push each element onto the Stack until empty_stack is true for the temporary stack.</p>
            </li>
          </ul>
          <p>A final predicate for printing a stack in reverse order is <code class="function">reverse_print_stack</code>. This is very useful when a stack has, in reversed order, the current path from the start state to the present state of the graph search.</p>
          <pre>reverse_print_stack(S) :-
  empty_stack(S).
reverse_print_stack(S) :-
  stack(E, Rest, S),
  reverse_print_stack(Rest),
  write(E), nl.</pre>
        </section>
        <section>
          <h4>The Queue ADT in Prolog</h4>
          <p>A queue is a first-in-first-out (FIFO) data structure. It is often characterized as a list where elements are taken off or dequeued from one end and elements are added to or enqueued at the other end. The queue is used for defining breadth-first search.</p>
          <p>The queue operators are:</p>
          <ul>
            <li>
              <p>1. <kbd>empty_queue([]).</kbd></p>
              <p>This predicate tests whether a queue is empty or initializes a new empty queue.</p>
            </li>
            <li>
              <p>2.</p>
              <pre>enqueue(E, [ ], [E]).
enqueue(E, [H | T], [H | Tnew]) :-
enqueue(E, T, Tnew).</pre>
              <p>This recursive predicate adds the element E to a queue, the second argument. The new augmented queue is the third argument.</p>
            </li>
            <li>
              <p>3. <kbd>dequeue(E, [E|T], T).</kbd></p>
              <p>This predicate produces a new queue, the third argument, which is the result of taking the next element, the first argument, off the original queue, the second argument.</p>
            </li>
            <li>
              <p>4. <kbd>dequeue(E, [E|T], _).</kbd></p>
              <p>This predicate lets us peek at the next element, E, of the queue.</p>
            </li>
            <li>
              <p>5. <kbd>member_queue(Element, Queue) :- member(Element, Queue).</kbd></p>
              <p>This tests whether Element is a member of Queue.</p>
            </li>
            <li>
              <p>6. <kbd>add_list_to_queue(List, Queue, Newqueue) :- append(Queue, List, Newqueue).</kbd></p>
              <p>This predicate enqueues an entire list of elements. Of course, 5 and 6 can be created using 1&#x2013;4.</p>
            </li>
          </ul>
        </section>
        <section>
          <h4>The Priority Queue ADT in Prolog</h4>
          <p>A priority queue orders the elements of a regular queue so that each new element added to the priority queue is placed in its sorted order, with the <q>best</q> element first. The <code class="function">dequeue</code> operator removes the <q>best</q> sorted element from the priority queue. We will use the priority queue in the design of the best-first search algorithm<?see in Chapter 4?>.</p>
          <p>Because the priority queue is a sorted queue, many of its operators are the same as the queue operators, in particular, <code class="function">empty_queue</code>, <code class="function">member_queue</code>, and <code class="function">dequeue</code> (the <q>best</q> of the sorted elements will be next for the dequeue). <code class="function">enqueue</code> in a priority queue is the <code class="function">insert_pq operator</code>, as each new item is placed in its proper sorted order.</p>
          <pre>insert_pq(State, [ ], [State]) :- !.
insert_pq(State, [H | Tail], [State, H | Tail]) :-
  precedes(State, H).
insert_pq(State, [H | T], [H | Tnew]) :-
  insert_pq(State, T, Tnew).
precedes(X, Y) :- X &lt; Y. % &lt; depends on problem</pre>
          <p>The first argument of this predicate is the new element that is to be inserted. The second argument is the previous priority queue, and the third argument is the augmented priority queue. The <code class="function">precedes</code> predicate checks that the order of elements is preserved.</p>
          <p>Another priority queue operator is <code class="function">insert_list_pq</code>. This predicate is used to merge an unsorted list or set of elements into the priority queue, as is necessary when adding the children of a state to the priority queue for best-first search<?see Chapter 4?>. <code class="function">insert_list_pq</code> uses <code class="function">insert_pq</code> to put each individual new item into the priority queue:</p>
          <pre>insert_list_pq([ ], L, L).
insert_list_pq([State | Tail], L, New_L) :-
  insert_pq(State, L, L2),
  insert_list_pq(Tail, L2, New_L).</pre>
        </section>
        <section>
          <h4>The Set ADT in Prolog</h4>
          <p>A set is a collection of elements with no element repeated. Sets can be used for collecting all the children of a state or for maintaining the set of all states visited while executing a search algorithm.</p>
          <p>In Prolog a set of elements, e.g., {a,b}, may be represented as a list, <kbd>[a,b]</kbd>, with the order of the list not important. The set operators include <code class="function">empty_set</code>, <code class="function">member_set</code>, <code class="function">delete_if_in</code>, and <code class="function">add_if_not_in</code>. We also include the traditional operators for combining and comparing sets, including <code class="function">union</code>, <code class="function">intersection</code>, <code class="function">set_difference</code>, <code class="function">subset</code>, and <code class="function">equal_set</code>.</p>
          <pre>empty_set([ ]).
member_set(E, S) :-
  member(E, S).
delete_if_in_set(E, [ ], [ ]).
delete_if_in_set(E, [E | T], T) :- !.
delete_if_in_set(E, [H | T], [H | T_new]) :-
  delete_if_in_set(E, T, T_new), !.
add_if_not_in_set(X, S, S) :-
  member(X, S), !.
add_if_not_in_set(X, S, [X | S]).
union([ ], S, S).
union([H | T], S, S_new) :-
  union(T, S, S2),
add_if_not_in_set(H, S2, S_new),!.
subset([], _).
subset([H | T], S) :-
  member_set(H, S),
subset(T, S).
intersection([], _, []).
intersection([H | T], S, [H | S_new]) :-
  member_set(H, S),
  intersection(T, S, S_new), !.
intersection([_ | T], S, S_new) :-
  intersection(T, S, S_new), !.
set_difference([ ], _, [ ]).
set_difference([H | T], S, T_new) :-
  member_set(H, S),
  set_difference(T, S, T_new), !.
set_difference([H | T], S, [H | T_new]) :-
  set_difference(T, S, T_new), !.
equal_set(S1, S2) :-
  subset(S1, S2),
  subset(S2, S1).</pre>
          <p><?see In Chapters 4 and 5 ?>we use many of these abstract data types to build more complex graph search algorithms and meta-interpreters in Prolog. For example, the stack and queue ADTs are used to build the <q>open</q> list that organizes depth-first and breadth-first search. The set ADTs coordinate the <q>closed</q> list that helps prevent cycles in a search.</p>
        </section>
      </section>
      <!-- end of "Abstract Data Types in Prolog" -->
      <!--</section>-->
      <!-- end of "Abstract Data Types and Search" -->
      <section>
        <h2>Depth-, Breadth-, and Best-First Search Using the Production System Design Pattern</h2>
        <section>
          <h3>Production System Search in Prolog</h3>
          <p>The <dfn>production system</dfn> <?see Luger 2009, Section 6.2?> is a model of computation that has proved particularly important in AI, both for implementing search algorithms and for modeling human problem solving behavior. A production system provides pattern-directed control of a problem-solving process and consists of a set of production rules, a working memory, and a recognize&#x2013;act control cycle.</p>
          <p>A production system is defined by:</p>
          <dl>
            <!-- <varlistentry> -->
            <dt>The set of production rules</dt>
            <dd>These are often simply called productions. A production is a condition&#x2013;action pair and defines a single chunk of problem-solving knowledge. The condition part of the rule is a pattern that determines when that rule may be applied by matching data in the working memory. The action part of the rule defines the associated problem-solving step.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>Working memory</dt>
            <dd>Working memory contains a description of the current state of the world in a reasoning process. This description is a pattern that, in data-driven reasoning, is matched against the condition part of a production to select appropriate problem-solving actions. The actions of production rules are specifically designed to alter the contents of working memory, leading to the next phase of the recognize-act cycle.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>The recognize&#x2013;act cycle</dt>
            <dd>The control structure for a production system is simple: working memory is initialized with the beginning problem description. The current state of the problem solving is maintained as a set of patterns in working memory. These patterns are matched against the conditions of the production rules; this produces a subset of the production rules, called the <dfn>conflict set</dfn>, whose conditions match the patterns in working memory. One of the productions in the conflict set is then selected (<dfn>conflict resolution</dfn>) and the production is fired. After the selected production rule is fired, the control cycle repeats with the modified working memory. The process terminates when the contents of working memory do not match any rule conditions.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
            <dt>Conflict resolution</dt>
            <dd>Conflict resolution chooses a rule from the conflict set for firing. Conflict resolution strategies may be simple, such as selecting the first rule whose condition matches the state of the world, or may involve complex rule selection heuristics. The pure production system model has no mechanism for recovering from dead ends in the search; it simply continues until no more productions are enabled and halts. Many practical implementations of production systems allow backtracking to a previous state of working memory in such situations.<?see A schematic drawing of a production system is presented in Figure 4.1.?></dd>
            <!-- </varlistentry> -->
          </dl>
          <section>
            <h4>Example: The Knight's Tour Revisited</h4>
            <p>The 3 x 3 knight's tour problem may be solved with a production system. Each move can be represented as a rule whose condition is the location of the knight on a particular square and whose action moves the knight to another square. Sixteen productions represent all possible moves of the knight.</p>
            <p>We next specify a recursive procedure to implement a control algorithm for the production system. We will use the <a href="#recursion_based_graph_search">recursive path algorithm</a><?see of Section 3.1?>, where the third argument of the path predicate is the list of already visited states. Because <kbd>path(Z, Z, L)</kbd> will unify only with predicates whose first two arguments are identical, such as <kbd>path(3, 3, _)</kbd> or <kbd>path(5, 5, _)</kbd>, it defines the desired terminating condition. If <kbd>path(X, X, L)</kbd> does not succeed we look at the production rules for a next state and then recur.</p>
            <p>The general recursive path definition is given by two predicate calculus formulas:</p>
            <pre>path(Z, Z, L).
path(X, Y, L) :-
  move(X, Z), not(member(Z, L)),
  path(Z, Y, [Z | L]).</pre>
            <p>Working memory, represented by the parameters of the recursive path predicate, contains both the current board state and the goal state. The control regime applies rules until the current state equals the goal state and then halts. A simple conflict resolution scheme would fire the first rule that did not cause the search to loop. Because the search may lead to dead ends (from which every possible move leads to a previously visited state and thus a loop), the control regime must also allow backtracking<?see ; an execution of this production system that determines whether a path exists from square 1 to square 2 is charted in Table 4.2?>.</p>
            <p>Production systems are capable of generating infinite loops when searching a state space graph. These loops are particularly difficult to spot in a production system because the rules can fire in any order. That is, looping may appear in the execution of the system, but it cannot easily be found from a syntactic inspection of the rule set.</p>
          </section>
        </section>
        <section id="the_wolf_goat_cabbage_problem">
          <h3>A Production System Solution to the Farmer, Wolf, Goat, Cabbage Problem*</h3>
        </section>
        <section>
          <h3>Designing Alternative Search Strategies</h3>
          <p>As <?see the previous subsection ?>demonstrated, Prolog itself uses depth-first search with backtracking. We now show how alternative search strategies can be implemented in Prolog. Our implementations of depth-first, breadth-first, and best-first search use open and closed lists to record states in the search. The open list contains all potential next states in the search. How the open list is maintained, as a stack, as a queue, or as a priority queue, determines which particular state is next, that is, search is in either depth-first, breadth-first, or as best-first modes. The closed set keeps track of all the states that have been previously visited, and is used primarily to prevent looping in the graph as well as to keep track of the current path through the space.<?see The details of how the open and closed data structures organize a search space can be found in Luger (2009, Chapter 3 and 4).?> When search fails at any point we do not backtrack. Instead, open and closed are updated within the path call and the search continues with these revised values. The cut is used to keep Prolog from storing the old versions of the open and closed lists.</p>
          <section id="depth-first_search_in_prolog">
            <h4>Implementing Depth-first Search in Prolog</h4>
            <p>Because the values of variables are restored when recursion backtracks, the list of visited states in the depth-first path algorithm of the previous section records states only if they are on the current path to the goal. Although testing each <q>new</q> state for membership in this list prevents loops, it still allows branches of the space to be reexamined if they are reached along paths generated earlier but abandoned at that time as unfruitful. A more efficient implementation keeps track of all the states that have ever been encountered. This more complete collection of states made up the members of the set we call <dfn>closed</dfn><?see see Luger 2009, Chapter 3?>, and <kbd>Closed_set</kbd> in the following algorithm.</p>
            <p><kbd>Closed_set</kbd> holds all states on the current path plus the states that were rejected when the algorithm determined they had no usable children; thus, it no longer represents the path from the start to the current state. To capture this path information, we create the ordered pair <kbd>[State, Parent]</kbd> to keep track of each state and its parent; the Start state is represented by <kbd>[Start, nil]</kbd>. These state&#x2013;parent pairs will be used to re-create the solution path from the <kbd>Closed_set</kbd>.</p>
            <p>We now present a shell structure for depth-first search in Prolog, keeping track of both open and closed and checking each new state to be sure it was not previously visited. <kbd>path</kbd> has three arguments, <kbd>the Open_stack</kbd>, <kbd>Closed_set</kbd>, maintained as a set, and the <kbd>Goal state</kbd>. The current state, <kbd>State</kbd>, is the next state on the <kbd>Open_stack</kbd>. The stack and set operators are discussed <a href="#ADTs_in_Prolog">here</a>.</p>
            <p>Search starts by calling a <kbd>go</kbd> predicate that initializes the <kbd>path</kbd> call. Note that <kbd>go</kbd> places the <kbd>Start</kbd> state with the <kbd>nil</kbd> parent, <kbd>[Start, nil]</kbd>, alone on <kbd>Open_stack</kbd>; the <kbd>Closed_set</kbd> is empty:</p>
            <pre>go(Start, Goal) :-
  empty_stack(Empty_open),
  stack([Start, nil], Empty_open, Open_stack),
  empty_set(Closed_set),
  path(Open_stack, Closed_set, Goal).</pre>
            <p>The three-argument <kbd>path</kbd> call is:</p>
            <pre>path(Open_stack, _, _) :-
  empty_stack(Open_stack),
  write(&#x2019;No solution found with these rules&#x2019;).
path(Open_stack, Closed_set, Goal) :-
  stack([State, Parent], _, Open_stack),
  State = Goal,
  write(`A Solution is Found!&#x2019;), nl,
  printsolution([State, Parent], Closed_set).
path(Open_stack, Closed_set, Goal) :-
  stack([State, Parent], Rest_open_stack, Open_stack),
  get_children(State, Rest_open_stack, Closed_set, Children),
  add_list_to_stack(Children, Rest_open_stack, New_open_stack),
  union([[State, Parent]], Closed_set, New_closed_set),
  path(New_open_stack, New_closed_set, Goal), !.
get_children(State, Rest_open_stack, Closed_set, Children) :-
  bagof(Child, moves(State, Rest_open_stack, Closed_set, Child), Children).
moves(State, Rest_open_stack, Closed_set, [Next, State]) :-
  move(State, Next),
  not(unsafe(Next)), % test depends on problem
  not(member_stack([Next,_], Rest_open_stack)),
  not(member_set([Next,_], Closed_set)).</pre>
            <p>We assume a set of <kbd>move</kbd> rules appropriate to the problem, and, if necessary, an <kbd>unsafe</kbd> predicate:</p>
            <pre>move(Present_state, Next_state) :- ... % test rules
move(Present_state, Next_state) :- ...
...</pre>
            <p>The first <kbd>path</kbd> call terminates search when the <kbd>Open_stack</kbd> is empty, which means there are no more states on the open list to continue the search. This usually indicates that the graph has been exhaustively searched. The second <kbd>path</kbd> call terminates and prints out the solution path when the solution is found. Since the states of the graph search are maintained as <kbd>[State, Parent]</kbd> pairs, <kbd>printsolution</kbd> will go to the <kbd>Closed_set</kbd> and recursively rebuild the solution path. Note that the solution is printed from start to goal.</p>
            <pre>printsolution([State, nil], _) :- write(State), nl.
printsolution([State, Parent], Closed_set) :-
  member_set([Parent, Grandparent], Closed_set),
  printsolution([Parent, Grandparent], Closed_set),
  write(State), nl.</pre>
            <section id="bagof_and_moves_in_Prolog">
              <h5>Predicates <kbd>bagof</kbd> and <kbd>moves</kbd></h5>
              <p>The third path call uses <kbd>bagof</kbd>, a Prolog built-in predicate standard to most interpreters. <kbd>bagof</kbd> lets us gather all the unifications of a pattern into a single list. The second parameter to <kbd>bagof</kbd> is the pattern predicate to be matched in the database. The first parameter specifies the components of the second parameter that we wish to collect. For example, we may be interested in the values bound to a single variable of a predicate. All bindings of the first parameter resulting from these matches are collected in a list, the <dfn>bag</dfn>, and bound to the third parameter.</p>
              <p>In this program, <kbd>bagof</kbd> collects the states reached by firing all of the enabled production rules. Of course, this is necessary to gather all descendants of a particular state so that we can add them, in proper order, to open. The second argument of <kbd>bagof</kbd>, a new predicate named <kbd>moves</kbd>, calls the <kbd>move</kbd> predicates to generate all the states that may be reached using the production rules. The arguments to <kbd>moves</kbd> are the present state, the open list, the closed set, and a variable that is the state reached by a good move. Before returning this state, moves checks that the new state, <kbd>Next</kbd>, is not a member of either <kbd>rest_open_stack</kbd>, <kbd>open</kbd> once the present state is removed, or <kbd>closed_set</kbd>. <kbd>bagof</kbd> calls <kbd>moves</kbd> and collects all the states that meet these conditions. The third argument of <kbd>bagof</kbd> represents the new states that are to be placed on the <kbd>Open_stack</kbd>.</p>
              <p>For some Prolog interpreters, <kbd>bagof</kbd> fails when no matches exist for the second argument and thus the third argument, <kbd>List</kbd>, is empty. This can be remedied by substituting <kbd>(bagof(X, moves(S, T, C, X), List); List = [ ])</kbd> for the current calls to <kbd>bagof</kbd> in the code.</p>
              <p>Finally, because the states of the search are represented as state&#x2013;parent pairs, member check predicates, e.g., <kbd>member_set</kbd>, must be revised to reflect the structure of pattern matching. We test if a state&#x2013;parent pair is identical to the first element of the list of state&#x2013;parent pairs and then recur if it isn't:</p>
              <pre>member_set([State, Parent], [[State, Parent]|_]).
member_set(X, [_|T]) :- member_set(X, T).</pre>
            </section>
          </section>
          <section id="breadth-first_search_in_prolog">
            <h4>Implementing Breadth-first Search in Prolog</h4>
            <p>We now present the <em>shell</em> of an algorithm for breadth-first search using explicit open and closed lists. This algorithm is called by:</p>
            <pre>go(Start, Goal) :-
  empty_queue(Empty_open_queue),
  enqueue([Start, nil], Empty_open_queue, Open_queue),
  empty_set(Closed_set),
  path(Open_queue, Closed_set, Goal).</pre>
            <p><kbd>Start</kbd> and <kbd>Goal</kbd> have their obvious values. The shell can be used with the move rules and unsafe predicates for any search problem. Again we create the ordered pair <kbd>[State, Parent]</kbd>, as we did with depth-first search, to keep track of each state and its parent; the start state is represented by <kbd>[Start, nil]</kbd>. This will be used by <kbd>printsolution</kbd> to re-create the solution path from the <kbd>Closed_set</kbd>. The first parameter of path is the <kbd>Open_queue</kbd>, the second is the <kbd>Closed_set</kbd>, and the third is the <kbd>Goal</kbd>. Don't care variables, those whose values are not used in a clause, are written as <q><kbd>_</kbd></q>.</p>
            <pre>path(Open_queue, _, _) :-
  empty_queue(Open_queue),
  write(&#x2019;Graph searched, no solution found.&#x2019;).
path(Open_queue, Closed_set, Goal) :-
  dequeue([State, Parent], Open_queue, _),
  State = Goal,
  write(&#x2019;Solution path is: &#x2018;), nl,
  printsolution([State, Parent], Closed_set).
path(Open_queue, Closed_set, Goal) :-
  dequeue([State, Parent], Open_queue, Rest_open_queue),
  get_children(State, Rest_open_queue, Closed_set, Children),
  add_list_to_queue(Children, Rest_open_queue, New_open_queue),
  union([[State, Parent]], Closed_set, New_closed_set),
  path(New_open_queue, New_closed_set, Goal), !.
get_children(State, Rest_open_queue, Closed_set, Children) :-
  bagof(Child, moves(State, Rest_open_queue, Closed_set, Child), Children).
moves(State, Rest_open_queue, Closed_set, [Next, State]) :-
  move(State, Next),
  not(unsafe(Next)), %test depends on problem
  not(member_queue([Next,_], Rest_open_queue)),
  not(member_set([Next,_], Closed_set)).</pre>
            <p>This algorithm is a shell in that no <kbd>move</kbd> rules are given. These must be supplied to fit the specific problem domain, such as the <a href="#the_wolf_goat_cabbage_problem">FWGC problem</a>. The queue and set operators have been described <a href="#ADTs_in_Prolog">here</a>.</p>
            <p>The first path termination condition is defined for the case that <kbd>path</kbd> is called with its first argument, <kbd>Open_queue</kbd>, empty. This happens only when no more states in the graph remain to be searched and the solution has not been found. A solution is found in the second <kbd>path</kbd> predicate when the head of the <kbd>open_queue</kbd> and the <kbd>Goal</kbd> state are identical. When <kbd>path</kbd> does not terminate, the third call, with <kbd>bagof</kbd> and <kbd>moves</kbd> predicates, gathers all the children of the current state and maintains the queue. (The detailed actions of these two predicates have been described <a href="#bagof_and_moves_in_Prolog">here</a>.) In order to recreate the solution path, we saved each state as a state&#x2013;parent pair, <kbd>[State, Parent]</kbd>. The start state has the parent <kbd>nil</kbd>. As already noted, the state&#x2013;parent pair representation makes necessary a slightly more complex pattern matching in the member, <kbd>moves</kbd>, and <kbd>printsolution</kbd> predicates.</p>
          </section>
          <section id="best-first_search_in_prolog">
            <h4>Implementing Best-first Search in Prolog</h4>
            <p>Our shell for best-first search is a modification of the <a href="#depth-first_search_in_prolog">breadth-first algorithm</a> in which the open queue is replaced by a priority queue, ordered by heuristic merit, which supplies the current state for each new call to <kbd>path</kbd>. In our algorithm, we attach a heuristic measure permanently to each new state on open and use this measure for ordering the states on open. We also retain the parent of each state. This information is used by <kbd>printsolution</kbd>, as in depth- and breadth-first search, to build the solution path once the goal is found.</p>
            <p>To keep track of all required search information, each state is represented as a list of five elements: the state description, the parent of the state, an integer giving the depth in the graph of the state's discovery, an integer giving the heuristic measure of the state, and the integer sum of the third and fourth elements. The first and second elements are found in the usual way; the third is determined by adding one to the depth of its parent; the fourth is determined by the heuristic measure of the particular problem. The fifth element, used for ordering the states on the <kbd>open_pq</kbd>, is <kbd>f(n) = g(n) + h(n)</kbd>. A justification for using this approach to order states for heuristic search, usually referred to as the <dfn>A Algorithm</dfn>, is presented in Luger (2009, Chapter 4).</p>
            <p>As before, the move rules are not specified; they are defined to fit the specific problem. The ADT operators for set and priority queue are presented in the section on <a href="#ADTs_in_Prolog">ADTs</a>. heuristic, also specific to each problem, is a measure applied to each state to determine its heuristic weight, the value of the fourth parameter in its descriptive list.</p>
            <p>This best-first search algorithm has two termination conditions and is called by:</p>
            <pre>go(Start, Goal) :-
  empty_set(Closed_set),
  empty_pq(Open),
  heuristic(Start, Goal, H),
  insert_pq([Start, nil, 0, H, H], Open, Open_pq),
  path(Open_pq, Closed_set, Goal).</pre>
            <p><kbd>nil</kbd> is the parent of <kbd>Start</kbd> and <kbd>H</kbd> is its heuristic evaluation. The code for best-first search is:</p>
            <pre>path(Open_pq, _,_) :-
  empty_pq(Open_pq),
  write(&#x2019;Graph searched, no solution found.&#x2019;).

path(Open_pq, Closed_set, Goal) :-
  dequeue_pq([State, Parent, _, _, _], Open_pq,_),
  State = Goal,
  write(&#x2019;The solution path is: &#x2018;), nl,
  printsolution([State, Parent, _, _, _], Closed_set).
path(Open_pq, Closed_set, Goal) :-
  dequeue_pq([State, Parent, D, H, S], Open_pq, Rest_open_pq),
  get_children([State, Parent, D, H, S], Rest_open_pq, Closed_set, Children, Goal),
  insert_list_pq(Children, Rest_open_pq, New_open_pq),
  union([[State, Parent, D, H, S]], Closed_set, New_closed_set),
  path(New_open_pq, New_closed_set, Goal), !.</pre>
            <p><kbd>get_children</kbd> is a predicate that generates all the children of <kbd>State</kbd>. It uses <kbd>bagof</kbd> and <kbd>moves</kbd> predicates as in the previous searches, with details earlier this section. A set of <kbd>move</kbd> rules, a <kbd>safe</kbd> check for legal moves, and a <kbd>heuristic</kbd> must be specifically defined for each application. The <kbd>member</kbd> check must be specifically designed for five element lists.</p>
            <pre>get_children([State,_,D,_, _],Rest_open_pq, Closed_set,Children,Goal) :-
bagof(Child, moves([State, _, D, _, _],
Rest_open_pq, Closed_set, Child,Goal),
Children).
moves([State, _, Depth, _, _], Rest_open_pq, Closed_set,[Next,State,New_D,H,S], Goal) :-
move(State, Next),
not(unsafe(Next)),
% application specific
not(member_pq([Next, _, _, _, _],Rest_open_pq)),
not(member_set([Next, _, _, _, _],Closed_set)),
New_D is Depth + 1,
heuristic(Next, Goal, H), % application specific
S is New_D + H.</pre>
            <p><kbd>printsolution</kbd> prints the solution path, recursively finding state&#x2013;parent pairs by matching the first two elements in the state description with the first two elements of the five element lists that make up the <kbd>Closed_set</kbd>.</p>
            <pre>printsolution([State, nil, _, _, _], _) :-
  write(State), nl.
printsolution([State, Parent, _, _, _], Closed_set):-
  member_set([Parent, Grandparent, _, _, _], Closed_set),
  printsolution([Parent, Grandparent, _, _, _], Closed_set),
  write(State), nl.</pre>
            <?see In Chapter 5 we further generalize the approach taken so far in that we present a set of built-in Prolog meta-predicates, predicates like bagof, that explicitly manipulate other Prolog predicates. This will set the stage for creating meta-interpreters in Chapter 6.?>
          </section>
        </section>
      </section>
      <section>
        <h2>Special or Advanced Topics in Prolog</h2>
        <section>
          <h3>The Effect of Rule and Goal Ordering</h3>
          <p>Two syntactic issues, irrelevant for logic programs, are important to consider when composing Prolog programs. The rule order, or clause order, of clauses in each procedure must be decided. Also the goal order of goals in the bodies of each clause must be determined. The consequences of these decisions can be immense. There can be orders of magnitude of difference in efficiency in the performance of Prolog programs. In extreme though quite common cases, correct logic programs will fail to give solutions because of <a href="#nontermination_in_prolog">nontermination</a>.</p>
          <blockquote>The rule order determines the order in which solutions are found.</blockquote>
          <p>Changing the order of rules in a procedure permutes the branches in any search tree for a goal using that procedure. The search tree is traversed depth-first. So permuting the branches causes a different order of traversal of the search tree, and a different order of finding solutions.</p>
          <section>
            <h4>The Effect of Goal Order in Prolog</h4>
            <p>Goal order is more significant than clause order. It is the principal means of specifying sequential flow of control in Prolog programs.</p>
            <p>We first discuss goal order from the perspective of database programming. The reason that the order of goals in the body of a clause affects the order of solutions to a query is different from the reason that the order of rules in a procedure affects the solution order. Changing rule order does not change the search tree that must be traversed for a given query. The tree is just traversed in a different order. Changing goal order changes the search tree.</p>
            <blockquote>Goal order determines the search tree.</blockquote>
            <p>Goal order affects the amount of searching the program does in solving a query by determining which search tree is traversed.</p>
            <p>The optimal goal order of Prolog programs varies with different uses. Consider the definition of grandparent. There are two possible rules:</p>
            <pre>grandparent(X,Z) :- parent(X,Y), parent(Y,Z),
grandparent(X,Z) :- parent(Y,Z), parent(X,Y).</pre>
            <p>If you wish to find someone's grandson with the <kbd>grandfather/2</kbd> relationship with a query such as <kbd>grandparent (abraham, X)?</kbd>, the first of the rules searches more directly. If looking for someone's grandparent with a query such as <kbd>grandparent (X, isaac) ?</kbd>, the second rule finds the solution more directly. If efficiency is important, then it is advisable to have two distinct relationships, grandparent and grandchild, to be used appropriately at the user's discretion.</p>
            <p>In contrast to rule order, goal order can determine whether computations terminate. Consider the recursive rule for ancestor:</p>
            <pre>ancestor(X,Y) :- parent(X, Z), ancestor(Z,Y).</pre>
            <p>If the goals in the body are swapped, the ancestor program becomes left recursive, and all Prolog computations with ancestor are nonterminating.</p>
          </section>
        </section>
        <section id="nontermination_in_prolog">
          <h3>Non-Termination in Prolog</h3>
          <p>Nontermination arises with recursive rules. Consider a <kbd>friend/2</kbd> predicate. A sample fact would be <kbd>friend(fred,tom)</kbd>. Since this relationship is commutative, we might be tempted to add a rule like <kbd>friend(X,Y) :- friend(Y,X).</kbd>. But if we do so, then no computation involving <kbd>friend/2</kbd> would ever terminate.</p>
          <p>Recursive rules that have the recursive goal as the first goal in the body are known as <dfn>left recursive</dfn> rules. The foregoing rule is an example. Left recursive rules are inherently troublesome in Prolog. They cause nonterminating computations if called with inappropriate arguments.</p>
          <p>The best solution to the problem of left recursion is avoidance. Commutative relationships are best handled differently, by defining a new predicate that has a clause for each permutation of the arguments of the relationship. We might define the relationship <kbd>friend/2</kbd> as a rule whose goals are made up of <kbd>befriend</kbd> predicate, the one used in stating facts about friendship. Thus:</p>
          <pre>befriend(fred, tom).
friend(X,Y) :- befriend(X,Y).
friend(X,Y) :- befriend(Y,X).</pre>
          <p>Unfortunately, it is not generally possible to remove all occurrences of left recursion...</p>
        </section>
      </section>

      <section>
        <h2>Binding to C</h2>
        <p>The nature of this interaction with Prolog dictates the nature of a C to Prolog interface. It too must be able to either execute compiled Prolog code, or query a loaded Prolog program. In this sense, the interface from C to Prolog will look more like a database API than procedural interlanguage calls.</p>
        <p>The Hello World program illustrates the Prolog to C direction of the interface as well. Note that the <kbd>write</kbd> statement has nothing to do with logic, pattern- matching, or search; it simply performs I/O. Prolog provides a number of special predicates, such as <code class="function">write</code>, which are used primarily for their side effects. It is in this area that Prolog is weaker than C.</p>
        <p>The Prolog programmer must rely on whatever special predicates a particular vendor provides with an implementation. So, for example, if a particular Prolog implementation doesn't supply the tools for accessing Windows, then it can't be used to implement Windows applications. This is where Prolog to C connections come in. They let a programmer define as many extended predicates, such as <code class="function">write</code>, as desired, to allow Prolog code access to any services accessable from C. This fundamental architecture of Prolog shapes the design of an interface between it and C. The calls from C to Prolog reflect the database nature of Prolog. The calls from Prolog to C reflect the procedural nature of C.</p>
      </section>

      <section>
        <h2>Prolog Applications</h2>
        <section id="expert_sys_in_pl">
          <h3><a href="expert-systems.html">Expert Systems</a> in Prolog</h3>
          <section>
            <h4>Asking the User</h4>
            <p>The ask predicate will have to determine from the user whether or not a given attribute-value pair is true. The program needs to be modified to specify which attributes are askable. This is easily done by making rules for those attributes that call ask.</p>
            <pre>eats(X):- ask(eats, X).
feet(X):- ask(feet, X).
wings(X):- ask(wings, X).
neck(X):- ask(neck, X).
color(X):- ask(color, X).</pre>
            <p>Now if the system has the goal of finding color(white) it will call ask, rather than look in the program. If ask(color, white) succeeds, color(white) succeeds.</p>
            <p>The simplest version of ask prompts the user with the requested attribute and value and seeks confirmation or denial of the proposed information. The code is:</p>
            <pre>ask(Attr, Val):-
write(Attr:Val),
write('? '),
read(yes).</pre>
            <p>The read will succeed if the user answers <kbd>yes</kbd>, and fail if the user types anything else. Now the program can be run without having the data built into the program. The same query to bird starts the program, but now the user is responsible for determining whether some of the attribute-values are true. The following dialog shows how the system runs:</p>
            <pre>?- bird(X).
nostrils : external_tubular? yes.
live : at_sea? yes.
bill : hooked? yes.
size : large? yes.
wings : long_narrow? yes.
color : white? yes.
X = laysan_albatross</pre>
            <p>There is a problem with this approach. If the user answered <kbd>no</kbd> to the last question, then the rule for bird(laysan_albatross) would have failed and backtracking would have caused the next rule for bird(black_footed_albatross) to be tried. The first subgoal of the new rule causes Prolog to try to prove family(albatross) again, and ask the same questions it already asked. It would be better if the system remembered the answers to questions and did not ask again.</p>
          </section>
          <section>
            <h4>Remembering the Answer</h4>
            <p>A new predicate, known/3 is used to remember the user's answers to questions. It is not specified directly in the program, but rather is dynamically asserted whenever ask gets new information from the user.</p>
            <p>Every time ask is called it first checks to see if the answer is already known to be yes or no. If it is not already known, then ask will assert it after it gets a response from the user. The three arguments to known are: yes/no, attribute, and value. The new version of ask looks like:</p>
            <pre>ask(A, V):-
  known(yes, A, V), % succeed if true
  !. % stop looking
ask(A, V):-
  known(_, A, V), % fail if false
  !,
  fail.
ask(A, V):-
  write(A:V), % ask user
  write('? : '),
  read(Y), % get the answer
  asserta(known(Y, A, V)), % remember it
  Y == yes. % succeed or fail</pre>
            <p>The cuts in the first two rules prevent ask from backtracking after it has already determined the answer.</p>
          </section>
          <section>
            <h4>Multi-valued Answers</h4>
            <p>There is another level of subtlety in the approach to known. The ask predicate now assumes that each particular attribute value pair is either true or false. This means that the user could respond with a <q>yes</q> to both color:white and color:black. In effect, we are letting the attributes be multi-valued. This might make sense for some attributes such as voice but not others such as bill, which only take a single value.</p>
            <p>The best way to handle this is to add an additional predicate to the program, which specifies the attributes that are multi-valued:</p>
            <pre>multivalued(voice).
multivalued(feed).</pre>
            <p>A new clause is now added to ask to cover the case where the attribute is not multi-valued (and therefore single-valued) and already has a different value from the one asked for. In this case ask should fail. For example, if the user has already answered yes to size - large then ask should automatically fail a request for size - small without asking the user. The new clause goes before the clause which actually asks the user:</p>
            <pre>ask(A, V):-
not multivalued(A),
known(yes, A, V2),
V \== V2,
!,
fail.</pre>
          </section>
          <section>
            <h4>Menus for the User</h4>
            <p>The user interface can further be improved by adding a menu capability that gives the user a list of possible values for an attribute. It can further enforce that the user enter a value on the menu.</p>
            <p>This can be implemented with a new predicate, menuask. It is similar to ask, but has an additional argument which contains a list of possible values for the attribute. It would be used in the program in an analogous fashion to ask:</p>
            <pre>size(X):-
  menuask(size, X, [large, plump, medium, small]).
flight(X):-
  menuask(flight, X, [ponderous, agile, flap_glide]).</pre>
            <p>The menuask predicate can be implemented using either a sophisticated windowing interface, or by simply listing the menu choices on the screen for the user. When the user returns a value it can be verified, and the user reprompted if it is not a legal value.</p>
            <p>A simple implementation would have initial clauses as in ask, and have a slightly different clause for actually asking the user. That last clause of menuask might look like:</p>
            <pre>menuask(A, V, MenuList) :-
  write('What is the value for'), write(A), write('?'), nl,
  write(MenuList), nl,
  read(X),
  check_val(X, A, V, MenuList),
  asserta( known(yes, A, X) ),
  X == V.
check_val(X, A, V, MenuList) :-
  member(X, MenuList),
  !.
check_val(X, A, V, MenuList) :-
  write(X), write(' is not a legal value, try again.'), nl,
  menuask(A, V, MenuList).</pre>
            <p>The check_val predicate validates the user's input. In this case the test ensures the user entered a value on the list. If not, it retries the menuask predicate.</p>
          </section>
        </section>
        <section>
          <h3>Biology in Prolog</h3>
          <section>
            <h4>Our First Database of Biology in Prolog</h4>
            <p>First <code class="function">belong/2</code> is defined. It will be used instead of <code class="function">member/2</code>. Then some discontiguous predicates are registered. Last, predicates <code class="function">has/2</code> and <code class="function">isa/2</code> are defined. Now we are ready to present some biological facts!</p>
            <pre id="bio0_pl">
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/prolog_code/bio0.pl" parse="text">
                <xi:fallback/>
              </xi:include>
            </pre>
          </section>
        </section>
        <!-- end of "Biology in Prolog" -->
        <section>
          <h3>Electronics in Prolog</h3>
          <section>
            <h4>Combinational Circuits in Prolog</h4>
            <p>Let us first work out how to represent logic gates as predicates. Such predicates shall reflect their truth tables...</p>
            <pre>inv(0,1).
inv(1, 0).
nand(O, 0, 1).
nand(O, 1, 1).
nand(1, 0, 1).
nand(1, 1,0).</pre>
            <p>Circuits may be built up by constructing Prolog procedures containing goals for representing circuit elements. Consider a circuit represented by:</p>
            <informalequation>
            E = nand(nand(<var>A</var>,<var>B</var>),nor(<var>C</var>,<var>D</var>))
          </informalequation>
            <p>Let's call the output of the incoming nand and nor gates <var>t<subscript>1</subscript></var> and <var>t<subscript>2</subscript></var>. Then we may write a prolog rule:</p>
            <pre>circ1(A, B, C, D, E) :-
  nand(A, B, T1),
  nor(C, 0, T2),
  nand(T1, T2, E).</pre>
            <p>Inputs and internal nodes may be shared simply by naming them the same.</p>
          </section>
          <section>
            <h4>Sequential Circuits in Prolog*</h4>
          </section>
        </section>
      </section>  <!-- end of "Special or Advanced Topics in Prolog" -->

    </main>
  </body>
</html>
