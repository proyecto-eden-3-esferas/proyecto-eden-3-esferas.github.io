<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>STL Containers</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p><a rel="prev" href="cpp.containers.html">C++ Standard Containers</a></p>
        <p><a rel="next" href="cpp.sequence-containers.html">C++ Sequence Containers: Arrays, Lists...</a></p>
        <p><a            href="cpp.hash.html">Hash Function(s) for Containers Based on Hash Tables (C++)</a></p>
      <div>
      </div>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a            href="cpp.iterators.html">Iterators: Pointers for STL Containers</a></p>
        <p><a            href="cpp.stl.html">The C++ Standard Template Library</a></p>
      </div>
    </nav>
    <main>
      <h1>Associative Containers</h1>
      <p>An <dfn>associative container</dfn> is a variable-sized container that supports efficient retrieval of elements (values) based on keys. It supports insertion and removal of elements, but differs from a <a target="_blank" href="cpp.sequence-containers.html">sequence container</a> in that it does not provide a mechanism for inserting an element at a specific position but the container itself keeps its elements in order internally in a suitable data structure.</p>
      <section id="associative_container_immutability">
        <h2>Immutability of Associative Containers</h2>
        <p> Since the elements of an associative container are stored according to their keys (in a binary tree, hash table...), it is essential that the key associated with each element is <dfn>immutable</dfn>. In simple associative containers this means that the elements themselves are immutable, while in other types of associative containers, such as pair associative containers (that is, <strong>maps</strong>), the elements themselves are mutable but the part of an element that is its key cannot be modified or assigned a value to. This has an important consequence: associative containers cannot have <dfn>mutable iterators</dfn> in the sense that  if <var>it</var> is an iterator for an associative container and <var>t</var> is an object of <var>it</var>&apos;s value type, then <kbd>*it = t</kbd> is <em>not</em> a valid expression.</p>
        <p>Consequently, every element of a <em>simple</em> associative container is immutable: objects may be inserted and erased, but not modified.</p>
      </section>

      <!-- end of "Immutability of Associative Containers" -->
      <section id="associative_container_types">
        <h2>Types of Associative Containers</h2>
        <p>Associative containers are either maps or sets. A map associates or <q>maps</q> a key to a value, whereas in a set (<code href="#set">set</code> and <code href="#multiset">multiset</code>) their elements are their own keys.</p>
        <p>A map may be either a <code>stl::map</code> or a <code>stl::multimap</code>, and a set may be either a <code>stl::set</code> or a <code>stl::multiset</code>. Here the prefix <q>multi</q> means that elements with the same key are allowed. Furthermore, sameness is to be understood not literally but according to a function or a function object that takes to objects and returns a boolean value.</p>
        <p>According to their implementation and performance, associative containers are further divided into:</p>
        <ol>
          <li>ordered containers: and are <code>std::set</code>, <code>std::multiset</code>, <code>std::map</code>, and <code>std::multimap</code>. They are implemented as binary trees, often red-black trees. They use a comparison function or a <a href="#ordered_comparison_fo">comparison function object</a> to compare keys.</li>
          <li>unordered containers: and are <code>std::unordered_set</code>, <code>std::unordered_multiset</code>, <code>std::unordered_map</code>, and <code>std::unordered_multimap</code>. According to Bjarne Stroutstrup, they are implemented as hash tables with linked overflow.</li>
        </ol>
      </section> <!-- end of "Types of Associative Containers" -->

      <section id="comparison_fo">
        <h2>Comparison Function Objects for STL&apos;s Associative Containers</h2>
        <section>
          <h3>Introduction</h3>
          <p>To use the Standard Template Library (STL) associative containers, the type of keys stored must be comparable.</p>
          <p>For sorted containers (e.g <code>std::set</code>), the comparison is by equivalence, which roughly means overloading the <code class="function">operator&lt;</code>, and for unsorted containers (e.g <code>std::unordered_set</code>) the comparison is by equality, which in turn (again, roughly) means overloading the <code class="function">operator==</code>.</p>
        </section>
        <section>
          <h3>Custom Comparison for STL&apos;s Associative Containers</h3>
          <p>For some instances of a container with a predefined comparison function for the stored type, you may want to supply an alternative comparison function that makes more sense for the container instance&apos;s purpose.</p>
          <p>For example, given a type <code>Person</code> that are normally sorted by <var>Person::id</var>, for some <code>std::set&lt;Person&gt;</code> called <var>names</var> you may want to compare the elements by <var>Person::name</var> instead of <var>Person::id</var>. How do you <q>override</q> the default comparison function for Person to achieve the desired behavior for this particular instance of <code>std::set&lt;Person&gt;</code>?</p>
          <section>
            <h4>The Complete Declaration for Associative Containers</h4>
            <p>To exemplify the concepts, I&apos;ll consider <code>std::set</code> as a representative of the STL&apos;s associative containers, the differences between it and the others aren&apos;t significant for our purpose: how to create an associative container with a different comparison function from the one defined by the type of element held inside the container?</p>
            <p>The complete declaration for std::set is:</p>
            <pre>template
&lt;
class T,
class Compare = less&lt;T&gt;,
class Alloc = allocator&lt;T&gt;
&gt;
class set;</pre>
            <p>Where:</p>
            <ol>
              <li><code>T</code> is the type of elements that will be held</li>
              <li>Alloc is the memory allocator, with the default being <code>allocator&lt;T&gt;</code></li>
            </ol>
            <p>And the most important aspect for this discussion:</p>
            <blockquote>Compare is the type of the comparison used, with the default being <code>std::less&lt;T&lt;</code></blockquote>
            <p>But, what&apos;s <code>std::less&lt;T&lt;</code>?</p>
            <p><code>std::less&lt;T&lt;</code> is a function object that expresses the <q>less-than</q> semantic for objects of type <code>T</code>. Its behavior is to call the <code class="function">operator&lt;()</code> overloaded by the type <code>T</code> to check the relative order of two objects <var>A</var> and <var>B</var> of type <code>T</code>.</p>
            <p>Given the declaration for <code>std::set</code>, we can see that the way for providing our desired behavior is to supply a different type of comparison function object for the template parameter: <code>Compare</code>. Alright? Let&apos;s do it then!</p>
            <p>Our type <code>Person</code> looks like this:</p>
            <pre>#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;

class Person {
public:
	explicit Person(int id, const std::string &amp;name) : m_id{id}, m_name{name} {}
	const int id() const {return m_id;}
	const std::string&amp; name() const {return m_name;}
private:
	const int m_id;
	const std::string m_name;
};

bool operator&lt;(const Person &amp;lhs, const Person &amp;rhs) { // compare by id
	return lhs.id() &lt; rhs.id();
}

std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os, const Person &amp;rhs) { // for formatted output
	os &lt;&lt; "Id: " &lt;&lt; rhs.id() &lt;&lt; ", Name: " &lt;&lt; rhs.name();
	return os;
}</pre>
            <p>And the use of <code>Person</code> inside <code>std::se</code>t and comparing by <var>Person::name</var> instead of <var>Person::id</var> can be achieved by:</p>
            <pre>struct PersonCompareByName {
	bool operator()(const Person &amp;lhs, const Person &amp;rhs) const {
		return lhs.name() &lt; rhs.name();
	}
};

int main() {
	auto people = {Person{2, "C"}, Person{3, "A"}, Person{1, "B"}};

	// By Id
	std::set&lt;Person&gt; peopleById = people;
	std::cout &lt;&lt; "By Id: " &lt;&lt; "\n\n";
	std::copy(cbegin(peopleById), cend(peopleById), std::ostream_iterator&lt;Person&gt;{std::cout, "\n"});

	std::cout &lt;&lt; '\n';

	// By Name (1)
	std::set&lt;Person, PersonCompareByName&gt; peopleByName = people;
	std::cout &lt;&lt; "By Name (1): " &lt;&lt; "\n\n";
	std::copy(cbegin(peopleByName), cend(peopleByName), std::ostream_iterator&lt;Person&gt;{std::cout, "\n"});

	std::cout &lt;&lt; '\n';

	// By Name (2)
	auto personComparator = [](const auto &amp;lhs, const auto &amp;rhs) {return lhs.name() &lt; rhs.name();};
	std::set&lt;Person, decltype(personComparator)&gt; peopleByName2{people, personComparator};
	std::cout &lt;&lt; "By Name (2): " &lt;&lt; "\n\n";
	std::copy(cbegin(peopleByName2), cend(peopleByName2), std::ostream_iterator&lt;Person&gt;{std::cout, "\n"});

	return 0;
}</pre>
            <p>First, we&apos;d created the peopleById that uses the internal (default) comparison function for the type Person: By Person::id(). Thus, every element inside the container will be sorted based on its id.</p>
            <p>Then, at (1) we created <var>peopleName</var> that relies on the function object <code>PersonCompareByName</code> as the argument for the template parameter <code>Compare</code>, establishing the comparison by Person::name().</p>
            <p>At (2) we achieved the same behavior of (1) but employing an alternative syntax that uses the lambda <var>personComparator</var> and supplied the template parameter with decltype.</p>
          </section>
        </section>
        <section id="ordered_comparison_fo">
          <h3>Function Objects for Ordered Associative Containers</h3>
          <p>Ordered associative containers use compare <a href="cpp.function-object.html">function objects</a> to keep themselves sorted. The default upon construction is <code>less&lt;Key&gt;</code>, which is defined in <filename>functional</filename>. You may define and pass in your own. It should overload <code class="function">bool operator()(const Key&amp; l, const Key&amp; r)</code> and meet the following three requirements for a <dfn>strict weak ordering</dfn>:</p>
          <dl>
            <!-- <varlistentry> -->
              <dt>It has to be <dfn>antisymmetric</dfn></dt>
              <dd>That is, if <kbd>less&lt;Key&gt;(<var>val1</var>,<var>val2</var>)</kbd> is true, then <kbd>less&lt;Key&gt;(<var>val2</var>,<var>val1</var>)</kbd> must be false.</dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>It has to be <dfn>transitive</dfn></dt>
              <dd/>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>It has to be <dfn>irreflexive</dfn></dt>
              <dd>That is, a key is never <kbd>less</kbd> than itself, or more formally <kbd>less&lt;Key&gt;(<var>val</var>,<var>val</var>)</kbd> is always false.</dd>
            <!-- </varlistentry> -->
          </dl>
          <p>On this definition we define an <dfn>equality</dfn> test given two elements: <q>they are equal if neither is <em>less</em> than the other.</q></p>
        </section>
      </section>
      <!-- end of "Comparison Function Objects for STL&apos;s Associative Containers" -->

      <section id="set">
        <h2><code>set</code> and <code>multiset</code></h2>
        <p>Set and multiset containers sort their elements automatically according to a certain sorting criterion. The difference between the two is that a <code id="multiset">multiset</code> allows duplicates, whereas a <code>set</code> does not.</p>
        <p>They are good for finding out if an element is in a set, or for retrieving an element that is <q>equal</q> to another, which actually is useful if function object <code>less&lt;T&gt;</code> is specialized to suit our goals.</p>
        <p>Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as red-black trees.</p>
        <section>
          <h3>Using a <code>std::set</code> for Recording <q>Visited</q> Items</h3>
          <p>We will be using the following:</p>
          <ol>
            <li>insertions, and possibly deletions</li>
            <li>
              <code class="function">const_iterator std::set::find( const Key&amp; key ) const</code>
            </li>
            <li><code class="function">const_iterator std::set::end() const</code> for comparing the returned value</li>
          </ol>
          <p>This would enable us to write a <code class="function">bool has(<var>s</var>, <var>k</var>) const</code>, and a similar <code class="function">bool has_or_add(<var>s</var>, <var>k</var>)</code> function.</p>
          <p>In many situations the key type would be just a pointer...</p>
        </section>

      </section>

      <section id="map">
        <h2><code>std::map</code></h2>
        <p>Maps are associative containers that store elements formed by a combination of a key value (<code>key_type</code>) and a mapped value (<code>mapped_type</code>), following a specific order, unlike .</p>
        <p>In a map, the key values are used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type <code>value_type</code>, which is a <code>std::pair</code> type combining both:</p>
        <pre>typedef pair&lt;const Key, Mapped&gt; value_type;</pre>
        <p>Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type <code>Compare</code>).</p>
        <p><code>std::map</code> containers are generally slower than <code>std::unordered_map</code> containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.</p>
        <hr/>
        <p>The mapped values in a map can be accessed directly by their corresponding key using the bracket operator (<code>std::map::operator[]</code>).</p>
        <section id="map.insert">
          <h3><code>std::map::insert(<var>ARGS</var>)</code></h3>
          <p><strong>Prototypes:</strong></p>
          <pre>pair&lt;iterator,bool&gt; insert (const value_type&amp; val);
template &lt;class P&gt;
pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);

// with hint:
iterator insert(const_iterator position, const value_type&amp; val);
template &lt;class P&gt;
iterator insert (const_iterator position, P&amp;&amp; val);

// range:
template &lt;class InputIterator&gt;
void insert (InputIterator first, InputIterator last);

// initializer list:
void insert (initializer_list&lt;value_type&gt; il);</pre>
          <p>Because element keys in a map are unique, the insertion operation checks whether each inserted element has a key equivalent to the one of an element already in the container, and if so, the element is not inserted, returning an iterator to this existing element (if the function returns a value).</p>
          <p>For a similar container allowing for duplicate elements, <i>see</i> <code><a href="#multimap">std::multimap</a></code>.</p>
          <p>An alternative way to insert elements in a map is by using member function <a href="#map.index-accessors">map::operator[]</a></p>
          <hr/>
          <p>Member types <code>iterator</code> and <code>const_iterator</code> are defined in map as <em>bidirectional</em> iterator types that point to elements.</p>
          <section>
            <h4>Postion Hints</h4>
            <p>As for hinting for the position where the element can be inserted, the function <code>std::map::insert()</code> optimizes its insertion time if position points to the element that will <em>follow</em> the inserted element (or to the end, if it would be the last).</p>
            <p>Notice that this is just a hint and does not force the new element to be inserted at that position within the map container (the elements in a map always follow a specific order depending on their key).</p>
          </section>
          <section>
            <h4>Return value</h4>
            <p>The single element versions return a pair, with its member <code>pair::first</code> set to an iterator pointing to either the newly inserted element or to the element with an equivalent key in the map. The <code>pair::second</code> element in the pair is set to true if a new element was inserted or false if an equivalent key already existed.</p>
            <p>The versions with a hint return an iterator pointing to either the newly inserted element or to the element that already had an equivalent key in the map.</p>
          </section>

          <section>
            <h4>An Example using <code>std::map::insert()</code></h4>
            <pre>// map::insert (C++98)
#include &lt;iostream&gt;
#include &lt;map&gt;

int main ()
{
  std::map&lt;char,int&gt; mymap;

  // first insert function version (single parameter):
  mymap.insert ( std::pair&lt;char,int&gt;('a',100) );
  mymap.insert ( std::pair&lt;char,int&gt;('z',200) );

  std::pair&lt;std::map&lt;char,int&gt;::iterator,bool&gt; ret;
  ret = mymap.insert ( std::pair&lt;char,int&gt;('z',500) );
  if (ret.second==false) {
    std::cout &lt;&lt; "element 'z' already existed";
    std::cout &lt;&lt; " with a value of " &lt;&lt; ret.first-&gt;second &lt;&lt; '\n';
  }

  // second insert function version (with hint position):
  std::map&lt;char,int&gt;::iterator it = mymap.begin();
  mymap.insert (it, std::pair&lt;char,int&gt;('b',300));  // max efficiency inserting
  mymap.insert (it, std::pair&lt;char,int&gt;('c',400));  // no max efficiency inserting

  // third insert function version (range insertion):
  std::map&lt;char,int&gt; anothermap;
  anothermap.insert(mymap.begin(),mymap.find('c'));

  // showing contents:
  std::cout &lt;&lt; "mymap contains:\n";
  for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n';

  std::cout &lt;&lt; "anothermap contains:\n";
  for (it=anothermap.begin(); it!=anothermap.end(); ++it)
    std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n';

  return 0;
}</pre>
            <p>Output:</p>
            <pre></pre>
          </section>
        </section>
        <section id="map.find">
          <h3><code>std::map::find()</code></h3>
          <p>Searches the container for an element with a key equivalent to k and returns an iterator to it if found, otherwise it returns an iterator to <code>map::end()</code>.</p>
          <p><strong>Prototypes</strong></p>
          <pre>iterator find (const key_type&amp; k);
const_iterator find (const key_type&amp; k) const;</pre>
          <p>Two keys are considered equivalent if the container&apos;s comparison object returns <code>false</code> reflexively (i.e., no matter the order in which the elements are passed as arguments).</p>
          <hr/>
          <p>Another member function, <code>map::count</code>, can be used to just check whether a particular key exists. In later versions you may also use <code>std::map::contains(<var>K</var>)</code>.</p>
          <p>Here is an example using <code>map::find</code>:</p>
          <pre>// map::find
#include &lt;iostream&gt;
#include &lt;map&gt;

int main ()
{
  std::map&lt;char,int&gt; mymap;
  std::map&lt;char,int&gt;::iterator it;

  mymap['a']=50;
  mymap['b']=100;
  mymap['c']=150;
  mymap['d']=200;

  it = mymap.find('b');
  if (it != mymap.end())
    mymap.erase (it);

  // print content:
  std::cout &lt;&lt; "elements in mymap:" &lt;&lt; '\n';
  std::cout &lt;&lt; "a =&gt; " &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\n';
  std::cout &lt;&lt; "c =&gt; " &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\n';
  std::cout &lt;&lt; "d =&gt; " &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\n';

  return 0;
}</pre>
        </section>
        <section id="map.bound">
          <h3><code>std::map::lower_bound</code> and <code>std::map::upper_bound</code></h3>
          <p><code>std::map::lower_bound</code> returns an iterator pointing to the first element in the container whose key is not considered to go before <var>k</var> (i.e., either it is equivalent or goes after), whereas <code>std::map::upper_bound</code> returns a key pointing to the next element after <var>k</var>, or just <code>std::map::end()</code>.</p>
          <p><strong>Prototypes:</strong></p>
          <pre>iterator lower_bound (const key_type&amp; k);
const_iterator lower_bound (const key_type&amp; k) const;</pre>
          <p>and</p>
          <pre>iterator upper_bound (const key_type&amp; k);
const_iterator upper_bound (const key_type&amp; k) const;</pre>
        </section>
        <section id="map.equal_range">
          <h3><code>std::map::equal_range</code></h3>
          <p>... is very much anologous to <a href="#map.bound"><code>std::map::lower_bound</code>/<code>std::map::upper_bound</code></a> in that it returns a <code>std::pair</code> of iterators, which represent the bounds of a range that includes all the elements in the container which have a key equivalent to <var>k</var> and, because the elements in a map container have unique keys, the range returned will contain a single element at most. Not so with same-named function <code>std::multimap::equal_range</code>.</p>
          <pre></pre>
          <p>[...]</p>
        </section>
        <section id="map.erase">
          <h3><code>std::map::erase()</code></h3>
          <p><strong>Prototypes:</strong></p>
          <pre>iterator  erase (const_iterator position);
size_type erase (const key_type&amp; k);
iterator  erase (const_iterator first, const_iterator last);</pre>
          <p>Removes from the map container either a single element or a range of elements ([<var>first</var>,<var>last</var>)).</p>
        </section>
        <section id="map.index-accessors">
          <h3>Difference Between <code>std::map::operator[](<var>KEY</var>)</code> and <code>std::map::at(<var>KEY</var>)</code></h3>
          <p>If you access a key using the indexing operator [] that is not currently a part of a map, then it automatically adds a key for you. This is a huge caveat. For this reason, I prefer using the indexing operator [] for setting, and members <code>find()</code> / <code>at()</code> for lookup.</p>
          <p>Another advantage of using <code>at()</code> over <code>[]</code> is the fact that it can operate on a const std::map, whereas <code>[]</code> won&apos;t.</p>
          <p>Importantly, <code>at(<var>key</var>)</code> throws an exception if the key doesn&apos;t exist.</p>
        </section>
      </section>
      <section id="multimap">
        <h2><code>std::multimap</code></h2>
        <p>Just like <code><a href="#map">std::map</a></code>&apos;, multimaps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.</p>
        <p>Unlike <code>std::map</code>, multiple elements are allowed to have equivalent keys.</p>
        <p>Member functions <code>std::map</code> and <code>std::multimap</code> are the same save for the ramifications from the fact that equivalent keys are allowed.</p>
        <ul>
          <li><code>std::multimap::equal_range</code> may return a range holding more than one element, not just one or none</li>
          <li><code>std::multimap::count(<var>KEY</var>)</code> may return any positive number, from zero to several</li>
          <li><code>std::multimap::insert(<var>VALUE</var>)</code> does not fail if an element already exists</li>
        </ul>
      </section>

      <section id="unordered_set">
        <h2><code>std::unordered_set</code> and <code>std::unordered_multiset</code></h2>
        <p style="text-align: right">(Heavily from <a target="_blank" href="https://cplusplus.com/reference/unordered_set/">https://cplusplus.com/reference/unordered_set/</a>)</p>
        <p>Unordered sets are containers that store unique elements in no particular order, and which allow for fast retrieval of individual elements based on their value.</p>
        <p>Internally, the elements are organized into buckets depending on their <a target="_blank" href="cpp.hash.html">hash</a> values to allow for fast access to individual elements directly by their values (with a constant average time complexity on average).</p>
        <p><code>std::unordered_set</code> containers are faster than <code>std::set</code> containers to access individual elements by their key, although they are generally less efficient for range iteration through a subset of their elements.</p>
        <section id="unordered_set.buckets">
          <h3>Buckets in <code>std::unordered_set</code>&apos;s</h3>
          <p>A <dfn>bucket</dfn> is a slot in the container&apos;s internal hash table to which elements are assigned based on their hash value.</p>
          <p>Buckets are numbered from 0 to (<code>bucket_count()</code> - 1).</p>
          <dl>
            <dt><code>bucket_count()</code></dt>
            <dd><p>Return number of buckets (public member function)</p></dd>
            <dt><code>max_bucket_count()</code></dt>
            <dd><p>Return maximum number of buckets (public member function)</p></dd>
            <dt><code>bucket_size()</code></dt>
            <dd id="bucket_size">
              <p><code>bucket_size()</code> returns the bucket size</p>
              <pre>size_type bucket_size ( size_type idx) const;</pre>
              <p>where <var>idx</var> is the bucket number, which should be lower than <code>bucket_count()</code>.</p>
            </dd>
            <dt><code>bucket()</code></dt>
            <dd>
              <pre>size_type bucket ( const key_type&amp; <var>k</var> ) const;</pre>
              <p>Returns the bucket number (or index) where the element with value <var>k</var> is located.</p>
            </dd>
          </dl>
        </section>

        <section id="hash-policy">
          <h3>Hash policy</h3>
          <dl>
            <dt><code>load_factor()</code></dt>
            <dd id="load_factor">
              <p><code>load_factor()</code> returns the load factor (public member function)</p>
              <pre>float load_factor() const noexcept;</pre>
              <p>The <dfn>load factor</dfn> is the ratio between the number of elements in the container (its size) and the number of buckets (<code>bucket_count()</code>):</p>
              <blockquote>load_factor = size / bucket_count</blockquote>
              <p>The load factor influences the probability of collision in the hash table (i.e., the probability of two elements being located in the same bucket). The container automatically increases the number of buckets to keep the load factor below a specific threshold (its <code>max_load_factor</code>), causing a rehash each time an expansion is needed.</p>
              <p>To retrieve or change this threshold, use member function <code>max_load_factor()</code>.</p>
            </dd>
            <dt><code>max_load_factor()</code></dt>
            <dd id="max_load_factor">
              <p><code>max_load_factor()</code> gets or sets the maximum load factor (public member function)</p>
              <pre>float max_load_factor() const noexcept;
void max_load_factor( float <var>mlf</var>);</pre>
              <p>By default, unordered_set containers have a <var>max_load_factor</var> of 1.0.</p>
            </dd>
            <dt><code>rehash()</code></dt>
            <dd>
              <pre>void rehash ( size_type n );</pre>
              <p>Sets the number of buckets in the container to <var>n</var> or more.</p>
              <p>If <var>n</var> is greater than the current number of buckets in the container (<code>bucket_count()</code>), a rehash is forced. The new bucket count can either be equal or greater than <var>n</var>.</p>
              <p>If <var>n</var> is lower than the current number of buckets in the container (<code>bucket_count()</code>), the function may have no effect on the bucket count and may not force a rehash.</p>
              <p>A <dfn>rehash</dfn> is the reconstruction of the hash table: All the elements in the container are rearranged according to their hash value into the new set of buckets. This may alter the order of iteration of elements within the container.</p>
              <p>Rehashes are automatically performed by the container whenever its load factor is going to surpass its <var>max_load_factor</var> in an operation.</p>
              <p>[...]</p>
            </dd>
            <dt><code>reserve()</code></dt>
            <dd>
              <p>Request a capacity change</p>
              <pre>void reserve( size_type <var>n</var>);</pre>
              <p>Sets the number of buckets in the container (<code>bucket_count()</code>) to the most appropriate to contain at least <var>n</var> elements. If <var>n</var> is greater than the current <var>bucket_count</var> multiplied by the <var>max_load_factor</var>, the container&apos;s bucket_count is increased and a rehash is forced. If <var>n</var> is lower than that, the function may have no effect.</p>
            </dd>
          </dl>
        </section>

        <section id="observers">
          <h3>Observers</h3>
          <dl>
            <dt><code>hash_function()</code>
            </dt>
            <dd>
              <p>Get hash function</p>
              <pre><var>hasher</var> hash_function() const;</pre>
            </dd>
            <dt><code>key_eq()</code></dt>
            <dd>
              <p>Get key equivalence predicate</p>
              <pre><var>key_equal</var> key_eq() const;</pre>
              <p>The key equivalence comparison is a predicate that takes the value of two elements as arguments and returns a <code>bool</code> value indicating whether they are to be considered equivalent. It is adopted by the container on construction. By default, it is <code>equal_to&lt;key_type&gt;</code>, which returns the same as applying the equal-to operator (<code>==</code>) to the arguments.</p>
            </dd>
            <dt><code>get_allocator()</code></dt>
            <dd>
              <p>Get allocator (public member function)</p>
            </dd>
          </dl>
        </section>

      </section>

      <section id="unordered_map">
        <h2><code>std::unordered_map</code> and <code>std::unordered_multimap</code></h2>
        <p style="text-align: right">(Heavily from <a target="_blank" href="https://cplusplus.com/reference/unordered_map/">https://cplusplus.com/reference/unordered_map/</a>)</p>
        <p>[...]</p>
      </section>

    </main>
  </body>
</html>
