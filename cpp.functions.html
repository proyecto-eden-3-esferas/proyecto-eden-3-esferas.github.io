<!DOCTYPE html>
<html>
  <head>
    <title>Functions in C++</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Functions in C++: C-style, lambdas, member functions etc."/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p><a rel="next" href="cpp.hash.html">Hash Function(s) in C++</a></p>
        <p><a rel="prev" href="cpp.html">The C++ Programming Language</a></p>
        <p><a            href="c.bitwise.html">Bitwise Operations in C++</a></p>
        <p><a            href="cpp.exceptions.html">C++ Exceptions</a></p>
        <p><a            href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a></p>
      </div>
      <div>
        <p><a href="cpp.core-guidelines.html">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup (<em>local</em>)</p>
        <p><a target="_blank" href="http://isocpp.github.io/CppCoreGuidelines/">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup, much like the C++ language itself (<em>online</em>)</p>
      </div>
      <div>
        <p><a href="cpp.cpp11.html">C++11</a></p>
        <p><a href="cpp.cpp14.html">C++14</a></p>
        <p><a href="cpp.cpp20.html">C++20</a></p>
      </div>
    </nav>

    <main>
      <h1>Functions in C++</h1>
      <p>A <dfn>function</dfn> is a block of code which only runs when it is called.</p>
      <p>You can pass data, known as <dfn>parameters</dfn>, into a function.</p>
      <p>Functions are used to perform certain actions, and they are important for reusing code: Define the code once, and use it many times.</p>

      <section id="operators">
        <h2>Operators</h2>
        <p>An <dfn>operator</dfn> is actually a function which uses different syntax. So, instead of <code>add(<var>a</var>,<var>b</var></code>) after defining function <code>add(...)</code> you would just type <code>a + b</code>, as long as operator + is defined for the types of <var>a</var> and <var>b</var>.</p>
        <p>Note that, when calling a binary operator, you write it between its operands (<code><var>x</var> + <var>y</var></code>). A unary operator is written before its one operand (as in <code>!<var>married</var></code>)</p>
        <p>C++ divides the operators into the following groups:</p>
        <ul>
          <li>arithmetic operators</li>
          <li>assignment operators</li>
          <li>comparison operators</li>
          <li>logical operators</li>
          <li>bitwise operators</li>
        </ul>

        <section id="operator-precedence">
          <h3>Operator Precedence</h3>
          <p style="text-align: right">(From <cite><a target="_blank" href="https://www.w3schools.com/cpp/cpp_operators_precedence.asp">https://www.w3schools.com/cpp/cpp_operators_precedence.asp</a></cite>)</p>
          <p>Here are some common operators in C++, from highest to lowest priority:</p>
          <ol>
            <li><code>()</code>: Parentheses</li>
            <li><code>*, /, %</code>: Multiplication, Division, Modulus</li>
            <li><code>+, -</code>: Addition, Subtraction</li>
            <li><code>>, &lt;, >=, &lt;=</code>: Comparison</li>
            <li><code>==, !=</code>: Equality</li>
            <li><code>&amp;&amp;</code>: Logical AND</li>
            <li><code>||</code>: Logical OR</li>
            <li><code>=</code>: Assignment</li>
          </ol>
          <p>An <strong>Example</strong> illustrating that subtraction and addition are done from left to right, unless you add parentheses:</p>
          <pre>int result1 = 10 - 2 + 5;    // (10 - 2) + 5 = 13
int result2 = 10 - (2 + 5);  // 10 - 7 = 3

cout &lt;&lt; result1 &lt;&lt; "\n";
cout &lt;&lt; result2 &lt;&lt; "\n";</pre>
          <p>[...]</p>

        </section>

        <section id="3-way">
          <h3>C++20: The Three-Way Comparison Operator</h3>
          <p style="text-align: right">(June 11, 2020 by Rainer Grimm at <code><a target="_blank" href="https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator/">https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator/</a></code>)</p>
          <p>The <dfn>three-way comparison operator</dfn> <code>&lt;=></code> is often just called the spaceship operator. The spaceship operator determines whether <var>A</var> &lt; <var>B</var>, <var>A</var> = <var>B</var>, or <var>A</var> > <var>B</var> for two values, <var>A</var> and <var>B</var>. You can define the spaceship operator, or the compiler can auto-generate it.</p>
          <p>Before C++20 introduced the three-way comparison operator, it was not enough to define <code>operator&lt;</code> but you also needed to define the remaining five in a consistent way, something like this:</p>
          <pre>bool operator==(const MyInt&amp; rhs) const {
    return value == rhs.value;
}
bool operator!=(const MyInt&amp; rhs) const {
    return !(*this == rhs);
}
bool operator&lt;=(const MyInt&amp; rhs) const {
    return !(rhs &lt; *this);
}
bool operator&gt;(const MyInt&amp; rhs)  const {
    return rhs &lt; *this;
}
bool operator&gt;=(const MyInt&amp; rhs) const {
    return !(*this &lt; rhs);
}</pre>
          <p>You can define the three-way comparison operator or request it from the compiler with =default. In both cases, you get all six comparison operators: ==, !=, &lt;, &lt;=, &gt;, and &gt;=.</p>
          <p>The programmer could define it like this:</p>
          <pre>struct MyInt {
    int value;
    explicit MyInt(int val): value{val} { }
    auto operator&lt;=&gt;(const MyInt&amp; rhs) const {           // (1)
        return value &lt;=&gt; rhs.value;
    }
};</pre>
          <p>or just let the compiler define it:</p>
          <pre>struct MyDouble {
  double value;
  explicit constexpr MyDouble(double val): value{val} { }
  auto operator&lt;=&gt;(const MyDouble&amp;) const = default;   // (2)
};</pre>
          <p>The compiler-generated three-way comparison operator needs the header <cite>&lt;compare&gt;</cite>, which is <code>implicit</code> <code>constexpr</code> and <code>noexcept</code>. Additionally, it performs a lexicographical comparison.</p>
          <aside><dfn>Lexicographical comparison</dfn> means that all base classes are compared left to right and all non-static members in their declaration order. I have to qualify: for performance reasons, the compiler-generated == and != operators behave differently in C++20.</aside>
          <!--
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          -->
        </section>
      </section>

      <section id="lambdas">
        <h2>lambdas</h2>
        <p style="text-align: right">(Largely from <cite>https://www.w3schools.com/cpp/cpp_functions_lambda.asp</cite>)</p>
        <p>A lambda function is a small, anonymous function you can write directly in your code. It's useful when you need a quick function without naming it or declaring it separately.</p>
        <p><strong>Syntax</strong></p>
        <pre>[<var>capture</var>] (<var>parameters</var>) {<var>code</var>};</pre>

        <section>
          <h3>A Simple Lambda Example</h3>
          <p>Here, <var>message</var> holds a lambda function that prints a message to the screen:</p>
          <pre>Example
int main() {
  auto message = []() {
    cout &lt;&lt; "Hello World!\n";
  };

  message();

  return 0;

}</pre>
        </section>
        <section>
          <h3>Lambda with Parameters</h3>
          <p>You can pass values into a lambda just like a regular function:</p>
          <pre>#include &lt;iostream&gt;
using namespace std;

int main() {
  auto add = [](int a, int b) {
    return a + b;
  };

  cout &lt;&lt; add(3, 4);
  return 0;
}</pre>
        </section>
        <section>
          <h3>Passing Lambdas to Functions</h3>
          <p>You can also pass a lambda function as an argument to another function. This is useful when you want to tell a function what to <em>do</em>, not just what data to use.</p>
          <p>In the example below, we send a small lambda function to another function, which then runs it twice:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;functional&gt; // Needed for std::function
using namespace std;

// A function that takes another function as parameter
void myFunction(std;;function&lt;void()> func) {
  func();
  func();
}

int main() {
  auto message = []() {
    cout &lt;&lt; "Hello World!\n";
  };

  myFunction(message);

  return 0;
} </pre>
          <p>Note that you must include the <cite>&lt;functional&gt;</cite> header for this example to work.</p>
        </section>
        <section>
          <h3>Capture Clause <code>[]</code></h3>
          <p>You can use the [ ] brackets to give a lambda access to variables outside of it. This is called the <dfn>capture clause</dfn>.</p>
          <p>In the example below, the lambda captures the variable <var>x</var> by value (a copy):</p>
          <pre>#include &lt;iostream&gt;
int main() {
  int x = 10;
  auto show = [x]() {
    cout &lt;&lt; x;
  };
  show();

  return 0;
}</pre>
          <p><strong>Note</strong> The lambda uses a copy of <var>x</var>. If you change <var>x</var> after defining the lambda, it won&apos;t affect the value inside the lambda, but you can also use <code>[&amp;]</code> to capture by reference.</p>
          <p>This is an example of <dfn>capture by reference</dfn> (the lambda will work with the original variable, not a separate copy):</p>
          <pre>int main() {
  int x = 10;

  auto show = [&amp;x]() {
    cout &lt;&lt; x;
    ++x;
  };

  x = 20;  // Change x after the lambda is created
  show();  // output: 20
           // now x==21

  return 0;
}</pre>
        </section>
        <section>
          <h3>Regular Functions vs Lambda Functions</h3>
          <p>Both regular functions and lambda functions let you group code and run it later, but they are used in slightly different situations.</p>
          <p>Use a regular function when:</p>
          <ul>
            <li>You plan to reuse the function in multiple places</li>
            <li>You want to give the function a clear, meaningful name</li>
            <li>The logic is long or complex</li>
          </ul>
          <p>Use a lambda function when:</p>
          <ul>
            <li>You only need the function once</li>
            <li>The code is short and simple</li>
            <li>You want to pass a quick function into another function</li>
          </ul>
        </section>
        <section>
          <h3>Lambda Capture Initializers</h3>
          <p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked).</p>
          <pre>int factory(int i) { return i * 10; }
auto f = [x = factory(2)] { return x; }; // returns 20

auto generator = [x = 0] () mutable {
  // this would not compile without 'mutable' as we are modifying x on each call
  return x++;
};
auto a = generator(); // == 0
auto b = generator(); // == 1
auto c = generator(); // == 2</pre>
          <p>Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <var>p</var> in the capture-list of <var>task2</var> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <var>p</var>.</p>
          <pre>auto p = std::make_unique&lt;int&gt;(1);

auto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied
// vs.
auto task2 = [p = std::move(p)] { *p = 5; }; // OK: <var>p</var> is move-constructed into the closure object
// the original p is empty after <var>task2</var> is created</pre>
          <p>Using this reference-captures can have different names than the referenced variable.</p>
          <pre>auto x = 1;
auto f = [&amp;r = x, x = x * 10] {
  ++r;
  return r + x;
};
f(); // sets <var>x</var> to 2 and returns 12</pre>
        </section>
        <section>
          <h3>Return type deduction</h3>
          <p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible.</p>
          <pre>// Deduce return type as `int`.
auto f(int i) {
 return i;
}
template &lt;typename T&gt;
auto&amp; f(T&amp; t) {
  return t;
}

// Returns a reference to a deduced type.
auto g = [](auto&amp; x) -> auto&amp; { return f(x); };
int y = 123;
int&amp; z = g(y); // reference to `y`</pre>
        </section>

        <section>
          <h3>Generic lambda expressions</h3>
          <p>C++14 allows the auto type-specifier in the parameter list, enabling polymorphic lambdas.</p>
          <pre>auto identity = [](auto x) { return x; };
int three = identity(3); // == 3
std::string foo = identity("foo"); // == "foo"</pre>
        </section>
      </section>

      <section id="bind">
        <h2>Binding Function Arguments with <code>std::bind()</code> (in the <code>&lt;functional&gt;</code> Header)</h2>
        <p><code>std::bind()</code> returns a function object based on <var>fn</var>, but with its arguments bound to <var>args</var>.</p>
        <pre>template &lt;           class Fn, class... Args&gt;  /* unspecified */
bind (Fn&amp;&amp; fn, Args&amp;&amp;... args); // (1)
template &lt;class Ret, class Fn, class... Args&gt;  /* unspecified */
bind (Fn&amp;&amp; fn, Args&amp;&amp;... args); // (2)</pre>
        <p>Each argument may either be bound to a value or be a placeholder (in namespace <code>std::placeholders</code>):</p>
        <ul>
          <li>If bound to a value, calling the returned function object will always use that value as argument.</li>
          <li>If a placeholder, calling the returned function object forwards an argument passed to the call (the one whose order number is specified by the placeholder).</li>
        </ul>
        <p>Calling the returned object returns the same type as <var>fn</var>, unless a specific return type is specified as <var>Ret</var> (second prototype) (note that <var>Ret</var> is the only template parameter that cannot be implicitly deduced by the arguments passed to this function).</p>
        <hr/>
        <p>The type of the returned object has the following properties:</p>
        <ul>
          <li>Its functional call returns the same as <var>fn</var> with its arguments bound to args... (or forwarded, for placeholders).</li>
          <li>For (1), it may have a member variable named <code>result_type</code>: if <var>Fn</var> is a pointer to function or member function type, it is defined as an alias of its return type. Otherwise, it is defined as <code>Fn::result_type</code>, if such a member type exists.</li>
          <li>For (2), it has a member variable named <code>result_type</code>, defined as an alias of <var>Ret</var>.</li>
          <li>It is move-constructible and, if the type of all of its arguments are copy-constructible, it is also copy-constructible. Both constructors never throw, provided none of the corresponding constructors of the decay types of <var>Fn</var> and <var>Args...</var> throw.</li>
        </ul>
        <section>
          <h3>Parameters</h3>
          <dl>
            <dt><var>fn</var></dt>
            <dd>
              <p>A function object, pointer to function or pointer to member.</p>
              <p><var>fn</var> shall have a decay type which is move-constructible from <var>fn</var>.</p>
            </dd>
            <dt><var>args...</var></dt>
            <dd>
              <p>List of arguments to bind: either values, or placeholders.</p>
              <p>The types in <var>args...</var> shall have decay types which are move-constructible from their respective arguments in <var>args....</var></p>
              <p>If for any argument, its decay type is a <a target="_blank" href="cpp.reference_wrapper.html">reference_wrapper</a>, it bounds to its referenced value instead.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h3>Return Value</h3>
          <p>A function object that, when called, calls <var>fn</var> with its arguments bound to <var>args</var>.</p>
          <p>If <var>fn</var> is a pointer to member, the first argument expected by the returned function is an object of the class <code>*fn</code> is a member (or a reference to it, or a pointer to it).</p>
        </section>
        <section>
          <h3>Example</h3>
          <p></p>
          <pre>#include &lt;iostream&gt;     // std::cout
#include &lt;functional&gt;   // std::bind

// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)
double my_divide (double x, double y) {return x/y;}

struct MyPair {
  double a,b;
  double multiply() {return a*b;}
};

int main () {
  using namespace std::placeholders;    // adds visibility of _1, _2, _3,...

  // binding functions:
  auto fn_five = std::bind (my_divide,10,2);               // returns 10/2
  std::cout &lt;&lt; fn_five() &lt;&lt; '\n';                          // 5

  auto fn_half = std::bind (my_divide,_1,2);               // returns x/2
  std::cout &lt;&lt; fn_half(10) &lt;&lt; '\n';                        // 5

  auto fn_invert = std::bind (my_divide,_2,_1);            // returns y/x
  std::cout &lt;&lt; fn_invert(10,2) &lt;&lt; '\n';                    // 0.2

  auto fn_rounding = std::bind&lt;int&gt; (my_divide,_1,_2);     // returns int(x/y)
  std::cout &lt;&lt; fn_rounding(10,3) &lt;&lt; '\n';                  // 3

  MyPair ten_two {10,2};

  // binding members:
  auto bound_member_fn = std::bind (&amp;MyPair::multiply,_1); // returns x.multiply()
  std::cout &lt;&lt; bound_member_fn(ten_two) &lt;&lt; '\n';           // 20

  auto bound_member_data = std::bind (&amp;MyPair::a,ten_two); // returns ten_two.a
  std::cout &lt;&lt; bound_member_data() &lt;&lt; '\n';                // 10

  return 0;
}</pre>
          <p>Output:</p>
          <pre>5
5
0.2
3
20
10</pre>
        </section>

      </section>
      <section>
        <h2>Trailing return types</h2>
        <p>C++11 allows functions and lambdas an alternative syntax for specifying their return types.</p>
        <pre>int f() {
  return 123;
}
// vs.
auto f() -&gt; int {
  return 123;
}
auto g = []() -&gt; int {
  return 123;
        };</pre>
        <p>This feature is especially useful when certain return types cannot be resolved:</p>
        <pre>// NOTE: This does not compile!
template &lt;typename T, typename U&gt;
decltype(a + b) add(T a, U b) {
    return a + b;
}

// Trailing return types allows this:
template &lt;typename T, typename U&gt;
auto add(T a, U b) -&gt; decltype(a + b) {
    return a + b;
}</pre>
        <p>In C++14, <a target="_blank" href="cpp.cpp14.html#decltype-auto">decltype(auto)</a> can be used instead.</p>
      </section>

      <section id="ref-qualified-member-functions">
        <h2>Ref-qualified member functions</h2>
        <p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p>
        <pre>struct Bar {
  // ...
};

struct Foo {
  Bar&amp; getBar() &amp; { return bar; }
  const Bar&amp; getBar() const&amp; { return bar; }
  Bar&amp;&amp; getBar() &amp;&amp; { return std::move(bar); }
  const Bar&amp;&amp; getBar() const&amp;&amp; { return std::move(bar); }
private:
  Bar bar;
};

Foo foo{};
Bar bar = foo.getBar(); // calls `Bar&amp; getBar() &amp;`

const Foo foo2{};
Bar bar2 = foo2.getBar(); // calls `Bar&amp; Foo::getBar() const&amp;`

Foo{}.getBar(); // calls `Bar&amp;&amp; Foo::getBar() &amp;&amp;`
std::move(foo).getBar(); // calls `Bar&amp;&amp; Foo::getBar() &amp;&amp;`
std::move(foo2).getBar(); // calls `const Bar&amp;&amp; Foo::getBar() const&amp;`</pre>
      </section>

    </main>

  </body>

</html>
