<!DOCTYPE html>
<html>
  <head>
    <title>Functions in C++</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Functions in C++: C-style, lambdas, member functions etc."/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a rel="prev" href="cpp.html">Functions in C++</a></p>
        <p><a            href="cpp.exceptions.html">C++ Exceptions</a></p>
        <p><a            href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a></p>
      </div>
      <div>
        <p><a href="cpp.core-guidelines.html">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup (<em>local</em>)</p>
        <p><a target="_blank" href="http://isocpp.github.io/CppCoreGuidelines/">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup, much like the C++ language itself (<em>online</em>)</p>
      </div>
      <div>
        <p><a href="cpp.cpp11.html">C++11</a></p>
        <p><a href="cpp.cpp14.html">C++14</a></p>
        <p><a href="cpp.cpp20.html">C++20</a></p>
      </div>
    </nav>

    <main>
      <h1>Functions in C++</h1>

      <section id="operators">
        <h2>Operators*</h2>
        <section id="3-way">
          <h3>C++20: The Three-Way Comparison Operator</h3>
          <p style="text-align: right">(June 11, 2020/1 Comment/in C++20/by Rainer Grimm at <code><a target="_blank" href="https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator/">https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator/</a></code>)</p>
          <p>The <dfn>three-way comparison operator</dfn> <code>&lt;=></code> is often just called the spaceship operator. The spaceship operator determines whether <var>A</var> &lt; <var>B</var>, <var>A</var> = <var>B</var>, or <var>A</var> > <var>B</var> for two values, <var>A</var> and <var>B</var>. You can define the spaceship operator, or the compiler can auto-generate it.</p>
          <p>Before C++20 introduced the three-way comparison operator, it was not enough to define <code>operator&lt;</code> but you also needed to define the remaining five in a consistent way, something like this:</p>
          <pre>bool operator==(const MyInt&amp; rhs) const {
    return value == rhs.value;
}
bool operator!=(const MyInt&amp; rhs) const {
    return !(*this == rhs);
}
bool operator&lt;=(const MyInt&amp; rhs) const {
    return !(rhs &lt; *this);
}
bool operator&gt;(const MyInt&amp; rhs)  const {
    return rhs &lt; *this;
}
bool operator&gt;=(const MyInt&amp; rhs) const {
    return !(*this &lt; rhs);
}</pre>
          <p>You can define the three-way comparison operator or request it from the compiler with =default. In both cases, you get all six comparison operators: ==, !=, &lt;, &lt;=, &gt;, and &gt;=.</p>
          <p>The programmer could define it like this:</p>
          <pre>struct MyInt {
    int value;
    explicit MyInt(int val): value{val} { }
    auto operator&lt;=&gt;(const MyInt&amp; rhs) const {           // (1)
        return value &lt;=&gt; rhs.value;
    }
};</pre>
          <p>or just let the compiler define it:</p>
          <pre>struct MyDouble {
  double value;
  explicit constexpr MyDouble(double val): value{val} { }
  auto operator&lt;=&gt;(const MyDouble&amp;) const = default;   // (2)
};</pre>
          <p>The compiler-generated three-way comparison operator needs the header <cite>&lt;compare&gt;</cite>, which is <code>implicit</code> <code>constexpr</code> and <code>noexcept</code>. Additionally, it performs a lexicographical comparison.</p>
          <aside><dfn>Lexicographical comparison</dfn> means that all base classes are compared left to right and all non-static members in their declaration order. I have to qualify: for performance reasons, the compiler-generated == and != operators behave differently in C++20.</aside>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>

        </section>
      </section>

      <section id="lambdas">
        <h2>lambdas</h2>

        <section>
          <h3>Lambda Capture Initializers</h3>
          <p>This allows creating lambda captures initialized with arbitrary expressions. The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body. The initializing expression is evaluated when the lambda is created (not when it is invoked).</p>
          <pre>int factory(int i) { return i * 10; }
auto f = [x = factory(2)] { return x; }; // returns 20

auto generator = [x = 0] () mutable {
  // this would not compile without 'mutable' as we are modifying x on each call
  return x++;
};
auto a = generator(); // == 0
auto b = generator(); // == 1
auto c = generator(); // == 2</pre>
          <p>Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lambda by value. Note that in the below example the <var>p</var> in the capture-list of <var>task2</var> on the left-hand-side of <code>=</code> is a new variable private to the lambda body and does not refer to the original <var>p</var>.</p>
          <pre>auto p = std::make_unique&lt;int&gt;(1);

auto task1 = [=] { *p = 5; }; // ERROR: std::unique_ptr cannot be copied
// vs.
auto task2 = [p = std::move(p)] { *p = 5; }; // OK: <var>p</var> is move-constructed into the closure object
// the original p is empty after <var>task2</var> is created</pre>
          <p>Using this reference-captures can have different names than the referenced variable.</p>
          <pre>auto x = 1;
auto f = [&amp;r = x, x = x * 10] {
  ++r;
  return r + x;
};
f(); // sets <var>x</var> to 2 and returns 12</pre>
        </section>
        <section>
          <h3>Return type deduction</h3>
          <p>Using an <code>auto</code> return type in C++14, the compiler will attempt to deduce the type for you. With lambdas, you can now deduce its return type using <code>auto</code>, which makes returning a deduced reference or rvalue reference possible.</p>
          <pre>// Deduce return type as `int`.
auto f(int i) {
 return i;
}
template &lt;typename T&gt;
auto&amp; f(T&amp; t) {
  return t;
}

// Returns a reference to a deduced type.
auto g = [](auto&amp; x) -> auto&amp; { return f(x); };
int y = 123;
int&amp; z = g(y); // reference to `y`</pre>
        </section>

        <section>
          <h3>Generic lambda expressions</h3>
          <p>C++14 allows the auto type-specifier in the parameter list, enabling polymorphic lambdas.</p>
          <pre>auto identity = [](auto x) { return x; };
int three = identity(3); // == 3
std::string foo = identity("foo"); // == "foo"</pre>
        </section>
      </section>

      <section id="bind">
        <h2>Binding Function Arguments with <code>std::bind()</code> (in the <code>&lt;functional&gt;</code> Header)</h2>
        <p><code>std::bind()</code> returns a function object based on <var>fn</var>, but with its arguments bound to <var>args</var>.</p>
        <pre>template &lt;           class Fn, class... Args&gt;  /* unspecified */
bind (Fn&amp;&amp; fn, Args&amp;&amp;... args); // (1)
template &lt;class Ret, class Fn, class... Args&gt;  /* unspecified */
bind (Fn&amp;&amp; fn, Args&amp;&amp;... args); // (2)</pre>
        <p>Each argument may either be bound to a value or be a placeholder (in namespace <code>std::placeholders</code>):</p>
        <ul>
          <li>If bound to a value, calling the returned function object will always use that value as argument.</li>
          <li>If a placeholder, calling the returned function object forwards an argument passed to the call (the one whose order number is specified by the placeholder).</li>
        </ul>
        <p>Calling the returned object returns the same type as <var>fn</var>, unless a specific return type is specified as <var>Ret</var> (second prototype) (note that <var>Ret</var> is the only template parameter that cannot be implicitly deduced by the arguments passed to this function).</p>
        <hr/>
        <p>The type of the returned object has the following properties:</p>
        <ul>
          <li>Its functional call returns the same as <var>fn</var> with its arguments bound to args... (or forwarded, for placeholders).</li>
          <li>For (1), it may have a member variable named <code>result_type</code>: if <var>Fn</var> is a pointer to function or member function type, it is defined as an alias of its return type. Otherwise, it is defined as <code>Fn::result_type</code>, if such a member type exists.</li>
          <li>For (2), it has a member variable named <code>result_type</code>, defined as an alias of <var>Ret</var>.</li>
          <li>It is move-constructible and, if the type of all of its arguments are copy-constructible, it is also copy-constructible. Both constructors never throw, provided none of the corresponding constructors of the decay types of <var>Fn</var> and <var>Args...</var> throw.</li>
        </ul>
        <section>
          <h3>Parameters</h3>
          <dl>
            <dt><var>fn</var></dt>
            <dd>
              <p>A function object, pointer to function or pointer to member.</p>
              <p><var>fn</var> shall have a decay type which is move-constructible from <var>fn</var>.</p>
            </dd>
            <dt><var>args...</var></dt>
            <dd>
              <p>List of arguments to bind: either values, or placeholders.</p>
              <p>The types in <var>args...</var> shall have decay types which are move-constructible from their respective arguments in <var>args....</var></p>
              <p>If for any argument, its decay type is a <a target="_blank" href="cpp.reference_wrapper.html">reference_wrapper</a>, it bounds to its referenced value instead.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h3>Return Value</h3>
          <p>A function object that, when called, calls <var>fn</var> with its arguments bound to <var>args</var>.</p>
          <p>If <var>fn</var> is a pointer to member, the first argument expected by the returned function is an object of the class <code>*fn</code> is a member (or a reference to it, or a pointer to it).</p>
        </section>
        <section>
          <h3>Example</h3>
          <p></p>
          <pre>#include &lt;iostream&gt;     // std::cout
#include &lt;functional&gt;   // std::bind

// a function: (also works with function object: std::divides&lt;double&gt; my_divide;)
double my_divide (double x, double y) {return x/y;}

struct MyPair {
  double a,b;
  double multiply() {return a*b;}
};

int main () {
  using namespace std::placeholders;    // adds visibility of _1, _2, _3,...

  // binding functions:
  auto fn_five = std::bind (my_divide,10,2);               // returns 10/2
  std::cout &lt;&lt; fn_five() &lt;&lt; '\n';                          // 5

  auto fn_half = std::bind (my_divide,_1,2);               // returns x/2
  std::cout &lt;&lt; fn_half(10) &lt;&lt; '\n';                        // 5

  auto fn_invert = std::bind (my_divide,_2,_1);            // returns y/x
  std::cout &lt;&lt; fn_invert(10,2) &lt;&lt; '\n';                    // 0.2

  auto fn_rounding = std::bind&lt;int&gt; (my_divide,_1,_2);     // returns int(x/y)
  std::cout &lt;&lt; fn_rounding(10,3) &lt;&lt; '\n';                  // 3

  MyPair ten_two {10,2};

  // binding members:
  auto bound_member_fn = std::bind (&amp;MyPair::multiply,_1); // returns x.multiply()
  std::cout &lt;&lt; bound_member_fn(ten_two) &lt;&lt; '\n';           // 20

  auto bound_member_data = std::bind (&amp;MyPair::a,ten_two); // returns ten_two.a
  std::cout &lt;&lt; bound_member_data() &lt;&lt; '\n';                // 10

  return 0;
}</pre>
          <p>Output:</p>
          <pre>5
5
0.2
3
20
10</pre>
        </section>

      </section>
      <section>
        <h2>Trailing return types</h2>
        <p>C++11 allows functions and lambdas an alternative syntax for specifying their return types.</p>
        <pre>int f() {
  return 123;
}
// vs.
auto f() -&gt; int {
  return 123;
}
auto g = []() -&gt; int {
  return 123;
        };</pre>
        <p>This feature is especially useful when certain return types cannot be resolved:</p>
        <pre>// NOTE: This does not compile!
template &lt;typename T, typename U&gt;
decltype(a + b) add(T a, U b) {
    return a + b;
}

// Trailing return types allows this:
template &lt;typename T, typename U&gt;
auto add(T a, U b) -&gt; decltype(a + b) {
    return a + b;
}</pre>
        <p>In C++14, <a target="_blank" href="cpp.cpp14.html#decltype-auto">decltype(auto)</a> can be used instead.</p>
      </section>

      <section id="ref-qualified-member-functions">
        <h2>Ref-qualified member functions</h2>
        <p>Member functions can now be qualified depending on whether <code>*this</code> is an lvalue or rvalue reference.</p>
        <pre>struct Bar {
  // ...
};

struct Foo {
  Bar&amp; getBar() &amp; { return bar; }
  const Bar&amp; getBar() const&amp; { return bar; }
  Bar&amp;&amp; getBar() &amp;&amp; { return std::move(bar); }
  const Bar&amp;&amp; getBar() const&amp;&amp; { return std::move(bar); }
private:
  Bar bar;
};

Foo foo{};
Bar bar = foo.getBar(); // calls `Bar&amp; getBar() &amp;`

const Foo foo2{};
Bar bar2 = foo2.getBar(); // calls `Bar&amp; Foo::getBar() const&amp;`

Foo{}.getBar(); // calls `Bar&amp;&amp; Foo::getBar() &amp;&amp;`
std::move(foo).getBar(); // calls `Bar&amp;&amp; Foo::getBar() &amp;&amp;`
std::move(foo2).getBar(); // calls `const Bar&amp;&amp; Foo::getBar() const&amp;`</pre>
      </section>

    </main>

  </body>

</html>
