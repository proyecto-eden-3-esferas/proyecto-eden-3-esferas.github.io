<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>STL Containers</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p><a rel="prev" href="cpp.containers.html">C++ Standard Containers</a></p>
        <p><a rel="next" href="cpp.associative-containers.html">C++ Associative Containers: Maps, Sets...</a></p>
      </div>
      <div>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a            href="cpp.iterators.html">Iterators: Pointers for STL Containers</a></p>
        <p><a            href="cpp.stl.html">The C++ Standard Template Library</a></p>
      </div>
    </nav>

    <main>
      <h1>Sequence Containers</h1>
      <section id="lists">
        <h2>Lists with <code>std::list</code> and <code>std::forward_list</code></h2>
        <p>A <dfn><a target="_blank" href="adt.linked-list.html">list</a></dfn> is a sequence optimized for insertion and deletion of elements. When you insert into a list or delete an element from a list , the locations of other elements of the list are not affected. In particular, iterators referring to other elements are not affected.</p>
        <p>The main drawback of <code>std::list</code> and <code>std::forward_list</code> compared to these other sequence containers is that they lack direct access to the elements by their position; For example, to access the sixth element in a list, one has to iterate from a known position (like the beginning or the end) to that position, which takes linear time in the distance between these. They also consume some extra memory to keep the linking information associated to each element (which may be an important factor for large lists of small-sized elements).</p>
        <p><a target="_blank" href="ai.html#symbolic">Artificial Intelligence</a> lists are basically weakly-typed or untyped lists. Such lists may contain elements of any type, even sublists... Just like lists in C++, they are <em>not</em> index-addressable.</p>
        <hr/>
        <p>The STL provides two linked-list types:</p>
        <ol>
          <li><a href="#std_list">list</a>: a doubly-linked list, and</li>
          <li><a href="#forward_list">forward_list</a>: a singly-linked list introduced in recent revisions (C++11)</li>
        </ol>
        <p>These are implemented in container <code>std::list&lt;&gt;</code> and <code>std::forward_list&lt;&gt;</code>.</p>
        <p id="list_shared_members">With the exception of subscripting, capacity management, and <code class="function">size()</code> for <code>forward_list</code>, the STL lists provide the member types and operations offered by <code>vector&lt;&gt;</code>. In addition, <code>list&lt;&gt;</code> and <code>forward_list&lt;&gt;</code> provide specific list member functions:</p>
        <section id="std_list">
          <h3>Doubly-Linked Lists with <code>std::list</code></h3>
          <table>
            <tbody>
              <tr>
                <td>st.push_front(x)</td>
                <td>Add x to lst (using copy or move) before the first element</td>
              </tr>
              <tr>
                <td><var>lst</var>.pop_front()</td>
                <td>Remove the first element from lst</td>
              </tr>
              <tr>
                <td><var>lst</var>.emplace_front(args)</td>
                <td>Add T{args} to lst before the first element</td>
              </tr>
              <tr>
                <td><var>lst</var>.remove(v)</td>
                <td>Remove all elements of lst with value v</td>
              </tr>
              <tr>
                <td><var>lst</var>.remove_if(f)</td>
                <td>Remove all elements of lst for which f(x)==true</td>
              </tr>
              <tr>
                <td><var>lst</var>.unique()</td>
                <td>Remove adjacent duplicate elements of lst</td>
              </tr>
              <tr>
                <td><var>lst</var>.unique(f)</td>
                <td>Remove adjacent duplicate elements of lst using f for equality</td>
              </tr>
              <tr>
                <td><var>lst</var>.merge(lst2)</td>
                <td>Merge the ordered lists lst and lst2 using &lt; as the order; lst2 is merged into lst and emptied in the process</td>
              </tr>
              <tr>
                <td><var>lst</var>.merge(lst2,f)</td>
                <td>Merge the ordered lists lst and lst2 using f as the order; lst2 is merged into lst and emptied in the process</td>
              </tr>
              <tr>
                <td><var>lst</var>.sort()</td>
                <td>Sort lst using &lt; as the order</td>
              </tr>
              <tr>
                <td><var>lst</var>.sort(f)</td>
                <td>Sort lst using f as the order</td>
              </tr>
              <tr>
                <td><var>lst</var>.reverse()</td>
                <td>Reverse the order of the elements of lst ; noexcept</td>
              </tr>
            </tbody>
          </table>
          <section>
            <h4>List Element Access</h4>
            <ul>
              <li><code>front()</code> Access first element</li>
              <li><code>back()</code> Access last element</li>
            </ul>
          </section>
          <section>
            <h4><code>splice</code></h4>
            <p><code>splice</code> is a public member function that transfers elements from list to list.</p>
            <pre>// entire list (1):
void splice (const_iterator position, list&amp; x);
void splice (const_iterator position, list&amp;&amp; x);

// single element (2):
void splice (const_iterator position, list&amp; x, const_iterator i);
void splice (const_iterator position, list&amp;&amp; x, const_iterator i);

// element range (3):
void splice (const_iterator position, list&amp;  x, const_iterator first, const_iterator last);
void splice (const_iterator position, list&amp;&amp; x, const_iterator first, const_iterator last);</pre>
            <p>This member function effectively inserts those elements into the container and removes them from x, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. They are transferred, no matter whether <var>x</var> is an lvalue or an rvalue, or whether the value_type supports move-construction or not.</p>
            <hr/>
            <p>An example:</p>
            <pre>// splicing lists
#include &lt;iostream&gt;
#include &lt;list&gt;

int main ()
{
  std::list&lt;int&gt; mylist1, mylist2;
  std::list&lt;int&gt;::iterator it;

  // set some initial values:
  for (int i=1; i&lt;=4; ++i)
     mylist1.push_back(i);      // mylist1: 1 2 3 4

  for (int i=1; i&lt;=3; ++i)
     mylist2.push_back(i*10);   // mylist2: 10 20 30

  it = mylist1.begin();
  ++it;                         // points to 2

  mylist1.splice (it, mylist2); // mylist1: 1 10 20 30 2 3 4
                                // mylist2 (empty)
                                // "it" still points to 2 (the 5th element)

  mylist2.splice (mylist2.begin(),mylist1, it);
                                // mylist1: 1 10 20 30 3 4
                                // mylist2: 2
                                // "it" is now invalid.
  it = mylist1.begin();
  std::advance(it,3);           // "it" points now to 30

  mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end());
                                // mylist1: 30 3 4 1 10 20

  std::cout &lt;&lt; "mylist1 contains:";
  for (it=mylist1.begin(); it!=mylist1.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  std::cout &lt;&lt; "mylist2 contains:";
  for (it=mylist2.begin(); it!=mylist2.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}</pre>
          </section>

        </section>
        <section id="forward_list">
          <h3>Singly-Linked Lists with <code>std::forward_list</code>*</h3>
          <p><code>std::forward_list</code> objects are single-linked lists, and thus they can only be iterated forwards, in exchange for being somewhat smaller and more efficient than doubly-linked <code>std::list</code>&apos;s.</p>
        </section>
      </section>

      <section id="vector">
        <h2>Vectors</h2>
        <p>std::<code>vectors</code> are automatic arrays which keep track of their <dfn>size</dfn>, that is how many places have been occupied (pressumably in an integer variable), as well as their <dfn>capacity</dfn>, which is the total number of objects of the given type that they can accomodate. Further, when they have filled up, they reallocate their sequence of objects in a larger chunk of memory, the start of this run of memory is updated (in a pointer variable), and the new, larger capacity is updated, too. This means that indeces into the array-like structure remain valid, but pointers are invalidated, so they must never be taken in the first place.</p>
        <p>Unlike with linked lists, insertions (or deletions) are either meaningless or demand that all objects after the one inserted be shifted one place, which is done in linear time, whereas lists perform insertions and deletions in constant time. Furthermore, insertions and deletions would invalidate all subsequent indeces...</p>
      </section>

      <section id="stl_deque">
        <h2>Double-Ended Queues with <code>std::deque</code></h2>
        <p>A <code>deque</code> (pronounced "deck") is very similar to a vector. It manages its elements with a dynamic array, provides random access, and has almost the same interface as a vector. The difference is that with a <code>deque</code> the dynamic array is open at both ends. Thus, a <code>deque</code> is fast for insertions and deletions at both the end and the beginning.</p>
        <p>Deques have the following differences compared with the abilities of vectors:</p>
        <ol>
          <li>Inserting and removing elements is fast both at the beginning and at the end (for vectors it is only fast at the end). These operations are done in amortized constant time.</li>
          <li>The internal structure has one more indirection to access the elements, so element access and iterator movement of <code>deque</code>&apos;s are usually a bit slower.</li>
          <li>Iterators must be smart pointers of a special type rather than ordinary pointers because they must jump between different blocks.</li>
          <li>In systems that have size limitations for blocks of memory (for example, some PC systems), a <code>deque</code> might contain more elements because it uses more than one block of memory. Thus, max_size() might be larger for <code>deque</code>'s.</li>
          <li>Deques provide no support to control the capacity and the moment of reallocation. In particular, any insertion or deletion of elements other than at the beginning or end invalidates all pointers, references, and iterators that refer to elements of the <code>deque</code>.</li>
          <li>However, reallocation may perform better than for vectors, because according to their typical internal structure, <code>deque</code>&apos;s don&apos;t have to copy all elements on reallocation, only the block (out of several blocks) targeted by the insertion/deletion.</li>
          <li>Blocks of memory might get freed when they are no longer used, so the memory size of a <code>deque</code> might shrink (however, whether and how this happens is implementation specific).</li>
        </ol>
      </section>

      <section id="array">
        <h2>Fixed-sized Arrays with <code>std::array</code></h2>
        <p><code>std::array</code> is a fixed-sized array, kind of a paired-down <code>std::vector</code>.</p>
        <p><code>std::array</code> is defined in <cite>&lt;array&gt;</cite>.</p>
        <p>The size of an <code>std::array</code> object is passed in as a template parameter.</p>
        <hr/>
        <p>Synopsis:</p>
        <pre>template &lt;typename T, size_t N&gt; class array;</pre>
        <p>where <var>T</var> is the type of the elements contained and is aliased as member type <code>array::value_type</code>.</p>
        <hr/>
        <p>It is as efficient in terms of storage size as an ordinary array declared with the language's bracket syntax (<code>[]</code>). This class merely adds a layer of member and global functions to it, so that arrays can be used as standard containers.</p>
        <hr/>
        <p>Unlike with the other containers in the Standard Library, swapping two array containers is a linear operation that involves swapping all the elements in the ranges individually, which generally is a considerably less efficient operation. On the other side, this allows the iterators to elements in both containers to keep their original container association.</p>
        <p>Another unique feature of array containers is that they can be treated as tuple objects: The <cite>&lt;array&gt;</cite> header overloads the global <code>std::get</code> function to access the elements of the array as if it was a tuple, as well as specialized <code>tuple_size</code> and <code>tuple_element</code> types.</p>
        <hr/>
        <p><code>std::array</code> has the full set of iterator member functions: <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code>, <code>cbegin()</code>, <code>cend()</code>, <code>crbegin()</code>, and <code>crend()</code></p>
        <hr/>
        <p>The capacity interface has three these constant member functions: <code>size()</code>, <code>max_size()</code>, and <code>emply()</code>. Both <code>size()</code> and <code>max_size</code> are always equal to the second template parameter used to instantiate the array template class. <code>empty()</code> only return true if the array size is 0, that is, if the second template parameter is 0.</p>
        <hr/>
        <p>Member <code>fill(const value_type&amp; <var>value</var>)</code> fills array with <var>value</var>.</p>
        <hr/>
        <p>Member <code>data()</code> returns a pointer to the first element in the <code>std::array</code> object.</p>
        <pre>value_type* data() noexcept;
const value_type* data() const noexcept;</pre>
        <section>
          <h3>Element Access Members</h3>
          <p>Access is limited to the following member functions:</p>
          <ul>
            <li><code>operator[](<var>INDEX</var>)</code> Access element (public member function)</li>
            <li><code>at(<var>INDEX</var>)</code> Access element (public member function) and throws <code>std::out_of_range</code> exception if <var>INDEX</var> is beyond boundaries</li>
            <li><code>front()</code> Access first element (public member function)</li>
            <li><code>back()</code> Access last element (public member function)</li>
            <li><code>data()</code> Get pointer to data (public member function)</li>
          </ul>
        </section>

      </section>

      <section id="bitmap">
        <h2>Bitmap's*</h2>
      </section>

      <section>
        <h2>Random Access Returning Reference</h2>
        <p>Sequence containers based on an array offer access through indexes. They will declare:</p>
        <pre>reference operator[](size_type idx);
const_reference operator[](size_type idx) const;</pre>
        <p>These are fast but do not perform bound checking. Trying to access beyond the end of the underlying array may, well, crash the program or yield the wrong result. If unsure, use:</p>
        <pre id="bounds_checking_at">      reference at(size_type idx);
const_reference at(size_type idx) const;</pre>
        <p>Member function <code class="function">at(size_type idx)</code> returns a <code>reference</code> or <code>const_reference</code> all right, but will throw an <code>out_of_range</code> exception. Use <code class="function">at(size_type idx)</code> inside a <kbd>try {...}</kbd> block.</p>
        <p>If you write a container in the STL tradition that returns references to elements of an array, write the body of your <code class="function">at(size_type idx)</code> like this:</p>
        <pre>if(idx &gt;= size())
  throw out_of_range("Container::at() used with idx past the end");
else
  return the_array[idx];</pre>
      </section>

      <section>
        <h2>Find and Replace Operations</h2>
        <p>Functions <code class="function">find(...)</code> returns a <kbd>size_type</kbd> variable, actually an integer representing an index to the element found. A <code>string</code>&apos;s <code class="function">find()</code> operation may return <kbd>npos</kbd>, for <q>no position</q>, which should be defined as <inlineequation>-1</inlineequation>.</p>
      </section>

    </main>
  </body>
</html>
