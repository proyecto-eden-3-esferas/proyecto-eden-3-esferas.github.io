<!DOCTYPE html>
<html>
  <head>
    <title>Ranges (C++20)</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a href="cpp.coroutines.html">C++ Coroutines</a></p>
        <p><a href="cpp.modules.html">C++ Coroutines</a></p>
        <p><a href="cpp.format.html">C++20 Formatting</a></p>
      -->
      <div>
        <p><a rel="next" href="cpp.generics.concepts.html">Concepts or Template Constraints in C++</a></p>
      </div>
      <div>
        <p><a rel="prev" href="cpp.cpp20.html">C++20</a></p>
        <p><a            href="cpp.cpp11.html">C++11</a></p>
        <p><a            href="cpp.cpp14.html">C++14</a></p>
        <p><a            href="computing.html">Computing</a></p>
      </div>
    </nav>

    <main>
      <h1>Ranges (C++20)</h1>

      <p>Ranges are a new element of the STL that makes using algorithms more concise and adds the ability to write code in a functional style.</p>
      <p>[...]</p>
      <nav>
        <!--
        <p><a href="#motivation">Motivation</a></p>
          <h3>3.1.1: Avoid code duplication</h3>
          <h3>3.1.2: Consistency</h3>
          <h3>3.1.3: Safety</h3>
          <h3>3.1.4: Composability</h3>
        -->
      <p><a href="#terminology">Terminology</a></p>
      <!--
          <h3>A <code>common_range</code></h3>
          <h3>A <code>sized_range</code></h3>
      -->
      <p><a href="#algo">A range algorithm</a></p>
      <!--<h3>3.4.1: Projections for range algorithms</h3>-->
      <p><a href="#view-into-range">A view into a range</a></p>
      <p><a href="#adaptor">A range adaptor</a></p>
          <!--<h3>3.6.1: A custom range adaptor</h3>-->
      <p><a href="#new-ranges-namespaces">The new ranges namespaces</a></p>
      <p><a href="#concepts">Ranges Concepts</a></p>
      <p><a href="#views">Views</a></p>
      <p><a href="#writing-your-own">Creating a custom range</a></p>
      <!--
          <h3>3.10.1: Implementing the view</h3>
          <h3>3.10.2: A range adaptor for <code>custom_take_view</code></h3>
          <h3>3.10.3: Add the pipe-syntax to <code>custom_take_view</code></h3>
          <h3>3.10.4: A more generalized pipe-syntax implementation</h3>
      -->
      </nav>
      <!--
      <section id="motivation">
        <h2>3.1: Motivation</h2>
          <h3>3.1.1: Avoid code duplication</h3>
          <h3>3.1.2: Consistency</h3>
          <h3>3.1.3: Safety</h3>
          <h3>3.1.4: Composability</h3>
      </section>
      -->

      <section id="terminology">
        <h2>Terminology</h2>
          <section>
            <h3>A Range</h3>
            <p>A <dfn>range</dfn> is a type with an iterator pair consisting of a <code>begin()</code> and <code>end()</code> function:</p>
            <pre>struct Range {
  T begin();
  T end();
};</pre>
            <p>The code above models a classical <a href="cpp.containers.html">STL container</a>. For at least some ranges, we need something more general that does not only model a finite range. We usually compare <var>begin</var> and <var>end</var> for equality and stop the iterations as soon as that condition is true. For an infinite range, which is possible with ranges, <var>end</var> is usually a different type than that for <var>begin</var>. The STL brings us a new type for convenience: <code>std::default_sentinel_t</code>:</p>
            <pre>struct Range {
  T                       begin();
  std::default_sentinel_t end();
};</pre>
            <p>You can see <code>std::default_sentinel_t</code> as a tag type, which simply enables <code>end()</code> to have a return type and match the correct overload of <code>operator==</code> later on.</p>
          </section>
          <section>
            <h3>A <code>common_range</code></h3>
            <p>Ranges, as explained, consist of an <code>end()</code> member function that provides a sentinel. A <code>common_range</code>, on the other hand, is a range where <code>begin(r)</code> and <code>end(r)</code> return the same type. This implies that a <code>common_range</code>&apos;s <code>end()</code> does not return a sentinel.</p>
            <p>All classic iterators model a <code>common_range</code>. Moreover, most STL types have a common_range constructor.</p>
          </section>
          <section>
            <h3>A <code>sized_range</code></h3>
          </section>
      </section>

      <section id="algo">
        <h2>3.4: A range algorithm</h2>
          <h3>3.4.1: Projections for range algorithms</h3>
      </section>

      <section id="view-into-range">
        <h2>3.5: A view into a range</h2>
      </section>

      <section id="adaptor">
        <h2>3.6: A range adaptor</h2>
          <h3>3.6.1: A custom range adaptor</h3>
      </section>

      <section id="new-ranges-namespaces">
        <h2>3.7: The new ranges namespaces</h2>
      </section>

      <section id="concepts">
        <h2>3.8: Ranges Concepts</h2>
      </section>

      <section id="views">
        <h2>3.9: Views</h2>
      </section>

      <section id="writing-your-own">
        <h2>3.10: Creating a custom range</h2>
          <h3>3.10.1: Implementing the view</h3>
          <h3>3.10.2: A range adaptor for <code>custom_take_view</code></h3>
          <h3>3.10.3: Add the pipe-syntax to <code>custom_take_view</code></h3>
          <h3>3.10.4: A more generalized pipe-syntax implementation</h3>
      </section>
    </main>

  </body>

</html>
