<!DOCTYPE html>
<html>
  <head>
    <title>Variadic Templates</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Variadic Templates in C++"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a href="cpp.templates.html">C++ Generics (Templates)</a></p>
      -->
      <div>
        <p><a rel="next" href="cpp.templates.html">C++ Templates</a></p>
        <p><a rel="prev" href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a            href="cpp.traits.html">(Implementing) Trait Classes in C++</a></p>
        <p><a            href="cpp.type-aliases.html">Type Aliases in C++</a></p>
        <p><a            href="cpp.alias-templates.html">C++ Alias Templates</a></p>
        <p><a            href="cpp.separate_compilation.templates.html">Separate Compilation of Templates</a></p>
        <p><a            href="cpp.generics.concepts.html">C++ Concepts in Generic Programming</a></p>
      </div>
      <div>
        <p><a href="cpp.stl.html">C++ Standad Template Library (STL)</a></p>
        <p><a href="cpp.containers.html">C++ STL Containers</a></p>
      </div>
      <div>
        <p><a href="cpp.html">The C++ Programming Language</a></p>
      </div>
    </nav>
    <main>
      <h1>Variadic Templates</h1>
      <section>
        <h2>Variadic function templates in C++</h2>
        <p>Variadic templates are class or function templates that can take any variable(zero or more) number of arguments. In C++, templates can have a fixed number of parameters only that have to be specified at the time of declaration. However, variadic templates help to overcome this issue. Douglas Gregor and Jaakko JÃ¤rvi came up with this feature for C++.</p>
        <p>Variadic arguments are very similar to arrays in C++. We can easily iterate through the arguments, find the size (i.e. length) of the template, can access the values by an index, and can slice the templates too.</p>
        <p>So basically, Variadic function templates are functions that can take multiple numbers of arguments.</p>
        <p><strong>Syntax:</strong></p>
        <pre>template &lt;typename arg, typename... Args&gt;
return_type function_name(arg var1, Args... args)</pre>
        <p>The ellipsis (<code>...</code>) makes <var>Args</var> or <var>args</var> a so-called <dfn>parameter pack</dfn>. To be precise, <var>Args</var> is a template parameter pack and <var>args</var> a function parameter pack. Two operations are possible with parameter packs. They can be packed and unpacked. If the ellipse is to the left of <var>Args</var>, the parameter pack will be packed; if it is to the right of <var>Args</var>, it will be unpacked. Because of the function template argument deduction, the compiler can derive the template arguments.</p>
        <aside>Usually, you don&apos;t apply pack expansion directly. You use variadic templates doing it automatically, using fold expression, or constexpr if in C++17.</aside>
        <!--<p><strong>Note:</strong> The arguments must be put inside angular brackets.</p>-->
        <p>Below is an example in C++ to show how we can use a variadic function template:</p>
        <pre>// C++ program to demonstrate working of
// Variadic function Template
#include &lt;iostream&gt;
using namespace std;

// To handle base case of below recursive
// Variadic function Template
void print()
{
    cout &lt;&lt; "I am empty function and "
            "I am called at last.\n";
}

// Variadic function Template that takes
// variable number of arguments and prints
// all of them.
template &lt;typename T, typename... Types&gt;
void print(T var1, Types... var2)
{
    cout &lt;&lt; var1 &lt;&lt; endl;

    print(var2...);
}

// Driver code
int main()
{
    print(1, 2, 3.14,
          "Pass me any "
          "number of arguments",
          "I will print\n");

    return 0;
}</pre>
        <p>Output:</p>
        <pre>1
2
3.14
Pass me any number of arguments
I will print

I am empty function and I am called at last.</pre>
        <aside>Remember that templates are replaced by actual functions by the compiler.</aside>
        <hr/>
        <p><strong>Explanation:</strong> The variadic templates work as follows:</p>
        <p>The statement, <code>print(1, 2, 3.14, "Pass me any number of arguments", "I will print\n");</code> is evaluated in the following manner:</p>
        <p>Firstly, the compiler resolves the statement into</p>
        <pre>cout &lt;&lt; 1 &lt;&lt; endl ;
print(2, 3.14, "Pass me any number of arguments",
      "I will print\n");</pre>
        <p>Now, the compiler finds a print() function which can take those arguments and in result executes the variadic print() function again in a similar manner. And so on.</p>
        <pre></pre>
        <p></p>
        <section>
          <h3>Variadic Templates in the STL</h3>
          <p>Variadic templates are often used in the Standard Template Library and the core language.</p>
          <pre>template &lt;typename... Types&gt;                                              // (1)
class tuple;

template &lt;typename Callable, typename... Args &gt;                           // (2)
explicit thread(Callable&amp;&amp; f, Args&amp;&amp;... args);

template &lt;typename Lockable1, typename Lockable2, typename... LockableN&gt;  // (3)
void lock(Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn);

sizeof...(ParameterPack);</pre>
        </section>
        <section>
          <h3><code>sizeof...</code> Operator</h3>
          <p>The <code>sizeof...</code> operator can be used to determine how many elements a parameter pack contains directly. The elements are not evaluated.</p>
          <pre>// printSize.cpp

#include &lt;iostream&gt;

using namespace std::literals;

template &lt;typename ... Args&gt;
void printSize(Args&amp;&amp; ... args){
    std::cout &lt;&lt; sizeof...(Args) &lt;&lt; ' ';              // (1)
    std::cout &lt;&lt; sizeof...(args) &lt;&lt; '\n';             // (2)
}

int main() {

    std::cout &lt;&lt; '\n';

    printSize();                                       // (3)
    printSize("C string", "C++ string"s, 2011, true);  // (4)

    std::cout &lt;&lt; '\n';

}</pre>
        </section>
        <section>
          <h3>Usage of Parameter Packs</h3>
          <p style="text-align: right">(From <cite><a target="_blank" href="https://www.modernescpp.com/index.php/more-arbout-variadic-templates/">https://www.modernescpp.com/index.php/more-arbout-variadic-templates/</a></cite>, by Rainer Grimm)</p>
          <p>The usage of parameter packs obeys a typical pattern for class templates.</p>
          <ol>
            <li>Operate on the first element of the parameter pack and recursively invoke the operation on the remaining elements. This step reduces the parameter pack successively by its first element.</li>
            <li>The recursion ends after a finite number of steps.</li>
            <li>The boundary condition is typically a fully specialized template.</li>
          </ol>
          <p>Thanks to this functional pattern for processing lists, you can calculate the product of numbers at compile time, for instance.</p>
          <pre>// multVariadicTemplates.cpp

#include &lt;iostream&gt;

template&lt;int ...&gt;                                                 // (1)
struct Mult;

template&lt;&gt;                                                        // (2)
struct Mult&lt;&gt; {
    static const int value = 1;
};

template&lt;int i, int ... tail&gt;                                     // (3)
struct Mult&lt;i, tail ...&gt; {
    static const int value = i * Mult&lt;tail ...&gt;::value;
};

int main(){

    std::cout &lt;&lt; '\n';

    std::cout &lt;&lt; "Mult&lt;10&gt;::value: " &lt;&lt; Mult&lt;10&gt;::value &lt;&lt; '\n';  // (4)
    std::cout &lt;&lt; "Mult&lt;10,10,10&gt;::value: " &lt;&lt; Mult&lt;10, 10, 10&gt;::value &lt;&lt; '\n';
    std::cout &lt;&lt; "Mult&lt;1,2,3,4,5&gt;::value: " &lt;&lt; Mult&lt;1, 2, 3, 4, 5&gt;::value &lt;&lt; '\n';

    std::cout &lt;&lt; '\n';

}</pre>
          <p>The class template Mult consists of a primary template and two specializations. Since the primary template (1) is not needed, a declaration is sufficient in this case: template&lt;int ...&gt; struct Mult. The specializations of the class template exist for no element (2) and at least one element (3). If Mult&lt;10,10,10&gt;::value is called, the last template is used by successively calling the first element with the rest of the parameter pack so that the value expands to the product 10*10*10. In the final recursion, the parameter pack contains no elements, and the boundary condition comes into action: template&lt;&gt; struct Mult&lt;&gt; (1). This returns the result of Mult&lt;10,10,10&gt;::value= 10*10*10*1 at compile time.</p>
          <!--
          <pre></pre>
          <p></p>
          <pre></pre>
          -->
        </section>

      </section>
      <section>
        <h2>Variadic Templates and Perfect Forwarding</h2>
        <p>Forwarding parameters is a way to receive all the arguments received by a function and resend them as they come. This is achieved through <dfn class="firstterm">variadic templates</dfn>, which allow the programmer to pass an undefined number of arguments to a function/method.</p>
        <p>The code that follows combines two new features of the C++11, <kbd class="userinput">constexpr</kbd> and variadic parameters. <dfn class="firstterm">constexpr</dfn> allows making computations at compile time if they are feasable (there are several conditions to meet, but for now, we just assume that they are fulfilled). In this example, we find the minimum of a list of arguments at compile time (thanks to <kbd class="userinput">constexpr</kbd>!). This is a generic version that works only with integers but works on 2, 3, 4, ... n arguments.</p>
        <pre>constexpr int min(int n, int p)
{
  return n &lt; p ? n : p;
}
template&lt;typename... Args&gt; constexpr int min(int n, Args... args)
{
    return min(n, min(args...));
}

int main(int argc, char *argv[])
{
  static_assert(min(4, 5, 6, 42, 7, 3, 6) == 3, "min is incorrect");
  return 0;
}</pre>
        <p>Forwarding is done through the <kbd class="userinput">std::forward</kbd> function from the <cite class="filename">utility</cite> header. It forwards the arguments exactly as they are received (more information in the man). Here is a little example of how it works:</p>
        <pre>#include &lt;iostream&gt;
#include &lt;utility&gt;

struct Item
{
  Item(): value{0} {}

  Item(const Item&amp; p){ std::cout &lt;&lt; "Copy" &lt;&lt; std::endl; }

  int value;
};

void take_args(int&amp; a, int&amp;&amp; b, int c, Item&amp; f)
{
  std::cout &lt;&lt; a &lt;&lt; " - " &lt;&lt; b &lt;&lt; " - " &lt;&lt; c
            &lt;&lt; " - " &lt;&lt;  f.value &lt;&lt; std::endl;
}

template &lt;typename... Args&gt;
void call_take_args(Args&amp;&amp;... args)
{
  take_args(std::forward&lt;Args&gt;(args)...);
}

int main()
{
  Item f;
  int i = 2;
  call_take_args(i, 4, 5, f);
}
// The program outputs "2 - 4 - 5 - 0".</pre>

      </section>

      <!--
      <section id="generic-factory">
        <h2>Implementing the C++ Idiom for a Fully Generic Factory</h2>
        <p style="text-align: right">(From <cite><a target="_blank" href="https://www.modernescpp.com/index.php/the-first-big-update-of-my-c-20-book">https://www.modernescpp.com/index.php/the-first-big-update-of-my-c-20-book</a></cite>)</p>
      </section>
      -->

    </main>
  </body>
</html>
