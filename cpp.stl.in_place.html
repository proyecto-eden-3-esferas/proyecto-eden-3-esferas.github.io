<!DOCTYPE html>
<html>
  <head>
    <title>std::in_place*</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="std::in_place, std::in_place_type, std::in_place_index, std::in_place_t, std::in_place_type_t, std::in_place_index_t"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>
    <meta name="author" content="AUTHOR"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
        <p><a href="cpp.stl.html">C++ Standad Template Library (STL)</a></p>
      -->
      <div>
        <p><a href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a href="cpp.streams.html">C++ Streams: Sources and Destinations of Data</a></p>
        <p><a href="cpp.classes.html">OOP in C++: Classes</a></p>
        <p><a href="cpp.function-object.html">C++ Function Objects</a></p>
      </div>
      <div>
        <p><a href="cpp.unique_ptr.html"><code>std::unique_ptr</code>: a Smart Pointer that Cannot be Copied</a></p>
        <p><a href="cpp.shared_ptr.html"><code>std::shared_ptr</code>: a Smart Pointer that Keeps Count of its Copies</a></p>
      </div>
      <div>
        <p><a href="cpp.stl.variant.html"><code>std::variant</code>&apos;s: Intelligent C++ Unions</a></p>
        <p><a href="cpp.stl.optional.html">Using <code>std::optional</code> to store optional values</a></p>
        <p><a href="cpp.stl.any.html">Using <code>std::any</code> to store values of <em>any</em> type</a></p>
        <p><a href="cpp.stl.emplacing.html">C++ Emplacing</a></p>
        <p><a href="cpp.containers.html">C++ STL Containers</a></p>
        <p><a href="cpp.iterators.html">Iterators: Pointers for STL Containers</a></p>
        <p><a href="cpp.strings.html">STD Strings: &lt;string&gt; and &lt;string_view&gt;</a></p>
        <p><a href="cpp.generics.concepts.html">C++ Concepts in Generic Programming</a></p>
        <p><a href="cpp.exceptions.html">C++ Exceptions</a></p>
        <p><a href="cpp.type_traits.html">Handling Type with <code>&lt;type_traits&gt;</code></a></p>
        <p><a rel="prev" href="cpp.html">The C++ Programming Language</a></p>
      </div>
      <div>
        <p><a href="cpp.get.html">C++ get()</a></p>
      </div>
      <div>
        <p><a target="_blank" href="http://isocpp.github.io/CppCoreGuidelines/">C++ Core Guidelines</a>, a collaborative effort led by Bjarne Stroustrup, much like the C++ language itself.</p>
        <p><a href="cpp.boost.html">The C++ Boost Library: Beyond the STL</a></p>
      </div>
    </nav>

    <main>
      <h1><code>std::in_place</code>, <code>std::in_place_type</code>, <code>std::in_place_index</code>, <code>std::in_place_t</code>, <code>std::in_place_type_t</code>, <code>std::in_place_index_t</code> (C++17)</h1>
      <p>(<i>Also see</i> <cite><a target="_blank" href="https://www.cppstories.com/2018/07/in-place-cpp17/">https://www.cppstories.com/2018/07/in-place-cpp17/</a></cite>)</p>
      <p>Defined in header <cite>&lt;utility&gt;</cite>.</p>
      <p>These helpers are used to efficiently initialise objects <q>in-place</q> - without additional temporary copy or move operations.</p>
      <hr/>
      <p>The following standard library types use (1-6) as disambiguation tags:</p>
      <ul>
        <li><code>any</code> (C++17) objects that hold instances of any CopyConstructible type (class)</li>
        <li><code>expected</code> (C++23) a wrapper that contains either an expected or error value (class template)</li>
        <li><code>move_only_function</code> (C++23) move-only wrapper of any callable object that supports qualifiers in a given call signature (class template)</li>
        <li><code>optional</code> (C++17) a wrapper that may or may not hold an object (class template)</li>
        <li><code>variant</code> (C++17) a type-safe discriminated union (class template)</li>
      </ul>
      <p><i>See</i> <a target="_blank" href="#cpp.stl.variant.html#in_place"><code>variant</code> constructors taking a <code>in_place*</code> parameter</a>.</p>

      <section id="syntax">
        <h2>Syntax</h2>
        <pre>struct in_place_t { explicit in_place_t() = default; }; // (1) for std::optional
inline constexpr std::in_place_t in_place {}; // (2) for std::optional
template&lt; class T &gt;
struct in_place_type_t { explicit in_place_type_t() = default; }; // (3) used for std::variant and std::any
template&lt; class T &gt;
constexpr std::in_place_type_t&lt;T&gt; in_place_type {}; // (4) used for std::variant and std::any
template&lt; std::size_t I &gt;
struct in_place_index_t { explicit in_place_index_t() = default; }; // (5) used for std::variant
template&lt; std::size_t I &gt;
constexpr std::in_place_index_t&lt;I&gt; in_place_index {}; // (6) used for std::variant</pre>
        <p>1,3,5) The type/type templates std::in_place_t, std::in_place_type_t and std::in_place_index_t can be used in the constructor's parameter list to match the intended tag.</p>
        <p>2,4,6) The corresponding std::in_place, std::in_place_type, and std::in_place_index instances of (1,3,5) are disambiguation tags that can be passed to the constructors to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.</p>

        <pre></pre>
      </section>

    </main>

  </body>

</html>
