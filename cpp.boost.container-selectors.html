<!DOCTYPE html>
<html>
  <head>
    <title>boost container selectors</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a href="cpp.namespaces.html">C++ Namespaces</a></p>
        <p><a href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a href="cpp.containers.html">C++ STL Containers</a></p>
      </div>
      <div>
        <p><a href="cpp.boost.html">The C++ Boost Library: Beyond the STL</a></p>
        <p><a href="cpp.boost.geometry.html">C++ Boost Geomety</a></p>
        <p><a href="cpp.boost.graph.html">C++ Boost Graph</a></p>
        <!--
        <p><a href="cpp.boost.geometry.html.bak">C++ Boost Geomety (<code>.bak</code>)</a></p>
        <p><a href="cpp.boost.graph.html.old">C++ Boost Graph (<code>.old</code>)</a></p>
        -->
      </div>
    </nav>

    <main>
      <h1>Boost Container Selectors</h1>
      <p><a href="cpp.boost.html">Boost</a>, and the <a href="cpp.boost.graph.html">C++ Boost Graph</a> in particular, uses containers from the STL such as <code class="classname">std::vector</code>, <code class="classname">std::list</code>, and <code class="classname">std::set</code> to store elements of a set. Which is to be used is selected through empty classes passed as template paramenters upon declaration.</p>
      <ul>
        <li><code class="constant">vecS</code> selects <code class="classname">std::vector</code>.</li>
        <li><code class="constant">listS</code> selects <code class="classname">std::list</code>.</li>
        <li><code class="constant">slistS</code> selects <code class="classname">std::slist</code>.</li>
        <li><code class="constant">setS</code> selects <code class="classname">std::set</code>.</li>
        <li><code class="constant">multisetS</code> selects <code class="classname">std::multiset</code>.</li>
        <li><code class="constant">hash_setS</code> selects <code class="classname">boost::unordered_set</code>.</li>
      </ul>
      <aside>
        <p> ... are redundant and wrong because modern C++ allows underlying container selection via <a target="_blank" href="cpp.templates.html#template-template-args">Template Template Arguments</a>.</p>
      </aside>

      <section id="container-generator">
        <h2>Generating your own Selector Struct with <code>container_gen</code> Traits Class</h2>
        <p> The <code>adjacency_list</code> class uses a traits class called <code>container_gen</code> to map the <code>OutEdgeList</code> and <code>VertexList</code> selectors to the actual container types used for the graph storage. The default version of the traits class is listed below, along with an example of how the class is specialized for the <code>listS</code> selector.</p>
        <pre>namespace boost {
  template &lt;class Selector, class ValueType&gt;
  struct container_gen { };

  template &lt;class ValueType&gt;
  struct container_gen&lt;listS, ValueType&gt; {
    typedef std::list&lt;ValueType&gt; type;
  };
}</pre>

        <p>To use some other container of your choice (such as <code>std::unordered_set</code>), define a selector class and then specialize the <code>container_gen</code> for your selector, inside the <code>boost</code> namespace.</p>
        <pre>struct unordered_setS { }; // your selector

  namespace boost {
    // the specialization for your selector
    template &lt;class ValueType&gt;
    struct container_gen&lt;unordered_setS, ValueType&gt; {
      typedef std::unordered_set&lt;ValueType&gt; type;
    };
  }</pre>
        <section>
          <h3>Templetized Selectors</h3>
          <p>There may also be situations when you want to use a container that has more template parameters than just <code>ValueType</code>. For instance, you may want to supply the allocator type. One way to do this is to hard-code in the extra parameters within the specialization of <code>container_gen</code>. However, if you want more flexibility then you can add a template parameter to the selector class. In the code below we show how to create a selector that lets you specify the allocator to be used with the <code>std::list</code>.</p>
          <pre>template &lt;class Allocator&gt;
  struct list_with_allocatorS { };

  namespace boost {
    template &lt;class Alloc, class ValueType&gt;
    struct container_gen&lt;list_with_allocatorS&lt;Alloc&gt;, ValueType&gt;
    {
      typedef typename Alloc::template rebind&lt;ValueType&gt;::other Allocator;
      typedef std::list&lt;ValueType, Allocator&gt; type;
    };
  }

  // now you can define a graph using std::list
  //   and a specific allocator
  typedef adjacency_list&lt; list_with_allocatorS&lt; std::allocator&lt;int&gt; &gt;, vecS, directedS&gt; MyGraph;</pre>
        </section>
      </section>

    </main>

  </body>

</html>
