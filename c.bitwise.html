<!DOCTYPE html>
<html>
  <head>
    <title>Bitwise Operations in C/C++</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Bitwise Operations in C/C++"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      <p><a            href="c-cpp.html">C and C++</a></p>
      -->

      <div>
        <p><a rel="prev" href="c.html">The C Programming Language</a></p>
        <p><a            href="c.io.html">Input/Output in C</a></p>
        <p><a            href="c.time.html">Handling Time in C with the <code>&lt;time.h&gt;</code> library</a></p>
        <p><a            href="c.designated-initialization.html">Designated Initialization in C</a></p>
        <p><a            href="c.decay.html">Decay: Loss of C-Array Length Information</a></p>
        <p><a            href="cpp.preprocessor.html">The C/C++ Preprocessor</a></p>
      </div>
      <div>
        <p><a            href="c.assert.html"><code>assert</code> in C</a></p>
        <p><a            href="c.static_assert.html"><code>static_assert</code> in C</a></p>
        <p><a            href="c.abort.html"><code>abort</code> for Abnormal Program Termination</a></p>
        <p><a            href="c.exit.html"><code>exit</code> for Normal Program Termination with Cleaning Up</a></p>
        <p><a            href="c.atexit.html"><code>atexit</code> to Register a Function to be Called on <code>exit()</code> Invocation</a></p>
        <p><a            href="c.quick_exit.html"><code>quick_exit</code> for Normal Program Termination without Completely Cleaning Up</a></p>
      </div>
      <div>
        <p><a            href="c99.html">C99 (a Former Version of C)</a></p>
        <p><a            href="c11.html">C11 (a Former Version of C)</a></p>
        <p>                              C17:the Current Version of C (minor changes))</p>
      </div>
      <div>
        <p><a            href="linkage-and-scope.html">Linkage and Scope (focus on C/C++)</a></p>
        <p><a            href="c-and-cpp.html">C and C++</a></p>
        <p><a rel="next" href="cpp.html">The C++ Programming Language</a></p>
      </div>

    </nav>

    <main>
      <h1>Bitwise Operations in C/C++</h1>
      <blockquote>Why store a bool when 8 of them fit in a byte?</blockquote>

      <section id="bitmasks">
        <h2>Bitmasks</h2>
        <p>A <dfn>bitmask</dfn> is a binary pattern used to select, set, clear, or toggle specific bits in a variable — usually with the help of bitwise operators.</p>
        <p>Here&apos;s a refresher in C/C++ style syntax:</p>
        <pre>#define BIT0 (1 &lt;&lt; 0)  // 00000001
#define BIT1 (1 &lt;&lt; 1)  // 00000010
#define BIT2 (1 &lt;&lt; 2)  // 00000100
...</pre>
        <p>If you want to store multiple binary flags in one byte, you can use each bit as a switch:</p>
        <pre>uint8_t flags = 0;
flags |= BIT2;  // turn on bit 2
flags &amp;= ~BIT1; // turn off bit 1
if (flags &amp; BIT2) {
    // bit 2 is on
}</pre>
      </section>
      <!--
      <section>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
      </section>
      -->
      <section id="embedded">
        <h2>Bitmasks in Embedded Engineers</h2>
        <p style="text-align: right">(From <cite><a target="_blank" href="https://medium.com/@nikheelvs/how-embedded-engineers-use-bitmasks-and-why-you-should-too-2befe2490889">https://medium.com/@nikheelvs/how-embedded-engineers-use-bitmasks-and-why-you-should-too-2befe2490889</a></cite>)</p>
        <p>Whether you&apos;re toggling an LED or decoding a TCP header, bitmasks are a secret weapon that give you both power and performance. In the world of embedded systems, every byte counts — but the beauty of bit-level thinking goes far beyond microcontrollers.</p>
        <p><i>Some Real Use Cases in Embedded Systems:</i></p>
        <dl>
          <dt>GPIO State Control</dt>
          <dd>
            <p>In firmware for microcontrollers (like STM32, ESP32, etc.), you&apos;ll often manipulate GPIO ports directly:</p>
            <pre>GPIO_PORT |= (1 &lt;&lt; 5);   // Set pin 5 high
GPIO_PORT &amp;= ~(1 &lt;&lt; 5);  // Set pin 5 low</pre>
            <p>Why? Because hardware registers expose <strong>bit fields</strong> — one bit per pin. You can&apos;t waste time or RAM with structs or variables.</p>
          </dd>
          <dt>Flags in Event Loops</dt>
          <dd>
            <p>Instead of polling multiple boolean variables, embedded loops often use a single byte (or <code>uint32_t</code>, or...) for flag storage:</p>
            <pre>#define EVENT_BUTTON_PRESS (1 &lt;&lt; 0)
#define EVENT_TIMEOUT      (1 &lt;&lt; 1)
#define EVENT_ERROR        (1 &lt;&lt; 2)

if (event_flags &amp; EVENT_BUTTON_PRESS) {
    handle_button();
    event_flags &amp;= ~EVENT_BUTTON_PRESS;
}</pre>
            <p>It’s fast, memory-efficient, and avoids branching where unnecessary.</p>
          </dd>
        </dl>
      </section>
    </main>

  </body>

</html>
