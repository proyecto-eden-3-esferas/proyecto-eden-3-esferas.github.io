<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>STL Containers</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Container Adaptors: std::queue, std::priority_queue, and std::stack"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>
    <meta name="author" content="AUTHOR"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p><a rel="prev" href="cpp.containers.html">C++ Standard Containers</a></p>
        <p><a rel="next" href="cpp.associative-containers.html">C++ Associative Containers: Maps, Sets...</a></p>
      </div>
      <div>
        <p><a            href="cpp.templates.html">C++ Generics (Templates)</a></p>
        <p><a            href="cpp.iterators.html">Iterators: Pointers for STL Containers</a></p>
        <p><a            href="cpp.stl.html">The C++ Standard Template Library</a></p>
      </div>
    </nav>

    <main>
      <h1>Container Adaptors: <code>std::queue</code>, <code>std::priority_queue</code>, and <code>std::stack</code></h1>
      <p><dfn>Containers adaptors</dfn> are classes that use an encapsulated object of a specific container class as its <strong>underlying container</strong>, providing a specific (somewhat reduced) set of member functions to access its elements.</p>
      <aside>All three container adaptors have a member function <a href="#emplace"><code>emplace(<var>args</var>)</code></a>.</aside>

      <section id="queue">
        <h2><code>std::queue</code></h2>
        <p>Both <code>std::queue</code> and <code>std::priority_queue</code> are defined in header <cite>&lt;queue&gt;</cite>.</p>
        <p><code>std::queue</code>s are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.</p>
        <p>In a <code>std::queue</code> elements are pushed into the <q>back</q> of the specific container and popped from its <q>front</q>.</p>
        <p>The underlying container may be one of the standard container class template in the <a target="_blank" href="cpp.stl.html">STL</a> or some other specifically designed container class. This underlying container shall support at least the following operations:</p>
        <ul>
          <li><code>empty()</code></li>
          <li><code>size()</code></li>
          <li><code>front()</code></li>
          <li><code>back()</code></li>
          <li><code>push_back(<var>element</var>)</code></li>
          <li><code>pop_front()</code></li>
        </ul>
        <p>The standard container classes <code>std::deque</code> and <code>std::list</code> fulfill these requirements. By default, if no container class is specified for a particular queue class instantiation, the standard container <code>std::deque</code> is used.</p>
        <hr/>
        <p><code>std::queue</code> has the following member functions:</p>
        <table>
          <tr> <td>(<var>constructor</var>)()</td> <td>Construct queue (public member function)</td> </tr>
          <tr> <td><code>empty()</code></td> <td>Test whether container is empty (public member function)</td> </tr>
          <tr> <td><code>size()</code></td> <td>Return size (public member function)</td> </tr>
          <tr> <td><code>front()</code></td> <td>Access next element (public member function)</td> </tr>
          <tr> <td><code>back()</code></td> <td>Access last element (public member function)</td> </tr>
          <tr> <td><code>push(<var>element</var>)</code></td> <td>Insert element (public member function)</td> </tr>
          <tr> <td><code><a href="#emplace">emplace(<var>args_pack</var>)</a></code></td> <td>Construct and insert element (public member function)</td> </tr>
          <tr> <td><code>pop()</code></td> <td>Remove next element (public member function)</td> </tr>
          <tr> <td><code>swap()</code></td> <td>Swap contents (public member function)</td> </tr>
        </table>
      </section>

      <section id="priority_queue">
        <h2><code>std::priority_queue</code></h2>
        <p>Both <code>std::queue</code> and <code>std::priority_queue</code> are defined in header <cite>&lt;queue&gt;</cite>.</p>
        <p>Priority queues (<code>std::priority_queue</code>) are a type of container adaptors, specifically designed such that its first element is always the greatest of the elements it contains, according to some strict weak ordering criterion.</p>
        <pre>template &lt;class T, class Container = vector&lt;T&gt;,  class Compare = less&lt;typename Container::value_type&gt; &gt;
class priority_queue;</pre>
        <p>This context is similar to a heap, where elements can be inserted at any moment, and only the max heap element can be retrieved (the one at the top in the priority queue).</p>
        <p>Elements are <strong>popped</strong> from the <q>back</q> of the specific container, which is known as the <strong>top</strong> of the priority queue and accessed through member <code>priority_queue::top()</code>.</p>
        <p>The standard container classes <code><a target="_blank" href="cpp.sequence-containers.html#vector">std::vector</a></code> and <code><a target="_blank" href="cpp.sequence-containers.html#deque">std::deque</a></code> fulfill the requirements for an underlying container. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container <code>std::vector</code> is used.</p>
        <p>Support of random access iterators is required to keep a heap structure internally at all times. This is done automatically by the container adaptor by automatically calling the algorithm functions <code>std::make_heap</code>, <code>std::push_heap</code> and <code>std::pop_heap</code> (defined in <cite>&lt;algorithm&gt;</cite>) when needed.</p>
        <hr/>
        <p><strong>Member Functions for Accessing the Top Element:</strong></p>
        <p>Besides <code>push(<var>element</var>)</code>, <code>pop()</code>, and <code><a href="#emplace">emplace(<var>args</var>)</a></code>, there is <code>top()</code>.</p>
        <section id="compare">
          <h3><code><var>Compare</var></code></h3>
          <p><code><var>Compare</var></code> is a binary predicate that takes two elements (of type <code><var>T</var></code>) as arguments and returns a bool.</p>
          <p>The expression <code>comp(<var>a</var>,<var>b</var>)</code>, where <var>comp</var> is an object of this type and <var>a</var> and <var>b</var> are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.</p>
          <p>The <code>priority_queue</code> uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering).</p>
          <p>This can be a function pointer or a function object, and defaults to <code>less&lt;T&gt;</code>, which returns the same as applying the less-than operator (a&lt;b).</p>
        </section>
      </section>

      <section id="stack">
        <h2><code>std::stack</code></h2>
        <p><code>std::stack</code> is defined in header <cite>&lt;stack&gt;</cite>.</p>
        <p>Stacks are a type of container adaptor, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from one end of the container.</p>
        <p>Elements in a <code>std::stack</code> are pushed/popped from the <q>back</q> of the specific container, which is known as the <strong>top</strong> of the stack.</p>
        <p>The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall support the following operations:</p>
        <ul>
          <li><code>empty()</code></li>
          <li><code>size()</code></li>
          <li><code>back()</code></li>
          <li><code>push_back(<var>element</var>)</code></li>
          <li><code>pop_back()</code></li>
        </ul>
      </section>

      <section id="emplace">
        <h2><code>queue::emplace(<var>...args</var>)</code> and <code>priority_queue::emplace(<var>...args</var>)</code></h2>
        <p><code><var>CONTAINER</var>::emplace(<var>...args</var>)</code> adds a new element at the end of the queue, after its current last element. This new element is constructed in place passing args as the arguments for its constructor.</p>
        <pre>template &lt;class... Args&gt; void emplace (Args&amp;&amp;... args);</pre>
        <p>This member function effectively calls the member function <code>emplace_back(<var>args</var>)</code> of the underlying container, <a target="_blank" href="cpp.move-semantics.html#forwarding">forwarding</a> args.</p>
      </section>

    </main>
  </body>
</html>
