<!DOCTYPE html>
<html>
  <head>
    <title>SQLite C Core API</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
        <p><a href="A_PAGE.html">LINK_TEXT</a></p>
        <p><a href="ANOTHER_PAGE.html">LINK_TEXT</a></p>
        <p><a rel="prev" href="PREVIOUS_PAGE.html">LINK_TEXT</a></p>
        <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
      <div>
        <p><a            href="sqlite.sqlite3.html">Running <code>sqlite3</code></a></p>
        <p><a            href="sqlite.sqlite3.ref.html">Command Line Shell For SQLite</a></p>
        <p><a            href="sqlite.data-types.html">SQLite Data Types</a></p>
        <p><a            href="sqlite.tables.html">Tables in SQLite</a></p>
        <p><a rel="prev" href="sqlite.c-api.html">SQLite C Api</a></p>
        <p><a            href="sqlite.c-extension-api.html">SQLite C Extension API</a></p>
        <p><a            href="sqlite.html">SQLite: A Light OpenSource Relational Database (RDBMS and Library)</a></p>
      </div>
      <div>
        <p><a            href="c.html">The C   Programming Language</a></p>
        <p><a rel="next" href="cpp.html">The C++ Programming Language</a></p>
      </div>
      <div>
        <p><a            href="relational-database.html">Relational DataBases</a></p>
        <p><a            href="sql.html">Structured Query Language (SQL)</a></p>
      </div>
      <div>
        <p><a href="special-relational-tables.html">Special Relational Tables</a></p>
      </div>
    </nav>

    <main>
      <h1>SQLite C Core API</h1>
      <p>The SQLite version 3 API consists of dozens and dozens of functions. Only about eight functions, however, are needed to actually connect, process queries, and disconnect from a database. The remaining functions can be arranged into small groups that specialize in accomplishing specific tasks.</p>

      <section id="wrapped">
        <h3>Wrapped Queries</h3>
          <h4>Connecting and Disconnecting</h4>
          <p>Before you can execute SQL commands, you first have to connect to a database. Connecting to a database is perhaps best described as opening a database, because SQLite databases are contained in single operating system files (one file to one database). Analogously, the preferred term for disconnecting is closing the database.</p>
          <p>You open a database with the <code>sqlite3_open_v2()</code>, <code>sqlite3_open()</code>, or <code>sqlite3_open16()</code> functions, which have the following declaration(s):</p>
          <pre>int sqlite3_open_v2(
  const char *filename, /* Database filename (UTF-8) */
  sqlite3 **ppDb        /* OUT: SQLite db handle */
  int flags,
  const char *zVfs      /* Name of VFS module to use */
);

int sqlite3_open (
  const void *filename, /* Database filename (UTF-8) */
  sqlite3 **ppDb        /* OUT: SQLite db handle */
);

int sqlite3_open16(
  const void *filename, /* Database filename (UTF-16) */
  sqlite3 **ppDb        /* OUT: SQLite db handle */
);</pre>
          <p>Typically, you&apos;ll use <code>sqlite3_open_v2()</code>, because this is the latest and greatest function in SQLite for opening your database, and it accommodates more options and capabilities over the old <code>sqlite3_open()</code>. Regardless of the function chosen, the filename argument can be the name of an operating system file, the text string <code>:memory:</code>, or an empty string or a NULL pointer. If you use <code>:memory:</code>, <code>sqlite3_open_v2()</code> will create an in-memory database in RAM that lasts only for the duration of the session. If filename is an empty string or a NULL, <code>sqlite3_open_v2()</code> opens a temporary disk file that is automatically deleted when the connection closes. Otherwise, <code>sqlite3_open_v2()</code> attempts to open the database file by using its value. If no file by that name exists, <code>sqlite3_open_v2()</code> will open a new database file by that name if the <code>SQLITE_OPEN_CREATE</code> flag is included in the third parameter, or it will return an error if the <code>SQLITE_OPEN_CREATE</code> flag is omitted.</p>
          <p>The flags parameter is a bit vector that can include the following values: <code>SQLITE_OPEN_READONLY</code>, <code>SQLITE_OPEN_READWRITE</code>, and <code>SQLITE_OPEN_CREATE</code>. The names are reasonable self-explanatory, but a few subtleties are worth noting. <code>SQLITE_OPEN_READONLY</code> and <code>SQLITE_OPEN_READWRITE</code> open a SQLite database in read-only or read/write mode as their names suggest. Both options require that the database file already exist; otherwise, an error will be returned. <code>SQLITE_OPEN_CREATE</code> combined with <code>SQLITE_OPEN_READWRITE</code> exhibits the legacy <code>sqlite3_open()</code> behavior. Where a database already exists, it is opened for reading and writing. If the database specified doesn&apos;t exist, it is created (though the act of persisting the database to disk will be pending the creation of the first object).</p>
          <p>The flags parameter can also be combined with the <code>SQLITE_OPEN_NOMUTEX</code>, <code>SQLITE_OPEN_FULLMUTEX, SQLITE_OPEN_SHAREDCACHE</code>, or <code>SQLITE_OPEN_PRIVATECACHE</code> flags to further control transactional behavior for the database handle.</p>
          <p>The final parameter, <var>zVfs</var>, allows the caller to override the default <code>sqlite3_vfs</code> operating system interface.</p>
          <p>Upon completion, <code>sqlite3_open_v2()</code> will initialize the sqlite3 structure passed into it by the <var>ppDb</var> argument. This structure should be considered as an opaque handle representing a single connection to a database. This is more of a connection handle than a database handle since it is possible to attach multiple databases to a single connection. However, this connection still represents exactly one transaction context regardless of how many databases are attached.</p>
          <p>You close a connection by using the <code>sqlite3_close()</code> function, which is declared as follows:</p>
          <pre>int sqlite3_close(sqlite3*);</pre>
          <p>For <code>sqlite3_close()</code> to complete successfully, all prepared queries associated with the connection must be finalized. If any queries remain that have not been finalized, <code>sqlite3_close()</code> will return <code>SQLITE_BUSY</code> with the error message <q>Unable to close due to unfinalized statements</q>.</p>
          <aside><strong>Note:</strong> If there is a transaction open on a connection when it is closed by <code>sqlite3_close()</code>, the transaction will automatically be rolled back.</aside>

        <section id="sqlite3_exec">
          <h4>The exec Query</h4>
          <p>The <code>sqlite3_exec()</code> function provides a quick, easy way to execute SQL commands and is especially handy for commands that modify the database (that is, don&apos;t return any data). This is often also referred to as a <dfn>convenience function</dfn>, which nicely wraps up a lot of other tasks in one easy API call. This function has the following declaration:</p>
          <pre>int sqlite3_exec(
  sqlite3*,        /* An open database */
  const char *sql, /* SQL code to be executed */
  sqlite_callback, /* Callback function */
  void *data,      /* 1st argument to callback function */
  char **errmsg    /* Error msg written here */
);</pre>
          <p>The SQL code provided in the sql argument can consist of more than one SQL command. <code>sqlite3_exec()</code> will parse and execute every command in the sql string until it reaches the end of the string or encounters an error. The listing below (taken from <cite>create.c</cite>) illustrates how to use <code>sqlite3_exec()</code>.The example opens a database called <var>test.db</var> and creates within it a single table called <var>episodes</var>. After that, it inserts one record. The create table command will physically create the database file if it does not already exist.</p>
          <pre>int main(int argc, char **argv)
{
  sqlite3 *db;
  char *zErr;
  int rc;
  char *sql;
  rc = sqlite3_open_v2("test.db", &amp;db);
  if(rc) {
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    sqlite3_close(db);
    exit(1);
  }
  sql = "create table episodes(id int, name text)";
  rc = sqlite3_exec(db, sql, NULL, NULL, &amp;zErr);
  if(rc != SQLITE_OK) {
    if (zErr != NULL) {
      fprintf(stderr, "SQL error: %s\n", zErr);
      sqlite3_free(zErr);
  }
  sql = "insert into episodes values (10, 'The Dinner Party')";
  rc = sqlite3_exec(db, sql, NULL, NULL, &amp;zErr);
}</pre>

          <p>It is actually possible to get records from <code>sqlite3_exec()</code>, although you don&apos;t see it implemented much outside of the C API. <code>sqlite3_exec()</code> contains a callback mechanism that provides a way to obtain results from select statements. This mechanism is implemented by the third and fourth arguments of the function. The third argument is a pointer to a callback function. If it&apos;s provided, SQLite will call the function for each record processed in each select statement executed within the sql argument. The callback function has the following declaration:</p>
          <pre>typedef int (*sqlite3_callback) (
  void*,  /* Data provided in the 4th argument of sqlite3_exec() */
  int,    /* The number of columns in row */
  char**, /* An array of strings representing fields in the row */
  char**  /* An array of strings representing column names */
);</pre>
          <p>The fourth argument to <code>sqlite3_exec()</code> is a void pointer to any application-specific data you want to supply to the callback function. SQLite will pass this data as the first argument of the callback function.</p>

          <p>The final argument (<var>errmsg</var>) is a pointer to a string to which an error message can be written should an error occur during processing. Thus, <code>sqlite3_exec()</code> has two sources of error information. The first is the return value. The other is the human-readable string, assigned to <var>errmsg</var>. If you pass in a <code>NULL</code> for <var>errmsg</var>, then SQLite will not provide any error message. Note that if you do provide a pointer for <var>errmsg</var>, the memory used to create the message is allocated on the heap. You should therefore check for a non-NULL value after the call and use <code>sqlite3_free()</code> to free the memory used to hold the <var>errmsg</var> string if an error occurs.</p>
          <aside><strong>Note</strong> Note that you can pass a NULL into <code>sqlite3_free()</code>. The result is a harmless no-op. So, you can, if you want, call sqlite3_free(errmsg) without having to check to see whether errmsg is not NULL. It mainly depends on where and how you want to interrogate any actual errors and respond accordingly.</aside>

          <p>Putting it all together, <code>sqlite3_exec()</code> allows you to issue a batch of commands, and you can collect all the returned data by using the callback interface. For example, let&apos;s insert a record into the <var>episodes</var> table and then select all of its records, all in a single call to <code>sqlite3_exec()</code>. The complete code, shown below, is taken from <cite>exec.c</cite>.</p>
          <pre>int callback(void* data, int ncols, char** values, char** headers);
int main(int argc, char **argv)
{
  sqlite3 *db;
  int rc;
  char *sql;
  char *zErr;
  rc = sqlite3_open_v2("test.db", &amp;db);
  if(rc) {
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    sqlite3_close(db);
    exit(1);
  }
  const char* data = "Callback function called";
  sql = "insert into episodes (id, name) values (11,'Mackinaw Peaches');"
  "select * from episodes;";
  rc = sqlite3_exec(db, sql, callback, data, &amp;zErr);
  if(rc != SQLITE_OK) {
    if (zErr != NULL) {
      fprintf(stderr, "SQL error: %s\n", zErr);
      sqlite3_free(zErr);
    }
  }
  sqlite3_close(db);
  return 0;
} /* main() */

int callback(void* data, int ncols, char** values, char** headers)
{
  int i;
  fprintf(stderr, "%s: ", (const char*)data);
  for(i=0; i &lt; ncols; i++) {
    fprintf(stderr, "%s=%s ", headers[i], values[i]);
  }
  fprintf(stderr, "\n");
  return 0;
}</pre>
          <p>SQLite parses the <var>sql</var> string; runs the first command, which inserts a record; and then runs the second command, consisting of the <code>SELECT</code> statement. For the second command, SQLite calls the <var>callback</var> function for each record returned. Running the program produces the following output:</p>
          <pre>Callback function called: id=10 name=The Dinner Party
Callback function called: id=11 name=Mackinaw Peaches</pre>
          <p>Notice that the callback function returns 0. This return value actually exerts some control over <code>sqlite3_exec()</code>. If the callback function returns a nonzero value, then <code>sqlite3_exec()</code> will abort (in other words, it will terminate all processing of this and subsequent commands in the <var>sql</var> string).</p>
          <p>So, <code>sqlite3_exec()</code> provides an easy way to modify the database and also provides an interface with which to process records. Why then should you bother with <a href="#prepared-queries">prepared queries</a>? Well, as you will see in the next section, there are quite a few advantages:</p>
          <ul>
            <li>Prepared queries don&apos;t require a callback interface, which makes coding simple and more linear.</li>
            <li>Prepared queries have associated functions that provide better column information. You can obtain a column&apos;s storage type, declared type, schema name (if it is aliased), table name, and database name. <code>sqlite3_exec()</code>&apos;s callback interface provides just the column names.</li>
            <li>Prepared queries provide a way to obtain field/column values in other data types besides text and in native C data types such as <code>int</code> and <code>double</code>, whereas <code>sqlite3_exec()</code>&apos;s callback interface only provides fields as string values.</li>
            <li>Prepared queries can be rerun, allowing you to reuse the compiled SQL.</li>
            <li>Prepared queries support parameterized SQL statements.</li>
          </ul>
          <aside>
            <h5>Examining Changes</h5>
            <p>If you are performing an update or a delete, you may want to know how many records were affected. You can get this information from <code>sqlite3_changes()</code>. It provides the number of affected records for the last executed update, insert, or delete statement. Obviously, if you are running a batch of queries (multiple commands in the sql argument of <code>sqlite3_exec()</code>), this function will be good only for the last command in the batch. Note also that <code>sqlite3_changes()</code> does not include changes activated from the result of triggers fired from your original command.</p>
            <p>If you are performing an insert on a table with an autoincrement column, odds are you will eventually want to know the primary key value of an inserted record. In such cases, you can use <code>sqlite3_last_insert_rowid()</code> to obtain this value. You can also do this from within SQL as well via the <code>last_insert_rowid()</code> SQL function.</p>
          </aside>
        </section>

        <section id="sqlite3_get_table">
          <h4>The Get Table Query</h4>
          <p>The <code>sqlite3_get_table()</code> function returns an entire result set of a command in a single function call. Just as <code>sqlite3_exec()</code> wraps the prepared query API functions, allowing you to run them all at once, <code>sqlite3_get_table()</code> wraps <code>sqlite3_exec()</code> for commands that return data with just as much convenience. Using <code>sqlite3_get_table()</code>, you don&apos;t have to bother with the <code>sqlite3_exec()</code> callback function, thus making it easier to fetch records. <code>sqlite3_get_table()</code> has the following declaration:</p>
          <pre>int sqlite3_get_table(
  sqlite3*,        /* An open database */
  const char *sql, /* SQL to be executed */
  char ***resultp, /* Result written to a char *[] that this points to */
  int *nrow,       /* Number of result rows written here */
  int *ncolumn,    /* Number of result columns written here */
  char **errmsg    /* Error msg written here, if any */
);</pre>
          <p>This function takes all the records returned from the SQL statement in sql and stores them in the <var>resultp</var> argument using memory declared on the heap (using <code>sqlite3_malloc()</code>). The memory must be freed using <code>sqlite3_free_table()</code>, which takes the <var>resultp</var> pointer as its sole argument. The first record in <var>resultp</var> is actually not a record but contains the names of the columns in the result set. Examine the code fragment below (taken from <cite>get_table.c</cite>).</p>
          <pre>int main(int argc, char **argv)
{
  /* Connect to database, etc. */

  char *result[];
  sql = "select * from episodes;";
  rc = sqlite3_get_table(db, sql, &amp;result, &amp;nrows, &amp;ncols, &amp;zErr);

  /* Do something with data */

  /* Free memory */
  sqlite3_free_table(result);
}</pre>
          <p>If, for example, the result set returned is of the following form:</p>
          <pre>name | id
-----------------------
The Junior Mint   | 43
The Smelly Car    | 28
The Fusilli Jerry | 21</pre>
          <p>then the format of the result array will be structured as follows:</p>
          <pre>result [0] = "name";
result [1] = "id";
result [2] = "The Junior Mint";
result [3] = "43";
result [4] = "The Smelly Car";
result [5] = "28";
result [6] = "The Fusilli Jerry";
result [7] = "21";</pre>
          <p>The first two elements contain the column headings of the result set. Therefore, you can think of the result set indexing as 1-based with respect to rows but 0-based with respect to columns. An example may help clarify this. The listing below shows the code to print out each column of each row in the result set.</p>
          <pre>/* Iterating Through sqlite3_get_table() Results */
rc = sqlite3_get_table(db, sql, &amp;result, &amp;nrows, &amp;ncols, &amp;zErr);
for(i=0; i &lt; nrows; i++) {
  for(j=0; j &lt; ncols; j++) {
    /* the i+1 term skips over the first record,
       which is the column headers */
    fprintf(stdout, "%s", result[(i+1)*ncols + j]);
  }
}</pre>

        </section>  <!-- end of "The Get Table Query" -->

      </section>  <!-- end of "Wrapped Queries" -->

      <section id="prepared-queries">
        <h3>Prepared Queries</h3>
        <p>We have already introduced the concepts of the prepare, step, and finalize functions. This section covers all aspects of this process, including stepping through result sets, fetching records, and using parameterized queries. We told you prepared statements were infinitely preferable to the convenience wrapper functions, and this is where we prove the point.</p>
        <p>The <a href="#wrapped">wrapper functions</a> simply wrap all these steps into a single function call, making it more convenient in some situations to run specific commands. Each query function provides its own way of getting at rows and columns. As a general rule, the more packaged the method is, the less control you have over execution and results. Therefore, prepared queries offer the most features, the most control, and the most information, with <code>sqlite3_exec()</code> offering slightly fewer features and <code>sqlite3_get_table()</code> offering fewer still.</p>
        <p>Prepared queries use a special group of functions to access field and column information from a row. You get column values using <code>sqlite3_column_<var>xxx</var>()</code>, where <var>xxx</var> represents the data type of the value to be returned (for example, <code>int</code>, <code>double</code>, <code>blob</code>). You can retrieve data in whatever format you like. You can also obtain the declared types of columns (as they are defined in the <code>CREATE TABLE</code> statement) and other miscellaneous metadata such as storage format and both associated table and database names. <code>sqlite3_exec()</code>, by comparison, provides only a fraction of this information through its callback function. The same is true with <code>sqlite3_get_table()</code>, which only includes the result set&apos;s column headers with the data.</p>
        <p>In practice, you will find that each query method has its uses. <code>sqlite3_exec()</code> is especially good for running commands that modify the database (create, drop, insert, update, and delete). One function call, and it&apos;s done. Prepared queries are typically better for <code>SELECT</code> statements because they offer so much more information, more linear coding (no callback functions), and more control by using cursors to iterate over results.</p>
        <p>As you&apos;ll recall<!-- from Chapter 5-->, prepared queries are performed in three basic steps: compilation, execution, and finalization. You compile the query with <code>sqlite3_prepare_v2()</code>, execute it step-by-step using <code>sqlite3_step()</code>, and close it using <code>sqlite3_finalize()</code>, or you can reuse it using <code>sqlite3_reset()</code>. This process and the individual steps are all explained in detail in the following sections.</p>
          <h4>Compilation</h4>
          <p>Compilation, or <em>preparation</em>, takes a SQL statement and compiles it into byte code readable by the virtual database engine (VDBE). It is performed by <code>sqlite3_prepare_v2()</code>, which is declared as follows:</p>
          <pre>int sqlite3_prepare_v2 (
  sqlite3 *db,           /* Database handle */
  const char *zSql,      /* SQL text, UTF-8 encoded */
  int nBytes,            /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt, /* OUT: Statement handle */
  const char **pzTail    /* OUT: Pointer to unused portion of zSql */
);</pre>
          <p><code>sqlite3_prepare_v2()</code> compiles the first SQL statement in the <var>zSQL</var> string (which can contain multiple SQL statements). It allocates all the resources necessary to execute the statement and associates it along with the byte code into a single statement handle (also referred to as simply a statement), designated by the out parameter <var>ppStmt</var>, which is a <q>sqlite3_stmt</q> structure. From the programmer&apos;s perspective, this structure is little more than an opaque handle used to execute a SQL statement and obtain its associated records. However, this data structure contains the command&apos;s byte code, bound parameters, B-tree cursors, execution context, and any other data <code>sqlite3_step()</code> needs to manage the state of the query during execution.</p>
          <p><code>sqlite3_prepare_v2()</code> does not affect the connection or database in any way. It does not start a transaction or get a lock. It works directly with the compiler, which simply prepares the query for execution. Statement handles are highly dependent on the database schema with which they were compiled. If another connection alters the database schema, between the time you prepare a statement and the time you actually run it, your prepared statement will expire. However, <code>sqlite3_prepare_v2()</code> is built to automatically attempt to recompile (re-prepare) your statement if possible and will do this silently if a schema change has invalidated your existing statement. If the schema has changed in such a way as to make recompilation impossible, your call to <code>sqlite3_step()</code> with the statement will lead to a <code>SQLITE_SCHEMA</code> error, which is discussed later in the section <cite><a href="#errors-and-the-unexpected">Errors and the Unexpected</a></cite>. At this point, you would need to examine the error associated with <code>SQLITE_SCHEMA</code> by using the <code>sqlite3_errmsg()</code> function.</p>
          <h4>Execution*</h4>
          <p>Once you prepare the query, the next step is to execute it using <code>sqlite3_step()</code>, declared as follows:</p>
          <pre>int sqlite3_step(sqlite3_stmt *pStmt);</pre>
          <p><code>sqlite3_step()</code> takes the statement handle and talks directly to the VDBE, which steps through its byte-code instructions one by one to carry out the SQL statement. On the first call to <code>sqlite3_step()</code>, the VDBE obtains the requisite database lock needed to perform the command. If it can&apos;t get the lock, <code>sqlite3_step()</code> will return <code>SQLITE_BUSY</code>, if there is no busy handler installed. If one is installed, it will call that handler instead.</p>
          <p>For SQL statements that don&apos;t return data, the first call to <code>sqlite3_step()</code> executes the command in its entirety, returning a result code indicating the outcome. For SQL statements that do return data, such as <code>SELECT</code>, the first call to <code>sqlite3_step()</code> positions the statement&apos;s B-tree cursor on the first record. Subsequent calls to <code>sqlite3_step()</code> position the cursor on subsequent records in the result set. <code>sqlite3_step()</code> returns <code>SQLITE_ROW</code> for each record in the set until it reaches the end, whereupon it returns <code>SQLITE_DONE</code>, indicating that the cursor has reached the end of the set.</p>
          <aside><strong>Note</strong> For those of you familiar with older versions of SQLite, these result codes are part of the more advanced— and some would say more correct—set of result codes that replace the legacy simple return values like <code>SQLITE_ERROR</code>. A full list of result codes and extended result codes is available at <a target="_blank" href="www.sqlite.org/c3ref/ c_abort.html">www.sqlite.org/c3ref/c_abort.html</a></aside>
          <p>All other API functions related to data access use the statement&apos;s cursor to obtain information about the current record. For example, the <code>sqlite3_column_<var>xxx</var>()</code> functions all use the statement handle, specifically its cursor, to fetch the current record&apos;s fields.</p>
          <h4>Finalization and Reset*</h4>
          <p>Once the statement has reached the end of execution, it must be finalized. You can either finalize or reset the statement using one of the following functions:</p>
          <pre>int sqlite3_finalize(sqlite3_stmt *pStmt);
int sqlite3_reset(sqlite3_stmt *pStmt);</pre>
          <p><code>sqlite3_finalize()</code> will close out the statement. It frees resources and commits or rolls back any implicit transactions (if the connection is in autocommit mode), clearing the journal file and freeing the associated lock.</p>
          <p>If you want to reuse the statement, you can do so using <code>sqlite3_reset()</code>. It will keep the compiled SQL statement (and any bound parameters) but commits any changes related to the current statement to the database. It also releases its lock and clears the journal file if autocommit is enabled. The primary difference between <code>sqlite3_finalize()</code> and <code>sqlite3_reset()</code> is that the latter preserves the resources associated with the statement so that it can be executed again, avoiding the need to call <code>sqlite3_prepare()</code> to compile the SQL command.</p>
          <p>Let&apos;s go through an example. The listing below shows a simple, complete program using a prepared query. It is taken from <code>select.c</code> in the examples.</p>
          <pre>int main(int argc, char **argv)
{
  int rc, i, ncols;
  sqlite3 *db;
  sqlite3_stmt *stmt;
  char *sql;
  const char *tail;

  rc = sqlite3_open_v2("foods.db", &amp;db);
  if(rc) {
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    sqlite3_close(db);
    exit(1);
  }

  sql = "select * from episodes;";

  rc = sqlite3_prepare_v2(db, sql, -1, &amp;stmt, &amp;tail);

  if(rc != SQLITE_OK) {
    fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(db));
  }

  rc = sqlite3_step(stmt);
  ncols = sqlite3_column_count(stmt);

  while(rc == SQLITE_ROW) {
    for(i=0; i &lt; ncols; i++) {
      fprintf(stderr, "'%s' ", sqlite3_column_text(stmt, i));
    }
    fprintf(stderr, "\n");

    rc = sqlite3_step(stmt);
  }
  sqlite3_finalize(stmt);
  sqlite3_close(db);

  return 0;
}</pre>
          <p>This example connects to the <var>foods.db</var> database, queries the episodes table, and prints out all columns of all records within it. Keep in mind this is a simplified example—there are a few other things we need to check for when calling <code>sqlite3_step()</code>, such as errors and busy conditions, but we will address them later.</p>
          <p>Like <code>sqlite3_exec()</code>, <code>sqlite3_prepare_v2()</code> can accept a string containing multiple SQL statements.</p>
          <p>However, unlike <code>sqlite3_exec()</code>, it will process only the first statement in the string. But it does make it easy for you to process subsequent SQL statements in the string by providing the <var>pzTail</var> out parameter. After you call <code>sqlite3_prepare()</code>, it will point this parameter (if provided) to the starting position of the next statement in the zSQL string. Using <code>pzTail</code>, processing a batch of SQL commands in a given string can be executed in a loop as follows:</p>
          <pre>while(sqlite3_complete(sql)) {
  rc = sqlite3_prepare(db, sql, -1, &amp;stmt, &amp;tail);
  /* Process query results */

  /* Skip to next command in string. */
  sql = tail;
}</pre>
          <p>This example uses another API function not yet covered—<code>sqlite3_complete()</code>, which does as its name suggests. It takes a string and returns true if there is at least one complete (but not necessarily valid) SQL statement in it, and it returns false otherwise. In reality, <code>sqlite_complete()</code> looks for a semicolon terminator for the string (and accounting for literals in the SQL). So, although its name suggests some kind of infallible observer checking your statements, it&apos;s really just a handy tool for things such as showing you the continuation prompt in the sqlite command line when writing multiline statements and doing other similar useful tasks.</p>

      </section>

      <section>
        <h3>Fetching Records*</h3>
        <p>So far, you have seen how to obtain records and columns from <code>sqlite3_exec()</code> and <code>sqlite3_get_table()</code>. Prepared queries, by comparison, offer many more options when it comes to getting information from records in the database.</p>
        <p>For a statement that returns records, the number of columns in the result set can be obtained using <code>sqlite3_column_count()</code> and <code>sqlite3_data_count()</code>, which are declared as follows:</p>
        <pre>int sqlite3_column_count(sqlite3_stmt *pStmt);
int sqlite3_data_count(sqlite3_stmt *pStmt);</pre>
        <p><code>sqlite3_column_count()</code> returns the number of columns associated with a statement handle. You can call it on a statement handle before it is actually executed. If the query in question is not a select statement, <code>sqlite3_column_count()</code> will return 0. Similarly, <code>sqlite3_data_count()</code> returns the number of columns for the current record, after <code>sqlite3_step()</code> returns <code>SQLITE_ROW</code>. This function will work only if the statement handle has an active cursor.</p>
          <h4>Getting Column Information</h4>
          <p>You can obtain the name of each column in the current record using <code>sqlite3_column_name()</code>, which is declared as follows:</p>
          <pre>const char *sqlite3_column_name( sqlite3_stmt*, /* statement handle */
                                 int iCol       /* column ordinal */);</pre>
          <p>Similarly, you can get the associated storage class for each column using <code>sqlite3_column_type()</code>, which is declared as follows:</p>
          <pre>int sqlite3_column_type( sqlite3_stmt*, /* statement handle */
                         int iCol       /* column ordinal */);</pre>
          <p>This function returns an integer value that corresponds to one of five storage class codes, defined as follows:</p>
          <pre>#define SQLITE_INTEGER  1
#define SQLITE_FLOAT    2
#define SQLITE_TEXT     3
#define SQLITE_BLOB     4
#define SQLITE_NULL     5</pre>
          <p>These are SQLite&apos;s native data types, or <dfn>storage classes</dfn><!--, as described in Chapter 4-->. All data stored within a SQLite database is stored in one of these five forms, depending on its initial representation and the affinity of the column. For our purposes, the terms storage class and data type are synonymous.<!-- For more information on storage classes, see the sections “Storage Classes” and “Type Affinity” in Chapter 4.--></p>
          <p>You can obtain the declared data type of a column as it is defined in the table&apos;s schema using the <code>sqlite3_column_decltype()</code> function, which is declared as follows:</p>
          <pre>const char *sqlite3_column_decltype(
  sqlite3_stmt*, /* statement handle */
  int            /* column ordinal */);</pre>

          <p>If a column in a result set does not correspond to an actual table column (say, for example, the column is the result of a literal value, expression, function, or aggregate), this function will return NULL as the declared type of that column. For example, suppose you have a table in your database defined as follows:</p>
          <pre>CREATE TABLE t1(c1 INTEGER);</pre>
          <p>Then you execute the following query:</p>
          <pre>SELECT c1 + 1, 0 FROM t1;</pre>
          <p>In this case, <code>sqlite3_column_decltype()</code> will return INTEGER for the first column and NULL for the second.</p>
          <p>In addition to the declared type, you can obtain other information on a column using the following functions:</p>
          <pre>const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int iCol);
const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int iCol);
const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int iCol);</pre>
          <p>The first function will return the database associated with a column, the second will return its table, and the last function will return the column&apos;s actual name as defined in the schema. That is, if you assigned the column an alias in the SQL statement, <code>sqlite3_column_origin_name()</code> will return its actual name as defined in the schema. Note that these functions are available only if you compile SQLite with the <code>SQLITE_ENABLE_COLUMN_METADATA</code> preprocessor directive.</p>
          <h4>Getting Column Values</h4>
          <p>You can obtain the values for each column in the current record using the <code>sqlite3_column_<var>xxx</var>()</code> functions, which are of the following general form:</p>
          <pre><var>xxx</var> sqlite3_column_<var>xxx</var>( sqlite3_stmt*, /* statement handle */
                        int iCol /* column ordinal */);</pre>
          <p>Here <var>xxx</var> is the data type you want the data represented in (for example, int, blob, double, and so on). These are the most commonly used of the <code>sqlite3_column_<var>xxx</var>()</code> functions:</p>
          <pre>int sqlite3_column_int(sqlite3_stmt*, int iCol);
double sqlite3_column_double(sqlite3_stmt*, int iCol);
long long int sqlite3_column_int64(sqlite3_stmt*, int iCol);
const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);</pre>
          <p>For each function, SQLite converts the internal representation (storage class in the column) to the type specified in the function name. There are a number of rules SQLite uses to convert the internal data type representation to that of the requested type. The table below lists these rules.</p>
          <table border="1" id="simple_with_header_and_th">
            <thead> <tr> <th>Internal Type</th> <th>Requested Type</th> <th>Conversion</th> </tr> </thead>
                    <tr> <td>NULL</td> <td>INTEGER</td> <td>Result is 0.</td> </tr>
                    <tr> <td>NULL</td> <td>FLOAT</td> <td>Result is 0.0.</td> </tr>
                    <tr> <td>NULL</td> <td>TEXT</td> <td>Result is a NULL pointer.</td> </tr>
                    <tr> <td>NULL</td> <td>BLOB</td> <td>Result is a NULL pointer.</td> </tr>
                    <tr> <td>INTEGER</td> <td>FLOAT</td> <td>Convert from integer to float.</td> </tr>
                    <tr> <td>INTEGER</td> <td>TEXT</td> <td>Result is the ASCII rendering of the integer.</td> </tr>
                    <tr> <td>INTEGER</td> <td>BLOB</td> <td>Result is the ASCII rendering of the integer.</td> </tr>
                    <tr> <td>FLOAT</td> <td>INTEGER</td> <td>Convert from float to integer.</td> </tr>
                    <tr> <td>FLOAT</td> <td>TEXT</td> <td>Result is the ASCII rendering of the float.</td> </tr>
                    <tr> <td>FLOAT</td> <td>BLOB</td> <td>Result is the ASCII rendering of the float.</td> </tr>
                    <tr> <td>TEXT</td> <td>INTEGER</td> <td>Use atoi().</td> </tr>
                    <tr> <td>TEXT</td> <td>FLOAT</td> <td>Use atof().</td> </tr>
                    <tr> <td>TEXT</td> <td>BLOB</td> <td>No change.</td> </tr>
                    <tr> <td>BLOB</td> <td>INTEGER</td> <td>Convert to TEXT and then use atoi().</td> </tr>
                    <tr> <td>BLOB</td> <td>FLOAT</td> <td>Convert to TEXT and then use atof().</td> </tr>
                    <tr> <td>BLOB</td> <td>TEXT</td> <td>Add a \000 terminator if needed.</td> </tr>
          </table>
          <p>Like the <code>sqlite3_bind_<var>xxx</var>()</code> functions described later, <code>BLOB</code>s require a little more work in that you must specify their length in order to copy them. For <code>BLOB</code> columns, you can get the actual length of the data using <code>sqlite3_column_bytes()</code>, which is declared as follows:</p>
          <pre>int sqlite3_column_bytes( sqlite3_stmt*, /* statement handle */
                          int            /* column ordinal */);</pre>
          <p>Once you get the length, you can copy the binary data using <code>sqlite3_column_blob()</code>. For example, say the first column in the result set contains binary data. One way to get a copy of that data would be as follows:</p>
          <pre>int len = sqlite3_column_bytes(stmt,0);
void* data = malloc(len);
memcpy(data, len, sqlite3_column_blob(stmt,0));</pre>
          <h4>A Practical Example</h4>
          <p>To help solidify all these column functions, the following listing (taken from <cite>columns.c</cite>) illustrates using the functions we&apos;ve described to retrieve column information and values for a simple <code>SELECT</code> statement.</p>
          <pre>int main(int argc, char **argv)
{
  int rc, i, ncols, id, cid;
  char *name, *sql;
  sqlite3 *db;
  sqlite3_stmt *stmt;

  sql = "select id, name from episodes";
  sqlite3_open_v2("test.db", &amp;db);

  sqlite3_prepare_v2(db, sql, strlen(sql), &amp;stmt, NULL);

  ncols = sqlite3_column_count(stmt);
  rc = sqlite3_step(stmt);

  /* Print column information */
  for(i=0; i &lt; ncols; i++) {
    fprintf(stdout, "Column: name=%s, storage class=%i, declared=%s\n",
    sqlite3_column_name(stmt, i),
    sqlite3_column_type(stmt, i),
    sqlite3_column_decltype(stmt, i));
  }

  fprintf(stdout, "\n");

  while(rc == SQLITE_ROW) {
    id   = sqlite3_column_int( stmt, 0);
    cid  = sqlite3_column_int( stmt, 1);
    name = sqlite3_column_text(stmt, 2);
    if(name != NULL) {
      fprintf(stderr, "Row: id=%i, cid=%i, name='%s'\n", id, cid,name);
    } else {
      /* Field is NULL */
      fprintf(stderr, "Row: id=%i, cid=%i, name=NULL\n", id,cid);
    }
    rc = sqlite3_step(stmt);
  }

  sqlite3_finalize(stmt);
  sqlite3_close(db);
  return 0;
}</pre>
          <p>This example connects to the database, selects records from the episodes table, and prints the column information and the fields for each row (using their internal storage class). Running the program produces the following output:</p>
          <samp>Column: name=id, storage class=1, declared=integer
Column: name=name, storage class=3, declared=text

Row: id=1, name='The Dinner Party'
Row: id=2, name='The Soup Nazi'
Row: id=3, name='The Fusilli Jerry'</samp>

          <aside>
            <h5>FINDING A STATEMENT&apos;S CONNECTION</h5>
            <p>In practice, you may find yourself writing code where some of your functions have access only to the statement handle, not the connection handle. If these functions encounter an error while working with the statement handle, they will not have a way to get error information from <code>sqlite3_errmsg()</code>, because it requires a connection handle to work. This is where <code>sqlite3_db_handle()</code> comes in handy. It is declared as follows:</p>
            <pre>int sqlite3_db_handle(sqlite3_stmt*);</pre>
            <p>Given a statement handle, <code>sqlite3_db_handle()</code> returns the associated connection handle. This way, you don&apos;t need to worry about having to pass the connection handle along with the statement handle everywhere you process query results.</p>
          </aside>

      </section>

      <section>
        <h3>Parameterized Queries*</h3>
        <p>The API includes support for designating parameters in a SQL statement, allowing you to provide (or <q>bind</q>) values for them at a later time. Bound parameters are used in conjunction with <code>sqlite3_prepare()</code>. For example, you could create a SQL statement like the following:</p>
        <pre>insert into foo values (?,?,?);</pre>
        <p>Then you can, for example, bind the integer value 2 to the first parameter (designated by the first ? character), the string value <q>pi</q> to the second parameter, and the double value 3.14 for the third parameter, as illustrated in the following code (taken from <cite>parameters.c</cite>):</p>
        <pre>const char* sql = "insert into foo values(?,?,?)";
sqlite3_prepare(db, sql, strlen(sql), &amp;stmt, &amp;tail);

sqlite3_bind_int(stmt, 1, 2);
sqlite3_bind_text(stmt, 2, "pi");
sqlite3_bind_double(stmt, 3, 3.14);
sqlite3_step(stmt);
sqlite3_finalize(stmt);</pre>
        <p>This generates and executes the following statement:</p>
        <pre>insert into foo values (2, 'pi', 3.14)</pre>
        <p>This particular method of binding uses positional parameters <!--(as described in Chapter 5) -->where each parameter is designated by a question mark (<code>?</code>) character and later identified by its index or relative position in the SQL statement.</p>
        <p>Before delving into the other parameter methods, it is helpful to first understand the process by which parameters are defined, bound, and evaluated. When you write a parameterized statement such as the following, the parameters within it are identified when <code>sqlite3_prepare()</code> compiles the query:</p>
        <pre>insert into episodes (id,name) values (?,?)</pre>
        <p><code>sqlite3_prepare()</code> recognizes that there are parameters in a SQL statement. Internally, it assigns each parameter a number to uniquely identify it. In the case of positional parameters, it starts with 1 for the first parameter found and uses sequential integer values for subsequent parameters. It stores this information in the resulting statement handle (<code>sqlite3_stmt</code> structure), which will then expect a specific number of values to be bound to the given parameters before execution. If you do not bind a value to a parameter, <code>sqlite3_step()</code> will use NULL for its value by default when the statement is executed.</p>
        <p>After you prepare the statement, you then bind values to it. You do this using the <code>sqlite3_bind_<var>xxx</var>()</code> functions, which have the following general form:</p>
        <pre>sqlite3_bind_<var>xxx</var>( sqlite3_stmt*, /* statement handle */
                  int i, /* parameter number */
                <var>xxx</var> value /* value to be bound */
);</pre>
        <p>The <var>xxx</var> in the function name represents the data type of the value to bind. For example, to bind a double value to a parameter, you would use sqlite3_bind_double(), which is declared as follows:</p>
        <pre>int sqlite3_bind_int(sqlite3_stmt*, int, int);
int sqlite3_bind_double(sqlite3_stmt*, int, double);
int sqlite3_bind_int64(sqlite3_stmt*, int, long long int);
int sqlite3_bind_null(sqlite3_stmt*, int);
int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int n, void(*)(void*));</pre>
        <p>In general, the bind functions can be divided into two classes, one for scalar values (int, double, int64, and NULL) and the other for arrays (blob, text, and text16). They differ only in that the array bind functions require a length argument and a pointer to a cleanup function. Also, <code>sqlite3_bind_text()</code> automatically escapes quote characters like <code>sqlite3_mprintf()</code>. Using the <code>BLOB</code> variant, the array bind function has the following declaration:</p>
        <pre>int sqlite3_bind_blob( sqlite3_stmt*, /* statement handle */
                       int, /* ordinal */
                       const void*, /* pointer to blob data */
                       int n, /* length (bytes) of data */
                       void(*)(void*)); /* cleanup hander */</pre>
        <p>There are two predefined values for the cleanup handler provided by the API that have special meanings, defined as follows:</p>
        <pre>
#define SQLITE_STATIC    ((void(*)(void *))  0)
#define SQLITE_TRANSIENT ((void(*)(void *)) -1)</pre>
        <p>Each value designates a specific cleanup action. <code>SQLITE_STATIC</code> tells the array bind function that the array memory resides in unmanaged space, so SQLite does not attempt to clean it up. <code>SQLITE_TRANSIENT</code> tells the bind function that the array memory is subject to change, so SQLite makes its own private copy of the data, which it automatically cleans up when the statement is finalized. The third option is to provide a pointer to your own cleanup function, which must be of the following form:</p>
        <pre>void cleanup_fn(void*)</pre>
        <p>If provided, SQLite will call your cleanup function, passing in the array memory when the statement is finalized.</p>
        <aside><strong>Note</strong> Bound parameters remain bound throughout the lifetime of the statement handle. They remain bound even after a call to <code>sqlite3_reset()</code> and are freed only when the statement is finalized (by calling <code>sqlite3_ finalize()</code>).</aside>
        <p>Once you have bound all the parameters you want, you can then execute the statement. You do this using the next function in the sequence: <code>sqlite3_step()</code>. <code>sqlite3_step()</code> will take the bound values, substitute them for the parameters in the SQL statement, and then begin executing the command.</p>
        <p>Now that you understand the binding process, the four parameter-binding methods differ only by the following:</p>
        <ul>
          <li>The way in which parameters are represented in the SQL statement (using a positional parameter, explicitly defined parameter number, or alphanumeric parameter name)</li>
          <li>The way in which parameters are assigned numbers</li>
        </ul>
        <p>For positional parameters, <code>sqlite3_prepare()</code> assigns numbers using sequential integer values starting with 1 for the first parameter. In the previous example, the first ? parameter is assigned 1, and the second ? parameter is assigned 2. With positional parameters, it is your job to keep track of which number corresponds to which parameter (or question mark) in the SQL statement and correctly specify that number in the bind functions.</p>

          <h4>Numbered Parameters</h4>
          <p>Numbered parameters, on the other hand, allow you to specify your own numbers for parameters, rather than use an internal sequence. The syntax for numbered parameters uses a question mark followed by the parameter number. Take, for example, the following piece of code (taken from <cite>parameters.c</cite>):</p>
          <pre>name = "Mackinaw Peaches";
sql = "insert into episodes (id, cid, name) "
      "values (?100,?100,?101)";
rc = sqlite3_prepare(db, sql, strlen(sql), &amp;stmt, &amp;tail);
if(rc != SQLITE_OK) {
  fprintf(stderr, "sqlite3_prepare() : Error: %s\n", tail);
  return rc;
}

sqlite3_bind_int(stmt, 100, 10);
sqlite3_bind_text(stmt, 101, name, strlen(name), SQLITE_TRANSIENT);
sqlite3_step(stmt);
sqlite3_finalize(stmt);</pre>
          <p>This example uses 100 and 101 for its parameter numbers. Parameter number 100 has the integer value 10 bound to it. Parameter 101 has the string value <q>Mackinaw Peaches</q> bound to it. Note how numbered parameters come in handy when you need to bind a single value in more than one place in a SQL statement. Consider the values part of the previous SQL statement:</p>
          <pre>insert into episodes (id, cid, name) values (?100,?100,?101);</pre>
          <p>Parameter 100 is being used twice—once for id and again for cid. Thus, numbered parameters save time when you need to use a bound value in more than one place.</p>
          <aside><strong>Note</strong> When using numbered parameters in a SQL statement, keep in mind that the allowable range consists of the integer values 1–999, and for optimal performance and memory utilization, you should choose smaller numbers.</aside>

          <h4>Named Parameters</h4>
          <p>The third parameter binding method is using named parameters. Whereas you can assign your own numbers using numbered parameters, you can assign alphanumeric names with named parameters. Likewise, because numbered parameters are prefixed with a question mark (?), you identify named parameters by prefixing a colon (:) or at-sign (@) to the parameter name. Consider the following code snippet (taken from <cite>parameters.c</cite>):</p>
          <pre>name = "Mackinaw Peaches";
sql = "insert into episodes (id, cid, name) values (:cosmo,:cosmo,@newman)";

rc = sqlite3_prepare(db, sql, strlen(sql), &amp;stmt, &amp;tail);

sqlite3_bind_int( stmt,
                  sqlite3_bind_parameter_index(stmt, ":cosmo"),
                  10);

sqlite3_bind_text( stmt,
sqlite3_bind_parameter_index(stmt,
                             "@newman"),
                             name,
                             strlen(name),
                             SQLITE_TRANSIENT );

sqlite3_step(stmt);
sqlite3_finalize(stmt);</pre>
          <p>This example is identical to the previous example using numbered parameters, except it uses two named parameters called <quote>:cosmo</quote> and <quote>@newman</quote> instead. Like positional parameters, named parameters are automatically assigned numbers by <quote>sqlite3_prepare()</quote>. Although the numbers assigned to each parameter are unknown, you can resolve them using <quote>sqlite3_bind_parameter_index()</quote>, which takes a parameter name and returns the corresponding parameter number. This is the number you use to bind the value to its parameter. All in all, named parameters mainly help with legibility more than anything else.</p>
          <aside><strong>Note</strong> While the function <quote>sqlite3_bind_parameter_index()</quote> seems to refer to a parameter number as an index, for all intents and purposes the two terms (number and index) are synonymous.</aside>

          <h4>Tcl Parameters</h4>
          <p>The final parameter scheme is called Tcl parameters and is specific more to the Tcl extension than it is to the C API. Basically, it works identically to named parameters except that rather than using alphanumeric values for parameter names, it uses Tcl variable names. In the Tcl extension, when the Tcl equivalent of <code>sqlite3_prepare()</code> is called, the Tcl extension automatically searches for Tcl variables with the given parameter names in the active Tcl program environment and binds them to their respective parameters. Despite its current application in the Tcl interface, nothing prohibits this same mechanism from being applied to other language interfaces, which can in turn implement the same feature. In this respect, referring to this parameter method solely as Tcl parameters may be a bit of a misnomer. The Tcl extension just happened to be the first application that utilized this method. Basically, the Tcl parameter syntax does little more than provide an alternate syntax to named parameters—rather than prefixing the parameters with a colon (:) or an at-sign (@), it uses a dollar sign ($).</p>
      </section>

      <section id="errors-and-the-unexpected">
        <h3>Errors and the Unexpected*</h3>
        <p>Things can and do go wrong, and there is part of the API devoted to that.</p>
        <p>The three things you always have to guard against in your code are errors, busy conditions, and, my personal favorite, schema changes.</p>
          <h4>Handling Errors</h4>
          <p>Many of the API functions return integer result codes. That means they can potentially return error codes of some sort. The most common functions to watch are typically the most frequently used, such as <code>sqlite3_open_v2()</code>, <code>sqlite3_prepare_v2()</code>, and friends, as well as <code>sqlite3_exec()</code>. You should always program defensively and review every API function before you use it to ensure that you deal with error conditions that can arise. Of all the error results defined in SQLite, only a fraction of them will really matter to your application in practice. All of the SQLite result codes are listed in the table below, and the API functions that can return them include the following:</p>
          <pre>sqlite3_bind_<var>xxx</var>()
sqlite3_close()
sqlite3_create_collation()
sqlite3_collation_needed()
sqlite3_create_function()
sqlite3_prepare_v2()
sqlite3_exec()
sqlite3_finalize()
sqlite3_get_table()
sqlite3_open_v2()
sqlite3_reset()
sqlite3_step()</pre>
          <p>You can get extended information on a given error using <code>sqlite3_errmsg()</code>, which is declared as follows:</p>
          <pre>const char *sqlite3_errmsg(sqlite3*);</pre>
          <p>It takes a connection handle as its only argument and returns the most recent error resulting from an API call on that connection. If no error has been encountered, it returns the string <q>not an error.</q></p>
          <table border="1">
            <caption>SQLite Result Codes</caption>
            <thead> <tr> <th>Code</th> <th>Description</th> </tr> </thead>
            <tbody> <tr> <td><code>SQLITE_OK</code></td> <td>The operation was successful.</td> </tr>
                    <tr> <td><code>SQLITE_ERROR</code></td> <td>General SQL error or missing database. It may be possible to obtain more error information depending on the error condition (<code>SQLITE_SCHEMA</code>, for example).</td> </tr>
                    <tr> <td><code>SQLITE_INTERNAL</code></td> <td>Internal logic error.</td> </tr>
                    <tr> <td><code>SQLITE_PERM</code></td> <td>Access permission denied.</td> </tr>
                    <tr> <td><code>SQLITE_ABORT</code></td> <td>A callback routine requested an abort.</td> </tr>
                    <tr> <td><code>SQLITE_BUSY</code></td> <td>The database file is locked.</td> </tr>
                    <tr> <td><code>SQLITE_LOCKED</code></td> <td>A table in the database is locked.</td> </tr>
                    <tr> <td><code>SQLITE_NOMEM</code></td> <td>A call to <code>malloc()</code> has failed within a database operation.</td> </tr>
                    <tr> <td><code>SQLITE_READONLY</code></td> <td>An attempt was made to write to a read-only database.</td> </tr>
                    <tr> <td><code>SQLITE_INTERRUPT</code></td> <td>Operation was terminated by <code>sqlite3_interrupt()</code>.</td> </tr>
                    <tr> <td><code>SQLITE_IOERR</code></td> <td>Some kind of disk I/O error occurred.</td> </tr>
                    <tr> <td><code>SQLITE_CORRUPT</code></td> <td>The database disk image is malformed. This will also occur if an attempt is made to open a non-SQLite database file as a SQLite database.</td> </tr>
                    <tr> <td><code>SQLITE_FULL</code></td> <td>Insertion failed because the database is full. There is no more space on the file system or the database file cannot be expanded.</td> </tr>
                    <tr> <td><code>SQLITE_CANTOPEN</code></td> <td>SQLite was unable to open the database file.</td> </tr>
                    <tr> <td><code>SQLITE_PROTOCOL</code></td> <td>The database is locked or there has been a protocol error.</td> </tr>
                    <tr> <td><code>SQLITE_EMPTY</code></td> <td>(Internal only.) The database table is empty.</td> </tr>
                    <tr> <td><code>SQLITE_SCHEMA</code></td> <td>The database schema has changed.</td> </tr>
                    <tr> <td><code>SQLITE_CONSTRAINT</code></td> <td>Abort due to constraint violation.</td> </tr>

                    <tr> <td><code>SQLITE_MISMATCH</code></td> <td>Data type mismatch. An example of this is an attempt to insert noninteger data into a column labeled <code>INTEGER PRIMARY KEY</code>. For most columns, SQLite ignores the data type and allows any kind of data to be stored. But an <code>INTEGER PRIMARY KEY</code> column is allowed to store integer data only.</td> </tr>
                    <tr> <td><code>SQLITE_MISUSE</code></td> <td>Library was used incorrectly. This error might occur if one or more of the SQLite API routines is used incorrectly.</td> </tr>
                    <tr> <td><code>SQLITE_NOLFS</code></td> <td>Uses OS features not supported on host. This value is returned if the SQLite library was compiled with large file support (LFS) enabled but LFS isn&apos;t supported on the host operating system.</td> </tr>
                    <tr> <td><code>SQLITE_AUTH</code></td> <td>Authorization denied. This occurs when a callback function installed using <code>sqlite3_set_authorizer()</code> returns <code>SQLITE_DENY</code>.</td> </tr>
                    <tr> <td><code>SQLITE_FORMAT</code></td> <td>Auxiliary database format error.</td> </tr>
                    <tr> <td><code>CODE</code></td> <td>DESC</td> </tr>
                    <tr> <td><code>SQLITE_RANGE</code></td> <td>Second parameter to <code>sqlite3_bind()</code> out of range.</td> </tr>
                    <tr> <td><code>SQLITE_NOTADB</code></td> <td>File opened is not a SQLite database file.</td> </tr>
                    <tr> <td><code>SQLITE_ROW</code></td> <td><code>sqlite3_step()</code> has another row ready.</td> </tr>
                    <tr> <td><code>SQLITE_DONE</code></td> <td><code>sqlite3_step()</code> has finished executing.</td> </tr>
            </tbody>
          </table>
          <p>Although it is very uncommon outside of embedded systems, one of the most critical errors you can encounter is <code>SQLITE_NOMEM</code>, which means that no memory can be allocated on the heap (for example, <code>malloc()</code> failed). SQLite is quite robust in this regard, recovering gracefully from out-of-memory error conditions. It will continue to work assuming the underlying operating system completes memory allocation system calls like <code>malloc()</code>.</p>

          <h4>Handling Busy Conditions</h4>
          <p>Two important functions related to processing queries are <code>sqlite3_busy_handler()</code> and <code>sqlite3_busy_timeout()</code>. If your program uses a database on which there are other active connections, odds are it will eventually have to wait for a lock and therefore will have to deal with <code>SQLITE_BUSY</code>. Whenever you call an API function that causes SQLite to seek a lock and SQLite is unable to get it, the function will return <code>SQLITE_BUSY</code>. There are three ways to deal with this:</p>
          <ul>
            <li>Handle <code>SQLITE_BUSY</code> yourself, either by rerunning the statement or by taking some other action</li>
            <li>Have SQLite call a busy handler</li>
            <li>Ask SQLite to wait (block or sleep) for some period of time for the lock to clear              </li>
          </ul>
          <p>The last option involves using <code>sqlite3_busy_timeout()</code>. This function tells SQLite how long to wait for a lock to clear before returning <code>SQLITE_BUSY</code>. Although it can ultimately result in you still having to handle <code>SQLITE_BUSY</code>, in practice setting this value to a sufficient period of time (say 30 seconds) usually provides enough time for even the most intensive transaction to complete. Nevertheless, you should still have some contingency plan in place to handle <code>SQLITE_BUSY</code>.</p>

          <h4>User-Defined Busy Handlers</h4>
          <p>The second option entails using <code>sqlite3_busy_handler()</code>. This function provides a way to call a user-defined function rather than blocking or returning <code>SQLITE_BUSY</code> right away. It&apos;s declared as follows:</p>
          <pre>int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);</pre>
          <p>The second argument is a pointer to a function to be called as the busy handler, and the third argument is a pointer to application-specific data to be passed as the first argument to the handler. The second argument to the busy handler is the number of prior calls made to the handler for the same lock.</p>
          <p>Such a handler might call <code>sleep()</code> for a period to wait out the lock, or it may send some kind of notification. It may do whatever you like, because it is yours to implement. Be warned, though, that registering a busy handler does not guarantee that it will always be called.<!-- As mentioned in Chapter 5,--> SQLite will forego calling a busy handler for a connection if it perceives a deadlock might result. Specifically, if your connection in <code>SHARED</code> is interfering with another connection in <code>RESERVED</code>, SQLite will not invoke your busy handler, hoping you will take the hint. In this case, you are trying to write to the database from <code>SHARED</code> (starting the transaction with <code>BEGIN</code>) when you really should be starting from <code>RESERVED</code> (starting the transaction with <code>BEGIN IMMEDIATE</code>).</p>
          <p>The only restriction on busy handlers is that they may not close the database. Closing the database from within a busy handler can delete critical data structures out from under the executing query and result in crashing your program.</p>
          <aside>All things considered, the best route may be to set the timeout to a reasonable value and then take some precautions if and when you receive a <code>SQLITE_BUSY</code> value. In general, if you are going to write to the database, start in <code>RESERVED</code>. If you don&apos;t do this, then the next best thing is to install a busy handler, set the timeout to a known value, and if SQLite returns <code>SQLITE_BUSY</code>, check the response time. If the time is less than the busy handler&apos;s delay, then SQLite is telling you that your query (and connection) is preventing a writer from proceeding. If you want to write to the database at this point, you should finalize or reset and then reexecute the statement, this time starting with <code>BEGIN IMMEDIATE</code>.</aside>

          <h4>Handling Schema Changes*</h4>
          <p>Whenever a connection changes the database schema, all other prepared statements that were compiled before the change are invalidated. The result is that the first call to <code>sqlite3_step()</code> for such statements will attempt to recompile the relevant SQL and proceed normally from there if possible. If recompilation is impossible (for example, if an object has been dropped entirely), the <code>sqlite3_step()</code> returns <code>SQLITE_SCHEMA</code>. From a locking standpoint, the schema change occurs between the time a reader calls <code>sqlite3_prepare()</code> to compile a statement and <code>calling sqlite3_step()</code> to execute it.</p>
          <p>When this happens, the only course of action for you is to handle the change in circumstances and start over. Several events can cause <code>SQLITE_SCHEMA</code> errors:</p>
          <ul>
            <li>Detaching databases</li>
            <li>Modifying or installing user-defined functions or aggregates</li>
            <li>Modifying or installing user-defined collations</li>
            <li>Modifying or installing authorization functions</li>
            <li>Vacuuming the database            </li>
          </ul>
          <p>The reason the <code>SQLITE_SCHEMA</code> condition exists ultimately relates to the VDBE. When a connection changes the schema, other compiled queries may have VDBE code that points to database objects that no longer exist or are in a different location in the database. Rather than running the risk of a bizarre runtime error later, SQLite invalidates all statements that have been compiled but not executed. They must be recompiled.</p>

          <aside>
            <h5>Tracing Execution</h5>
            <p>If you are having a hard time figuring out exactly what your program is doing with the database, you can track what SQL statements it has executed using sqlite3_trace(). Its declaration is as follows:</p>
            <pre>void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);</pre>
            <p>This function is analogous to putting a wiretap on a connection. You can use it to generate a log file of all SQL executed on a given connection as well provide helpful debugging information. Every SQL statement that is processed is passed to the callback function specified in the second argument. SQLite passes the data provided in the third argument of <code>sqlite3_trace()</code> to the first argument of the callback function.</p>
          </aside>

          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>

          <h4>*</h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>

          <h4>*</h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>

      </section>

      <section>
        <h3>Operational Control*</h3>
          <h4></h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <h4></h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <h4></h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
      </section>

      <section>
        <h3>Threads*</h3>
          <h4></h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <h4></h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <h4></h4>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
          <p></p>
          <pre></pre>
      </section>

    </main>

  </body>

</html>
