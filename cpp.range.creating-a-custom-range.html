<!DOCTYPE html>
<html>
  <head>
    <title>Creating a custom range in C++</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <meta name="description" content="Creating a custom range in C++ (incomplete)"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>
    <meta name="author" content="AUTHOR"/>
    ADD: https://mariusbancila.ro/blog/2019/01/20/cpp-code-samples-before-and-after-ranges/
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      <p><a href="cpp.coroutines.html">C++ Coroutines</a></p>
      <p><a href="cpp.modules.html">C++ Coroutines</a></p>
      <p><a href="cpp.format.html">C++20 Formatting</a></p>
      -->
      <div>
      <p><a rel="next" href="cpp.range.creating-your-own.html">Creating Your Own Ranges/Views</a></p>
      <p><a            href="cpp.generics.concepts.html">Concepts or Template Constraints in C++</a></p>
      <p><a rel="prev" href="cpp.range.html">Ranges (C++20)</a></p>
      </div>
      <div>
      <p><a href="https://hannes.hauswedell.net/post/2019/11/30/range_intro/">Hannes Hauswedell&apos;Introduction to C++ Ranges</a></p>
      </div>
    </nav>

    <main>
      <h1>Creating a custom range in C++ (incomplete)</h1>
      <p>In this section, we will be exploring how we can create a custom view, including its corresponding range adaptor. For the sake of simplicity, we will (re)implement <code>take_view</code>, which is also present in the STL.</p>
      <p>Our goal is that the following code compiles and gives the correct result, as it would with <code>std::views::take</code>:</p>
      <pre>const std::vector&lt;int&gt; n{2, 3, 5, 6, 7, 8, 9};
auto v = n | rv::filter(is_even) | views::custom_take(2);
std::ranges::copy(v,
std::ostream_iterator&lt;int&gt;(std::cout, " "));</pre>


      <section>
        <h2>Implementing the view</h2>
        <p>The first step is to implement the actual view to a range. In this view, we need to store the range and the number of elements this view should process from the range. While implementing this, we apply the range concepts available in C++20. The listing below shows an implementation, which we will walk through next.</p>
        <pre>template&lt;std::ranges::view R&gt;// #A Using ranges::view concept
class custom_take_view
: public std::ranges::view_interface&lt;custom_take_view&lt;R&gt;&gt; {
  // #B Necessary data members:
  R base_{};
  std::ranges::range_difference_t&lt;R&gt; count_{};

public:
  // #C Default constructible:
  custom_take_view() = default;

  // #D Constructor for range and count:
  constexpr custom_take_view(
    R base,
    std::ranges::range_difference_t&lt;R&gt; count)
    :base_{std::move(base)} ,count_{count}
  {}

  // #E view_interface members:
  constexpr R base() const &amp; {return base_;}
  constexpr R base()&amp;&amp;   {return std::move(base_);}

  // #F Actual begin and end:
  constexpr auto begin() {return std::ranges::begin(base_);}
  constexpr auto end() {
    return std::ranges::next(std::ranges::begin(base_),count_);
  }
};

template&lt;std::ranges::range R&gt;// #G Deduction guide
custom_take_view(R&amp;&amp; base, std::ranges::range_difference_t&lt;R&gt;)
  -&gt;custom_take_view&lt;std::ranges::views::all_t&lt;R&gt;&gt;;</pre>
        <p>In the template head of the class template <code>custom_take_view</code>, we directly start applying concepts #A. This class should work only with a view type. This concept checks that <var>R</var> is a range that is movable, default initializable, and is a view. The last concept checks whether <var>R</var> is derived from view_base. Our <code>custom_take_view</code> derives from view_base with the help of <code>view_interface</code>, using Curiously Recurring Template Pattern (CRTP).</p>
        <p>After the head, we declare the required data members #B. In #C, we ensure that custom_take_view is default-constructible. The next constructor in #D is used when our view is created from a range and a count. This is the second item in the list in ยง3.</p>
        <p>The view_interface requires a couple of members, which are implemented in #E. The actual implementation for <code>begin</code> and <code>end</code> is presented in #F. Here, we use the ranges <code>begin</code> version. In <code>end</code> you can see the actual implementation, the only part here that does something other than setting defaults. Using <code>std::ranges::next</code>, we retrieve the next iterator element after <code>begin</code> with an offset of <code>count</code>. With that, we already have a working implementation of <code>custom_take_view</code>.</p>
        <hr/>
        <p>Please note that this is a simplified version. The STL has to deal with different range types, depending on whether <var>R</var> is a <code>simple_view</code> or a <code>sized_range</code>. We leave this out here.</p>
        <p>What is also needed is the Class Template Argument Deduction (CTAD) deduction guide in #G. Without this deduction guide, we cannot create a <code>custom_take_view</code> just by passing a range and a count.</p>
        <p>We now have the base for our <code>custom_take_view</code>. Let&apos;s make our view fit nicely into all the other ranges and add the missing range adaptor.</p>
      </section>
      <section>
        <h2>A range adaptor for <code>custom_take_view</code></h2>
        <p>The next thing we need for <code>custom_take_view</code> is a range adaptor. The code shown below should, in practice, be wrapped in a dedicated namespace like <code>details</code>.</p>
        <pre>template&lt;std::integral T&gt; // #A Only integrals
struct custom_take_range_adaptor_closure {
  T count_;// #B Store the count
  constexpr custom_take_range_adaptor_closure(T count)
  : count_{count}
  {}

  // #C Allow it to be called with a range:
  template&lt;std::ranges::viewable_range R&gt;
  constexpr auto operator()(R&amp;&amp;r)const {
    return custom_take_view(std::forward&lt;R&gt;(r),count_);
  }
};</pre>
        <!--
        <p></p>
        <pre></pre>
        <p></p>
        <pre></pre>
        -->
      </section>
      <!--
      <section>
        <h2>Add the pipe-syntax to <code>custom_take_view</code></h2>
      </section>
      <section>
        <h2>A more generalized pipe-syntax implementation</h2>
      </section>
      -->

    </main>

  </body>

</html>
