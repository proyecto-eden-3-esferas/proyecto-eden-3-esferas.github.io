<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>eXtensible Stylesheet Language Transformations</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>

    <link rel="alternate" hreflang="x-default" href="http://www.example.com/"/>
    <link rel="alternate" hreflang="es" href="http://es.example.com/"/>
    <link rel="alternate" hreflang="de" href="http://de.example.com/"/>

    <link rel="author" href="https://plus.google.com/ExampleProfile"/>
    <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
      <div>
        <p>
          <a href="https://github.com/proyecto-eden-3-esferas/SVG/">My Code for Geometry and SVG Schematics</a>
        </p>
      </div>
      <div>
        <p>
          <a href="xml.en.html">XML: The eXtensible Markup Language</a>
        </p>
        <p>
          <a href="HTML.html">HTML: XML for the Web</a>
        </p>
      </div>
      <div>
        <p>
          <a href="svg.html">SVG: XML for Drawing</a>
        </p>
      </div>
      <div>
        <p>
          <a href="TheWeb.html">The Web</a>
        </p>
      </div>
    </nav>
    <!-- TODO
      [ ] Bring in Communicate.xml::<title>Transforming to HTML through XSLT</title>
      [ ] transform elements: link
    -->
    <main>
      <h1>eXtensible Stylesheet Language Transformations</h1>
      <p>XSLT is a declarative programming language for transforming XML or any other text. It searches for parts of an XML document that match a series of predefined templates, and then applies transformation and formatting rules to each matched part. Another language, <a href="#xpath">XPath</a>, is used to help in finding those matching parts.</p>
      <section>
        <h2>How XSLT Works</h2>
        <p>An XSLT <dfn>stylesheet</dfn> is used to define the transformation rules to be applied on the target XML document. XSLT stylesheet is written in XML format. XSLT Processor takes the XSLT stylesheet and applies the transformation rules on the target XML document and then it generates a formatted document in the form of XML, HTML, or text format. Possibly, this formatted document is then utilized by XSLT formatter to generate the actual output which is to be displayed to the end-user.</p>
      </section>
      <section>
        <h2>Gentle Introduction to XML through an Example</h2>
        <p>Here is the contents of an XML file named greeting.xml:</p>
        <pre>&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet href="greeting.xsl" type="text/xsl"?&gt;
&lt;greeting&gt;
  Hello, World!
&lt;/greeting&gt;</pre>
        <p>to be transformed into html format by stylesheet greeting.xsl. The second line asks the browser to process the contents. If you omit it, you can feed greeting.xml and greeting.xsl to an XSLT processor such as xsltproc, as found in linux. The contents of the stylesheet are:</p>
        <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="html"/&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="greeting"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="greeting"&gt;
  &lt;html&gt;
    &lt;body&gt;
      &lt;h1&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/h1&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
        <p>The root element is &lt;xsl:stylesheet&gt; , or the synonym &lt;xsl:transform&gt;. You must always specify the XSLT namespace, and it is important to set the version attribute correctly to match the type of processing required. After you've declared the namespace, all the XSLT element names require the namespace prefix, which is xsl: by convention. The prefix also makes it clear which element is referenced if other namespaces are in use. The version attribute on the &lt;xsl:stylesheet&gt; element is rather confusing. It has absolutely nothing to do with the version of XSLT; rather, it refers to the version of XML to be output.</p>
        <p>In XSLT 1.0, the method attribute can take the values "xml", "html" , or "text". The XSLT 2.0 specification adds "xhtml" to the possible attribute values.</p>
        <p>You can add in the <sgmltag>output</sgmltag> tag two more attributes specifying the XHTML doctype-system and doctype-public attribute values. These will result in the processor generating correct declarations in the output, before the <sgmltag>html</sgmltag> element:</p>
        <pre>&lt;xsl:output
  method="xml"
  encoding="UTF-8"
  doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
  doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;</pre>
        <p>You are not restricted to following the nested nodes as shown in this example. You might want to select all the paragraphs in the source document for processing, in which case you would use &lt;xsl:apply-templates select= "//p"/&gt;.</p>
      </section>
      <section>
        <h2>The XSLT Namespace</h2>
        <p>All standard XSLT elements are in the <code class="userinput">http://www.w3.org/1999/XSL/Transform</code> namespace. In this section, we assume that this URI is mapped to the <code class="userinput">xsl</code> prefix using an appropriate <code class="userinput">xmlns:xsl</code> declaration somewhere in the stylesheet. This mapping is normally declared on the root element like this:</p>
        <pre>&lt;xsl:stylesheet version="1.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
      &lt;!-- XSLT top-level elements go here --&gt;
    &lt;/xsl:stylesheet&gt;</pre>
      </section>
      <section>
        <h2>Embedding Stylesheets in XML Documents</h2>
        <p>XSLT stylesheets are often used in a batch environment as separate files, but it is also possible to embed a stylesheet directly in an XML document, possibly to deliver the document directly to a browser for rendering. This means that the XML document must be aware of the stylesheet.</p>
        <p>There is a separate recommendation from the W3C that identifies the process for embedding stylesheets in XML documents, called <cite class="document" xml:href="http://www.w3.org/TR/xml-stylesheet">Associating Style Sheets with XML Documents, Version 1.0</cite>. This recommendation describes a predefined XML processing instruction, or PI, that can be used at the top of any XML document to allow the XML to find the top of the XSLT stylesheet, wherever it is in the XML.</p>
        <p>The PI uses an <var>href</var> attribute with a URI to point to the ID of the <code class="userinput">&lt;xsl:stylesheet&gt;</code> element. This URI must be a fragment identifier (signalled by the # prefix) because it is a reference to a part of the document containing the PI. It is not used to reference an external stylesheet. The following PI model definition shows the two required attributes and four optional attributes for the <code class="userinput">&lt;?xml-stylesheet?&gt;</code> PI:</p>
        <pre>&lt;?xml-stylesheet
  href= string
  type= string
  title = string
  media = string
  charset = string
  alternate = "yes" | "no"
?&gt;</pre>
        <p>The following example, taken directly from the XSLT specification, shows an embedded stylesheet in an XML document. Notice that this example contains a few elements from the XSL formatting objects specification. The stylesheet is called into play with the <code class="userinput">&lt;?xml-stylesheet?&gt;</code> PI. The template rule matching on id('foo') in the example finds an element in the XML with an ID of "foo" and uses the instructions in the template to format it, in this case with a bold font.</p>
        <pre>&lt;?xml-stylesheet type="text/xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
               version="1.0"
             xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
      &lt;xsl:import href="doc.xsl"/&gt;
      &lt;xsl:template match="id('foo')"&gt;
        &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
      &lt;/xsl:template&gt;
      &lt;xsl:template match="xsl:stylesheet"&gt;
        &lt;!-- ignore --&gt;
      &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
    &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;</pre>
        <p>The template rule matching on <code class="userinput">xsl:stylesheet</code> is required in all embedded stylesheets so that <code class="userinput">&lt;xsl:stylesheet&gt;</code> elements are processed as elements.</p>
      </section>
      <section>
        <h2>Linking to a Stylesheet</h2>
        <h2 class="subtitle">Client&#x2212;side transformation</h2>
        <p>Client&#x2212;side transformation is supported by XSLT processors embedded in browsers. Client&#x2212;side transformation has the advantage that you can spread the processing overhead onto the client machines. However, it means you are dependent on the client browser dealing correctly with the XSLT.</p>
        <p>The following XML file sets its own stylesheet for the browser to process:</p>
        <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="class.xsl"?&gt;

&lt;class&gt;
  &lt;student&gt;Jack&lt;/student&gt;
  &lt;student&gt;Harry&lt;/student&gt;
  &lt;student&gt;Rebecca&lt;/student&gt;
  &lt;teacher&gt;Mr. Bean&lt;/teacher&gt;
&lt;/class&gt;
</pre>
        <p>The stylesheet (named <cite class="filename">class.xsl</cite>) in turn should produce XHTML code:</p>
        <pre>&lt;?xml version="1.0" ?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

	&lt;xsl:template match="teacher"&gt;
		&lt;p&gt;&lt;u&gt;&lt;xsl:value-of select="."/&gt;&lt;/u&gt;&lt;/p&gt;
	&lt;/xsl:template&gt;

	&lt;xsl:template match="student"&gt;
		&lt;p&gt;&lt;b&gt;&lt;xsl:value-of select="."/&gt;&lt;/b&gt;&lt;/p&gt;
	&lt;/xsl:template&gt;
	&lt;xsl:template match="/"&gt;
		&lt;html&gt;
		&lt;body&gt;
		&lt;xsl:apply-templates/&gt;
		&lt;/body&gt;
		&lt;/html&gt;
	&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
        <p>The XML file <cite class="filename">class.xml</cite> is linked to the XSLT code by adding the xml-stylesheet reference. The XSLT code then applies its rules to transform the XML document.</p>
      </section>
      <section>
        <h2>Value Types</h2>
        <p>There are four value types in XPath, and two that are introduced by XSLT. The four basic value types are as follows:</p>
        <ul>
          <li><em>Boolean:</em> True or false</li>
          <li><em>Number:</em> A floating point number, NaN (not a number), Infinity and &#x2013;Infinity</li>
          <li><em>String:</em> A piece of text; none of the characters within a string have any particular significance in XPath</li>
          <li><em>Node set:</em> An unordered group of nodes</li>
        </ul>
        <p>XSLT introduces two further value types:</p>
        <ul>
          <li><em>Result tree fragment:</em> A portion of a result tree that is very similar to a mini node tree with a single root node; it cannot be indexed in the same way as a node tree</li>
          <li><em>External objects:</em> Objects created and used by extension functions; they do not fall into one of the other value types</li>
        </ul>
      </section>
      <section>
        <h2>Nodes</h2>
        <p>When an application wants to operate on an XML document (such as an XSLT processor running an XSLT stylesheet over an XML document), it builds an internal model of what the document looks like. In general, this model is known as a document object model or DOM. In XPath and XSLT, it's called a <dfn>node tree</dfn>. <dfn>Nodes</dfn> are the abstract components that make up a node tree. Many different kinds of nodes exist, and each type represents a different kind of component in an XML document. The following node types are significant in XSLT:</p>
        <ul>
          <li>Root nodes: The top of the node tree</li>
          <li>Element nodes: XML elements</li>
          <li>Attribute nodes: XML attributes</li>
          <li>Text nodes: Textual content in XML elements</li>
          <li>Comment nodes: XML comments</li>
          <li>Processing instruction nodes: XML processing instructions</li>
          <li>Namespace nodes: The in&#x2212;scope namespaces on an element</li>
        </ul>
        <p>The node tree reflects the logical form of the document rather than its physical form, which means that node trees don't contain nodes representing things such as the XML declaration, the DOCTYPE declaration, CDATA sections, or entities within the document. The top node of any node tree is the <dfn>root node</dfn>. The top&#x2212;most element in a document is called the document element. In a well&#x2212;formed XML document, only one document element ever exists. The nodes that appear within a node in a node tree are known as its children. As you might expect, then, every node except for the very top node has a parent. In most instances, a node' parent is an element node, with the only exception to this being nodes that are directly under the root node (the document element and any top&#x2212;level processing instructions or comments).</p>
      </section>
      <section id="XSLT_elem_1.0">
        <header>
          <h2>XSLT Elements V 1.0 (w3schools)</h2>
          <p class="abstract">This section is drawn from the pages in www.w3schools.com. For coverage of latest features, aka XSLT 2.0, see Appendix.</p>
        </header>
        <p>These are:</p>
        <dl>
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_apply-imports">XSLT apply-imports</a></dt>
            <dd>Applies a template rule from an imported style sheet</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_apply-templates">XSLT apply-templates</a></dt>
            <dd>Applies a template rule to the current element or to the current element's child nodes</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_attribute">XSLT attribute</a></dt>
            <dd>Adds an attribute</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_attribute-set">XSLT attribute-set</a></dt>
            <dd>Defines a named set of attributes</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_call-template">XSLT call-template</a></dt>
            <dd>Calls a named template</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_choose">XSLT choose</a></dt>
            <dd>Used in conjunction with &lt;when&gt; and &lt;otherwise&gt; to express multiple conditional tests</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_comment">XSLT comment</a></dt>
            <dd>Creates a comment node in the result tree</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_copy">XSLT copy</a></dt>
            <dd>Creates a copy of the current node (without child nodes and attributes)</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_copy-of">XSLT copy-of</a></dt>
            <dd>Creates a copy of the current node (with child nodes and attributes)</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_decimal-format">XSLT decimal-format</a></dt>
            <dd>Defines the characters and symbols to be used when converting numbers into strings, with the format-number() function</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_element">XSLT element</a></dt>
            <dd>Creates an element node in the output document</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_fallback">XSLT fallback</a></dt>
            <dd>Specifies an alternate code to run if the processor does not support an XSLT element</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_for-each">XSLT for-each</a></dt>
            <dd>Loops through each node in a specified node set</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_if">XSLT if</a></dt>
            <dd>Contains a template that will be applied only if a specified condition is true</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_import">XSLT import</a></dt>
            <dd>Imports the contents of one style sheet into another. Note: An imported style sheet has lower precedence than the importing style sheet</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_include">XSLT include</a></dt>
            <dd>Includes the contents of one style sheet into another. Note: An included style sheet has the same precedence as the including style sheet</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_key">XSLT key</a></dt>
            <dd>Declares a named key that can be used in the style sheet with the key() function</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_message">XSLT message</a></dt>
            <dd>Writes a message to the output (used to report errors)</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_namespace-alias">XSLT namespace-alias</a></dt>
            <dd>Replaces a namespace in the style sheet to a different namespace in the output</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_number">XSLT number</a></dt>
            <dd>Determines the integer position of the current node and formats a number</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_otherwise">XSLT otherwise</a></dt>
            <dd>Specifies a default action for the &lt;choose&gt; element</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_output">XSLT output</a></dt>
            <dd>Defines the format of the output document</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_param">XSLT param</a></dt>
            <dd>Declares a local or global parameter</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_preserve-space">XSLT preserve-space</a></dt>
            <dd>Defines the elements for which white space should be preserved</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_processing-instruction">XSLT processing-instruction</a></dt>
            <dd>Writes a processing instruction to the output</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_sort">XSLT sort</a></dt>
            <dd>Sorts the output</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_strip-space">XSLT strip-space</a></dt>
            <dd>Defines the elements for which white space should be removed</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_stylesheet_and_transform_elements">XSLT stylesheet and transform</a></dt>
            <dd>Defines the root element of a style sheet</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_template">XSLT template</a></dt>
            <dd>Rules to apply when a specified node is matched</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_text">XSLT text</a></dt>
            <dd>Writes literal text to the output</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_value-of">XSLT value-of</a></dt>
            <dd>Extracts the value of a selected node</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_variable">XSLT variable</a></dt>
            <dd>Declares a local or global variable</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_when">XSLT when</a></dt>
            <dd>Specifies an action for the &lt;choose&gt; element</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><a href="#xslt10_with-param">XSLT with-param</a></dt>
            <dd>Defines the value of a parameter to be passed into a template</dd>
          <!-- </varlistentry> -->
        </dl>
        <section class="sect2" id="xslt10_apply-imports">
          <h3>xsl:apply-imports</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:apply-imports</code> element applies a template rule from an imported style sheet.</p>
            <p>Template rules in imported style sheets have lower precedence than template rules in main style sheets. The <code class="tag">xsl:apply-imports</code> is used when we want to use a template rule from the imported style sheet rather than an equivalent rule in the main style sheet.</p>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Suppose we have a style sheet called <cite class="filename">standard.xsl</cite> that contains a template rule for message elements:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="message"&gt;
  &lt;h2&gt;&lt;xsl:apply-templates/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
            <p>Another style sheet could import <cite class="filename">standard.xsl</cite>, and modify the message elements, like this:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="standard.xsl"/&gt;

&lt;xsl:template match="message"&gt;
  &lt;div style="border:solid blue"&gt;
  &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt; </pre>
            <p>The result would be to transform a message into an element of the form:</p>
            <pre>&lt;div style="border:solid blue"&gt;&lt;h2&gt;...&lt;/h2&gt;&lt;/div&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_apply-templates">
          <h3>xsl:apply-templates</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:apply-templates</code> element applies a template to the current element or to the current element's child nodes.</p>
            <p>If we add a select attribute to the <code class="tag">xsl:apply-templates</code> element it will process only the child element that matches the value of the attribute. We can use the select attribute to specify in which order the child nodes are to be processed.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:apply-templates select="expression" mode="name"&gt;

  &lt;!-- Content:(xsl:sort|xsl:with-param)* --&gt;

&lt;/xsl:apply-templates&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>select 	&lt;expression&gt; 	(optional)</dt>
                <dd>Specifies the nodes to be processed. An asterisk selects the entire node-set. If this attribute is omitted, all child nodes of the current node will be selected</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>mode 	&lt;name&gt; 	(optional)</dt>
                <dd>If there are multiple ways of processing defined for the same element, distinguishes among them</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>Wrap a single h1 element around each title element in the document:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="title"&gt;
  &lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt; </pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>Wrap a single h1 element around all the title elements which are children of message:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="message"&gt;
  &lt;h1&gt;&lt;xsl:apply-templates select="title"/&gt;&lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 3</h4>
            <p>Wrap a single h1 element around all the child nodes of message that have the mode attribute set to <code class="literal">big</code>:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="message"&gt;
  &lt;h1&gt;&lt;xsl:apply-templates select="*" mode="big"/&gt;&lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt; </pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_attribute">
          <h3>xsl:attribute</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:attribute&gt;</code> element is used to add attributes to elements.</p>
            <aside class="warning"><strong>Warning:</strong> The <code class="tag">xsl:attribute&gt;</code> element replaces existing attributes with equivalent names.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:attribute name="attributename" namespace="uri"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:attribute&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;attributename&gt; (required)</dt>
                <dd>Specifies the name of the attribute</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>namespace &lt;URI&gt; (Optional)</dt>
                <dd>Defines the namespace URI for the attribute</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>Add a source attribute to the picture element:</p>
            <pre>&lt;picture&gt;
  &lt;xsl:attribute name="source"/&gt;
&lt;/picture&gt; </pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>Add a source attribute to the picture element and fill it with values from <code class="userinput">images/name</code> :</p>
            <pre>&lt;picture&gt;
  &lt;xsl:attribute name="source"&gt;
    &lt;xsl:value-of select="images/name" /&gt;
  &lt;/xsl:attribute&gt;
&lt;/picture&gt; </pre>
          </section>
          <section class="sect3">
            <h4>Example 3</h4>
            <p>Create an attribute-set that can be applied to any output element:</p>
            <pre>&lt;xsl:attribute-set name="font"&gt;
  &lt;xsl:attribute name="fname"&gt;Arial&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="size"&gt;14px&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="color"&gt;red&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt; </pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_attribute-set">
          <h3>xsl:attribute-set</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:attribute-set</code> element creates a named set of attributes. The attribute-set can be applied as whole to the output document.</p>
            <aside class="note"><strong>Note.</strong> Must be child of <code class="tag">xsl:stylesheet</code> or <code class="tag">xsl:transform</code>.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:attribute-set
name="name" use-attribute-sets="name-list"&gt;

  &lt;!-- Content:xsl:attribute* --&gt;

&lt;/xsl:attribute-set&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;name&gt; (required)</dt>
                <dd>Specifies the name of the attribute-set</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>use-attribute-sets &lt;name-list&gt; (optional)</dt>
                <dd>A white space separated list of other attribute-sets to use in the attribute-set</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Create an attribute-set that can be applied to any output element:</p>
            <pre>&lt;xsl:attribute-set name="font"&gt;
  &lt;xsl:attribute name="fname"&gt;Arial&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="size"&gt;14px&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="color"&gt;red&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt; </pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_call-template">
          <h3>xsl:call-template</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:call-template</code> element calls a named template.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <para/>
            <pre>&lt;xsl:call-template name="templatename"&gt;

  &lt;!-- Content:xsl:with-param* --&gt;

&lt;/xsl:call-template&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;templatename&gt; (required)</dt>
                <dd>Specifies the name of the template to be called</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Call a template named "description" when the processor finds a car element:</p>
            <pre>&lt;xsl:template match="car"&gt;
  &lt;xsl:call-template name="description"/&gt;
&lt;/xsl:template&gt; </pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_choose">
          <h3>xsl:choose</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:choose</code> element is used in conjunction with <code class="tag">xsl:when</code> and <code class="tag">xsl:otherwise</code> to express multiple conditional tests.</p>
            <p>If no <code class="tag">xsl:when</code> is true, the content of <code class="tag">xsl:otherwise</code> is processed.</p>
            <p>If no <code class="tag">xsl:when</code> is true, and no <code class="tag">xsl:otherwise</code> element is present, nothing is created.</p>
            <tip>For simple conditional testing, use the <code class="tag">xsl:if</code> element instead.</tip>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:choose&gt;

  &lt;!-- Content:(xsl:when+,xsl:otherwise?) --&gt;

&lt;/xsl:choose&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>The code below will add a pink background-color to the artist column WHEN the price of the CD is higher than 10.</p>
            <pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title"/&gt;&lt;/td&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="price &amp;gt; 10"&gt;
            &lt;td bgcolor="#ff00ff"&gt;
            &lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;td&gt;&lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/tr&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>Declare a variable named <var>color</var>. Set its value to the color attribute of the current element. If the current element has no color attribute, the value of <var>color</var> will be <code class="literal">green</code>:</p>
            <pre>&lt;xsl:variable name="color"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@color"&gt;
      &lt;xsl:value-of select="@color"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;green&lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_comment">
          <h3>xsl:comment</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:comment</code> element is used to create a comment node in the result tree.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:comment&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:comment&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <pre>&lt;xsl:comment&gt;This is a comment!&lt;/xsl:comment&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_copy">
          <h3>xsl:copy</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:copy</code> element creates a copy of the current node.</p>
            <aside class="warning"><strong>Warning:</strong> Namespace nodes of the current node are automatically copied as well, but child nodes and attributes of the current node are not automatically copied!</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:copy use-attribute-sets="name-list"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:copy&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>use-attribute-sets &lt;name-list&gt; (optional)</dt>
                <dd>A white space separated list of attribute-sets to apply to the output node, if the node is an element</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Copy the message node to the output document:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="message"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt; </pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_copy-of">
          <h3>xsl:copy-of</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:copy-of</code> element creates a copy of the current node.</p>
            <aside class="note"><strong>Note.</strong> Namespace nodes, child nodes, and attributes of the current node are automatically copied as well!</aside>
            <tip>This element can be used to insert multiple copies of the same node into different places in the output.</tip>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <para/>
            <pre>&lt;xsl:copy-of select="expression"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>select &lt;expression&gt; (required)</dt>
                <dd>Specifies what to be copied</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>The following code...</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:variable name="header"&gt;
  &lt;tr&gt;
  &lt;th&gt;Element&lt;/th&gt;
  &lt;th&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;table&gt;
    &lt;xsl:copy-of select="$header" /&gt;
    &lt;xsl:for-each select="reference/record"&gt;
    &lt;tr&gt;
    &lt;xsl:if test="category='XML'"&gt;
      &lt;td&gt;&lt;xsl:value-of select="element"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="description"/&gt;&lt;/td&gt;
    &lt;/xsl:if&gt;
    &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/table&gt;
  &lt;br /&gt;
  &lt;table&gt;
    &lt;xsl:copy-of select="$header" /&gt;
    &lt;xsl:for-each select="table/record"&gt;
    &lt;tr&gt;
    &lt;xsl:if test="category='XSL'"&gt;
      &lt;td&gt;&lt;xsl:value-of select="element"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="description"/&gt;&lt;/td&gt;
    &lt;/xsl:if&gt;
    &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_decimal-format">
          <h3>xsl:decimal-format</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:decimal-format</code> element defines the characters and symbols to be used when converting numbers into strings, with the <code class="function">format-number()</code> function.</p>
            <p>Not all countries use the same characters for separating the decimal part from the integer part, and for grouping digits. With the <code class="tag">xsl:decimal-format</code> element you can change special characters to other symbols.</p>
            <p>This element is a top level element.</p>
            <p>The <code class="function">format-number()</code> function can refer to the <code class="tag">xsl:decimal-format</code> element by name.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:decimal-format
  name="name"
  decimal-separator="char"
  grouping-separator="char"
  infinity="string"
  minus-sign="char"
  NaN="string"
  percent="char"
  per-mille="char"
  zero-digit="char"
  digit="char"
  pattern-separator="char"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;name&gt; (optional)</dt>
                <dd>Specifies a name for this format</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>decimal-separator &lt;char&gt; (optional)</dt>
                <dd>Specifies the decimal point character. Default is "."</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>grouping-separator &lt;char&gt; (optional)</dt>
                <dd>Specifies the thousands separator character. Default is ","</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>infinity &lt;string&gt; (optional)</dt>
                <dd>Specifies the string used to represent infinity. Default is "Infinity"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>minus-sign &lt;char&gt; (optional)</dt>
                <dd>Specifies the character to represent negative numbers. Default is "-"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>NaN &lt;string&gt; (optional)</dt>
                <dd>Specifies the string used when the value is not a number". Default is "NaN"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>percent &lt;char&gt; (optional)</dt>
                <dd>Specifies the percentage sign character. Default is "%"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>per-mille &lt;char&gt; (optional)</dt>
                <dd>Specifies the per thousand sign character. Default is "&#x2030;"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>zero-digit &lt;char&gt; (optional)</dt>
                <dd>Specifies the digit zero character. Default is "0"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>digit &lt;char&gt; (optional)</dt>
                <dd>Specifies the character used to indicate a place where a digit is required. Default is #</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>pattern-separator &lt;char&gt; (optional)</dt>
                <dd>Specifies the character used to separate positive and negative subpatterns in a format pattern. Default is ";"</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>The example below shows how to format to European currency (note that the third argument in format-number() refers to the name of the <code class="tag">xsl:decimal-format</code> element:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:decimal-format name="euro" decimal-separator="," grouping-separator="."/&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="format-number(26825.8, '#.###,00', 'euro')"/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
            <p>Output:</p>
            <pre>26.825,80</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_element">
          <h3>xsl:element</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:element</code> element is used to create an element node in the output document.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:element
name="name"
namespace="URI"
use-attribute-sets="namelist"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:element&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name 	&lt;name&gt; 	(required)</dt>
                <dd>Specifies the name of the element to be created (the value of the name attribute can be set to an expression that is computed at run-time, like this: <code class="tag">xsl:element name="{$country}"/</code></dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>namespace 	&lt;URI&gt; 	(optional)</dt>
                <dd>Specifies the namespace URI of the element (the value of the namespace attribute can be set to an expression that is computed at run-time, like this: <code class="tag">xsl:element name="{$country}" namespace="{$someuri}"/</code></dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>use-attribute-sets 	&lt;namelist&gt; 	(optional)</dt>
                <dd>A white space separated list of attribute-sets containing attributes to be added to the element</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Create a "singer" element that contains the value of each artist element:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:for-each select="catalog/cd"&gt;
    &lt;xsl:element name="singer"&gt;
      &lt;xsl:value-of select="artist" /&gt;
    &lt;/xsl:element&gt;
    &lt;br /&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_fallback">
          <h3>xsl:fallback</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:fallback</code> element specifies an alternate code to run if  the XSL processor does not support an XSL element.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:fallback&gt;

  &lt;!-- Content: template --&gt;

&lt;/xsl:fallback&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>This example is supposed to loop through each "title" element with a made up <code class="tag">xsl:loop</code> element. If the XSL processor does not support this element (which it does not), it will use the <code class="tag">xsl:for-each</code> element instead:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="catalog/cd"&gt;
  &lt;xsl:loop select="title"&gt;
    &lt;xsl:fallback&gt;
      &lt;xsl:for-each select="title"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:fallback&gt;
  &lt;/xsl:loop&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_for-each">
          <h3>xsl:for-each</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:for-each</code> element loops through each node in a specified node set.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:for-each select="expression"&gt;
  &lt;!-- Content --&gt;
&lt;/xsl:for-each&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>select 	&lt;expression&gt; 	(required)</dt>
                <dd>An XPath expression that specifies which node set to be processed.</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>The example below loops trough each cd element outputs the title for each cd:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;div&gt;
    &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;p&gt;&lt;xsl:value-of select="title" /&gt;&lt;/p&gt;
    &lt;/xsl:for-each&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>The example below loops trough each cd element and creates a table row with the values from title and artist for each cd:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Music Collection:&lt;/h1&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title" /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="artist" /&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_if">
          <h3>xsl:if</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:if</code> element contains a template that will be applied only if a specified condition is true.</p>
            <tip>Use <code class="tag">xsl:choose</code> in conjunction with <code class="tag">xsl:when</code> and <code class="tag">xsl:otherwise</code> to express multiple conditional tests!</tip>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:if
test="expression"&gt;

  &lt;!-- Content: template --&gt;

&lt;/xsl:if&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>test &lt;expression&gt; (required)</dt>
                <dd>Specifies the condition to be tested</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>Select the values of title and artist IF the price of the CD is higher than 10:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;xsl:if test="price &amp;gt; 10"&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;xsl:value-of select="title"/&gt;&lt;/td&gt;
          &lt;td&gt;&lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/xsl:if&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>Display the title of each CD. Insert ", " between each CD-title if it is not the last CD or the last but one. If it is the last CD, add "!" behind the title. If it is the last but one CD, add ", and " behind the title:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;p&gt;Titles:
    &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;xsl:value-of select="title"/&gt;
      &lt;xsl:if test="position()!=last()"&gt;
        &lt;xsl:text&gt;, &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test="position()=last()-1"&gt;
        &lt;xsl:text&gt; and &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test="position()=last()"&gt;
        &lt;xsl:text&gt;!&lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
    &lt;/p&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_import">
          <h3>xsl:import</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:import</code> element is a top-level element that is used to import the contents of one style sheet into another.</p>
            <aside class="note"><strong>Note.</strong> An imported style sheet has lower precedence than the importing style sheet.</aside>
            <aside class="note"><strong>Note.</strong> This element must appear as the first child node of <code class="tag">xsl:stylesheet</code> or <code class="tag">xsl:transform</code>.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <para/>
            <pre>&lt;xsl:import href="URI"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>href &lt;URI&gt; (required)</dt>
                <dd>Specifies the URI of the style sheet to import</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Suppose you have a style sheet called <cite class="filename">cdcatalog_ex3.xsl</cite>:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="catalog/cd/title"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="catalog/cd/artist"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
            <p>A second style sheet called <cite class="filename">cdcatalog_import.xsl</cite> imports <cite class="filename">cdcatalog_ex3.xsl</cite>:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="cdcatalog_ex3.xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-imports/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt; </pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_include">
          <h3>xsl:include</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:include</code> element is a top-level element that includes the contents of one style sheet into another.</p>
            <aside class="note"><strong>Note.</strong> An included style sheet has the same precedence as the including style sheet.</aside>
            <aside class="note"><strong>Note.</strong> This element must appear as a child node of <code class="tag">xsl:stylesheet</code> or <code class="tag">xsl:transform</code>.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:include href="URI"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>href &lt;URI&gt; (required)</dt>
                <dd>Specifies the URI of the style sheet to import</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <para/>
            <pre></pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_key">
          <h3>xsl:key</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:key</code> element is a top-level element which declares a named key that can be used in the style sheet with the <code class="function">key()</code> function.</p>
            <aside class="note"><strong>Note.</strong> A key does not have to be unique!</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:key
name="name"
match="pattern"
use="expression"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name 	&lt;name&gt; (required)</dt>
                <dd>Specifies the name of the key</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>match &lt;pattern&gt; (required)</dt>
                <dd>Defines the nodes to which the key will be applied</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>use &lt;expression&gt; (required)</dt>
                <dd>The value of the key for each of the nodes</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Suppose you have an XML file called <cite class="filename">persons.xml</cite>:</p>
            <pre>&lt;persons&gt;
  &lt;person name="Tarzan" id="050676"/&gt;
  &lt;person name="Donald" id="070754"/&gt;
  &lt;person name="Dolly" id="231256"/&gt;
&lt;/persons&gt;</pre>
            <p>You can define a key in an XSL file like this:</p>
            <pre>&lt;xsl:key name="preg" match="person" use="@id"/&gt;</pre>
            <p>To find the person with id="050676", write (in the XSL file):</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:key name="preg" match="person" use="@id"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;xsl:for-each select="key('preg','050676')"&gt;
    &lt;p&gt;
    Id: &lt;xsl:value-of select="@id"/&gt;&lt;br /&gt;
    Name: &lt;xsl:value-of select="@name"/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_message">
          <h3>xsl:message</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:message</code> element writes a message to the output. This element is primarily used to report errors.</p>
            <p>This element can contain almost any other XSL element (<code class="tag">xsl:text</code>, <code class="tag">xsl:value-of</code>, etc.).</p>
            <p>The <var>terminate</var> attribute gives you the choice to either quit or continue the processing when an error occurs.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:message terminate="yes|no"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:message&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>terminate yes/no (optiona)</dt>
                <dd>"yes" terminates the processing after the message is written to the output. "no" continues the processing after the message is written to the output. Default is "no".</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Check if artist is an empty string. If yes, we quit the XSL processor and display a message:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;xsl:for-each select="catalog/cd"&gt;
    &lt;p&gt;Title: &lt;xsl:value-of select="title"/&gt;&lt;br /&gt;
    Artist:
    &lt;xsl:if test="artist=''"&gt;
      &lt;xsl:message terminate="yes"&gt;
        Error: Artist is an empty string!
      &lt;/xsl:message&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="artist"/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_namespace-alias">
          <h3>xsl:namespace-alias</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:namespace-alias</code> element is used to replace a namespace in the style sheet to a different namespace in the output.</p>
            <aside class="note"><strong>Note.</strong> <code class="tag">xsl:namespace-alias</code> is a top-level element, and must be a child node of <code class="tag">xsl:stylesheet</code> or <code class="tag">xsl:transform</code>.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:namespace-alias
                stylesheet-prefix="prefix|#default"
                result-prefix="prefix|#default"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>stylesheet-prefix prefix/#default (required)</dt>
                <dd>Specifies the namespace you wish to change</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>result-prefix prefix#default (required)</dt>
                <dd>Specifies the desired namespace for the output</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>The wxsl prefix is converted to the xsl prefix in the output:</p>
            <pre>&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:wxsl="https://www.w3schools.com/w3style.xsl"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="wxsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;wxsl:stylesheet&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/wxsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_number">
          <h3>xsl:number</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:number</code> element is used to determine the integer position of the current node in the source. It is also used to format a number.</p>
            <pre>&lt;xsl:number
count="expression"
level="single|multiple|any"
from="expression"
value="expression"
format="formatstring"
lang="languagecode"
letter-value="alphabetic|traditional"
grouping-separator="character"
grouping-size="number"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <para/>
            <pre></pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>count &lt;expression&gt; 	(optional)</dt>
                <dd>An XPath expression that specifies what nodes are to be counted</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>level single/multiple/any (optional)</dt>
                <dd>Controls how the sequence number is assigned. Can be one of the following: single (default) multiple, any (not supported by Netscape 6)</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>from 	&lt;expression&gt;	(optional)</dt>
                <dd>An XPath expression that specifies where the counting will start</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>value &lt;expression&gt; (optional)</dt>
                <dd>Specifies a user-provided number that is used in place of a sequence generated number</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>format formatstring (optional)</dt>
                <dd>
                  <p>Defines the output format for the number. Can be one of the following:</p>
                  <ul>
                    <li>format="1" results in 1 2 3 . .</li>
                    <li>format="01" results in 01 02 03 (not supported by Netscape 6)</li>
                    <li>format="a" results in a b c . . (not supported by Netscape 6)</li>
                    <li>format="A" results in A B C. . (not supported by Netscape 6)</li>
                    <li>format="i" results in i ii iii iv . . (not supported by Netscape 6)</li>
                    <li>format="I" results in I II III IV . . (not supported by Netscape 6)</li>
                  </ul>
                </dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>lang	languagecode	(optional)</dt>
                <dd>Specifies the language alphabet to be used for the numbering (Not supported by Netscape 6)</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>letter-value 	alphabetic/traditional 	(optional)</dt>
                <dd>Specifies whether the numbering in the selected language is alphabetic or traditional. The default is alphabetic</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>grouping-separator character (optional)</dt>
                <dd>Specifies what character should be used to separate groups of digits. The default is the comma</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>grouping-size	number (optional)</dt>
                <dd>Specifies how many digits are in the groups that are being separated by the character specified in the grouping-separator attribute. The default is 3</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <pre>&lt;xsl:number value="250000" grouping-separator="."/&gt;</pre>
            <p>Output:</p>
            <pre>250.000</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <pre>&lt;xsl:number value="250000" grouping-size="2"/&gt;</pre>
            <p>Output:</p>
            <pre>25,00,00</pre>
          </section>
          <section class="sect3">
            <h4>Example 3</h4>
            <para/>
            <pre>&lt;xsl:number value="12" grouping-size="1"
                grouping-separator="#" format="I"/&gt;</pre>
            <p>Output:</p>
            <pre>X#I#I</pre>
          </section>
          <section class="sect3">
            <h4>Example 4</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;p&gt;
  &lt;xsl:for-each select="catalog/cd"&gt;
    &lt;xsl:number value="position()" format="1" /&gt;
    &lt;xsl:value-of select="title" /&gt;&lt;br /&gt;
  &lt;/xsl:for-each&gt;
  &lt;/p&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_otherwise">
          <h3>xsl:otherwise</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:otherwise</code> element specifies a default action for the <code class="tag">xsl:choose</code> element. This action will take place when none of the <code class="tag">xsl:when</code> conditions apply.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:otherwise&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:otherwise&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>The code below will add a pink background-color to the artist column WHEN the price of the cd is higher than 10, OTHERWISE it will just print the name of the artist:</p>
            <pre> &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title"/&gt;&lt;/td&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="price&amp;gt;'10'"&gt;
            &lt;td bgcolor="#ff00ff"&gt;
            &lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;td&gt;&lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/tr&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>Declare a variable named <var>color</var>. Set its value to the color attribute of the current element. If the current element has no color attribute, the value of <var>color</var> will be <code class="literal">green</code>:</p>
            <pre>&lt;xsl:variable name="color"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@color"&gt;
      &lt;xsl:value-of select="@color"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;green&lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_output">
          <h3>xsl:output</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:output</code> element defines the format of the output document.</p>
            <aside class="note"><strong>Note.</strong> <code class="tag">xsl:output</code> is a top-level element, and must appear as a child node of <code class="tag">xsl:stylesheet</code> or <code class="tag">xsl:transform</code>.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:output
method="xml|html|text|name"
version="string"
encoding="string"
omit-xml-declaration="yes|no"
standalone="yes|no"
doctype-public="string"
doctype-system="string"
cdata-section-elements="namelist"
indent="yes|no"
media-type="string"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>method 	xml/html/text/name 	(optional)</dt>
                <dd>Defines the output format. The default is XML (but if the first child of the root node is <code class="tag">html</code> and there are no preceding text nodes, then the default is HTML) Netscape 6 only supports "html" and "xml"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>version	string (optional)</dt>
                <dd>Sets the W3C version number for the output format (only used with method="html" or method="xml")</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>encoding 	&lt;string&gt; (optional)</dt>
                <dd>Sets the value of the encoding attribute in the output</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>omit-xml-declaration yes/no (optional)</dt>
                <dd>"yes" specifies that the XML declaration (&lt;?xml...?&gt;) should be omitted in the output. "no" specifies that the XML declaration should be included in the output. The default is "no"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>standalone 	yes/no 	(optional)</dt>
                <dd>"yes" specifies that a standalone declaration should occur in the output. "no" specifies that a standalone declaration should not occur in the output. The default is "no" (This attribute is not supported by Netscape 6)</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>doctype-public &lt;string&gt; (optional)</dt>
                <dd>Sets the value of the PUBLIC attribute of the DOCTYPE declaration in the output</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>doctype-system &lt;string&gt; (optional)</dt>
                <dd>Sets the value of the SYSTEM attribute of the DOCTYPE declaration in the output</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>cdata-section-elements &lt;namelist&gt; (optional)</dt>
                <dd>A white-space separated list of elements whose text contents should be written as CDATA sections</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>indent yes/no (optional)</dt>
                <dd>"yes" indicates that the output should be indented according to its hierarchic structure. "no" indicates that the output should not be indented according to its hierarchic structure. This attribute is not supported by Netscape 6</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>media-type &lt;string&gt; (optional)</dt>
                <dd>Defines the MIME type of the output. The default is "text/xml" This attribute is not supported by Netscape 6</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>The output in this example will be an XML document, version 1.0. The character encoding is set to "UTF-8" and the output will be indented for readability:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="xml" version="1.0"
encoding="UTF-8" indent="yes"/&gt;

...

...

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>The output in this example will be an HTML document, version 4.0. The character encoding is set to "UTF-8" and the output will be indented for readability:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="4.0"
encoding="UTF-8" indent="yes"/&gt;

...

...

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_param">
          <h3>xsl:param</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:param</code> element is used to declare a local or global parameter.</p>
            <aside class="note"><strong>Note.</strong> The parameter is global if it's declared as a top-level element, and local if it's declared within a template.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:param
name="name"
select="expression"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:param&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;name&gt; (required)</dt>
                <dd>Specifies the name of the parameter</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>select &lt;expression&gt; (optional)</dt>
                <dd>Specifies an XPath expression that specifies a default value for the parameter</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;xsl:for-each select="catalog/cd"&gt;
    &lt;xsl:call-template name="show_title"&gt;
      &lt;xsl:with-param name="title" select = "title" /&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:for-each&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name = "show_title" &gt;
  &lt;xsl:param name = "title" /&gt;
  &lt;p&gt;Title: &lt;xsl:value-of select = "$title" /&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_processing-instruction">
          <h3>xsl:processing-instruction</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:processing-instruction</code> element writes a processing instruction to the output.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:processing-instruction
name="process-name"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:processing-instruction&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;process-name&gt; (required)</dt>
                <dd>Specifies the name of the processing instruction</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>This code:</p>
            <pre>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;
href="style.css" type="text/css"
&lt;/xsl:processing-instruction&gt;</pre>
            <p>Creates this tag:</p>
            <pre>&lt;?xml-stylesheet href="style.css" type="text/css"?&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_sort">
          <h3>xsl:sort</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:sort</code> element is used to sort the output.</p>
            <aside class="note"><strong>Note.</strong> <code class="tag">xsl:sort</code> is always within <code class="tag">xsl:for-each</code> or <code class="tag">xsl:apply-templates</code>.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:sort select="expression"
lang="language-code"
data-type="text|number|qname"
order="ascending|descending"
case-order="upper-first|lower-first"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>select &lt;XPath-expression&gt; (optional)</dt>
                <dd>Specifies which node/node-set to sort on</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>lang &lt;language-code&gt; (optional)</dt>
                <dd>Specifies which language is to be used by the sort</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>data-type "text/number/qname" (optional)</dt>
                <dd>Specifies the data-type of the data to be sorted. Default is "text</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>order "ascending/descending" (optional)</dt>
                <dd>Specifies the sort order. Default is "ascending"</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>case-order "upper-first/lower-first" (optional)</dt>
                <dd>Specifies whether upper- or lowercase letters are to be ordered first</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>The example below will sort the output by artist:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;h2&gt;My CD Collection&lt;/h2&gt;
  &lt;table border="1"&gt;
    &lt;tr bgcolor="#9acd32"&gt;
      &lt;th&gt;Title&lt;/th&gt;
      &lt;th&gt;Artist&lt;/th&gt;
    &lt;/tr&gt;
    &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;xsl:sort select="artist"/&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_stylesheet_and_transform_elements">
          <h3>xsl:stylesheet and xsl transform Elements</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:stylesheet</code> and <code class="tag">xsl:transform</code> elements are completely synonymous elements. Both are used to define the root element of the style sheet.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>
&lt;xsl:stylesheet
id="name"
version="version"
extension-element-prefixes="list"
exclude-result-prefixes="list"&gt;

  &lt;!-- Content:(&lt;xsl:import&gt;*,top-level-elements) --&gt;

&lt;/xsl:stylesheet&gt;

&lt;xsl:transform
id="name"
version="version"
extension-element-prefixes="list"
exclude-result-prefixes="list"&gt;

  &lt;!-- Content:(&lt;xsl:import&gt;*,top-level-elements) --&gt;

&lt;/xsl:transform&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>version &lt;version&gt; (required)</dt>
                <dd>Specifies the XSLT version of the style sheet</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>extension-element-prefixes &lt;list&gt; (optional)</dt>
                <dd>A white space separated list of namespace prefixes used for extension elements. This attribute is not supported by Netscape 6</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>exclude-result-prefixes &lt;list&gt; (optional)</dt>
                <dd>A white space separated list of namespace prefixes that should not be sent to the output</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>id &lt;name&gt; (optional)</dt>
                <dd>A unique id for the style sheet. This attribute is not supported by Netscape 6</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

....

....

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;xsl:transform version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

....

....

&lt;/xsl:transform&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_template">
          <h3>xsl:template</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:template&gt;</code> element contains rules to apply when a specified node is matched. The match attribute is used to associate the template with an XML element. The match attribute can also be used to define a template for a whole branch of the XML document (i.e. match="/" defines the whole document).</p>
            <aside class="note"><strong>Note.</strong> <code class="tag">xsl:template</code> is a top-level element.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:template
name="name"
match="pattern"
mode="mode"
priority="number"&gt;

  &lt;!-- Content:(&lt;xsl:param&gt;*,template) --&gt;

&lt;/xsl:template&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;name&gt; (optional)</dt>
                <dd>
                  <p>Specifies a name for the template.</p>
                  <aside class="note"><strong>Note.</strong> If this attribute is omitted there must be a match attribute</aside>
                </dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>match &lt;pattern&gt; (optional)</dt>
                <dd>
                  <p>The match pattern for the template.</p>
                  <aside class="note"><strong>Note.</strong> If this attribute is omitted there must be a name attribute</aside>
                </dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>mode &lt;mode&gt; (optional)</dt>
                <dd>Specifies a mode for this template</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>priority &lt;number&gt; (optional)</dt>
                <dd>A number which indicates the numeric priority of the template</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;h2&gt;My CD Collection&lt;/h2&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="cd"&gt;
  &lt;p&gt;
  &lt;xsl:apply-templates select="title"/&gt;
  &lt;xsl:apply-templates select="artist"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="title"&gt;
  Title: &lt;span style="color:#ff0000"&gt;
  &lt;xsl:value-of select="."/&gt;&lt;/span&gt;
  &lt;br /&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="artist"&gt;
  Artist: &lt;span style="color:#00ff00"&gt;
  &lt;xsl:value-of select="."/&gt;&lt;/span&gt;
  &lt;br /&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_text">
          <h3>xsl:text</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:text</code> element is used to write literal text to the output.</p>
            <aside class="note"><strong>Note.</strong> This element may contain literal text, entity references, and #PCDATA.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:text
disable-output-escaping="yes|no"&gt;

  &lt;!-- Content:#PCDATA --&gt;

&lt;/xsl:text&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>disable-output-escaping yes/no (optional)</dt>
                <dd>"yes" indicates that special characters (like "&lt;") should be output as is. "no" indicates that special characters (like "&lt;") should be output as "&amp;lt;". Default is "no". This attribute is not supported by Netscape 6</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>Displays the title of each CD. Inserts a ", " between each cd-title if it is not the last CD - or the last but one. If it is the last CD, it will add a "!" behind the title. If it is the last but one, add a ", and " behind the title:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;p&gt;Titles:
    &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;xsl:value-of select="title"/&gt;
      &lt;xsl:if test="position() &lt; last()-1"&gt;
        &lt;xsl:text&gt;, &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test="position()=last()-1"&gt;
        &lt;xsl:text&gt;, and &lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:if test="position()=last()"&gt;
        &lt;xsl:text&gt;!&lt;/xsl:text&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
    &lt;/p&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_preserve-space">
          <h3>xsl:preserve-space</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:preserve-space</code> element is used to define the elements for which white space should be preserved.</p>
            <aside class="note"><strong>Note.</strong> Preserving white space is the default setting, so using the <code class="tag">xsl:preserve-space</code> element is only necessary if the <code class="tag">xsl:strip-space</code> element is used.</aside>
            <aside class="note"><strong>Note.</strong> Note: The <code class="tag">xsl:preserve-space</code> element and the <code class="tag">xsl:strip-space</code> element are top-level elements.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:preserve-space elements="list-of-element-names"/&gt;
&lt;xsl:strip-space elements="list-of-element-names"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>elements</dt>
                <dd>
                  <p>Required. A white space separated list of element names for which white space should be preserved/removed.</p>
                  <aside class="note"><strong>Note.</strong> The list can also contain "*" and "prefix:*" so that all elements or all elements from a particular namespace can be joined</aside>
                </dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>In the example below we preserve white space nodes for title and artist elements, and remove white space nodes for country, company, price, and year elements:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:strip-space elements="country company price year" /&gt;
&lt;xsl:preserve-space elements="title artist" /&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;xsl:for-each select="catalog/cd"&gt;
    &lt;p&gt;
    &lt;xsl:value-of select="title" /&gt;&lt;br /&gt;
    &lt;xsl:value-of select="artist" /&gt;&lt;br /&gt;
    &lt;xsl:value-of select="country" /&gt;&lt;br /&gt;
    &lt;xsl:value-of select="company" /&gt;&lt;br /&gt;
    &lt;xsl:value-of select="price" /&gt;&lt;br /&gt;
    &lt;xsl:value-of select="year" /&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_strip-space">
          <h3>xsl:strip-space</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:strip-space</code> element is used to define the elements for which white space should be removed.</p>
            <aside class="note"><strong>Note.</strong> Preserving white space is the default setting, so using the <code class="tag">xsl:preserve-space</code> element is only necessary if  the <code class="tag">xsl:strip-space</code> element is used.</aside>
            <aside class="note"><strong>Note.</strong> The <code class="tag">xsl:preserve-space</code> element and the <code class="tag">xsl:strip-space</code> element are top-level elements.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:preserve-space elements="list-of-element-names"/&gt;</pre>
            <pre>&lt;xsl:strip-space elements="list-of-element-names"/&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>elements 	&lt;list-of-element-names&gt; (required)</dt>
                <dd>
                  <p>A white space separated list of element names for which white space should be preserved/removed.</p>
                  <aside class="note"><strong>Note.</strong> The list can also contain "*" and "&lt;prefix&gt;:*" so that all elements or all elements from a particular namespace can be joined.</aside>
                </dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <p>In the example below we preserve white space nodes for title and artist elements, and remove white space nodes for country, company, price, and year elements:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
              &lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

                &lt;xsl:strip-space elements="country company price year" /&gt;
                &lt;xsl:preserve-space elements="title artist" /&gt;

                &lt;xsl:template match="/"&gt;
                  &lt;html&gt;
                  &lt;body&gt;
                  &lt;xsl:for-each select="catalog/cd"&gt;
                    &lt;p&gt;
                      &lt;xsl:value-of select="title" /&gt;&lt;br /&gt;
                      &lt;xsl:value-of select="artist" /&gt;&lt;br /&gt;
                      &lt;xsl:value-of select="country" /&gt;&lt;br /&gt;
                      &lt;xsl:value-of select="company" /&gt;&lt;br /&gt;
                      &lt;xsl:value-of select="price" /&gt;&lt;br /&gt;
                      &lt;xsl:value-of select="year" /&gt;
                    &lt;/p&gt;
                  &lt;/xsl:for-each&gt;
                &lt;/body&gt;
              &lt;/html&gt;
            &lt;/xsl:template&gt;

            &lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_value-of">
          <h3>xsl:value-of</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:value-of</code> element extracts the value of a selected node. The <code class="tag">xsl:value-of</code> element can be used to select the value of an XML element and add it to the output.</p>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:value-of select="expression" disable-output-escaping="yes|no" /&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>select &lt;expression&gt; (required)</dt>
                <dd>An XPath expression that specifies which node/attribute to extract the value from. It works like navigating a file system where a forward slash (/) selects subdirectories.</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>disable-output-escaping yes/no (optional)</dt>
                <dd>"yes" indicates that special characters (like "&lt;") should be output as is. "no" indicates that special characters (like "&lt;") should be output as "&amp;lt;". Default is "no".</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>The example below puts the values from the first title and artist elements and puts it in a table:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Music Collection:&lt;/h1&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="catalog/cd/title" /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="catalog/cd/artist" /&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>The example below loops trough each cd element and creates a table row with the values from title and artist for each cd element:</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Music Collection:&lt;/h1&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title" /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="artist" /&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_variable">
          <h3>xsl:variable</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:variable</code> element is used to declare a local or global variable.</p>
            <aside class="note"><strong>Note.</strong> The variable is global if it's declared as a top-level element, and local if it's declared within a template.</aside>
            <aside class="note"><strong>Note.</strong> Once you have set a variable's value, you cannot change or modify that value!</aside>
            <tip>You can add a value to a variable by the content of the <code class="tag">xsl:variable</code> element OR by the select attribute!</tip>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:variable
name="name"
select="expression"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:variable&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;name&gt; (required)</dt>
                <dd>Specifies the name of the variable</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>select &lt;expression&gt; (optional)</dt>
                <dd>Defines the value of the variable</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>If the select attribute is present, the <code class="tag">xsl:variable</code> element cannot contain any content. If the select attribute contains a literal string, the string must be within quotes. The following two examples assign the value "red" to the variable "color":</p>
            <pre>&lt;xsl:variable name="color" select="'red'" /&gt;

&lt;xsl:variable name="color" select='"red"' /&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>If the <code class="tag">xsl:variable</code> element only contains a name attribute, and there is no content, then the value of the variable is an empty string:</p>
            <pre>&lt;xsl:variable name="j" /&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 3</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:variable name="header"&gt;
  &lt;tr bgcolor="#9acd32"&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Artist&lt;/th&gt;
  &lt;/tr&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;table border="1"&gt;
    &lt;xsl:copy-of select="$header" /&gt;
    &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title"/&gt;&lt;/td&gt;
        &lt;td&gt;&lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_when">
          <h3>xsl:when</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:when</code> element is used to specify an action for the <code class="tag">xsl:choose</code> element. The <code class="tag">xsl:when</code> element evaluates an expression, and if it returns true, an action is performed.</p>
            <aside class="note"><strong>Note.</strong> The <code class="tag">xsl:when</code> element is used in conjunction with <code class="tag">xsl:choose</code> and <code class="tag">xsl:otherwise</code> to express multiple conditional tests.</aside>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:when
test="boolean-expression"&gt;

  &lt;!-- Content: template --&gt;

&lt;/xsl:when&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>test &lt;boolean-expression&gt; (required)</dt>
                <dd>Specifies a Boolean expression to be tested</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example 1</h4>
            <p>The code below will add a pink background-color to the artist column WHEN the price of the cd is higher than 10.</p>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
    &lt;h2&gt;My CD Collection&lt;/h2&gt;
    &lt;table border="1"&gt;
      &lt;tr bgcolor="#9acd32"&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Artist&lt;/th&gt;
      &lt;/tr&gt;
      &lt;xsl:for-each select="catalog/cd"&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;xsl:value-of select="title"/&gt;&lt;/td&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test="price&amp;gt;'10'"&gt;
            &lt;td bgcolor="#ff00ff"&gt;
            &lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
          &lt;/xsl:when&gt;
          &lt;xsl:otherwise&gt;
            &lt;td&gt;&lt;xsl:value-of select="artist"/&gt;&lt;/td&gt;
          &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
      &lt;/tr&gt;
      &lt;/xsl:for-each&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Example 2</h4>
            <p>Declare a variable named "color". Set its value to the color attribute of the current element. If the current element has no color attribute, the value of "color" will be "green":</p>
            <pre>&lt;xsl:variable name="color"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@color"&gt;
      &lt;xsl:value-of select="@color"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;green&lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:variable&gt;</pre>
          </section>
        </section>
        <section class="sect2" id="xslt10_with-param">
          <h3>xsl:with-param</h3>
          <section class="sect3">
            <h4>Definition and Usage</h4>
            <p>The <code class="tag">xsl:with-param</code> element defines the value of a parameter to be passed into a template.</p>
            <aside class="note"><strong>Note.</strong> The value of the name attribute of <code class="tag">xsl:with-param</code> must match a name in an <code class="tag">xsl:param</code> element (the <code class="tag">xsl:with-param</code> element is ignored if there is no match).</aside>
            <aside class="note"><strong>Note.</strong> The <code class="tag">xsl:with-param</code> element is allowed within <code class="tag">xsl:apply-templates</code> and <code class="tag">xsl:call-template</code>.</aside>
            <tip>You can add a value to the parameter by the content of the <code class="tag">xsl:with-param</code> element OR by the select attribute!</tip>
          </section>
          <section class="sect3">
            <h4>Syntax</h4>
            <pre>&lt;xsl:with-param
name="name"
select="expression"&gt;

  &lt;!-- Content:template --&gt;

&lt;/xsl:with-param&gt;</pre>
          </section>
          <section class="sect3">
            <h4>Attributes</h4>
            <dl>
              <!-- <varlistentry> -->
                <dt>name &lt;name&gt; (required)</dt>
                <dd>Specifies the name of the parameter</dd>
              <!-- </varlistentry> -->
              <!-- <varlistentry> -->
                <dt>select &lt;expression&gt; (optional)</dt>
                <dd>An XPath expression that defines the value of the parameter</dd>
              <!-- </varlistentry> -->
            </dl>
          </section>
          <section class="sect3">
            <h4>Example</h4>
            <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;xsl:for-each select="catalog/cd"&gt;
    &lt;xsl:call-template name="show_title"&gt;
      &lt;xsl:with-param name="title" select = "title" /&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:for-each&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name = "show_title" &gt;
  &lt;xsl:param name = "title" /&gt;
  &lt;p&gt;Title: &lt;xsl:value-of select = "$title" /&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
      </section>
      <!-- end of "XSLT Elements (www.w3schools.com) -->
      <section>
        <h2>Templates</h2>
        <p>An XSLT stylesheet is comprised of a number of <dfn>templates</dfn> that define a particular part of the process. Templates are defined with xsl:template elements, each of which holds a sequence of XSLT instructions that are carried out when the template is used. The two ways of using templates are by calling them and by applying them. If an xsl:template element has a name attribute, it defines a named template, and you can use it by calling it with xsl:call&#x2013;template. If an xsl:template element has a match attribute, it defines a matching template, and you can apply it by applying templates to a node that it matches using xsl:apply&#x2013;templates.</p>
        <p>The syntax of the <code class="userinput">xsl:template</code> element is:</p>
        <pre>&lt;xsl:template
   name = <code class="classname">Qname</code>
   match = <code class="classname">Pattern</code>
   priority = <code class="classname">number</code>
   mode = <code class="classname">QName</code> &gt;
&gt;&gt;</pre>
        <p>where the meaning of the attributes are:</p>
        <dl>
          <!-- <varlistentry> -->
            <dt>name</dt>
            <dd>Name of the element on which template is to be applied. This allows calling (running) the template by name</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt>match</dt>
            <dd>Pattern which signifies the element(s) on which template is to be applied.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt>priority</dt>
            <dd>Priority number of a template. Matching template with low priority is not considered in from in front of high priority template.</dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt>mode</dt>
            <dd>Allows element to be processed multiple times to produce a different result each time.</dd>
          <!-- </varlistentry> -->
        </dl>
        <section>
          <h3>Built&#x2212;in templates</h3>
          <p>Several built&#x2212;in templates are designed to assist you by providing default processing for different kinds of nodes. These templates have the following effects:</p>
          <ul>
            <li>The content of the root node is processed.</li>
            <li>Elements are ignored, but their contents are processed.</li>
            <li>Any text in the source is copied to the result.</li>
            <li>All other nodes are ignored.</li>
          </ul>
          <p>When the processor starts processing the stylesheet, it begins by taking the root node of the source node tree and trying to find a template to apply to it. If you create an XSLT stylesheet without any templates in it, the processor processes the content of the root node, which includes the document element. Then, it processes the content of the document element, which may include other elements, and so on, recursively down the node tree. When it encounters a text node, it outputs that text node. The effect of this is that if you have a stylesheet that doesn't contain any templates then you will get all the text in the source XML as output.</p>
          <p>These are the built-in templates:</p>
          <section>
            <h4>Built-in template rule for element and document nodes</h4>
            <p>This template processes the document node and any of its children. This processing ensures that recursive processing will continue, even if no template is declared for a given element:</p>
            <pre>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
          </section>
          <section>
            <h4>Built-in template rule for modes</h4>
            <p>This template ensures that element and document nodes are processed, regardless of any mode that might be in effect.</p>
            <pre>&lt;xsl:template match="*|/" mode="x"&gt;
  &lt;xsl:apply-templates mode="x"/&gt;
&lt;/xsl:template&gt;</pre>
          </section>
          <section>
            <h4>Built-in template rule for text and attribute nodes</h4>
            <p>This template copies the text of all text and attribute nodes to the output tree. Be aware that you have to actually select the text and attribute nodes for this rule to be invoked:</p>
            <pre>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</pre>
          </section>
          <section>
            <h4>Built-in template rule for comment and processing instruction nodes</h4>
            <p>This template does nothing:</p>
            <pre>&lt;xsl:template match="comment()|processing-instruction()"/&gt;</pre>
          </section>
          <section>
            <h4>Built-in template rule for namespace nodes</h4>
            <p>This template also does nothing:</p>
            <pre>&lt;xsl:template match="namespace()"/&gt;</pre>
          </section>
        </section>
        <section id="xslt_copying_and_transforming">
          <h3>Copying and Transforming</h3>
          <p>In general you can start with a default copy template:</p>
          <pre>&lt;xsl:template match="node() | @*"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="node() | @*"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre>
          <p>or</p>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml"/&gt;
&lt;!-- Copy all elements, attributes, and text nodes --&gt;
&lt;xsl:template match="*|@*|text()|comment()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="*|@*|text()|comment()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
          <p>and then add your specific processing rules, which might either erase some nodes, or rename or restructure some nodes, or something else.</p>
          <section>
            <h4>&lt;value-of select="..."&gt;</h4>
          </section>
          <section>
            <h4>&lt;copy select="..."&gt;</h4>
          </section>
          <section>
            <h4>&lt;copy-of select="..."&gt;</h4>
            <p>The xsl:copy-of element creates a copy of the current node. Namespace nodes, child nodes, and attributes of the current node are automatically copied as well! This element can be used to insert multiple copies of the same node into different places in the output. Its select is required and specifies what to be copied</p>
            <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:variable name="header"&gt;
  &lt;tr&gt;
  &lt;th&gt;Element&lt;/th&gt;
  &lt;th&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
  &lt;body&gt;
  &lt;table&gt;
    &lt;xsl:copy-of select="$header" /&gt;
    &lt;xsl:for-each select="reference/record"&gt;
    &lt;tr&gt;
    &lt;xsl:if test="category='XML'"&gt;
      &lt;td&gt;&lt;xsl:value-of select="element"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="description"/&gt;&lt;/td&gt;
    &lt;/xsl:if&gt;
    &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/table&gt;
  &lt;br /&gt;
  &lt;table&gt;
    &lt;xsl:copy-of select="$header" /&gt;
    &lt;xsl:for-each select="table/record"&gt;
    &lt;tr&gt;
    &lt;xsl:if test="category='XSL'"&gt;
      &lt;td&gt;&lt;xsl:value-of select="element"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="description"/&gt;&lt;/td&gt;
    &lt;/xsl:if&gt;
    &lt;/tr&gt;
    &lt;/xsl:for-each&gt;
  &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt; </pre>
          </section>
          <section>
            <h4>xsl:copy vs. xsl:copy-of</h4>
            <p>The xsl:copy instruction copies the context item but none of its children nodes. It cannot have a @select XPath. A very common use of xsl:copy can be found in the identity transformation:</p>
            <pre id="xslt_copy_identity_tx">&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre>
            <p>Notice that here the node itself is copied via xsl:copy and the children nodes are then transformed via xsl:apply-templates, giving other templates a chance to intervene in the transformation.</p>
            <p>The xsl:copy-of instruction evaluates the XPath in its required @select attribute and copies the selected nodes and their children nodes, recursively. This is a deep copy. The xsl:copy-of instruction must have a @select XPath. Notice that xsl:copy-of could have been used in the <a href="#xslt_copy_identity_tx">identity transformation</a>, however the flexibility afforded by allowing other templates the chance to match during the recursion would have been lost.</p>
            <ul>
              <li>Use xsl:copy when you want to copy just the context item and have other plans for the children of the context item.</li>
              <li>Use xsl:copy-of when you want to copy XPath-selected nodes and their children, recursively.</li>
            </ul>
            <p>In short, xsl:copy makes a <em>shallow</em> copy, whereas xsl:copy-of makes a <em>deep</em> copy.</p>
          </section>
        </section>
        <section>
          <h3>Named Templates</h3>
          <p>These have a <code class="userinput">name</code> attribute, so that they may be called by call-template with matching name parameter.</p>
        </section>
        <section>
          <h3>The <code class="userinput">mode</code> Attribute</h3>
          <p>Sometimes the same input content needs to appear multiple times in the output document, formatted according to a different template each time. For instance, the titles of the chapters in a book would be formatted one way in the chapters themselves and a different way in the table of contents. Both <code class="userinput">xsl:apply-templates</code> and <code class="userinput">xsl:template</code> elements can have optional <code class="userinput">mode</code> attributes that connect different template rules to different uses. A <code class="userinput">mode</code> attribute on <code class="userinput">xsl:template</code> element identifies in which mode that template rule should be activated. An <code class="userinput">xsl:apply-templates</code> element with a <code class="userinput">mode</code> attribute only activates template rules with matching mode attributes.</p>
          <p>The example below demonstrates with a stylesheet that begins the output document with a list of people's names. This is accomplished in the <code class="userinput">toc</code> mode. Then a separate template rule, as well as a separate <code class="userinput">xsl:apply-templates</code> element in the default mode (really no mode at all), output the complete contents of all person elements.</p>
          <pre>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:template match="people"&gt;
    &lt;html&gt;
      &lt;head&gt;&lt;title&gt;Famous Scientists&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;ul&gt;&lt;xsl:apply-templates select="person" mode="toc"/&gt;&lt;/ul&gt;
        &lt;xsl:apply-templates select="person"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Table of Contents Mode Templates --&gt;
  &lt;xsl:template match="person" mode="toc"&gt;
    &lt;xsl:apply-templates select="name" mode="toc"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="name" mode="toc"&gt;
    &lt;li&gt;&lt;xsl:value-of select="last_name"/&gt;,
    &lt;xsl:value-of select="first_name"/&gt;&lt;/li&gt;
  &lt;/xsl:template&gt;

  &lt;!-- Normal Mode Templates --&gt;
  &lt;xsl:template match="person"&gt;
    &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          <p>Both <code class="userinput">xsl:template</code> and <code class="userinput">xsl:apply-templates</code> have an optional <code class="userinput">mode</code> attribute. If <code class="userinput">xsl:template</code> does not have a <code class="userinput">match</code> attribute, it must not have a <code class="userinput">mode</code> attribute. If an <code class="userinput">xsl:apply-templates</code> element has a <code class="userinput">mode</code> attribute, then it applies only to those template rules from <code class="userinput">xsl:template</code> elements that have a <code class="userinput">mode</code> attribute with the same value; if an <code class="userinput">xsl:apply-templates</code> element does <em>not</em> have a <code class="userinput">mode</code> attribute, then it applies only to those template rules from <code class="userinput">xsl:template</code> elements that do not have a <code class="userinput">mode</code> attribute.</p>
        </section>
        <section>
          <h3>Template priority</h3>
          <p>When a processor is told to apply templates to a node set, it goes through the nodes one by one and tries to find a matching template that matches each node. When it finds one, it uses that template to process the node. There might be more than one template that matches the node. Templates with a higher import priority override templates that are imported.</p>
          <p>If multiple templates remain after discounting ones that have been imported, then the processor assigns a priority to each template. The priority of a template can be set explicitly with the priority attribute on xsl:template. Otherwise, the priority is based on the pattern in the match attribute, from lowest to highest as follows:</p>
          <ul>
            <li>Patterns that match all nodes of a particular type (e.g. all elements)</li>
            <li>Patterns that match nodes in a particular namespace (e.g. all XHTML elements)</li>
            <li>Patterns that match nodes by name (e.g. all p elements) </li>
            <li>Patterns that include additional tests through predicates or through additional steps (e.g. all p elements that are descendents of a table element)</li>
          </ul>
          <p>If more than one template matches a node, and they have the same priority, the processor uses the last template defined in the stylesheet.</p>
        </section>
      </section>
      <section>
        <h2>Top-Level Elements</h2>
        <p>Any element whose parent is the <sgmltag>xsl:stylesheet</sgmltag> element is called a top-level element. Here we're simply setting up some properties for the transform. There are other elements we can put at the start of our stylesheet. Here is a brief discussion of these:</p>
        <dl>
          <!-- <varlistentry> -->
            <dt><sgmltag>xsl:include</sgmltag> and <sgmltag>xsl:import</sgmltag></dt>
            <dd>
              <p>These elements refer to another stylesheet. The other stylesheet and all of its contents are included in the current stylesheet. The main difference between <sgmltag>xsl:import</sgmltag> and <sgmltag>xsl:include</sgmltag> is that a template, variable, or anything else imported with <sgmltag>xsl:import</sgmltag> has a lower priority than the things in the current stylesheet. This gives you a mechanism to subclass stylesheets, if you want to think about this from an object-oriented point of view. You can import another stylesheet that contains common templates, but any templates in the importing stylesheet will be used instead of any templates in the imported stylesheet. Another difference is that <sgmltag>xsl:import</sgmltag> can only appear at the beginning of a stylesheet, while <sgmltag>xsl:include</sgmltag> can appear anywhere.</p>
            </dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt><sgmltag>xsl:strip-space</sgmltag> and <sgmltag>xsl:preserve-space</sgmltag></dt>
            <dd>
              <p>These elements contain a space-separated list of elements from which whitespace should be removed or preserved in the output. To define these elements globally, use <sgmltag>xsl:strip-space elements="*"/</sgmltag> or <sgmltag>xsl:preserve-space elements="*"/</sgmltag> . If we want to specify that whitespace be removed for all elements except for <sgmltag>greeting</sgmltag> elements and <sgmltag>salutation</sgmltag> elements, we would add this markup to our stylesheet:</p>
            </dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt>
              <sgmltag>xsl:key</sgmltag>
            </dt>
            <dd>
              <p>This element defines a key, which is similar to defining an index on a database.</p>
            </dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt>xsl:variable</dt>
            <dd>
              <p>This element defines a variable. Any <sgmltag>xsl:variable</sgmltag> that appears as a top-level element is global to the entire stylesheet.</p>
            </dd>
          <!-- </varlistentry> -->
          <!-- <varlistentry> -->
            <dt>xsl:param</dt>
            <dd>
              <p>This element defines a parameter. As with <sgmltag>xsl:variable</sgmltag> , any <sgmltag>xsl:param</sgmltag> that is a top-level element is global to the entire stylesheet.</p>
            </dd>
          <!-- </varlistentry> -->
        </dl>
        <section>
          <h3>How to Avoid Exporting Namespace Definitions to Resulting XML Documents</h3>
          <blockquote>
            <p>I'd like to take data from some XML files and transform them into a new XML document. However, I do not want the definition of a namespace in the XSLT to occur in the result document.</p>
          </blockquote>
          <p>You can use the <parameter>exclude-result-prefixes</parameter> attribute of the xsl:stylesheet element to avoid emitting namespace prefixes into the output document:</p>
          <pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;xsl:stylesheet version="1.0"
         xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
         xmlns:prefix1="http://www.something.com"
         exclude-result-prefixes="prefix1"&gt;

&lt;/xsl:stylesheet&gt;</pre>
          <p>To suppress multiple namespaces from the output document specify them separated by whitespace:</p>
          <pre>exclude-result-prefixes="prefix1 prefix2 prefix3"</pre>
          <p>From the XSLT specification:</p>
          <blockquote>When a stylesheet uses a namespace declaration only for the purposes of addressing the source tree, specifying the prefix in the exclude-result-prefixes attribute will avoid superfluous namespace declarations in the result tree.</blockquote>
          <section>
            <h4>Use <code class="userinput">extension-element-prefixes</code></h4>
            <p>Use <code class="userinput">extension-element-prefixes="Namespace"</code> like:</p>
            <pre>&lt;xsl:stylesheet
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:datetime="http://exslt.org/dates-and-times"
xmlns:str="http://exslt.org/strings"
xmlns:exsl="http://exslt.org/common"
xmlns:uw="xalan://ru.sbtc.util.XSLUtil"
extension-element-prefixes="exsl str datetime uw"
version="1.0"&gt;</pre>
            <p><code class="userinput">extension-element-prefixes</code> does have the same effect, but it has an additional effect. Any elements that you put in one of those namespaces will be interpreted as an extension element (rather than a literal result element). That may well be appropriate for the examples you have in your answer. But if you don't want that additional behavior, then just use exclude-result-prefixes </p>
          </section>
        </section>
      </section>
      <section id="push_pull_processing">
        <h2>Push and Pull Processing</h2>
        <p>In <dfn>push processing</dfn> a template rule is provided (written) for each kind of node. Then templates are applied for children of each node, and so on. Built-in templates are applied whenever a matching one has not been provided.</p>
        <p>Push processing is used when input and output have <em>the same structure</em>.</p>
        <p>In <dfn><a href="#pull_processing">pull processing</a></dfn> you explicitly select and process the required nodes.</p>
        <section>
          <h3>Push Processing</h3>
          <p>...</p>
          <p>Here is an example of turning a docbook file into HTML:</p>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;

  &lt;xsl:template match="book"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="book/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="para"&gt;
    &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="title"&gt;
    &lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          <p>Each xsl:apply-templates instruction is the stylesheet's way of telling the XSLT processor to send along the context node's child nodes to the stylesheet's relevant template rules. (Or, to quote Curtis Mayfield, "Keep On Pushing.")</p>
        </section>
        <section id="pull_processing">
          <h3>Pull Processing</h3>
          <p>In <dfn>pull processing</dfn> you explicitly select and process the required nodes. To this end the following elements are used:</p>
          <ul>
            <li>&lt;xsl:value-of  select='pattern'/&gt;</li>
            <li>&lt;xsl:apply-templates  select='pattern'/&gt;</li>
            <li>&lt;xsl:for-each  select='pattern'/&gt;</li>
          </ul>
          <p>Pull processing affords greater control over which nodes are to be processed. It is employed whenever input and output have very <em>different structure</em>.</p>
          <p>A pull stylesheet is appropriate when you are fairly certain of what your source document will look like. It's also a good idea if the structure of the result drives the processing; i.e., if you just want to pick certain information out of the source document and place it in the result.</p>
          <section>
            <h4>A Simple Example</h4>
            <p>Here is an simple example.</p>
            <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;

  &lt;xsl:template match="/"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="book/title"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;&lt;xsl:value-of select="book/title"/&gt;&lt;/h1&gt;
        &lt;xsl:for-each select="book/para"&gt;
          &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
            <p>...</p>
          </section>
          <section>
            <h4>A Full Example</h4>
            <p>Here elements are selected (1) by name or (2) by attribute, and (3) other elements are outsourced through the <code class="function">document(FILE_NAME)</code> function.</p>
            <pre>&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:db ="http://docbook.org/ns/docbook"
  version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;

  &lt;xsl:template match="/"&gt;

    &lt;xsl:element name="book"&gt;
      &lt;xsl:element name="title"&gt;Pulling Elements either by Name or by Attribute Value&lt;/xsl:element&gt;

      &lt;xsl:text&gt;
      &lt;/xsl:text&gt;


      &lt;!-- Pull all preface elements --&gt;
      &lt;xsl:apply-templates select="document('../book.xml')/book//preface"/&gt;&lt;xsl:text&gt;

      &lt;/xsl:text&gt;
      &lt;!-- Pull all elements with a class attribute whose value is 'private' --&gt;
      &lt;xsl:apply-templates select="/book//*[@class='private']"/&gt;

    &lt;/xsl:element&gt;


  &lt;/xsl:template&gt;

  &lt;!-- Copy all elements, attributes, and text nodes --&gt;
&lt;xsl:template match="*|@*|text()|comment()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="*|@*|text()|comment()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;


</pre>
          </section>
          <section>
            <h4>Pulling and Sorting</h4>
            <p>You want to call an empty sort element <code class="userinput">&lt;xsl:sort select="NODE-SET"/&gt;</code> inside a  <code class="userinput">&lt;xsl:for-each select="ELEMENT"&gt;...&lt;/xsl:for-each&gt;</code> element.</p>
            <p>In the follwing example only the titles of chapters are pulled, and then sorted:</p>
            <pre>&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:db ="http://docbook.org/ns/docbook"
  version="1.0"&gt;
  &lt;xsl:output method="xml"/&gt;

  &lt;xsl:template match="/"&gt;

    &lt;xsl:element name="book"&gt;
      &lt;xsl:element name="title"&gt;Pulling Chapter &lt;tag&gt;title&lt;/tag&gt; Elements and sorting by &lt;userinput&gt;./title&lt;/userinput&gt;&lt;/xsl:element&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;

      &lt;xsl:for-each select='//chapter'&gt;
        &lt;xsl:sort select="./title | ./info/title"/&gt;
        &lt;xsl:apply-templates select="title | info/title"/&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;
      &lt;/xsl:for-each&gt;

    &lt;/xsl:element&gt;


  &lt;/xsl:template&gt;

  &lt;!-- Copy all elements, attributes, and text nodes --&gt;
&lt;xsl:template match="*|@*|text()|comment()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="*|@*|text()|comment()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
            <section>
              <h5>Other Ordering Attributes</h5>
              <p>We may change the sorting criterium and avail ourselves of other sort attributes, such as by ascending or descending order:</p>
              <pre>&lt;xsl:sort select="./title | ./info/title" order="descending"/&gt;</pre>
              <p>We can also sort by <var>data-type</var>, which takes on any of values <code class="literal">text</code> (default), <code class="literal">number</code>, or <code class="literal">qname</code>:</p>
              <pre>&lt;xsl:sort select="./title | ./info/title" data-type="text"/&gt;</pre>
            </section>
            <section>
              <h5>Pulling and Re-ordering by the Numeric Value of an Attribute</h5>
              <p>If all <code class="tag">title</code> elements bore a <var>ordering</var> attribute with a numeric value (or any other attribute with a numeric value), you could order chapters by the numeric value of that attribute, as in:</p>
              <pre>&lt;xsl:sort select="@ordering" data-type="number"/&gt;</pre>
              <p>This enables us to generate differently ordered sequences, as many as our <code class="tag">chapter</code> elements bore numeric-valued attributes:</p>
              <pre>&lt;chapter id="my-chapter" ordering="21" scrambled-ordering="4" easy-ordering="7"&gt;
  ...
&lt;/chapter&gt;</pre>
              <p>We may even avail ourselves of the presence or absence of an attribute in <code class="tag">chapter</code> to pull it in or not:</p>
              <pre>&lt;xsl:for-each select='//chapter[@special-ordering]'&gt;
  &lt;xsl:sort select="@special-ordering" data-type="number"/&gt;</pre>
            </section>
          </section>
          <section>
            <h4>Pull Advantages?</h4>
            <p>Keeping the program logic for multiple classes of nodes in one template rule can be an advantage if you want to perform some specific steps on each node type, as well as some other steps on all those nodes. For example, let's say I want to wrap every member element from the following sample document in a p element.</p>
            <pre>&lt;members&gt;
  &lt;member joinDate="2003-10-03"&gt;Jimmy Osterberg&lt;/member&gt;
  &lt;member joinDate="2005-03-07"&gt;Declan McManus&lt;/member&gt;
  &lt;member joinDate="2003-10-03"&gt;Richard Starkey&lt;/member&gt;
  &lt;member joinDate="2004-08-23"&gt;Vincent Furnier&lt;/member&gt;
&lt;/members&gt;</pre>
            <p>I want to precede each with a p element that says <q>(founding member)</q> if the joinDate date equals <q>2003-10-03</q>, and with a p element of <q>(new member)</q> if the joinDate attribute begins with <q>2005</q>. The following does this easily in a single template rule:</p>
            <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="1.0"&gt;

  &lt;xsl:template match="member"&gt;

    &lt;xsl:if test="@joinDate='2003-10-03'"&gt;
      &lt;p&gt;(founding member)&lt;/p&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:if test="substring(@joinDate,1,4) = '2005'"&gt;
      &lt;p&gt;(new member)&lt;/p&gt;
    &lt;/xsl:if&gt;

    &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;

  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          </section>
        </section>
        <section>
          <h3>XSLT 2.0: New Options</h3>
          <p>XSLT 2.0 offers another approach. The xsl:next-match element tells the XSLT processor to find the next most applicable template rule for the context node being processed and apply it, letting you apply multiple template rules to a node while still using a push approach. Normally, when multiple template rules all have match conditions that can describe the same element (for example, if one template rule has a match condition of <q>*</q>, another has one of <q>member</q>, and another has one of <q>member[@joinDate='2003-10-03']</q>, they can all apply to the first member element shown above), the XSLT processor applies the one with the most specific description to the node&#x2014;in this case, the one with a match condition of <q>member[@joinDate='2003-10-03']</q>. (The choice is actually made based on a priority number to help judge how specific the description is. You can override this by explicitly setting a priority attribute value in the template rule.)</p>
          <p>While an XSLT processor processes a particular node in a template rule, the xsl:next-match instruction tells it, <q>Go find the next most appropriate template rule after this one, execute all of its instructions, and then resume in this template rule.</q> This lets you rewrite the stylesheet above like this, with the same effect:</p>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
     version="2.0"&gt;

    &lt;xsl:template match="member[@joinDate='2003-10-03']"&gt;
      &lt;p&gt;(founding member)&lt;/p&gt;
      &lt;xsl:next-match/&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="member[substring(@joinDate,1,4) = '2005']"&gt;
      &lt;p&gt;(new member)&lt;/p&gt;
      &lt;xsl:next-match/&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="member"&gt;
      &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
          <p>When either the first or second template rule here is triggered, it outputs the p element shown and then triggers the third template rule.</p>
          <p>It's best to use short examples in this kind of article, and the examples above are so short that the difference between the last two stylesheets seems trivial. You'll find that the usefulness of the xsl:next-match instruction becomes clearer as the amount of program logic to execute scales up. When you have different combinations of large blocks of instructions to execute on a set of nodes, putting these blocks inside of xsl:if instructions or the xsl:when children of xsl:choose elements makes a stylesheet increasingly difficult to read. When you combine the conditional processing made possible by carefully chosen match conditions with the template rule chaining allowed by xsl:next-match, you can have a much more elegant, readable solution. For even greater control over the relationship between the calling and the called templates, you can add xsl:with-param children to the xsl:next-match element to pass parameters, just like you can with named templates.</p>
        </section>
      </section>
      <section id="xslt_creating_links">
        <h2>Creating Links and Cross-References</h2>
        <p>This section discusses a several ways to link XML elements. It reviews three techniques:</p>
        <ul>
          <li>Using the <code class="function">id()</code> function</li>
          <li>Doing more advanced linking with the <code class="function">key()</code> function</li>
          <li>Generating links in unstructured documents</li>
        </ul>
        <section>
          <h3>The <code class="function">id()</code> Function</h3>
          <p>The <code class="function">id()</code> function selects elements by their unique <code class="classname">ID</code>. When the argument to <code class="function">id()</code> is of type <code class="classname">node-set</code>, then the result is the union of the result of applying <code class="function">id()</code> to the string-value of each of the nodes in the argument node-set. When the argument to <code class="function">id()</code> is of any other type, the argument is converted to a string as if by a call to the <code class="function">string()</code> function; the string is split into a whitespace-separated list of tokens (whitespace is any sequence of characters matching the production S); the result is a node-set containing the elements in the same document as the context node that have a unique <code class="classname">ID</code> equal to any of the tokens in the list. Thus</p>
          <ul>
            <li><code class="userinput">id("foo")</code>  selects the element with unique <code class="classname">ID</code> <constant>foo</constant></li>
            <li><code class="userinput">id("foo")/child::para[position()=5]</code>  selects the fifth para child of the element with unique <code class="classname">ID</code> <constant>foo</constant></li>
          </ul>
        </section>
        <section>
          <h3>The <code class="classname">ID</code>, <code class="classname">IDREF</code>, and <code class="classname">IDREFs</code> Datatypes</h3>
          <p>Three of the basic datatypes supported by XML Document Type Definitions (DTDs) are <code class="classname">ID</code>, <code class="classname">IDREF</code>, and <code class="classname">IDREFs</code>. Here's a simple DTD that illustrates these datatypes:</p>
          <pre>&lt;!--glossary.dtd--&gt;
&lt;!--The containing tag for the entire glossary--&gt;
&lt;!ELEMENT glossary  (glentry+) &gt;

&lt;!--A glossary entry--&gt;
&lt;!ELEMENT glentry  (term,defn+) &gt;

&lt;!--The word being defined--&gt;
&lt;!ELEMENT term  (#PCDATA) &gt;

&lt;!--The id is used for cross-referencing, and the
    xreftext is the text used by cross-references.--&gt;
&lt;!ATTLIST term
               id  ID    #REQUIRED
               xreftext  CDATA    #IMPLIED  &gt;

&lt;!--The definition of the term--&gt;
&lt;!ELEMENT defn  (#PCDATA | xref | seealso)* &gt;

&lt;!--A cross-reference to another term--&gt;
&lt;!ELEMENT xref   EMPTY  &gt;

&lt;!--refid is the ID of the referenced term--&gt;
&lt;!ATTLIST xref
               refid  IDREF    #REQUIRED &gt;

&lt;!--seealso refers to one or more other definitions--&gt;
&lt;!ELEMENT seealso EMPTY&gt;
&lt;!ATTLIST seealso
                  refids   IDREFS  #REQUIRED &gt;</pre>
          <p>In this DTD, each <code class="userinput">&lt;term&gt;</code> element is required to have an <var>id</var> attribute, and each <code class="userinput">&lt;xref&gt;</code> element must have an <var>refid</var> attribute. The <code class="classname">ID</code> and <code class="classname">IDREF</code> datatypes work according to two rules:</p>
          <ul>
            <li>Each value of the <var>id</var> attribute must be unique.</li>
            <li>Each value of the <var>refid</var> attribute must match a value of an <var>id</var> attribute elsewhere in the document.</li>
          </ul>
          <p>To round out our example, the <code class="userinput">&lt;seealso&gt;</code> element contains an attribute of type <code class="classname">IDREFS</code>. This datatype contains one or more values, each of which must match a value of an ID elsewhere in the document. Multiple values, if present, are separated by whitespace.</p>
          <p>There are some complications of <code class="classname">ID</code> and related datatypes, but we'll discuss them later.</p>
          <section>
            <h4>Limitations of <code class="classname">ID</code>s</h4>
            <p>There are some limitations of the ID datatype and the id() function, though:</p>
            <ul>
              <li>If you want to use the <code class="classname">ID</code> datatype, you have to declare the attributes that use that datatype in your DTD or schema. Unfortunately, if your DTD is defined <em>externally</em> to your XML document, the XML parser isn't required to read it. If the DTD isn't read, then the parser has no idea that a given attribute is of type <code class="classname">ID</code>.</li>
              <li>You must define the <code class="classname">ID</code> and <code class="classname">IDREF</code> relationship in the XML document. It would be nice to have the XML document define the data only, with the relationships between parts of the document defined externally (say, in a stylesheet). That way, if you needed to define a new relationship between parts of the document, you could do it by creating a new stylesheet, and you wouldn't have to modify your XML document. Requiring the XML document structure to change every time you need to define a new relationship between parts of the document will become unwieldy quickly.</li>
              <li>An element can have at most one attribute of type <code class="classname">ID</code>. If you'd like to refer to the same element in more than one way, you can't use the <code class="function">id()</code> function.</li>
              <li>Any given <code class="classname">ID</code> value can be found on at most one element. If you'd like to refer to more than one element with a single value, you can't use the <code class="function">id()</code> function for that, either.</li>
              <li>Only one set of <code class="classname">ID</code>s exists for the entire document. In other words, if you declare the attributes <var>customer_number</var>, <var>part_number</var>, and <var>order_number</var> to be of type <code class="classname">ID</code>, the value of a customer_number must be unique across all the attributes of type <code class="classname">ID</code>. It is illegal in this case for a customer_number to be the same as a part_number, even though those attributes might belong to different elements.</li>
              <li>An <code class="classname">ID</code> can only be an attribute of an XML element. The only way you can use the <code class="function">id()</code> function to refer to another element is through its attribute of type <code class="classname">ID</code>. If you want to find another element based on an attribute that isn't an <code class="classname">ID</code>, based on the element's content, based on the element's children, etc., the <code class="function">id()</code> function is of no use whatsoever.</li>
              <li>The value of an <code class="classname">ID</code> must be an XML name. In other words, it can't contain spaces, it can't start with a number, and it's subject to the other restrictions of XML names.<!-- (Section 2.3 of the XML Recommendation defines these restrictions; see http://www.w3.org/TR/REC-xml if you&apos;d like more information.)--></li>
            </ul>
            <p>To get around all of these limitations, XSLT defines the <code class="function">key()</code> function. We'll discuss that function in the next section.</p>
          </section>
        </section>
        <section>
          <h3>Generating Links with the <code class="function">key()</code> Function</h3>
          <p>Each <code class="function">key()</code> function effectively creates an index of the document. You can then use that index to find all elements that have a particular property. Conceptually, <code class="function">key()</code> works like a database index. If you have a database of (U.S. postal) addresses, you might want to index that database by the people's last names, by the states in which they live, by their Zip Codes, etc. Each index takes a certain amount of time to build, but it saves processing time later. If you want to find all the people who live in the state of Idaho, you can use the index to find all those people directly; you don't have to search the entire database.</p>
          <section>
            <h4>Defining a <code class="function">key()</code></h4>
            <p>You define a <code class="function">key()</code> function with the <code class="userinput">&lt;xsl:key&gt;</code> element:</p>
            <pre>&lt;xsl:key name="language-index" match="defn" use="@language"/&gt;</pre>
            <p>The key has three elements:</p>
            <ul>
              <li>A <var>name</var>, used to refer to this particular key. When you want to find parts of your XML document, use the <var>name</var> to indicate the key you want to use.</li>
              <li>A <var>match</var> attribute containing an XPath expression. This specifies what part of the document you want to index. The previous example created an index on all of the <code class="userinput">&lt;defn&gt;</code> elements. When we call the <code class="function">key()</code> function, it will return a <code class="userinput">&lt;defn&gt;</code> element. Note: according to Section 12.2 of the XSLT specification, the value of the <var>match</var> attribute can't contain a variable.</li>
              <li>
                <p>A <var>use</var> attribute containing another XPath expression. This attribute is interpreted in the context of the <var>match</var> attribute. In other words, the previous <code class="userinput">&lt;xsl:key&gt;</code> element created an index of all the <code class="userinput">&lt;defn&gt;</code> elements, and used the language attribute to retrieve them.</p>
                <aside class="note"><strong>Note.</strong> According to Section 12.2 of the XSLT specification, the value of the use attribute can't contain a variable.</aside>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <h3>Generating links in unstructured documents</h3>
          <p>So far, all of this section's examples have been structured nicely. When there was a relationship between two pieces of information, we had an <var>id</var> and <var>refid</var> pair to match them. What happens if the XML document you're transforming isn't written that way? Fortunately, we can use the <code class="function">key()</code> function and a new function, <code class="function">generate-id()</code>, to create structure where there isn't any.</p>
          <section>
            <h4>The <code class="function">generate-id()</code> Function</h4>
            <p>This function takes a <code class="classname">node-set</code> as its argument, and works as follows:</p>
            <ul>
              <li>
                <p>For a given transformation, every time <code class="function">generate-id()</code> is invoked against a given node, it returns the same <code class="classname">ID</code>. The <code class="classname">ID</code> doesn't change while you're doing a given transformation. If you run the transformation again, there's no guarantee <code class="function">generate-id()</code> will generate the same <code class="classname">ID</code> the second time around. All calls to <code class="function">generate-id()</code> in the second transformation will return the same <code class="classname">ID</code>, but that <code class="classname">ID</code> might not be the same as in the first transformation.</p>
                <aside class="note"><strong>Note.</strong> The <code class="function">generate-id()</code> function is not required to check if an <code class="classname">ID</code> it generates duplicates an <code class="classname">ID</code> that's already in the document. In other words, if your document has an attribute of type <code class="classname">ID</code> with a value of <constant>sdk3829a</constant>, there's a possibility that an <code class="classname">ID</code> returned by <code class="function">generate-id()</code> will also be <constant>sdk3829a</constant>. It's not likely, but be aware that it could happen.</aside>
              </li>
              <li>If you invoke <code class="function">generate-id()</code> against two different nodes, the two generated IDs will be different.</li>
              <li>Given a node-set, <code class="function">generate-id()</code> returns an <code class="classname">ID</code> for the node in the node-set that occurs first in document order.</li>
              <li>If the node-set you pass to the function is empty (you invoke <code class="function">generate-id(fleeber)</code>, and there are no <code class="tag">&lt;fleeber&gt;</code> elements in the current context), <code class="function">generate-id()</code> returns an empty string.</li>
              <li>If no node-set is passed in (you invoke <code class="function">generate-id()</code>), the function generates an <code class="classname">ID</code> for the context node.</li>
            </ul>
          </section>
        </section>
      </section>
      <section>
        <h2>Splitting Up Output Into Multiple Files</h2>
        <p>A classic XML transformation task is the splitting of a large source document into multiple result documents. For example, when preparing a large book for web delivery, you probably want to split it up so that each chapter gets converted to a separate HTML file, because the entire book would be too large to send to a web browser.</p>
        <p>The XSLT 1.0 specification has no provisions for splitting up output into multiple documents. This ability is so useful, however, that nearly every XSLT processor offers an extension element that lets you do this.</p>
        <p>Instead of picking one XSLT processor's syntax for splitting up output documents, or trying to cover all of them, this section shows the syntax for doing so with the xsl:document element described in the W3C 's XSLT 1.1 Working Draft. Although the W3C XSL Working Group eventually decided to discontinue work on XSLT 1.1 in order to fully devote their energy to XSLT 2.0, XSLT 1.1's xsl:document element is based on several existing implementations of this potential XSLT feature and will provide a model for future implementations until a XSLT 2.0 Recommendation eventually makes the xsl:document syntax official.</p>
        <p>The following stylesheet converts our document into a set of HTML files:</p>
        <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml" omit-xml-declaration="yes"/&gt;
  &lt;xsl:template match="chapter"&gt;
    &lt;xsl:variable name="chapNum"&gt;&lt;xsl:number/&gt;&lt;/xsl:variable&gt;
    &lt;xsl:document href="chap{$chapNum}.html"&gt;
      &lt;html&gt;&lt;body&gt;
        &lt;xsl:apply-templates/&gt;
      &lt;/body&gt;&lt;/html&gt;
    &lt;/xsl:document&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="chapter/title"&gt;
    &lt;h1&gt;&lt;xsl:apply-templates/&gt;&lt;/h1&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="para"&gt;
    &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
        <section>
          <h3>The &lt;xsl:document Element</h3>
        </section>
      </section>
      <section>
        <h2>Program Control</h2>
        <p>You can go through a set of nodes one by one, iterating over those nodes, by applying templates to them with xsl:apply&#x2013;templates. You can also iterate over a set of nodes using xsl:for&#x2013;each. As a result, the content of the xsl:for&#x2013;each is processed with each of the nodes as the current node. With both instructions, the nodes are usually processed in document order, but you can change the order using xsl:sort.</p>
        <section>
          <h3>xsl:if</h3>
          <p>It relies on a test attribute.</p>
          <pre>&lt;xsl:if test="not(@author='anonymous')"&gt;
  Book written by &lt;xsl:value-of select='@author'/&gt;
&lt;/xsl:if&gt;</pre>
        </section>
        <section>
          <h3>xsl:choose</h3>
          <p>XSLT's xsl:choose instruction is similar to xsl:if but with a few key differences:</p>
          <ul>
            <li>One xsl:choose element can test for more than one condition and add different nodes to the result tree based on which condition is true.</li>
            <li>An xsl:choose element can have a default template to add to the result tree if none of the conditions are true. (Compare to xsl:if , which has no equivalent of an "else" condition.)</li>
            <li>The xsl:choose element has specific subelements necessary for it to work. You can put any well-formed elements you want inside of an xsl:if element.</li>
          </ul>
          <p>When an XSLT processor sees an xsl:choose element, it checks the test attribute value of each xsl:when element that it finds as a child of the xsl:choose element. When it finds a true test expression, it adds that xsl:when element's contents to the result tree and then skips the rest of the xsl:choose ele- ment. If it finds no xsl:when element with a true test expression, it checks for the optional xsl:otherwise element at the end of the xsl:choose element. If it finds one, it adds its contents to the result tree.</p>
          <p>An example:</p>
          <pre>&lt;xsl:template match="poem"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="@year &amp;lt; 1638"&gt;
      The poem is one of Milton&amp;apos; earlier works.
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@year &amp;lt; 1650"&gt;
      The poem is from Milton&amp;apos; middle period.
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@year &amp;lt; 1668"&gt;
      The poem is one of Milton&amp;apos; later works.
    &lt;/xsl:when&gt;
    &lt;xsl:when test="@year &amp;lt; 1675"&gt;
      The poem is one of Milton&amp;apos; last works.
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      The poem was written after Milton&amp;apos; death.
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;</pre>
        </section>
        <section>
          <h3>Curly braces</h3>
          <p>For some stylesheet attribute values, curly braces tell the XSLT processor to evaluate the expression between them and to replace the curly braces and their contents with the result of that evaluation. The following stylesheet demonstrates the effect of the curly braces:</p>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml" omit-xml-declaration="yes"/&gt;
&lt;xsl:template match="/"&gt;
  &lt;test&gt;
    &lt;xsl:variable name="myVar"&gt;10&lt;/xsl:variable&gt;
      A. &lt;atvtest at1="hello world"/&gt;
      B. &lt;atvtest at1="3+2+$myVar"/&gt;
      C. &lt;atvtest at1="{3+2+$myVar}"/&gt;
      D. &lt;atvtest at1="yo, substring('hello world',7)"/&gt;
      E. &lt;atvtest at1="yo, {substring('hello world',7)}"/&gt;
    &lt;/test&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
          <p>References to variables inside of curly braces get converted to the value they represent, but when they have no curly braces around them, the reference to the variable is treated as literal text.</p>
        </section>
        <section>
          <h3>Iteration and Loops</h3>
          <p>Programming languages use loops to execute an action or series of actions several times. After performing the last action of such a series, the program "loops" back up to the first one. The program may repeat these actions a predetermined number of times or it may repeat the actions until a specified condition is true.</p>
          <ul>
            <li>The xsl:for-each instruction lets you perform the same group of instructions on a given set of nodes.</li>
            <li>By having a named template call itself recursively with parameters, you can execute a series of instructions for a fixed number of times or until a given condition is true. The technique may not be familiar to programmers accustomed to the "for" and "while" loops available in languages such as Java, C, and C++, but it can perform the same tasks.</li>
          </ul>
          <p>Here is some code to list all the figures in a chapter before it starts:</p>
          <pre>&lt;xsl:template match="chapter"&gt;
  Pictures:
  &lt;xsl:for-each select="descendant::figure"&gt;
    &lt;xsl:value-of select="title"/&gt;&lt;xsl:text&gt;
    &lt;/xsl:text&gt;
  &lt;/xsl:for-each&gt;
  Chapter:&lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
          <p>Another advantage of acting on a set of nodes with an xsl:for-each element instead of with an xsl:template element lies in a limitation to template rules that XSLT novices often don't notice: while it may appear that you can use XPath expressions in an xsl:template element's match attribute, you're actually limited to the subset of XPath expressions known as patterns. In the xsl:for-each element's select attribute, however, you have the full power of XPath expressions available.</p>
          <p>For example, you can't use the ancestor axis specifier in match patterns, but you can do so in an xsl:for-each element's select attribute. The following template uses the ancestor axis specifier to list the names of all a title element's ancestors:</p>
          <pre>&lt;xsl:template match="title"&gt;
  &lt;xsl:text&gt;title ancestors:&lt;/xsl:text&gt;
  &lt;xsl:for-each select="ancestor::*"&gt;
    &lt;xsl:value-of select="name()"/&gt;
    &lt;!-- Output a comma if it&amp;apos; not the last one in the node set that for-each is going through. --&gt;
    &lt;xsl:if test="position() != last()"&gt;
      &lt;xsl:text&gt;,&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;
&lt;xsl:template match="para"/&gt;</pre>
          <p>To execute a piece of code a specific number of times you have to use recursion, as in:</p>
          <pre>&lt;xsl:template name="hyphens"&gt;
  &lt;xsl:param name="howMany"&gt;1&lt;/xsl:param&gt;
  &lt;xsl:if test="$howMany &amp;gt; 0"&gt;
    &lt;!-- Add 1 hyphen to result tree. --&gt;
    &lt;xsl:text&gt;-&lt;/xsl:text&gt;
    &lt;!-- Print remaining ($howMany - 1) hyphens. --&gt;
    &lt;xsl:call-template name="hyphens"&gt;
      &lt;xsl:with-param name="howMany" select="$howMany - 1"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:if&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="sample"&gt;
  Print 1 hyphen:
  &lt;xsl:call-template name="hyphens"/&gt;
  Print 3 hyphens:
  &lt;xsl:call-template name="hyphens"&gt;
    &lt;xsl:with-param name="howMany" select="3"/&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>
        </section>
      </section>
      <section>
        <h2>Generating Output</h2>
        <p>To create a simple text string we use <sgmltag>xsl:text</sgmltag> when we need complete control over whitespace or when we're creating text output instead of a marked-up document.</p>
        <section id="xslt_space">
          <h3>Handling Space Through XSLT</h3>
          <p>You probably want to <em>normalize</em> space. Use <code class="userinput">normalize-space()</code>.</p>
          <section>
            <h4>Eliminating Redundant Space</h4>
            <p>Use <code class="userinput">normalize-space()</code>, which is a function that removes extra whitespace from its argument string. Its output is a string with whitespace removed as follows:</p>
            <ul>
              <li>All leading whitespace is removed.</li>
              <li>All trailing whitespace is removed.</li>
              <li>Within the string, any sequence of whitespace characters is replaced with a single space</li>
            </ul>
            <p>A simple example:</p>
            <pre>&lt;xsl:template match="text()"&gt;
  &lt;xsl:value-of select="normalize-space()"/&gt;
&lt;/xsl:template&gt;</pre>
          </section>
          <section>
            <h4>Preserving and Stripping Space</h4>
            <p>The <code class="userinput">&lt;xsl:preserve-space&gt;</code> element is used to define the elements for which white space should be preserved when no other characters are used. The <code class="userinput">&lt;xsl:strip-space&gt;</code> element is used to define the elements for which white space should be removed.</p>
            <aside class="note"><strong>Note.</strong> Preserving white space is the default setting, so using the <code class="userinput">&lt;xsl:preserve-space&gt;</code> element is only necessary if  the <code class="userinput">&lt;xsl:strip-space&gt;</code> element is used.</aside>
            <aside class="note"><strong>Note.</strong> Note: The <code class="userinput">&lt;xsl:preserve-space&gt;</code> element and the <code class="userinput">&lt;xsl:strip-space&gt;</code> element are top-level elements.</aside>
            <aside class="warning"><strong>Warning:</strong> The two elements are only relevant for whitespace-only text nodes. If just one non-whitespace character is present, the two xslt elements are irrelevant.</aside>
          </section>
        </section>
        <section>
          <h3>The <sgmltag>number</sgmltag> element</h3>
          <p>The <sgmltag>xsl:number</sgmltag> element is used to number the parts of a document or to format a numeric value. In general, <sgmltag>xsl:number</sgmltag> counts something.</p>
          <pre>&lt;xsl:for-each select="cars/manufacturer"&gt;
  &lt;p&gt;
    &lt;xsl:number format="1. "/&gt;
    &lt;xsl:value-of select="@name"/&gt;
  &lt;/p&gt;
&lt;/xsl:for-each&gt;</pre>
          <p>or:</p>
          <pre>&lt;xsl:for-each select="cars/manufacturer"&gt;
  &lt;p&gt;
    &lt;xsl:text&gt;Cars produced by &lt;/xsl:text&gt;
    &lt;xsl:value-of select="@name"/&gt;
    &lt;xsl:text&gt;: &lt;/xsl:text&gt;
    &lt;xsl:number value="count(car)" format="01"/&gt;
  &lt;/p&gt;
&lt;/xsl:for-each&gt;</pre>
          <p>or setting the level attribute to "multiple":</p>
          <pre>&lt;xsl:for-each select="book/chapter"&gt;
  &lt;xsl:number count="chapter" format="1. "/&gt;
  &lt;xsl:value-of select="title"/&gt;
  &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;
  &lt;xsl:for-each select="sect1"&gt;
    &lt;xsl:number count="chapter|sect1" level="multiple" format="1.1. "/&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:for-each&gt;</pre>
          <p>XSLT 2.0 also adds the ordinal attribute; ordinal="yes" combined with format="1" generates 1st , 2nd , 3rd , while ordinal="yes" combined with format="Ww" generates First , Second , Third . The ordinal attribute has many different options that depend on the lang attribute and the format attribute; as you would expect, each XSLT 2.0 processor supports a different set of languages and options for the ordinal attribute. See your processor's documentation for information on what capabilities are available.</p>
        </section>
        <section>
          <h3>The <sgmltag>sort</sgmltag> element</h3>
          <pre>&lt;xsl:for-each select="dfn"&gt;
&lt;xsl:sort select="."/&gt;</pre>
        </section>
        <section>
          <h3>The <sgmltag>value-of</sgmltag> element</h3>
          <p>To output the value of something from the XML source we use <sgmltag>xsl:value-of select="..."</sgmltag>.</p>
        </section>
        <section>
          <h3>Using <sgmltag>xsl:copy</sgmltag> and <sgmltag>xsl:copy-of</sgmltag></h3>
          <p>As you transform your XML input document into something else, you'll often want to just copy a given element to the output document:</p>
          <dl>
            <!-- <varlistentry> -->
              <dt>xsl:copy-of</dt>
              <dd>
                <p>does a <em>deep copy</em> of a node, so the root node and all of its children are copied to the output. If any of the root node's descendants are element nodes with attributes, the attributes are copied as well. (Remember, an element's attributes aren't considered children.)</p>
              </dd>
            <!-- </varlistentry> -->
            <!-- <varlistentry> -->
              <dt>xsl:copy</dt>
              <dd>
                <p>Using <sgmltag>xsl:copy</sgmltag> to copy our document requires using the <sgmltag>xsl:for-each</sgmltag> element to copy all the attributes of each element we're copying. It forces you do to most of the work yourself, but you have complete control over what exactly gets copied.</p>
              </dd>
            <!-- </varlistentry> -->
          </dl>
          <p>To really understand the power of xsl:copy-of, let's compare it to the xsl:value-of instruction. Both help you grab an arbitrary part of the source tree while the XSLT processor is processing another part of the tree. The xsl:value-of element doesn't add a copy of the grabbed node to the result tree, but a text node with a string representation of it. When xsl:value-of is told to convert a set of nodes to a string, it only gets the first one in that set, so it's only useful for getting one node's value at a time. The xsl:copy-of element, on the other hand, gets a whole node set and all of the nodes' children.</p>
        </section>
        <section>
          <h3>Handling space</h3>
          <p>Use <sgmltag>xsl:preserve-space elements="pre literallayout"/</sgmltag> or
          <sgmltag>xsl:strip-space elements="para title"/</sgmltag>.</p>
          <p>To clean up the whitespace, we can use the <code class="function">normalize-space( )</code> function. It does three things:</p>
          <ul>
            <li>it removes all leading spaces,</li>
            <li>it removes all trailing spaces, and</li>
            <li>it replaces any group of consecutive whitespace characters with a single space.</li>
          </ul>
          <pre>&lt;xsl:template match="text()"&gt;
  &lt;xsl:value-of select="normalize-space()"/&gt;
&lt;/xsl:template&gt;</pre>
        </section>
        <section>
          <h3>Grouping Nodes</h3>
          <p>When grouping nodes, we sort things to get them into a certain order, and then we group all items that have the same value for the sort key (or keys). We'll use xsl:sort for this grouping, and then use variables or functions such as key( ) or generate-id( ) to finish the job.</p>
        </section>
        <section id="xslt_translate">
          <h3>Translating Characters with <code class="function">string xsl:translate(<var>s1</var>, <var>s2</var>, <var>s3</var>)</code> function</h3>
          <p>This function returns a string where all characters in <var>s1</var> are returned as such save for those in <var>s2</var>. Those in <var>s2</var> are returned as in <var>s3</var>. <code class="function">translate()</code> will not copy characters in the input string that are in the <q>from</q> string but do not have a corresponding character in the <q>to</q> string.</p>
          <p>If you want to strip certain characters (e.g., whitespace) from a string, you might use <code class="function">translate()</code> with an empty replace string. For example, the following code can strip whitespace from a string:</p>
          <pre>translate($input," &amp;#x9;&amp;#xa;&amp;xd;", "")</pre>
          <bridgehead>Removing All But a Specific Set of Characters</bridgehead>
          <p>You can also use <code class="function">translate()</code> to remove all but a specific set of characters from a string. For example, the following code removes all non-numeric characters from a string:</p>
          <pre>translate($string,
          translate($string,'0123456789',''),'')</pre>
          <p>The inner <code class="function">translate()</code> removes all characters of interest (e.g., numbers) to obtain a from string for the outer <code class="function">translate()</code>, which removes these non-numeric characters from the original string.</p>
        </section>
      </section>
      <section>
        <h2>Variables, Parameters, and Keys</h2>
        <section>
          <h3>Variables</h3>
          <p>Variables are declared with xsl:variable. The two types of variables are local variables, which are defined within templates and only accessible within that template, and global variables, which are defined at the top level of the stylesheet and are accessible anywhere. A local variable cannot have its value reassigned, but global variables can be overridden by local variables.</p>
          <p>Variables can be set in two ways. First, they can be set through the select attribute. Second, they can be set through content of xsl:variable. Setting a variable through its content always sets it to a result tree fragment.</p>
          <p>The select attribute can set a variable to any value type.</p>
          <!-- smallskip -->
          <p>A variable in XSLT has more in common with a variable in algebra than with a variable in a typical programming language. A variable is a name that represents a value and, within a particular application of a template, it will never represent any other value: it can't be changed. XSLT variables actually have a lot more in common with something known as "constants" in many programming languages, and variables are used for a similar purpose as constants.</p>
          <p>The xsl:variable instruction creates a variable. Its name attribute identifies the variable's name. The value can be specified either as the xsl:variable element's contents (like the "10pt" in the example) or as the value of an optional select attribute in the xsl:variable element's start-tag.</p>
          <pre>&lt;xsl:variable name="HeaderTextSize"&gt;20pt&lt;/xsl:variable&gt;
&lt;xsl:template match="title"&gt;
  &lt;b&gt;&lt;font size="{$HeaderTextSize}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/font&gt;&lt;/b&gt;&lt;br/&gt;
&lt;/xsl:template&gt;</pre>
          <p>Alternatively, you can use the select attribute to set the value of a variable:</p>
          <pre>&lt;xsl:variable name="baseFontSize" select="12"/&gt;
&lt;xsl:variable name="HeaderTextSize" select="concat($baseFontSize+8,'pt')"/&gt;</pre>
        </section>
        <section>
          <h3>Parameters</h3>
          <p>Parameters are defined by xsl:param and work in much the same way as variables, except that the value of a parameter may be overridden by having another value passed to it. The value defined by the select attribute or content of xsl:param is the default value of the parameter, and is used when no other value is passed to it from outside.</p>
          <p>Parameters that are defined within templates must occur before anything else within the template. These local parameters can be overridden when the template is applied or called using xsl:with&#x2013;param within xsl:apply&#x2013;templates or xsl:call&#x2013;template. Parameters are passed by name &#x2014; the name attribute of xsl:with&#x2013;param indicates the parameter that it defines the value of. As with variables and default parameter values, the xsl:with&#x2013;param element can set a value either through the select attribute or through its content. Parameters that are defined at the top level of the stylesheet are global parameters. The XSLT Recommendation doesn't say anything about how global parameters are given values &#x2014; each XSLT processor sets global parameters in a different way.</p>
          <!-- medskip -->
          <p>The xsl:param instruction is just like xsl:variable , with one important difference: its value is only treated as a default value and can be overridden at runtime.</p>
          <p>How do you pass the alternative value for the parameter to the stylesheet? The official XSLT spec doesn't tell us!</p>
          <p>How we pass a new value to a template rule's local parameter isn't quite the open question that it is with global parameters, because XSLT provides the xsl:with-param instruction for just this purpose. You can use this element in an xsl:apply-templates element to assign a new value to a parameter in a template being applied, but it's more commonly used when calling a named template with the xsl:call-template instruction.</p>
          <pre>&lt;xsl:template name="titles"&gt;
  &lt;xsl:param name="headerElement"&gt;h4&lt;/xsl:param&gt;
  &lt;xsl:element name="{$headerElement}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="chapter/title"&gt;
  &lt;xsl:call-template name="titles"&gt;
    &lt;xsl:with-param name="headerElement"&gt;h1&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="sect1/title"&gt;
  &lt;xsl:call-template name="titles"&gt;
    &lt;xsl:with-param name="headerElement" select="'h2'"/&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;p&gt;&lt;xsl:apply-templates/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="chapter"&gt;
  &lt;html&gt;&lt;body&gt;&lt;xsl:apply-templates/&gt;&lt;/body&gt;&lt;/html&gt;
&lt;/xsl:template&gt;</pre>
        </section>
        <section>
          <h3>Declaring Keys To Perform Lookups</h3>
          <p>Keys create a hashtable that enables you to access nodes quickly. They are defined by xsl:key at the top level of the stylesheet. When a key is created, the processor works through the current document, finding all the nodes that match the pattern given in the match attribute of the xsl:key. Each of these nodes is stored in a hashtable and indexed by one or more key values. The key values are identified by evaluating the expression held in the use attribute of the xsl:key for the node as a string. However, if this expression returns a node set, the node is indexed by the string values of each of the nodes, rather than by just the first node in the node set. Using keys can greatly add to the efficiency of your stylesheet. They are also a vital component of some methods for grouping.</p>
          <!-- smallskip -->
          <p>When you need to look up values based on some other value&#x2014;especially when your stylesheet needs to do so a lot&#x2014;XSLT's xsl:key instruction and <code class="function">key()</code> function work together to make it easy. They can also make it fast.</p>
          <p>Given:</p>
          <pre>&lt;shirts&gt;
  &lt;colors&gt;
    &lt;color cid="c1"&gt;yellow&lt;/color&gt;
    &lt;color cid="c2"&gt;black&lt;/color&gt;
    &lt;color cid="c3"&gt;red&lt;/color&gt;
    &lt;color cid="c4"&gt;blue&lt;/color&gt;
    &lt;color cid="c5"&gt;purple&lt;/color&gt;
    &lt;color cid="c6"&gt;white&lt;/color&gt;
    &lt;color cid="c7"&gt;orange&lt;/color&gt;
    &lt;color cid="c7"&gt;green&lt;/color&gt;
  &lt;/colors&gt;

  &lt;shirt colorCode="c4"&gt;oxford button-down&lt;/shirt&gt;
  &lt;shirt colorCode="c1"&gt;poly blend, straight collar&lt;/shirt&gt;
  &lt;shirt colorCode="c6"&gt;monogrammed, tab collar&lt;/shirt&gt;
&lt;/shirts&gt;</pre>
          <p>And we want to produce:</p>
          <pre>blue oxford button-down
yellow poly blend, straight collar
white monogrammed, tab collar</pre>
          <p>So we write a stylesheet like:</p>
          <pre>&lt;xsl:key name="colorNumKey" match="color" use="@cid"/&gt;
&lt;xsl:template match="colors"/&gt;
&lt;xsl:template match="shirt"&gt;
  &lt;xsl:value-of select="key('colorNumKey',@colorCode)"/&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
          <p>The xsl:key element has three attributes:</p>
          <ul>
            <li>The name attribute holds the name of the lookup key. The <code class="function">key()</code> function uses this name to identify what kind of lookup it's doing.</li>
            <li>The match attribute holds a match pattern identifying the collection of nodes where the lookups will take place. In the example, the color elements are this collection. The fact that they are enclosed by a colors element gives the source document a little more structure, but it's not necessary for the key lookups to work. And</li>
            <li>The use attribute specifies the part or parts of the match attribute's collection of nodes that will be used to find the appropriate node&#x2014;in other words, the attribute specifies the index of the lookup. In the example, this index is the cid attribute of the color elements, because a lookup will pass along a color ID string to look up the corresponding color.</li>
          </ul>
          <p>No doubt these color elements would fit nicely into a table, but the beauty of doing so with XSLT (and XML) is that the elements named by your match attribute can have much more complex structures than any relational database table row. You have the full power of XML available, and the ability to use an XPath expression in the use attribute lets you identify any part of that structure you want to use as the lookup key.</p>
          <p>The <code class="function">key()</code> function performs the actual lookup. This function takes a value, searches through the keys for one whose use value equals the one it's looking for, and returns the element or elements that have that key value.</p>
        </section>
      </section>
      <section>
        <h2>XSLT and Entities</h2>
        <p>An example of <em>declaring</em> and <em>using</em> an <a href="#xml_entities">entity</a>:</p>
        <pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE xsl:stylesheet [&lt;!ENTITY netsi "netsi1964@gmail.com"&gt;]&gt;

&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt" exclude-result-prefixes="msxsl"&gt;

  &lt;xsl:output method="xml" indent="no"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;h1&gt;&amp;amp;netsi; bliver til "&amp;netsi;"&lt;/h1&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
        <p>...</p>
      </section>
      <section>
        <h2>XSL Recipes</h2>
        <section>
          <h3>Short Path Snippets</h3>
          <p>Select all chapters whose <code class="tag">title</code> starts with the string <q>C++</q>:</p>
          <pre>&lt;xsl:apply-templates select="chapter[starts-with(title, 'C++')]" /&gt;</pre>
          <p>To select all <code class="tag">chapter</code> elements but the third one:</p>
          <pre>&lt;xsl:apply-templates select="Channel[position() &amp;lt;= 3  or position() &gt;= 5]" /&gt;</pre>
          <p>To select all <code class="tag">chapter</code> elements between the third and the ninth:</p>
          <pre>&lt;xsl:apply-templates select="Channel[position() &gt;= 3  and position() &amp;lt;= 9]" /&gt;</pre>
          <p>or just:</p>
          <pre>&lt;xsl:apply-templates select="Channel[position() = (3 to 9)]" /&gt;</pre>
          <p>The <code class="function">contains()</code> function, like all other functions in XPath, is case-sensitive. You can do a case-insensitive search for a word within a string by making sure both strings use the same case throughout. You can translate elements into lowercase using the <code class="function">lower-case()</code> function:</p>
          <pre>contains(lower-case(title), "HTML")</pre>
          <p>...</p>
          <pre>&lt;xsl:analyze-string select="poem" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br /&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="normalize-space(.)" /&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre>
        </section>
        <section>
          <h3>Copying all Elements with either <code class="tag">copy</code> or <code class="tag">copy-of</code></h3>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml"/&gt;
  &lt;!-- Copy all elements, attributes, and text nodes --&gt;
  &lt;xsl:template match="*|@*|text()|comment()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="*|@*|text()|comment()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
          <p>Much the same, but using <code class="function">copy-of</code>:</p>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml"/&gt;

  &lt;!-- Copy all the other elements and attributes, and text nodes --&gt;
  &lt;xsl:template match="*|@*|text()|comment()"&gt;
     &lt;xsl:copy-of select="."/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
          <p>Not very useful per se, this code is included in other stylesheets.</p>
        </section>
        <section>
          <h3>Excluding Elements Selectively</h3>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml"/&gt;
&lt;xsl:template match="*[@class='private']"&gt; &lt;xsl:comment&gt;private&lt;/xsl:comment&gt; &lt;/xsl:template&gt;
&lt;!-- Copy all the other elements and attributes, and text nodes --&gt;
&lt;xsl:template match="*|@*|text()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="*|@*|text()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
        </section>
        <section>
          <h3>Hiding Elements Selectively</h3>
          <p>You may want to exclude all elements whose <var>class</var> attribule has value <code class="literal">private</code>.</p>
          <pre>&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
&lt;xsl:output method="xml"/&gt;
 &lt;xsl:template match="*[@class='private']"&gt;
    &lt;xsl:comment&gt;
      &lt;xsl:copy-of select="self::*"/&gt;
    &lt;/xsl:comment&gt;
  &lt;/xsl:template&gt;
  &lt;!-- Copy all the other elements and attributes, and text nodes --&gt;
  &lt;xsl:template match="*|@*|text()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="*|@*|text()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
        </section>
        <section>
          <h3>Numbering Chapters Automatically</h3>
          <p>To number the title of each chapter from 1. onwards, add these templates to the copy all template. Notice how the first, short template inhibit ordinary handling of chapter titles.</p>
          <pre>&lt;xsl:template match="chapter/title"/&gt;
&lt;xsl:template match="chapter"&gt;
  &lt;chapter&gt;
    &lt;title&gt;
      &lt;xsl:number format="1. "/&gt; &lt;xsl:value-of select="title" /&gt;
    &lt;/title&gt;
    &lt;xsl:apply-templates /&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;
</pre>
        </section>
        <section>
          <h3>Numbering Chapters and Sections (2 Levels Thereof) Automatically</h3>
          <p>Add these templates to the copy all template and study the code, too:</p>
          <pre>&lt;xsl:template match="chapter/title"/&gt;
&lt;xsl:template match="chapter"&gt;
  &lt;chapter&gt;
    &lt;title&gt;
      &lt;xsl:number format="1. "/&gt; &lt;xsl:value-of select="title" /&gt;
    &lt;/title&gt;
    &lt;xsl:apply-templates /&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="sect1/title"/&gt;
&lt;xsl:template match="sect1"&gt;
  &lt;section&gt;
    &lt;title&gt;
      &lt;xsl:number format="1. " level="multiple" count="chapter|sect1"/&gt;
      &lt;xsl:value-of select="title" /&gt;
    &lt;/title&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/section&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="sect2/title"/&gt;
&lt;xsl:template match="sect2"&gt;
  &lt;section&gt;
    &lt;title&gt;
      &lt;xsl:number format="1. " level="multiple" count="chapter|sect1|sect2"/&gt;
      &lt;xsl:value-of select="title" /&gt;
    &lt;/title&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/section&gt;
&lt;/xsl:template&gt;</pre>
        </section>
        <section>
          <h3>Sorting (a VariableList by Term)</h3>
          <p>A DocBook dl holds varlistentry' each holding a term element and a listitem element. Notice how <q>varlistentry</q> is not mentioned in the code. (Whenever the sorting key is numeric, add <code class="userinput">data-type="number"</code> in the sort opening label.)</p>
          <pre>&lt;xsl:template match="dl"&gt;
  &lt;dl&gt;
  &lt;xsl:apply-templates&gt;
    &lt;xsl:sort select="term" /&gt;
  &lt;/xsl:apply-templates&gt;
  &lt;/dl&gt;
&lt;/xsl:template&gt;</pre>
        </section>
        <section>
          <h3>Generating HTML from XML</h3>
          <pre>&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'&gt;
&lt;xsl:output method='html'
  indent='yes'
  doctype-public='-//W3C//DTD HTML 3.2 Final//EN'/&gt;
&lt;xsl:template match='/'&gt;
  &lt;HTML&gt;
    &lt;HEAD&gt;
      &lt;TITLE&gt;My Document Title&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;</pre>
          <p>And so on...</p>
        </section>
      </section>
      <!-- end of "XSL Recipes" -->
      <section id="xml_to_tex">
        <h2>Converting From (Docbook) XML to TeX</h2>
        <p>We shall be using file <cite class="filename">book.xml</cite> to test our stylesheets on.</p>
        <pre>
          <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/XSLT_code/book.xml" parse="text">
            <xi:fallback/>
          </xi:include>
        </pre>
        <p>We might start from a trivial stylesheet file (<cite class="filename">default.xsl</cite>) that just copies all the text nodes:</p>
        <pre>
          <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/XSLT_code/default.xsl" parse="text">
            <xi:fallback/>
          </xi:include>
        </pre>
        <section>
          <h3>Transforming Entities and Non-Ascii Characters with Sed</h3>
          <p>We want to transform '&#xE1;' to '\'a' and so on. We need a <code class="application">sed</code> script with lines like <code class="userinput">s/&#xE1;/\'a/g</code> and so on. Here is our <code class="application">sed</code> script for your eyes' delight:</p>
          <pre>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/XSLT_code/utf8-to-TeX.sed" parse="text">
              <xi:fallback/>
            </xi:include>
          </pre>
        </section>
        <section>
          <h3>Removing Redundant Space</h3>
          <p>Next, we would add templates that deal with mark up. We want to remove meaningless whitespace with redundant whitespace to be removed through <code class="userinput"><a href="#xslt_space">normalize-space()</a></code>, as well as printing titles in bold fonts, em in italic, etc. Last, the output must end with <code class="userinput">\bye</code>:</p>
          <pre>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/XSLT_code/xml_to_tex/xml_to_tex.01.xsl" parse="text">
              <xi:fallback/>
            </xi:include>
          </pre>
        </section>
        <section>
          <h3>Numbering Chapters Headers</h3>
          <p>Besides numbering chapters and headers, the <cite class="filename">xml_to_tex.02.xsl</cite> stylesheet also:</p>
          <ul>
            <li>handles several inline and block elements,</li>
            <li>handles mathematical formulas where the TeX code has been included inside a <code class="userinput">alt</code> element: <code class="classname">equation</code>, <code class="classname">inlineequation</code>, and <code class="classname">informalequation</code>, although equation numbering has not been implemented yet.</li>
          </ul>
          <pre>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/XSLT_code/xml_to_tex/xml_to_tex.02.xsl" parse="text">
              <xi:fallback/>
            </xi:include>
          </pre>
        </section>
        <section>
          <h3>Handling Mathematical Formulas</h3>
          <p>This is actually done by <cite class="filename">xml_to_tex.mathematical.xsl</cite>, which presumably is included by <cite class="filename">Electric_files/XSLT_code/xml_to_tex.02.xsl</cite>. Here is a listing of <cite class="filename">xml_to_tex.mathematical.xsl</cite></p>
          <pre>&lt;xi:include href="Electric_files/XSLT_code/xml_to_tex/xml_to_tex.mathematical.xsl" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
          &lt;xi:fallback/&gt;
        &lt;/xi:include&gt;</pre>
        </section>
        <section>
          <h3>The Trouble with Backslashes and Other Characters ('^', '_', '$', '#', '&amp;', '%', '~', '{', '}'...)</h3>
          <p>Now, if we translate all the backslashes <q>\</q> in the original to the sequence <q>\backslash</q>, then we cannot supply TeX code in, say, mathematical elements, or other TeX code containing long TeX commands, such as <q>\obeylines</q>.</p>
          <aside class="note"><strong>Note.</strong> This problem can be generalized to the other TeX specific characters: '^', '_', '$', '#', '&amp;'...</aside>
          <p>We need a method to prevent translating backslashes in xml whenever they are in a given element.</p>
          <p>One solution using existing tools is to translate all backslash characters inside an <code class="classname">alt</code> elements to another, non-TeX character, such as <q>&#x20AC;</q>, then translating it back to a backslash. Use function <code class="function"><a href="#xslt_translate">translate(<var>s</var>, <var>s<sub>origin</sub></var>, <var>s<sub>dest</sub></var>)</a></code>.</p>
          <aside class="note"><strong>Note.</strong> We must choose a stand-in character that is neither translated by our sed script nor is found in TeX mathematical formulas. Therefore, forget accented ('&#xE1;', '&#xF1;' etc), '&#xBF;' etc. We need something absolutely <em>unused</em>. On a linux machine I use handy <code class="userinput">Alt Gr</code> characters: '&#x20AC;', '&#xF8;', '&#xFE;', '&#x167;', '&#x142;', etc.</aside>
          <p>Here is a file that realizes this:</p>
          <pre>
            <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Electric_files/XSLT_code/borrowed_or_pro/escape_backslash_in_alt.xsl" parse="text">
              <xi:fallback/>
            </xi:include>
          </pre>
          <p>Next, we could write a reverse transformation file (<cite class="filename">unescape_backslash_in_alt</cite>) where <code class="userinput">'\'</code> and <code class="userinput">'&#x20AC;'</code> are exchanged.</p>
          <p>The procedure then is:</p>
          <ul>
            <li>change all backslashes in <code class="classname">alt</code> sections to an un-TeX character, such as '&#x20AC;'</li>
            <li>translate all characters through <code class="application">sed</code> and <cite class="filename">utf8-to-TeX.sed</cite></li>
            <li>revert all backslash substitutions in <code class="classname">alt</code> sections to '\'</li>
            <li>transform to TeX through stylesheet <cite class="filename">xml_to_tex.02.xsl</cite> or some higher version</li>
            <li>process your result through application <code class="application">tex</code> or some other means</li>
          </ul>
        </section>
        <!-- end of "The Trouble with Backslashes and Other Meaningful Characters" -->
        <section>
          <h3>Handling Lists, aka <code class="classname">itemizedlist</code>'''s*</h3>
          <p>This is a primitive template to handle lists:</p>
          <pre>&lt;xsl:template match="listitem"&gt;
    $\bullet$ &lt;xsl:apply-templates/&gt;

  &lt;/xsl:template&gt;</pre>
          <p>The problem remains of <q>\bullet</q> getting mangled to <q>\backslash bullet</q> by the sed script. One solution is for the XSLT transformation to use an euro sign instead of a backslash, i.e. <q>&#x20AC;bullet</q>, and then have another sed script to translate all euro signs back to slashes.</p>
          <p>Actually, we should do the same for all TeX commands introduced by the XSLT translation. In reverting the backslash substitutions, we no longer select for text in <code class="classname">alt</code> elements. The procedure now comprises the following steps:</p>
          <ul>
            <li>change all backslashes in <code class="classname">alt</code> sections to an un-TeX character, such as '&#x20AC;'</li>
            <li>translate all characters through <code class="application">sed</code> and <cite class="filename">utf8-to-TeX.sed</cite></li>
            <li>revert all backslash substitutions (not necessarily only those in <code class="classname">alt</code> sections) to '\'</li>
            <li>transform to TeX through stylesheet <cite class="filename">xml_to_tex.02.xsl</cite> or some higher version</li>
            <li>process your result through application <code class="application">tex</code> or some other means</li>
          </ul>
        </section>
      </section>
    </main>
  </body>
</html>
