<?xml version="1.0"?>
<!DOCTYPE html>
<html>
  <head>
    <title>the boost graph library (bgl)</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" type="text/css" href="stylesheet.en.css"/>
    <!--
    <meta name="keywords" content="KW1, KW2, KW3"/>

    <meta name="author" content="AUTHOR"/>
    <meta name="description" content="A_DESCRIPTION"/>
    <meta name="FIELD_NAME" content="FIELD_VALUE"/>

    <link rel="alternate" hreflang="x-default" href="http://www.example.com/"/>
    <link rel="alternate" hreflang="es" href="http://es.example.com/"/>
    <link rel="alternate" hreflang="de" href="http://de.example.com/"/>

    <link rel="author" href="https://plus.google.com/ExampleProfile"/>
    <link rel="license" href="https://creativecommons.org/licenses/by/4.0/"/>

    TODO's:

    (1) Store the following images in an accessible directory:
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_directed.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_directed.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_undirected.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_spanning_tree.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_Dijkstra.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_Kruskal.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/start_BGL_max_flow.jpg
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/analogy_STL_BGF.gif
~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/Computing/directed_graph_example.gif

    and change path accordingly, for instance change:
      ~/former/home/francisco/Documents/mis_escritos/precious/psimple/Electric_files/pictures/
    to
      ./pictures/

    (2) transform into HTML:
 <mediaobject>
   <imageobject>
     <img alt='(no image found!)' format='JPEG' src='../../Electric_files/pictures/Computing/start_BGL_directed.jpg'/>
   </imageobject>
 </mediaobject>
    -->
  </head>
  <body lang="en" class="computing">
    <nav>
    <!--
      <p><a href="A_PAGE.html">LINK_TEXT</a></p>
      <p><a href="ANOTHER_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="prev" href="PREVIOUS_PAGE.html">LINK_TEXT</a></p>
      <p><a rel="next" href="NEXT_PAGE.html">LINK_TEXT</a></p>
      -->
    </nav>

    <main>
      <h1>The Boost Graph Library (BGL)</h1>
      <p><a href="graphs">Graphs</a> are mathematical abstractions that are useful for solving many types of problems in computer science. Consequently, these abstractions must also be represented in computer programs. A standardized generic interface for traversing graphs is of utmost importance to encourage reuse of graph algorithms and data structures. Part of the Boost Graph Library is a generic interface that allows access to a graph's structure, but hides the details of the implementation. This is an <em>open</em> interface in the sense that any graph library that implements this interface will be interoperable with the BGL generic algorithms and with other algorithms that also use this interface. The BGL provides some general purpose graph classes that conform to this interface, but they are not meant to be the <em>only</em> graph classes. There certainly will be other graph classes that are better for certain situations. The main contribution of the The BGL is the formulation of this interface.</p>
      <p><a href="cpp_templates">Generic programming</a> is the methodology that was used in the construction of the Boost Graph Library. To understand the organization and structure of the BGL, the reader needs a good understanding of generic programming.</p>
      <note>The Boost Graph Library is a header-only library and does not need to be built to be used.</note>

      <section id="genericity_in_bgl">
        <h2>Genericity in the Boost Graph Library</h2>
        <p>Just as with <a href="genericity_in_stl">STL's genericity</a>, there are three ways in which the BGL is generic.</p>
        <dl>
          <div class="varlistentry">
            <dt class="term">Algorithm/Data-Structure Interoperability</dt>
            <dd>
              <p>First, the graph algorithms of the BGL are written to an interface that abstracts away the details of the particular graph data-structure. Like the STL, the BGL uses <a href="iterators">iterators</a> to define the interface for data-structure traversal. There are three distinct graph traversal patterns: traversal of all vertices in the graph, through all of the edges, and along the adjacency structure of the graph (from a vertex to each of its neighbors). There are separate iterators for each pattern of traversal.</p>
              <p>This generic interface allows template functions such as breadth_first_search() to work on a large variety of graph data-structures, from graphs implemented with pointer-linked nodes to graphs encoded in arrays. This flexibility is especially important in the domain of graphs. Graph data-structures are often custom-made for a particular application. Traditionally, if programmers want to reuse an algorithm implementation they must convert/copy their graph data into the graph library's prescribed graph structure, which severely limits the reuse of graph algorithms.</p>
              <p>In contrast, custom-made (or even legacy) graph structures can be used as-is with the generic graph algorithms of the BGL, using <a href="bgl_external_adaptation">external adaptation</a>, which consistes of wrapping a new interface around a data-structure without copying and without placing the data inside adaptor objects. The BGL interface was carefully designed to make this adaptation easy.</p>
            </dd>
          </div>
          <div class="varlistentry">
            <dt class="term">Extension through Visitors</dt>
            <dd>
              <p>Second, the graph algorithms of the BGL are extensible. The BGL introduces the notion of a <dfn>visitor</dfn>, which is just a function object with multiple methods. In graph algorithms, there are often several key <dfn>event points</dfn> at which it is useful to insert user-defined operations. The visitor object has a different method that is invoked at each event point. The particular event points and corresponding visitor methods depend on the particular algorithm. They often include methods like start_vertex(), discover_vertex(), examine_edge(), tree_edge(), and finish_vertex().</p>
            </dd>
          </div>
          <div class="varlistentry">
            <dt class="term">Vertex and Edge Property Multi-Parameterization</dt>
            <dd>
              <p>The third way that the BGL is generic is analogous to the parameterization of the element-type in STL containers, though again the story is a bit more complicated for graphs. We need to associate values (called <q>properties</q>) with both the vertices and the edges of the graph. In addition, it will often be necessary to associate multiple properties with each vertex and edge; this is what we mean by multi-parameterization. The STL <code>std::list&lt;T&gt;</code> class has a parameter <var>T</var> for its element type. Similarly, BGL graph classes have template parameters for vertex and edge <q>properties</q>. A property specifies the parameterized type of the property and also assigns an identifying tag to the property. This tag is used to distinguish between the multiple properties which an edge or vertex may have. A property value that is attached to a particular vertex or edge can be obtained via a <a href="bgl_property_map">property map</a>. There is a separate property map for each property.</p>
              <p>Traditional graph libraries and graph structures fall down when it comes to the parameterization of graph properties. This is one of the primary reasons that graph data-structures must be custom-built for applications. The parameterization of properties in the BGL graph classes makes them well suited for re-use.</p>
            </dd>
          </div>
        </dl>
      </section>  <!-- end of "Genericity in the Boost Graph Library" -->

      <section>
        <header>
          <h3>Getting started with the Boost Graph Library</h3>
          <!-- https://www.technical-recipes.com/2015/getting-started-with-the-boost-graph-library/ -->
        </header>
        <section>
          <h3>Introduction</h3>
          <p>Some simple walk-throughs on how to use the Boost Graph Library. I find much of the documentation, both online and printed, to be a bit impenetrable. I am sure I am not alone, so I thought it might be worthwhile to post a few examples of its usage that actually compile and work (for me anyway, let me know if you see any problems) as well as being reasonably up to date.</p>
          <p>The Boost Graph Library is a header-only library that requires no separate compilation.</p>
          <p>All that is usually required is to set the location of the additional include directories in your integrated development environment (IDE) and you're ready to go. In Microsoft Visual Studio for example, just set the location of the Boost Library path in C/C++ &gt; General &gt; Additional Include Directories.</p>
          <p>If you are developing in a Linux-based environment and have already installed Boost, there is good chance you don't need to do anything else.</p>
          <p>Shortcuts to examples covered in this boost graph library tutorial are as follows:</p>
          <ul>
            <li href="start_BGL_1">Creating a directed graph</li>
            <li href="start_BGL_2">Creating an undirected graph</li>
            <li href="start_BGL_3">Print edge weights in undirected graphs</li>
            <li href="start_BGL_4">Finding paths using Dijkstra's shortest path algorithm</li>
            <li href="start_BGL_5">Finding minimal spanning trees using Kruskal's algorithm</li>
            <li href="start_BGL_6">DIMACS maximum flow problems</li>
          </ul>
        </section>

        <section id="start_BGL_1">
          <h3>Creating a directed graph</h3>
          <p>The first thing you probably need to learn coding-wise, is the use of the adjacency list to create the graph edge connections. It's probably worthwhile getting used to making liberal use of typedefs, given that Boost library declarations can end up somewhat lengthy.</p>
          <p>To declare an adjacency list for a directed graph for example:</p>
          <pre>typedef boost::adjacency_list&lt;boost::vecS, boost::vecS, boost::directedS&gt; DirectedGraph;</pre>
          <p>Suppose we wish to build the following weighted directed graph:</p>
          <!-- <mediaobject> -->
            <!-- <imageobject> -->
              <img alt="(no image found!)" format="JPEG" src="./pictures/Computing/start_BGL_directed.jpg"/>
            <!-- </imageobject> -->
          <!-- </mediaobject> -->
          <p>We can do this by making repeated calls to add_edge to create the graph. The following code listing shows you how, and prints out the result:</p>
          <pre>#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;iostream&gt;

typedef boost::property&lt;boost::edge_weight_t, int&gt; EdgeWeightProperty;
typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS, boost::no_property, EdgeWeightProperty &gt; DirectedGraph;
typedef boost::graph_traits&lt;DirectedGraph&gt;::edge_iterator edge_iterator;

int main()
{
    DirectedGraph g;

    boost::add_edge (0, 1, 8, g);
    boost::add_edge (0, 3, 18, g);
    boost::add_edge (1, 2, 20, g);
    boost::add_edge (2, 3, 2, g);
    boost::add_edge (3, 1, 1, g);
    boost::add_edge (1, 3, 7, g);
    boost::add_edge (1, 4, 1, g);
    boost::add_edge (4, 5, 6, g);
    boost::add_edge (2, 5, 7, g);

    std::pair&lt;edge_iterator, edge_iterator&gt; ei = edges(g);

    std::cout &lt;&lt; "Number of edges = " &lt;&lt; num_edges(g) &lt;&lt; "\n";
    std::cout &lt;&lt; "Edge list:\n";

    std::copy( ei.first, ei.second,
                std::ostream_iterator&lt;boost::adjacency_list&lt;&gt;::edge_descriptor&gt;{
                    std::cout, "\n"});

    std::cout &lt;&lt; std::endl;

    return 0;
 }</pre>
          <p>...</p>
        </section>

        <section id="start_BGL_2">
          <h3>Creating an undirected graph</h3>
          <p>Consider the following undirected graph:</p>
          <!-- <mediaobject> -->
            <!-- <imageobject> -->
              <img alt="(no image found!)" format="JPEG" src="./pictures/Computing/start_BGL_undirected.jpg"/>
            <!-- </imageobject> -->
          <!-- </mediaobject> -->
          <p>Which we build in a similar way, but this time stipulating the use of the boost::undirectedS property:</p>
          <pre>#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;iostream&gt;

typedef boost::property&lt;boost::edge_weight_t, int&gt; EdgeWeightProperty;
typedef boost::adjacency_list&lt;boost::listS, boost::vecS,boost::undirectedS,boost::no_property,EdgeWeightProperty&gt; UndirectedGraph;
typedef boost::graph_traits&lt;UndirectedGraph&gt;::edge_iterator edge_iterator;

int main()
{
    UndirectedGraph g;

    boost::add_edge (0, 1, 8, g);
    boost::add_edge (0, 3, 18, g);
    boost::add_edge (1, 2, 20, g);
    boost::add_edge (2, 3, 2, g);
    boost::add_edge (1, 3, 7, g);
    boost::add_edge (1, 4, 1, g);
    boost::add_edge (4, 5, 6, g);
    boost::add_edge (2, 5, 7, g);

    std::pair&lt;edge_iterator, edge_iterator&gt; ei = edges(g);

    std::cout &lt;&lt; "Number of edges = " &lt;&lt; num_edges(g) &lt;&lt; "\n";
    std::cout &lt;&lt; "Edge list:\n";

    for (edge_iterator it = ei.first; it != ei.second; ++it )
    {
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; std::endl;

    return 0;
 }</pre>
          <p>...</p>
        </section>

        <section id="start_BGL_3">
          <h3>Print edge weights in undirected graphs</h3>
          <p>Consider the following spanning tree:</p>
          <!-- <mediaobject> -->
            <!-- <imageobject> -->
              <img alt="(no image found!)" format="JPEG" src="./pictures/Computing/start_BGL_spanning_tree.jpg"/>
            <!-- </imageobject> -->
          <!-- </mediaobject> -->
          <p>You may obtain the mapping between edges and their respective weights by using the <code>boost_property_map</code>:</p>
          <pre></pre>
          <p>And the full code listing is:</p>
          <pre>#include &lt;iostream&gt;
#include &lt;boost/graph/graph_traits.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;

typedef boost::property&lt;boost::edge_weight_t, double&gt; EdgeWeight;
typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, boost::no_property, EdgeWeight&gt; UndirectedGraph;
typedef boost::graph_traits&lt;UndirectedGraph&gt;::edge_iterator edge_iterator;

int main(int, char*[])
{
    // 1. Undirected graph - print out the edge weights
    UndirectedGraph g;

    boost::add_edge(0, 1, 8, g);
    boost::add_edge(0, 5, 2, g);
    boost::add_edge(5, 6, 1, g);
    boost::add_edge(4, 5, 5, g);
    boost::add_edge(3, 5, 7, g);

    boost::property_map&lt;UndirectedGraph, boost::edge_weight_t&gt;::type EdgeWeightMap = get(boost::edge_weight_t(), g);

    std::pair&lt;edge_iterator, edge_iterator&gt; edgePair;
    for (edgePair = edges(g); edgePair.first != edgePair.second; ++edgePair.first)
    {
        std::cout &lt;&lt; *edgePair.first &lt;&lt; " " &lt;&lt; EdgeWeightMap[*edgePair.first] &lt;&lt; std::endl;
    }

    return 0;
}</pre>
          <p>...</p>
        </section>

        <section id="start_BGL_4">
          <h3>Finding paths using Dijkstra's shortest path algorithm</h3>
          <p>The same <cite>dijkstra-example.cpp</cite> as used at the following link: http://www.boost.org/doc/libs/1_55_0/libs/graph/example/dijkstra-example.cpp</p>
          <p>Here is the graphical representation of <cite>dijkstra-example</cite> example graph:</p>
          <!-- <mediaobject> -->
            <!-- <imageobject> -->
              <img alt="(no image found!)" format="JPEG" src="./pictures/Computing/start_BGL_Dijkstra.jpg"/>
            <!-- </imageobject> -->
          <!-- </mediaobject> -->
          <p>In this demonstration we use the dijkstra_shortest_paths method to obtain not only the shortest path tree, but output the path between a selected source-destination pair as well.</p>
          <pre>#include &lt;boost/config.hpp&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;boost/graph/graph_traits.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;
#include &lt;boost/property_map/property_map.hpp&gt;

int main(int, char *[])
{
  typedef boost::adjacency_list &lt;boost::listS, boost::vecS, boost::directedS, boost::no_property,
      boost::property&lt;boost::edge_weight_t, int&gt; &gt; graph_t;
  typedef boost::graph_traits&lt;graph_t&gt;::vertex_descriptor vertex_descriptor;
  typedef std::pair&lt;int, int&gt; Edge;

  const int num_nodes = 5;
  enum nodes { A, B, C, D, E };
  char name[] = "ABCDE";
  Edge edge_array[] = { Edge(A, C), Edge(B, B), Edge(B, D), Edge(B, E),
    Edge(C, B), Edge(C, D), Edge(D, E), Edge(E, A), Edge(E, B)
  };

  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1 };
  int num_arcs = sizeof(edge_array) / sizeof(Edge);

  // Graph created from the list of edges
  graph_t g(edge_array, edge_array + num_arcs, weights, num_nodes);

  // Create property_map from edges to weights
  boost::property_map&lt;graph_t, boost::edge_weight_t&gt;::type weightmap = get(boost::edge_weight, g);

  // Create vectors to store the predecessors (p) and the distances from the root (d)
  std::vector&lt;vertex_descriptor&gt; p(num_vertices(g));
  std::vector&lt;int&gt; d(num_vertices(g));

  // Create descriptor for the source node
  vertex_descriptor s = vertex(A, g);
  vertex_descriptor goal = vertex(E, g);

  // Evaluate Dijkstra on graph g with source s, predecessor_map p and distance_map d
  boost::dijkstra_shortest_paths(g, s,
      boost::predecessor_map(&amp;p[0]).distance_map(&amp;d[0]));

        //p[] is the predecessor map obtained through dijkstra
    //name[] is a vector with the names of the vertices
    //s and goal are vertex descriptors
    std::vector&lt;boost::graph_traits&lt;graph_t&gt;::vertex_descriptor &gt; path;
    boost::graph_traits&lt;graph_t&gt;::vertex_descriptor current = goal;

    while(current!=s)
    {
        path.push_back(current);
        current = p[current];
    }
    path.push_back(s);

    // Prints the path obtained in reverse
    std::cout &lt;&lt; "Path from " &lt;&lt; name[s] &lt;&lt; " to " &lt;&lt; name[goal] &lt;&lt; std::endl;
    std::vector&lt;boost::graph_traits&lt;graph_t&gt;::vertex_descriptor &gt;::reverse_iterator it;

    for (it = path.rbegin(); it != path.rend(); ++it) {
        std::cout &lt;&lt; name[*it] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;

  return EXIT_SUCCESS;
}</pre>

        </section>
        <section id="start_BGL_5">
          <h3>Finding minimal spanning trees using Kruskal's algorithm</h3>
          <p>Again I take an original example from the boost.org site (<cite>http://www.boost.org/doc/libs/1_55_0/libs/graph/example/kruskal-example.cpp</cite>) and make use of it here.</p>
          <p>This is the graphical representation of example graph:</p>
          <!-- <mediaobject> -->
            <!-- <imageobject> -->
              <img alt="(no image found!)" format="JPEG" src="./pictures/Computing/start_BGL_Kruskal.jpg"/>
            <!-- </imageobject> -->
          <!-- </mediaobject> -->
          <p>I have removee the Boost workarounds (BOOST_MSVC &lt;= 1300 etc) and the outputting to the .dot file just to keep things more concise. I have also removed use of the <kbd class="userinput">using boost namespace</kbd> in my examples, but that's just a personal preference:</p>
          <pre>#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/kruskal_min_spanning_tree.hpp&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main()
{
  typedef boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::undirectedS,
    boost::no_property, boost::property&lt;boost::edge_weight_t, int&gt; &gt; Graph;

  typedef boost::graph_traits &lt;Graph&gt;::edge_descriptor Edge;
  typedef boost::graph_traits &lt;Graph&gt;::vertex_descriptor Vertex;
  typedef std::pair&lt;int, int&gt; E;

  const int num_nodes = 5;
  E edge_array[] = { E(0, 2), E(1, 3), E(1, 4), E(2, 1), E(2, 3),
    E(3, 4), E(4, 0), E(4, 1)
  };

  int weights[] = { 1, 1, 2, 7, 3, 1, 1, 1 };
  std::size_t num_edges = sizeof(edge_array) / sizeof(E);

  Graph g(edge_array, edge_array + num_edges, weights, num_nodes);

  boost::property_map&lt;Graph, boost::edge_weight_t &gt;::type weight = get(boost::edge_weight, g);
  std::vector &lt; Edge &gt; spanning_tree;

  boost::kruskal_minimum_spanning_tree(g, std::back_inserter(spanning_tree));

  std::cout &lt;&lt; "Print the edges in the MST:" &lt;&lt; std::endl;

  for (std::vector &lt; Edge &gt;::iterator ei = spanning_tree.begin();
        ei != spanning_tree.end(); ++ei)
  {
    std::cout &lt;&lt; source(*ei, g)
              &lt;&lt; " &lt;--&gt; "
              &lt;&lt; target(*ei, g)
              &lt;&lt; " with weight of "
              &lt;&lt; weight[*ei]
              &lt;&lt; std::endl;
  }

  return 0;
}</pre>
          <p>...</p>
        </section>

        <section id="start_BGL_6">
          <h3>DIMACS maximum flow problems</h3>
          <p>DIMACS (Center for Discrete Mathematics and Theoretical Computer Science has formulated 'challenges' for problems involving network flows. See this link for more information: http://lpsolve.sourceforge.net/5.5/DIMACS_maxf.htm</p>
          <p>The problem is to find the maximum possible flow from a given source node to a given sink node. Possible applications include finding the maximum flow of orders through a job shop, the maximum flow of water through a storm sewer system, and the maximum flow of product through a product distribution system.</p>
          <p>Example DIMACS file:</p>
          <pre>c This is a simple example file to demonstrate the DIMACS
c input file format for maximum flow problems. The solution
c vector is [5,10,5,0,5,5,10,5] with cost at 15.
c Problem line (nodes, links)
p max 6 8
c source
n 1 s
c sink
n 6 t
c Arc descriptor lines (from, to, capacity)
a 1 2 5
a 1 3 15
a 2 4 5
a 2 5 5
a 3 4 5
a 3 5 5
a 4 6 15
a 5 6 5
c
c End of file</pre>
          <p>The lines beginning with <q>c</q> are comment lines. The problem line begins with the letter <q>p</q> and represents the problem designation (max, min etc), the number of edges (8) and the number of vertices (6). Lines beginning with <q>n</q> are the node descriptors &#x2013; node ID and whether the node is a source (<q>s</q>) or a sink (<q>t</q>). Finally the <q>a</q> lines are descriptors giving the node interconnections and their weights.</p>
          <p>The following graphical representation of the example network flow problem, shows not only the network interconnections and capacities but the flows on the links as well:</p>
          <!-- <mediaobject> -->
            <!-- <imageobject> -->
              <img alt="(no image found!)" format="JPEG" src="./pictures/Computing/start_BGL_max_flow.jpg"/>
            <!-- </imageobject> -->
          <!-- </mediaobject> -->
          <p>Code listing as applied to this problem (you have to supply it your sample DICOM file as described previously):</p>
          <pre>#include &lt;boost/config.hpp&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

#include &lt;boost/graph/edmonds_karp_max_flow.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/read_dimacs.hpp&gt;
#include &lt;boost/graph/graph_utility.hpp&gt;

int main()
{
    typedef boost::adjacency_list_traits&lt;boost::vecS, boost::vecS, boost::directedS &gt; Traits;
    typedef boost::adjacency_list&lt;boost::listS, boost::vecS, boost::directedS,
        boost::property&lt;boost::vertex_name_t, std::string &gt;,
        boost::property&lt;boost::edge_capacity_t, long,
        boost::property&lt;boost::edge_residual_capacity_t, long,
        boost::property&lt;boost::edge_reverse_t, Traits::edge_descriptor&gt;&gt;&gt;&gt; Graph;

    Graph g;

    boost::property_map&lt;Graph, boost::edge_capacity_t&gt;::type
        capacity = get(boost::edge_capacity, g);
    boost::property_map&lt;Graph, boost::edge_reverse_t&gt;::type rev = get(boost::edge_reverse, g);
    boost::property_map&lt;Graph, boost::edge_residual_capacity_t&gt;::type
        residual_capacity = get(boost::edge_residual_capacity, g);

    Traits::vertex_descriptor s, t;

    // Use a DIMACS network flow file as stdin:
    std::ifstream is ("dimacs.txt", std::ios::in);
    read_dimacs_max_flow(g, capacity, rev, s, t, is);

#if defined(BOOST_MSVC) &amp;&amp; BOOST_MSVC &lt;= 1300
  std::vector&lt;default_color_type&gt; color(num_vertices(g));
  std::vector&lt;Traits::edge_descriptor&gt; pred(num_vertices(g));
  long flow = edmunds_karp_max_flow
    (g, s, t, capacity, residual_capacity, rev, &amp;color[0], &amp;pred[0]);
#else
  long flow = edmonds_karp_max_flow(g, s, t);
#endif

    std::cout &lt;&lt; "c  The total flow:" &lt;&lt; std::endl;
    std::cout &lt;&lt; "s " &lt;&lt; flow &lt;&lt; std::endl &lt;&lt; std::endl;
    std::cout &lt;&lt; "c flow values:" &lt;&lt; std::endl;

    boost::graph_traits&lt;Graph&gt;::vertex_iterator u_iter, u_end;
    boost::graph_traits&lt;Graph&gt;::out_edge_iterator ei, e_end;

    for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter)
        for (boost::tie(ei, e_end) = out_edges(*u_iter, g); ei != e_end; ++ei)
            if (capacity[*ei] &gt; 0)
                std::cout &lt;&lt; "f " &lt;&lt; *u_iter &lt;&lt; " " &lt;&lt; target(*ei, g) &lt;&lt; " "
                          &lt;&lt; (capacity[*ei] - residual_capacity[*ei])
                          &lt;&lt; std::endl;

    return EXIT_SUCCESS;
}</pre>
          <p>As anticipated the solution vector of the output variables is [5, 10, 5, 0, 5, 5, 10, 5].</p>
          <p>Example DIMACS file &#x201C;dimacs.txt&#x201D; downloadable from here: http://www.technical-recipes.com/Downloads/dimacs.txt</p>
        </section>

      </section>

      <section>
        <header>
          <h3>A Quick Tour of the Boost Graph Library</h3>
        </header>
        <p>The domain of graph data structures and algorithms is in some respects more complicated than that of containers. The abstract iterator interface used by STL is not sufficiently rich to encompass the numerous ways that graph algorithms may traverse a graph. Instead, we formulate an abstract interface that serves the same purpose for graphs that iterators do for basic containers (though iterators still play a large role). The figure below depicts the analogy between the STL and the BGL.</p>
        <!-- <mediaobject> -->
          <!-- <imageobject> -->
            <img alt="(no image found!)" format="GIF" src="./pictures/Computing/analogy_STL_BGF.gif"/>
          <!-- </imageobject> -->
          <caption>The analogy between the STL and the BGL.</caption>
        <!-- </mediaobject> -->
        <p>The graph abstraction consists of a set of vertices (or nodes), and a set of edges (or arcs) that connect the vertices. The next figure depicts a directed graph with five vertices (labeled 0 through 4) and 11 edges. The edges leaving a vertex are called the <dfn>out-edges</dfn> of the vertex. The edges {(0,1),(0,2),(0,3),(0,4)} are all out-edges of vertex 0. The edges entering a vertex are called the <dfn>in-edges</dfn> of the vertex. The edges {(0,4),(2,4),(3,4)} are all in-edges of vertex 4.</p>
        <!-- <mediaobject> -->
          <!-- <imageobject> -->
            <img alt="(no image found!)" format="GIF" src="./pictures/Computing/directed_graph_example.gif"/>
          <!-- </imageobject> -->
          <caption>The analogy between the STL and the BGL.</caption>
        <!-- </mediaobject> -->
        <p>In the following sections we will use the BGL to construct this example graph and manipulate it in various ways. The complete source code for this example can be found as <cite href="BGL_quick_tour_cpp">BGL_quick_tour.cpp</cite>. Each of the following sections discusses a slice of this example file. Excerpts from the output of the example program will also be listed.</p>

        <pre id="BGL_quick_tour_cpp">//=======================================================================
// Copyright 1997, 1998, 1999, 2000 University of Notre Dame.
// Authors: Andrew Lumsdaine, Lie-Quan Lee, Jeremy G. Siek
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//=======================================================================

#include &lt;boost/config.hpp&gt;
#include &lt;iostream&gt;                         // for std::cout
#include &lt;utility&gt;                          // for std::pair
#include &lt;algorithm&gt;                        // for std::for_each
#include &lt;boost/utility.hpp&gt;                // for boost::tie
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/graphviz.hpp&gt;

using namespace boost;

template &lt;class Graph&gt; struct exercise_vertex {
  exercise_vertex(Graph&amp; g_, const char name_[]) : g(g_),name(name_) { }
  typedef typename graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
  void operator()(const Vertex&amp; v) const
  {
    using namespace boost;
    typename property_map&lt;Graph, vertex_index_t&gt;::type
      vertex_id = get(vertex_index, g);
    std::cout &lt;&lt; "vertex: " &lt;&lt; name[get(vertex_id, v)] &lt;&lt; std::endl;

    // Write out the outgoing edges
    std::cout &lt;&lt; "\tout-edges: ";
    typename graph_traits&lt;Graph&gt;::out_edge_iterator out_i, out_end;
    typename graph_traits&lt;Graph&gt;::edge_descriptor e;
    for (boost::tie(out_i, out_end) = out_edges(v, g);
         out_i != out_end; ++out_i)
    {
      e = *out_i;
      Vertex src = source(e, g), targ = target(e, g);
      std::cout &lt;&lt; "(" &lt;&lt; name[get(vertex_id, src)]
                &lt;&lt; "," &lt;&lt; name[get(vertex_id, targ)] &lt;&lt; ") ";
    }
    std::cout &lt;&lt; std::endl;

    // Write out the incoming edges
    std::cout &lt;&lt; "\tin-edges: ";
    typename graph_traits&lt;Graph&gt;::in_edge_iterator in_i, in_end;
    for (boost::tie(in_i, in_end) = in_edges(v, g); in_i != in_end; ++in_i)
    {
      e = *in_i;
      Vertex src = source(e, g), targ = target(e, g);
      std::cout &lt;&lt; "(" &lt;&lt; name[get(vertex_id, src)]
                &lt;&lt; "," &lt;&lt; name[get(vertex_id, targ)] &lt;&lt; ") ";
    }
    std::cout &lt;&lt; std::endl;

    // Write out all adjacent vertices
    std::cout &lt;&lt; "\tadjacent vertices: ";
    typename graph_traits&lt;Graph&gt;::adjacency_iterator ai, ai_end;
    for (boost::tie(ai,ai_end) = adjacent_vertices(v, g);  ai != ai_end; ++ai)
      std::cout &lt;&lt; name[get(vertex_id, *ai)] &lt;&lt;  " ";
    std::cout &lt;&lt; std::endl;
  }
  Graph&amp; g;
  const char *name;
};


int main(int,char*[])
{
  // create a typedef for the Graph type
  typedef adjacency_list&lt;vecS, vecS, bidirectionalS,
     no_property, property&lt;edge_weight_t, float&gt; &gt; Graph;

  // Make convenient labels for the vertices
  enum { A, B, C, D, E, N };
  const int num_vertices = N;
  const char name[] = "ABCDE";

  // writing out the edges in the graph
  typedef std::pair&lt;int,int&gt; Edge;
  Edge edge_array[] =
  { Edge(A,B), Edge(A,D), Edge(C,A), Edge(D,C),
    Edge(C,E), Edge(B,D), Edge(D,E), };
  const int num_edges = sizeof(edge_array)/sizeof(edge_array[0]);

  // average transmission delay (in milliseconds) for each connection
  float transmission_delay[] = { 1.2, 4.5, 2.6, 0.4, 5.2, 1.8, 3.3, 9.1 };

  // declare a graph object, adding the edges and edge properties
#if defined(BOOST_MSVC) &amp;&amp; BOOST_MSVC &lt;= 1300
  // VC++ can't handle the iterator constructor
  Graph g(num_vertices);
  property_map&lt;Graph, edge_weight_t&gt;::type weightmap = get(edge_weight, g);
  for (std::size_t j = 0; j &lt; num_edges; ++j) {
    graph_traits&lt;Graph&gt;::edge_descriptor e; bool inserted;
    boost::tie(e, inserted) = add_edge(edge_array[j].first, edge_array[j].second, g);
    weightmap[e] = transmission_delay[j];
  }
#else
  Graph g(edge_array, edge_array + num_edges,
          transmission_delay, num_vertices);
#endif

  boost::property_map&lt;Graph, vertex_index_t&gt;::type
    vertex_id = get(vertex_index, g);
  boost::property_map&lt;Graph, edge_weight_t&gt;::type
    trans_delay = get(edge_weight, g);

  std::cout &lt;&lt; "vertices(g) = ";
  typedef graph_traits&lt;Graph&gt;::vertex_iterator vertex_iter;
  std::pair&lt;vertex_iter, vertex_iter&gt; vp;
  for (vp = vertices(g); vp.first != vp.second; ++vp.first)
    std::cout &lt;&lt; name[get(vertex_id, *vp.first)] &lt;&lt;  " ";
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "edges(g) = ";
  graph_traits&lt;Graph&gt;::edge_iterator ei, ei_end;
  for (boost::tie(ei,ei_end) = edges(g); ei != ei_end; ++ei)
    std::cout &lt;&lt; "(" &lt;&lt; name[get(vertex_id, source(*ei, g))]
              &lt;&lt; "," &lt;&lt; name[get(vertex_id, target(*ei, g))] &lt;&lt; ") ";
  std::cout &lt;&lt; std::endl;

  std::for_each(vertices(g).first, vertices(g).second,
                exercise_vertex&lt;Graph&gt;(g, name));

  std::map&lt;std::string,std::string&gt; graph_attr, vertex_attr, edge_attr;
  graph_attr["size"] = "3,3";
  graph_attr["rankdir"] = "LR";
  graph_attr["ratio"] = "fill";
  vertex_attr["shape"] = "circle";

  boost::write_graphviz(std::cout, g,
                        make_label_writer(name),
                        make_label_writer(trans_delay),
                        make_graph_attributes_writer(graph_attr, vertex_attr,
                                                     edge_attr));

  return 0;
}</pre>

        <section id="bgl_tour_constructing">
          <h3>Constructing a Graph</h3>
          <p>In this example we will use the BGL <code href="adjacency_matrix">adjacency_list</code> class to demonstrate the main ideas in the BGL interface. The <code>adjacency_list</code> class provides a generalized version of the classic adjacency list data structure. The <code>adjacency_list</code> is a template class with six template parameters, though here we only fill in the first three parameters and use the defaults for the remaining three. The first two template arguments (<var class="constant">vecS</var>, <var class="constant">vecS</var>) determine the data structure used to represent the out-edges for each vertex in the graph and the data structure used to represent the graph's vertex set (see section <cite class="section" href="choosing_the_edgelist_and_vertexlist">Choosing the <var class="parameter">Edgelist</var> and <var class="parameter">VertexList</var></cite> for information about the tradeoffs of the different data structures).</p>
          <p>The third argument, <var class="constant">bidirectionalS</var>, selects a directed graph that provides access to both out and in-edges. The other options for the third argument are <var class="constant">directedS</var> which selects a directed graph with only out-edges, and <var class="constant">undirectedS</var> which selects an undirected graph.</p>
          <p>Once we have the graph type selected, we can create the graph in the figure by declaring a graph object and filling in edges using the <code class="function">add_edge()</code> function of the <code class="interface">MutableGraph</code> interface (which <code>adjacency_list</code> implements). We use the array of pairs <code>edge_array</code> merely as a convenient way to explicitly create the edges for this example.</p>
          <pre>#include &lt;iostream&gt;                  // for std::cout
  #include &lt;utility&gt;                   // for std::pair
#include &lt;algorithm&gt;                 // for std::for_each
#include &lt;boost/graph/graph_traits.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;

using namespace boost;

int main(int,char*[])
{
  // create a typedef for the Graph type
  typedef adjacency_list&lt;vecS, vecS, bidirectionalS&gt; Graph;

  // Make convenient labels for the vertices
  enum { A, B, C, D, E, N };
  const int num_vertices = N;
  const char* name = "ABCDE";

  // writing out the edges in the graph
  typedef std::pair&lt;int, int&gt; Edge;
  Edge edge_array[] =
  { Edge(A,B), Edge(A,D), Edge(C,A), Edge(D,C),
      Edge(C,E), Edge(B,D), Edge(D,E)
  };
  const int num_edges = sizeof(edge_array)/sizeof(edge_array[0]);

  // declare a graph object
  Graph g(num_vertices);

  // add the edges to the graph object
  for (int i = 0; i &lt; num_edges; ++i)
    add_edge(edge_array[i].first, edge_array[i].second, g);
  ...
  return 0;
}</pre>
          <p>Instead of calling the <code class="function">add_edge()</code> function for each edge, we could use the edge iterator constructor of the graph. This is typically more efficient than using <code class="function">add_edge()</code>. Pointers to the <code>edge_array</code> can be viewed as iterators, so we can call the iterator constructor by passing pointers to the beginning and end of the array.</p>
          <pre>Graph g(edge_array, edge_array + sizeof(edge_array) / sizeof(Edge), num_vertices);</pre>
          <p>Instead of creating a graph with a certain number of vertices to begin with, it is also possible to add and remove vertices with the <code class="function">add_vertex()</code> and <code class="function">remove_vertex()</code> functions, also of the MutableGraph interface.</p>
        </section>

        <section>
          <h3>Accessing the Vertex Set</h3>
          <p>Now that we have created a graph, we can use the graph interface to access the graph data in different ways. First we can access all of the vertices in the graph using the <code class="function">vertices()</code> function of the VertexListGraph interface. This function returns a <code>std::pair</code> of vertex iterators (the first iterator points to the beginning of the vertices and the second iterator points past the end). Dereferencing a vertex iterator gives a vertex object. The type of the vertex iterator is given by the <code>graph_traits</code> class. Note that different graph classes can have different associated vertex iterator types, which is why we need the graph_traits class. Given some graph type, the <code>graph_traits</code> class will provide access to the vertex_iterator type.</p>
          <p>The following example prints out the index for each of the vertices in the graph. All vertex and edge properties, including index, are accessed via property map objects. The property_map class is used to obtain the property map type for a specific property (specified by vertex_index_t, one of the BGL predefined properties) and function call <code class="function">get(vertex_index, g)</code> returns the actual property map object.</p>
          <pre>// ...
  int main(int,char*[])
  {
    // ...

    typedef graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;

    // get the property map for vertex indices
    typedef property_map&lt;Graph, vertex_index_t&gt;::type IndexMap;
    IndexMap index = get(vertex_index, g);

    std::cout &lt;&lt; "vertices(g) = ";
    typedef graph_traits&lt;Graph&gt;::vertex_iterator vertex_iter;
    std::pair&lt;vertex_iter, vertex_iter&gt; vp;
    for (vp = vertices(g); vp.first != vp.second; ++vp.first) {
      Vertex v = *vp.first;
      std::cout &lt;&lt; index[v] &lt;&lt;  " ";
    }
    std::cout &lt;&lt; std::endl;
    // ...
    return 0;
  }</pre>
          <p>The output is:</p>
          <pre>vertices(g) = 0 1 2 3 4</pre>
        </section>

        <section>
          <h3>Accessing the Edge Set</h3>
          <p>The set of edges for a graph can be accessed with the <code class="function">edges()</code> function of the <code class="interface">EdgeListGraph</code> interface. Similar to the <code class="function">vertices()</code> function, this returns a pair of iterators, but in this case the iterators are edge iterators. Dereferencing an edge iterator gives an edge object. The <code class="function">source()</code> and <code class="function">target()</code> functions return the two vertices that are connected by the edge. Instead of explicitly creating a <code>std::pair</code> for the iterators, this time we will use the <code class="function">tie()</code> helper function. This handy function can be used to assign the parts of a <code class="function">std::pair</code> into two separate variables, in this case <var>ei</var> and <var>ei_end</var>. This is usually more convenient than creating a <code>std::pair</code> and is our method of choice for the BGL</p>
          <note><em>See</em> <code class="function" href="std_tie">std::tie</code> for an STL replacement.</note>
          <pre>// ...
  int main(int,char*[])
  {
    // ...
    std::cout &lt;&lt; "edges(g) = ";
    graph_traits&lt;Graph&gt;::edge_iterator ei, ei_end;
    for (tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
        std::cout &lt;&lt; "(" &lt;&lt; index[source(*ei, g)]
                  &lt;&lt; "," &lt;&lt; index[target(*ei, g)] &lt;&lt; ") ";
    std::cout &lt;&lt; std::endl;
    // ...
    return 0;
  }</pre>
          <p>The output is:</p>
          <pre>edges(g) = (0,1) (0,3) (2,0) (3,2) (2,4) (1,3) (3,4)</pre>
        </section>

        <section>
          <h3>The Adjacency Structure</h3>
          <p>In the next few examples we will explore the adjacency structure of the graph from the point of view of a particular vertex. We will look at the vertices' in-edges, out-edges, and its adjacent vertices. We will encapsulate this in an <code class="function">exercise_vertex</code> function, and apply it to each vertex in the graph. To demonstrate the STL-interoperability of BGL, we will use the STL <code class="function">for_each()</code> function to iterate through the vertices and apply the function.</p>
          <pre>//...
  int main(int,char*[])
  {
    //...
    std::for_each(vertices(g).first, vertices(g).second,
                  exercise_vertex&lt;Graph&gt;(g));
    return 0;
  }</pre>
          <p>We use a functor for <code class="function">exercise_vertex</code> instead of just a function because the graph object will be needed when we access information about each vertex; using a functor gives us a place to keep a reference to the graph object during the execution of the <code class="function">std::for_each()</code>. Also we template the functor on the graph type so that it is reusable with different graph classes. Here is the start of the <code class="function">exercise_vertex</code> functor:</p>
          <pre>template &lt;class Graph&gt; struct exercise_vertex {
    exercise_vertex(Graph&amp; g_) : g(g_) {}
    //...
    Graph&amp; g;
  };</pre>
        </section>

        <section>
          <h3>Vertex Descriptors</h3>
          <p>The first thing we need to know in order to write the <code class="function">operator()</code> method of the functor is the type for the vertex objects of the graph. The vertex type will be the parameter to the <code class="function">operator()</code> method. To be precise, we do not deal with actual vertex objects, but rather with <a href="bgl_vertex_and_edge_descriptors">vertex descriptors</a>. Many graph representations (such as adjacency lists) do not store actual vertex objects, while others do (e.g., pointer-linked graphs). This difference is hidden underneath the <q>black-box</q> of the vertex descriptor object. The vertex descriptor is something provided by each graph type that can be used to access information about the graph via the <code class="function">out_edges()</code>, <code class="function">in_edges()</code>, <code class="function">adjacent_vertices()</code>, and property map functions that are described in the following sections. The vertex_descriptor type is obtained through the <code>graph_traits</code> class. The <kbd class="userinput">typename</kbd> keyword used below is necessary because the type on the left hand side of the scope :: operator (the <code>graph_traits&lt;Graph&gt;</code> type) is dependent on a template parameter (the <code>Graph</code> type). Here is how we define the functor's apply method:</p>
          <pre>  template &lt;class Graph&gt; struct exercise_vertex {
    //...
    typedef typename graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;

    void operator()(const Vertex&amp; v) const
    {
      //...
    }
    //...
  };</pre>
          <p/>
        </section>

        <section>
          <h3>Out-Edges, In-Edges, and Edge Descriptors</h3>
          <p>The out-edges of a vertex are accessed with the <code class="function">out_edges()</code> function of the <code class="interface">IncidenceGraph</code> interface. The <code class="function">out_edges()</code> function takes two arguments: the first argument is the vertex and the second is the graph object. The function returns a pair of iterators which provide access to all of the out-edges of a vertex (similar to how the <code class="function">vertices()</code> function returned a pair of iterators). The iterators are called out-edge iterators and dereferencing one of these iterators gives an <a href="bgl_vertex_and_edge_descriptors">edge descriptor</a> object. An edge descriptor plays the same kind of role as the vertex descriptor object, it is a <q>black box</q> provided by the graph type. The following code snippet prints the source-target pairs for each out-edge of vertex <var>v</var>.</p>
          <pre>template &lt;class Graph&gt; struct exercise_vertex {
    //...
    void operator()(const Vertex&amp; v) const
    {
      typedef graph_traits&lt;Graph&gt; GraphTraits;
      typename property_map&lt;Graph, vertex_index_t&gt;::type
        index = get(vertex_index, g);

      std::cout &lt;&lt; "out-edges: ";
      typename GraphTraits::out_edge_iterator out_i, out_end;
      typename GraphTraits::edge_descriptor e;
      for (tie(out_i, out_end) = out_edges(v, g);
           out_i != out_end; ++out_i) {
        e = *out_i;
        Vertex src = source(e, g), targ = target(e, g);
        std::cout &lt;&lt; "(" &lt;&lt; index[src] &lt;&lt; ","
                  &lt;&lt; index[targ] &lt;&lt; ") ";
      }
      std::cout &lt;&lt; std::endl;
      //...
    }
    //...
  };</pre>
          <p>For vertex 0 the output is:</p>
          <pre>out-edges: (0,1) (0,2) (0,3) (0,4)</pre>

          <p>The <code class="function">in_edges()</code> function of the <code class="interface">BidirectionalGraph</code> interface provides access to all the in-edges of a vertex through in-edge iterators. The <code class="function">in_edges()</code> function is only available for the <code>adjacency_list</code> if <var class="constant">bidirectionalS</var> is supplied for the <var class="parameter">Directed</var> template parameter. There is an extra cost in space when <var class="constant">bidirectionalS</var> is specified instead of <var class="constant">directedS</var>.</p>
          <pre>template &lt;class Graph&gt; struct exercise_vertex {
    //...
    void operator()(const Vertex&amp; v) const
    {
      //...
      std::cout &lt;&lt; "in-edges: ";
      typedef typename graph_traits&lt;Graph&gt; GraphTraits;
      typename GraphTraits::in_edge_iterator in_i, in_end;
      for (tie(in_i, in_end) = in_edges(v,g);
           in_i != in_end; ++in_i) {
        e = *in_i;
        Vertex src = source(e, g), targ = target(e, g);
        std::cout &lt;&lt; "(" &lt;&lt; index[src] &lt;&lt; "," &lt;&lt; index[targ] &lt;&lt; ") ";
      }
      std::cout &lt;&lt; std::endl;
      //...
    }
    //...
  };</pre>
          <p>For vertex 0 the output is:</p>
          <pre>in-edges: (2,0) (3,0) (4,0)</pre>
        </section>
        <section>
          <h3>Adjacent Vertices</h3>
          <p>Given the out-edges of a vertex, the target vertices of these edges are adjacent to the source vertex. Sometimes an algorithm does not need to look at the edges of the graph and only cares about the vertices. Therefore the graph interface also includes the <code class="function">adjacent_vertices()</code> function of the <code class="interface">AdjacencyGraph</code> interface which provides direct access to the adjacent vertices. This function returns a pair of adjacency iterators. Dereferencing an adjacency iterator gives a vertex descriptor for an adjacent vertex.</p>
          <pre>  template &lt;class Graph&gt; struct exercise_vertex {
    //...
    void operator()(Vertex v) const
    {
      //...
      std::cout &lt;&lt; "adjacent vertices: ";
      typename graph_traits&lt;Graph&gt;::adjacency_iterator ai;
      typename graph_traits&lt;Graph&gt;::adjacency_iterator ai_end;
      for (tie(ai, ai_end) = adjacent_vertices(v, g);
           ai != ai_end; ++ai)
        std::cout &lt;&lt; index[*ai] &lt;&lt;  " ";
      std::cout &lt;&lt; std::endl;
    }
    //...
  };</pre>
          <p>For vertex 4 the output is:</p>
          <pre>adjacent vertices: 0 1</pre>
        </section>
        <section>
          <h3>Adding Some Color to your Graph</h3>
          <p>BGL attempts to be as flexible as possible in terms of accommodating how properties are attached to a graph. For instance, a property such as edge weight may need to be used throughout a graph object's lifespan and therefore it would be convenient to have the graph object also manage the property storage. On the other hand, a property like vertex color may only be needed for the duration of a single algorithm, and it would be better to have the property stored separately from the graph object. The first kind of property is called an <dfn>internally stored property</dfn> while the second kind is called an <dfn>externally stored property</dfn>. BGL uses a uniform mechanism to access both kinds of properties inside its graph algorithms called the <code class="interface">property map</code> interface, described in <cite class="section" href="property_map_concepts">Property Map Concepts</cite>. In addition, the <code class="interface">PropertyGraph</code> concept defines the interface for obtaining a property map object for an internally stored property.</p>
          <p>The BGL <code>adjacency_list</code> class allows users to specify internally stored properties through plug-in template parameters of the graph class. How to do this is discussed in detail in <cite class="section" href="BGL_internal_properties">Internal Properties</cite>. Externally stored properties can be created in many different ways, although they are ultimately passed as separate arguments to the graph algorithms. One straightforward way to store properties is to create an array indexed by vertex or edge index. In the adjacency_list with vecS specified for the VertexList template parameter, vertices are automatically assigned indices, which can be accessed via the property map for the <var class="type">vertex_index_t</var>. Edges are not automatically assigned indices. However the property mechanism can be used to attach indices to the edges which can be used to index into other externally stored properties.</p>
          <p>In the following example, we construct a graph and apply <code class="function">dijkstra_shortest_paths()</code>. The complete source code for the example is in <cite>examples/dijkstra-example.cpp</cite>. Dijkstra's algorithm computes the shortest distance from the starting vertex to every other vertex in the graph.</p>
          <p>Dijkstra's algorithm requires that a weight property is associated with each edge and a distance property with each vertex. Here we use an internal property for the weight and an external property for the distance. For the weight property we use the property class and specify <var class="type">int</var> as the type used to represent weight values and <var class="type">edge_weight_t</var> for the property tag (which is one of the BGL predefined property tags). The weight property is then used as a template argument for <code>adjacency_list</code>.</p>
          <p>The <var class="constant">listS</var> and <var class="constant">vecS</var> types are selectors that determine the data structure used inside the <code>adjacency_list</code> (see <cite class="section" href="choosing_the_edgelist_and_vertexlist">Choosing the Edgelist and VertexList</cite>). The <var class="constant">directedS</var> type specifies that the graph should be directed (versus undirected). The following code shows the specification of the graph type and then the initialization of the graph. The edges and weights are passed to the graph constructor in the form of iterators (a pointer qualifies as a <code class="interface">RandomAccessIterator</code>)</p>
          <pre>typedef adjacency_list&lt;listS, vecS, directedS,
                         no_property, property&lt;edge_weight_t, int&gt; &gt; Graph;
  typedef graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
  typedef std::pair&lt;int,int&gt; E;

  const int num_nodes = 5;
  E edges[] = { E(0,2),
                E(1,1), E(1,3), E(1,4),
                E(2,1), E(2,3),
                E(3,4),
                E(4,0), E(4,1) };
  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1};

  Graph G(edges, edges + sizeof(edges) / sizeof(E), weights, num_nodes);</pre>

          <p>For the external distance property we will use a <code>std::vector</code> for storage. BGL algorithms treat random access iterators as property maps, so we can just pass the beginning iterator of the distance vector to Dijkstra's algorithm. Continuing the above example, the following code shows the creation of the distance vector, the call to Dijkstra's algorithm (implicitly using the internal edge weight property), and then the output of the results.</p>
          <pre>// vector for storing distance property
  std::vector&lt;int&gt; d(num_vertices(G));

  // get the first vertex
  Vertex s = *(vertices(G).first);
  // invoke variant 2 of Dijkstra's algorithm
  dijkstra_shortest_paths(G, s, distance_map(&amp;d[0]));

  std::cout &lt;&lt; "distances from start vertex:" &lt;&lt; std::endl;
  graph_traits&lt;Graph&gt;::vertex_iterator vi;
  for(vi = vertices(G).first; vi != vertices(G).second; ++vi)
    std::cout &lt;&lt; "distance(" &lt;&lt; index(*vi) &lt;&lt; ") = "
              &lt;&lt; d[*vi] &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;</pre>
          <p>The output being:</p>
          <pre> distances from start vertex:
  distance(0) = 0
  distance(1) = 6
  distance(2) = 1
  distance(3) = 4
  distance(4) = 5
</pre>
        </section>

        <section>
          <h3>Extending Algorithms with Visitors</h3>
          <p>Often times an algorithm in a library <em>almost</em> does what you need, but not quite. For example, in the previous section we used Dijkstra's algorithm to calculate the shortest distances to each vertex, but perhaps we also wanted to record the tree of shortest paths. One way to do this is to record the predecessor (parent) for each node in the shortest-paths tree.</p>
          <p>It would be nice if we could avoid rewriting Dijkstra's algorithm, and just add that little bit extra needed to record the predecessors. In the STL, this kind of extensibility is provided by <a href="function_objects">functors</a>, which are optional parameters to each algorithm. In the BGL this role is fulfilled by visitors.</p>
          <p>A <dfn>visitor</dfn> is like a functor, but instead of having just one <q>apply</q> method, it has several. Each of these methods get invoked at certain well-defined points within the algorithm. The visitor methods are explained in detail in <cite class="section" href="bgl_visitor">Visitor Concepts</cite>. The BGL provides a number of visitors for some common tasks including a predecessor recording visitor. The user is encouraged to write his or her own visitors as a way of extending the BGL. Here we will take a quick look at the implementation and use of the predecessor recorder. Since we will be using the <code class="function">dijkstra_shortest_paths()</code> algorithm, the visitor we create must be a Dijkstra Visitor.</p>
          <p>The functionality of the <code>record_predecessors</code> visitor is separated into two parts. For the storage and access of the predecessor property, we will use a <code href="boost_property_maps">property map</code>. The predecessor visitor will then only be responsible for what parent to record. To implement this, we create a <code>record_predecessors</code> class and template it on the predecessor property map <code>PredecessorMap</code>. Since this visitor will only be filling in one of the visitor methods, we will inherit from <code>dijkstra_visitor</code>, which will provide empty methods for the rest. The constructor of the predecessor_recorder will take the property map object and save it away in a data member.</p>
          <pre></pre>
          <p/><pre>template &lt;class PredecessorMap&gt;
  class record_predecessors : public dijkstra_visitor&lt;&gt;
  {
  public:
    record_predecessors(PredecessorMap p)
      : m_predecessor(p) { }

    template &lt;class Edge, class Graph&gt;
    void edge_relaxed(Edge e, Graph&amp; g) {
      // set the parent of the target(e) to source(e)
      put(m_predecessor, target(e, g), source(e, g));
    }
  protected:
    PredecessorMap m_predecessor;
  };</pre>
          <p>The job of recording the predecessors is quite simple. When Dijkstra's algorithm relaxes an edge (potentially adding it to the shortest-paths tree) we record the source vertex as the predecessor of the target vertex. Later, if the edge is relaxed again the predecessor property will be overwritten by the new predecessor. Here we use the <code class="function">put()</code> function associated with the property map to record the predecessor. The edge_filter of the visitor tells the algorithm when to invoke the <code class="function">explore()</code> method. In this case we only want to be notified about edges in the shortest-paths tree so we specify tree_edge_tag.</p>
          <p>As a finishing touch, we create a helper function to make it more convenient to create predecessor visitors. All BGL visitors have a helper function like this.</p>
          <pre>template &lt;class PredecessorMap&gt;
  record_predecessors&lt;PredecessorMap&gt;
  make_predecessor_recorder(PredecessorMap p) {
    return record_predecessors&lt;PredecessorMap&gt;(p);
  }</pre>
          <p>We are now ready to use the record_predecessors in Dijkstra's algorithm. Luckily, BGL's Dijkstra's algorithm is already equipped to handle visitors, so we just pass in our new visitor. In this example we only need to use one visitor, but the BGL is also equipped to handle the use of multiple visitors in the same algorithm (see <cite class="section" href="bgl_visitor">Visitor Concepts</cite>Visitor Concepts).</p>
          <pre>  using std::vector;
  using std::cout;
  using std::endl;
  vector&lt;Vertex&gt; p(num_vertices(G), graph_traits&lt;G&gt;::null_vertex()); //the predecessor array
  dijkstra_shortest_paths(G, s, distance_map(&amp;d[0]).
                          visitor(make_predecessor_recorder(&amp;p[0])));

  cout &lt;&lt; "parents in the tree of shortest paths:" &lt;&lt; endl;
  for(vi = vertices(G).first; vi != vertices(G).second; ++vi) {
    cout &lt;&lt; "parent(" &lt;&lt; *vi;
    if (p[*vi] == graph_traits&lt;G&gt;::null_vertex())
      cout &lt;&lt; ") = no parent" &lt;&lt; endl;
    else
      cout &lt;&lt; ") = " &lt;&lt; p[*vi] &lt;&lt; endl;
  }</pre>
          <p>The output is:</p>
          <pre>parents in the tree of shortest paths:
  parent(0) = no parent
  parent(1) = 4
  parent(2) = 0
  parent(3) = 2
  parent(4) = 3</pre>
        </section>

      </section>  <!-- end of "A Quick Tour of the Boost Graph Library" -->

      <section>
        <h2>A Beginner's Introduction to the Boost Graph Library</h2>
        <section>
          <h3>Which Graph Class To Use</h3>
          <p>There are several BGL graph classes from which to choose. Since BGL algorithms are generic, they can also be used with any <em>conforming</em> user-defined graph class, but in this section we will restrict our discussion to BGL graph classes.</p>
          <p>The principle BGL graph classes are the <code>adjacency_list</code> and <code>adjacency_matrix</code> classes. The adjacency list class is a good choice for most situations, particularly for representing sparse graphs. The file-dependencies graph has only a few edges per vertex, so it is sparse. The adjacency matrix class is a good choice for representing dense graphs, but a very bad choice for sparse graphs, unless a sparse matrix is used.</p>
          <p>In this introductory section we shall be using the <code>adjacency_list</code> class exclusively. However, most of what is presented here will also apply directly to the <code>adjacency_matrix</code> class because its interface is almost identical to that of the <code>adjacency_list</code>.</p>

          <p>Here we use the same variant of adjacency list as was used in &#xA7;1.4.1.</p>
          <pre>typedef adjacency list&lt;
  listS, // Store out-edges of each vertex in a std::list
  vecS,  // Store vertex set in a std::vector
  directedS // The file dependency graph is directed
            &gt; file_dep_graph; // for file dependency graph, as introduced elsewhere</pre>
        </section>
        <section>
          <h3>Constructing a Graph Using Edge Iterators</h3>
          <p><?see In §1.2.4 ?>we have shown how the <code class="methodname">add_vertex()</code> and <code class="methodname">add_edge()</code> functions can be used to create a graph. Those functions add vertices and edges one at a time, but in many cases one would like to add them all at once. To meet this need the <code>adjacency_list</code> graph class has a constructor that takes two iterators that define a range of edges. The edge iterators can be any <code>InputIterator</code> that dereference to a <code>std::pair</code> of integers (<var>i</var>, <var>j</var>) that represent an edge in the graph. The two integers <var>i</var> and <var>j</var> represent vertices where <span class="inlineequation">0 &#x2264; i &lt; |V |</span> and <span class="inlineequation">0 &#x2264; j &lt; |V |</span>. The <var>n</var> and <var>m</var> parameters say how many vertices and edges will be in the graph. These parameters are optional, but providing them improves the speed of graph construction. The graph properties parameter <var>p</var> is attached to the graph object. The function prototype for the constructor that uses edge iterators is as follows:</p>
          <pre>template &lt;var class='type'name EdgeIterator&gt;
adjacency list(EdgeIterator first, EdgeIterator last,
               vertices_size_type n = 0, edges_size_type m = 0,
               const GraphProperties&amp; p = GraphProperties())</pre>
          <p>The following code demonstrates the use of the edge iterator constructor to create a graph. The <code>std::istream</code> iterator is used to make an input iterator that reads the edges in from the file. The file contains the number of vertices in the graph, followed by pairs of numbers that specify the edges. The second default-constructed input iterator is a placeholder for the end of the input. The <code>std::istream</code> iterator is passed directly into the constructor for the graph.</p>
          <pre>std::ifstream file_in("makefile-dependencies.dat");
typedef graph_traits&lt;file_dep_graph&gt;::vertices_size_type size_type;
size_type n_vertices;
file_in &gt;&gt; n_vertices; // read in number of vertices
std::istream iterator&lt;std::pair&lt;size_type, size_type&gt; &gt; input_begin(file_in), input_end;
file_dep_graph g(input_begin, input_end, n_vertices);</pre>
          <p>Since the value type of the std::istream iterator is <code>std::pair</code>, an input operator needs to be defined for <code>std::pair</code>.</p>
          <pre>namespace std {
  template &lt;var class='type'name T&gt;
  std::istream&amp; operator&gt;&gt;(std::istream&amp; in, std::pair&lt;T,T&gt;&amp; p) {
    in &gt;&gt; p.first &gt;&gt; p.second;
    return in;
  }
}</pre>
          <p/>
        </section>

        <section>
          <h3>Compilation Order</h3>
          <p>The first question that we address is that of specifying an order in which to build all of the targets. The primary consideration here is ensuring that before building a given target, all the targets that it depends on are already built.</p>
          <pre></pre>
          <p/>
        </section>

      </section>

      <section>
        <h2>Graph Interfaces</h2>
        <p>We shall describe the base <code class="interface">Graph</code> interface and its <a href="bgl_graph_refinements">refinements</a>.</p>

        <section>
          <h3>The Base <code class="interface">Graph</code> Interface</h3>
          <p>The Graph concept contains a few requirements that are common to all the graph concepts. These include some associated types for vertex_descriptor, edge_descriptor, etc. One should note that a model of Graph is not required to be a model of Assignable, so algorithms should pass graph objects by reference.</p>
          <section>
          <h4>Notation</h4>
            <p>G 	A type that is a model of Graph.</p>
            <p>g 	An object of type G.</p>
          </section>
          <section>
          <h4>Associated Types</h4>
            <dl>
              <div class="varlistentry">
                <dt class="term"><pre>boost::graph_traits&lt;G&gt;::vertex_descriptor</pre></dt>
                <dd>A vertex descriptor corresponds to a unique vertex in an abstract graph instance. A vertex descriptor must be Default Constructible, Assignable, and Equality Comparable.</dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>boost::graph_traits&lt;G&gt;::edge_descriptor</pre></dt>
                <dd>An edge descriptor corresponds to a unique edge (u,v) in a graph. An edge descriptor must be Default Constructible, Assignable, and Equality Comparable.</dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>boost::graph_traits&lt;G&gt;::directed_category</pre></dt>
                <dd>The choices are <var class="literal">directed_tag</var> and <var class="literal">undirected_tag</var>.</dd>
              </div>
              <div class="varlistentry" id="bgl_edge_parallel_category">
                <dt class="term"><pre>boost::graph_traits&lt;G&gt;::edge_parallel_category</pre></dt>
                <dd>This describes whether the graph class allows the insertion of parallel edges (edges with the same source and target). The two tags are <var class="literal">allow_parallel_edge_tag</var> and <var class="literal">disallow_parallel_edge_tag</var>.</dd>
              </div>
              <div class="varlistentry" id="bgl_traversal_category">
                <dt class="term"><pre>boost::graph_traits&lt;G&gt;::traversal_category</pre></dt>
                <dd>This describes the ways in which the vertices and edges of the graph can be visited. The choices are <var class="literal">incidence_graph_tag</var>, <var class="literal">adjacency_graph_tag</var>, <var class="literal">bidirectional_graph_tag</var>, <var class="literal">vertex_list_graph_tag</var>, <var class="literal">edge_list_graph_tag</var>, and <var class="literal">adjacency_matrix_tag</var>.</dd>
              </div>
            </dl>
          </section>
          <section>
          <h4>Valid Expressions</h4>
            <dl>
              <div class="varlistentry">
                <dt class="term"><pre>boost::graph_traits&lt;G&gt;::null_vertex()</pre></dt>
                <dd>Returns a special vertex_descriptor object which does not refer to any vertex of graph object which type is G.</dd>
              </div>
            </dl>
          </section>
          <section>
          <h4>Concept Checking Class</h4>
            <pre>template &lt;class G&gt;
  struct GraphConcept
  {
    typedef typename boost::graph_traits&lt;G&gt;::vertex_descriptor vertex_descriptor;
    typedef typename boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;
    typedef typename boost::graph_traits&lt;G&gt;::directed_category directed_category;
    typedef typename boost::graph_traits&lt;G&gt;::edge_parallel_category edge_parallel_category;
    typedef typename boost::graph_traits&lt;G&gt;::traversal_category traversal_category;

    void constraints() {
      function_requires&lt; DefaultConstructibleConcept&lt;vertex_descriptor&gt; &gt;();
      function_requires&lt; EqualityComparableConcept&lt;vertex_descriptor&gt; &gt;();
      function_requires&lt; AssignableConcept&lt;vertex_descriptor&gt; &gt;();
      function_requires&lt; DefaultConstructibleConcept&lt;edge_descriptor&gt; &gt;();
      function_requires&lt; EqualityComparableConcept&lt;edge_descriptor&gt; &gt;();
      function_requires&lt; AssignableConcept&lt;edge_descriptor&gt; &gt;();
    }
    G g;
  };</pre>
          </section>
        </section>  <!-- end of "The Base <code class='interface'>Graph</code> Interface" -->

        <section id="bgl_graph_refinements">
          <h3>Refinements of the <code class="interface">Graph</code> Interface</h3>
          <p>The refinements of the <code class="interface">graph</code> are:</p>
          <dl>

            <div class="varlistentry">
              <dt class="term"><code class="interface" href="bgl_IncidenceGraph">IncidenceGraph</code></dt>
              <dd>
                <p>The IncidenceGraph concept provides an interface for efficient access to the out-edges of each vertex in the graph.</p>
                <note>The <code class="interface">IncidenceGraph</code> interface is further refined by <code class="interface" href="bgl_BidirectionalGraph">BidirectionalGraph</code>.</note>
              </dd>
            </div>

            <div class="varlistentry">
              <dt class="term"><code class="interface" href="bgl_BidirectionalGraph">BidirectionalGraph</code></dt>
              <dd>
                <p>The BidirectionalGraph concept refines <code class="interface" href="bgl_IncidenceGraph">IncidenceGraph</code> and adds the requirement for efficient access to the in-edges of each vertex.</p>
              </dd>
            </div>

            <div class="varlistentry">
              <dt class="term"><code class="interface" href="bgl_AdjacencyGraph">AdjacencyGraph</code></dt>
              <dd>
                <p>The AdjacencyGraph concept provides and interface for efficient access of the adjacent vertices to a vertex in a graph. This is quite similar to the <code class="interface" href="bgl_IncidenceGraph">IncidenceGraph</code> concept (the target of an out-edge is an adjacent vertex), though...</p>
              </dd>
            </div>

            <div class="varlistentry">
              <dt class="term"><code class="interface" href="bgl_EdgeListGraph">EdgeListGraph</code></dt>
              <dd>
                <p>The EdgeListGraph concept refines the Graph concept, and adds the requirement for efficient access to all the edges in the graph.</p>
              </dd>
            </div>

            <div class="varlistentry">
              <dt class="term"><code class="interface" href="bgl_AdjacencyMatrix">AdjacencyMatrix</code></dt>
              <dd>
                <p>The AdjacencyMatrix concept refines Graph concept and adds the requirement for efficient access to any edge in the graph given the source and target vertices.</p>
              </dd>
            </div>

            <div class="varlistentry">
              <dt class="term"><code class="interface" href="bgl_VertexListGraph">VertexListGraph</code></dt>
              <dd>
                <p>The VertexListGraph concept refines the Graph concept, and adds the requirement for efficient traversal of all the vertices in the graph.</p>
              </dd>
            </div>

          </dl>

        </section>  <!-- end of "Refinements of the <code class='interface'>Graph</code> Interface" -->

        <section id="bgl_IncidenceGraph">
          <h3>The <code class="interface">IncidenceGraph</code> Interface</h3>
          <p>The <code class="interface">IncidenceGraph</code> concept provides an interface for efficient access to the out-edges of each vertex in the graph.</p>
          <p>Its associated types:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::traversal_category</code></dt>
              <dd>This tag type must be convertible to incidence_graph_tag.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::out_edge_iterator</code></dt>
              <dd>An out-edge iterator for a vertex v provides access to the out-edges of the vertex. As such, the value type of an out-edge iterator is the edge descriptor type of its graph. An out-edge iterator must meet the requirements of MultiPassInputIterator.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::degree_size_type</code></dt>
              <dd>The unsigned integral type used for representing the number out-edges or incident edges of a vertex.</dd>
            </div>
          </dl>
          <p>Valid expressions (global functions) are:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code class="function">source(e, g)</code></dt>
              <dd>
                <p>Returns the vertex descriptor for u of the edge (u,v) represented by e.</p>
                <p>Return type: vertex_descriptor</p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">target(e, g)</code></dt>
              <dd>
                <p>Returns the vertex descriptor for v of the edge (u,v) represented by e.</p>
                <p>Return type: vertex_descriptor</p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">out_edges(u, g)</code></dt>
              <dd>
                <p>Returns an iterator-range providing access to the out-edges (for directed graphs) or incident edges (for undirected graphs) of vertex u in graph g. The source vertex of an edge obtained via an out edge iterator is guaranteed (for both directed and undirected graphs) to be the vertex u used in the call to out_edges(u, g) and the target vertex must be a vertex adjacent to u.</p>
                <p>Return type: <code>std::pair&lt;out_edge_iterator, out_edge_iterator&gt;</code></p>
                </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">out_degree(u, g)</code></dt>
              <dd>
                <p>Returns the number of out-edges (for directed graphs) or the number of incident edges (for undirected graphs) of vertex u in graph g.</p>
                <p>Return type: degree_size_type</p>
                </dd>
            </div>
          </dl>
          <note>For undirected graphs, the edge (u,v) is the same as edge (v,u), so without some extra guarantee an implementation would be free use any ordering for the pair of vertices in an out-edge. For example, if you call out_edges(u, g), and v is one of the vertices adjacent to u, then the implementation would be free to return (v,u) as an out-edge which would be non-intuitive and cause trouble for algorithms. Therefore, the extra requirement is added that the out-edge connecting u and v must be given as (u,v) and not (v,u).</note>
        </section>

        <section id="bgl_BidirectionalGraph">
          <h3>The <code class="interface">BidirectionalGraph</code> Interface</h3>
          <p>The BidirectionalGraph concept refines IncidenceGraph and adds the requirement for efficient access to the in-edges of each vertex. This concept is separated from IncidenceGraph because for directed graphs efficient access to in-edges typically requires more storage space, and many algorithms do not require access to in-edges. For undirected graphs this is not an issue, since the in_edges() and out_edges() functions are the same, they both return the edges incident to the vertex.</p>
          <p>Its associated types:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::traversal_category</code></dt>
              <dd>This tag type must be convertible to bidirectional_graph_tag.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::in_edge_iterator</code></dt>
              <dd>An in-edge iterator for a vertex v provides access to the in-edges of v. As such, the value type of an in-edge iterator is the edge descriptor type of its graph. An in-edge iterator must meet the requirements of MultiPassInputIterator.</dd>
            </div>
          </dl>
          <p>Valid expressions (global functions) are:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code class="function">in_edges(v, g)</code></dt>
              <dd>
                <p>Returns an iterator-range providing access to the in-edges (for directed graphs) or incident edges (for undirected graphs) of vertex v in graph g. For both directed and undirected graphs, the target of an out-edge is required to be vertex v and the source is required to be a vertex that is adjacent to v.</p>
                <p>Return type: <code>std::pair&lt;in_edge_iterator, in_edge_iterator&gt;</code></p>
                </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">in_degree(v, g)</code></dt>
              <dd>
                <p>Returns the number of in-edges (for directed graphs) or the number of incident edges (for undirected graphs) of vertex v in graph g.</p>
                <p>Return type: degree_size_type</p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">degree(v, g)</code></dt>
              <dd>
                <p>Returns the number of in-edges plus out-edges (for directed graphs) or the number of incident edges (for undirected graphs) of vertex v in graph g.</p>
                <p>Return type: degree_size_type</p>
              </dd>
            </div>
          </dl>
          <section>
          <h4>Concept Checking Class</h4>
            <pre>template &lt;class G&gt;
  struct BidirectionalGraphConcept
  {
    typedef typename boost::graph_traits&lt;G&gt;::in_edge_iterator
      in_edge_iterator;
    void constraints() {
      BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept&lt;G&gt; ));
      BOOST_CONCEPT_ASSERT(( MultiPassInputIteratorConcept&lt;in_edge_iterator&gt; ));

      p = in_edges(v, g);
      e = *p.first;
      const_constraints(g);
    }
    void const_constraints(const G&amp; g) {
      p = in_edges(v, g);
      e = *p.first;
    }
    std::pair&lt;in_edge_iterator, in_edge_iterator&gt; p;
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor v;
    typename boost::graph_traits&lt;G&gt;::edge_descriptor e;
    G g;
  };</pre>
          </section>
        </section>

        <section id="bgl_AdjacencyGraph">
          <h3>The <code class="interface">AdjacencyGraph</code> Interface</h3>
          <p>The AdjacencyGraph concept provides and interface for efficient access of the adjacent vertices to a vertex in a graph. This is quite similar to the <code class="interface" href="bgl_IncidenceGraph">IncidenceGraph</code> concept (the target of an out-edge is an adjacent vertex). Both concepts are provided because in some contexts there is only concern for the vertices, whereas in other contexts the edges are also important.</p>
          <p>Its associated types:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::traversal_category</code></dt>
              <dd>This tag type must be convertible to adjacency_graph_tag.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::adjacency_iterator</code></dt>
              <dd>An adjacency iterator for a vertex v provides access to the vertices adjacent to v. As such, the value type of an adjacency iterator is the vertex descriptor type of its graph. An adjacency iterator must meet the requirements of MultiPassInputIterator.</dd>
            </div>
          </dl>
          <p>Valid expressions (global functions) are:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code class="function">adjacent_vertices(v, g)</code></dt>
              <dd>
                <p>Returns an iterator-range providing access to the vertices adjacent to vertex v in graph g.</p>
                <p>Return type: <code>std::pair&lt;adjacency_iterator, adjacency_iterator&gt;</code></p>
              </dd>
            </div>
          </dl>
          <note>The case of a multigraph (where multiple edges can connect the same two vertices) brings up an issue as to whether the iterators returned by the adjacent_vertices() function access a range that includes each adjacent vertex once, or whether it should match the behavior of the out_edges() function, and access a range that may include an adjacent vertex more than once. For now the behavior is defined to match that of out_edges(), though this decision may need to be reviewed in light of more experience with graph algorithm implementations.</note>
          <section>
          <h4>Design Rationale</h4>
            <p>The AdjacencyGraph concept is somewhat frivolous since <code class="interface" href="bgl_IncidenceGraph">IncidenceGraph</code> really covers the same functionality (and more). The AdjacencyGraph concept exists because there are situations when adjacent_vertices() is more convenient to use than out_edges(). If you are constructing a graph class and do not want to put in the extra work of creating an adjacency iterator, have no fear. There is an adaptor class named adjacency_iterator that you can use to create an adjacency iterator out of an out-edge iterator.</p>
          </section>
        </section>

        <section id="bgl_EdgeListGraph">
          <h3>The <code class="interface">EdgeListGraph</code> Interface</h3>
          <p>The EdgeListGraph concept refines the Graph concept, and adds the requirement for efficient access to all the edges in the graph.</p>
          <p>Its associated types:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::traversal_category</code></dt>
              <dd>This tag type must be convertible to edge_list_graph_tag.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::edge_iterator</code></dt>
              <dd>An edge iterator (obtained via edges(g)) provides access to all of the edges in a graph. An edge iterator type must meet the requirements of MultiPassInputIterator. The value type of the edge iterator must be the same as the edge descriptor of the graph.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::edges_size_type</code></dt>
              <dd>The unsigned integer type used to represent the number of edges in the graph.</dd>
            </div>
          </dl>
          <p>Valid expressions (global functions) are:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code class="function">edges(g)</code></dt>
              <dd>
                <p>Returns an iterator-range providing access to all the edges in the graph g.</p>
                <p>Return type: <code>std::pair&lt;edge_iterator, edge_iterator&gt;&lt;/dd&gt;</code></p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">num_edges(g)</code></dt>
              <dd>
                <p>Returns the number of edges in the graph g.</p>
                <p>Return type: edges_size_type</p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">source(e, g)</code></dt>
              <dd>
                <p>Returns the vertex descriptor for u of the edge (u,v) represented by e.</p>
                <p>Return type: vertex_descriptor</p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">target(e, g)</code></dt>
              <dd>
                <p>Returns the vertex descriptor for v of the edge (u,v) represented by e.</p>
                <p>Return type: vertex_descriptor</p>
              </dd>
            </div>
          </dl>
          <section>
          <h4>Concept Checking Class</h4>
            <pre>template &lt;class G&gt;
  struct EdgeListGraphConcept
  {
    typedef typename boost::graph_traits&lt;G&gt;::edge_iterator
      edge_iterator;
    void constraints() {
      BOOST_CONCEPT_ASSERT(( GraphConcept&lt;G&gt; ));
      BOOST_CONCEPT_ASSERT(( MultiPassInputIteratorConcept&lt;edge_iterator&gt; ));

      p = edges(g);
      E = num_edges(g);
      e = *p.first;
      u = source(e, g);
      v = target(e, g);
      const_constraints(g);
    }
    void const_constraints(const G&amp; g) {
      p = edges(g);
      E = num_edges(g);
      e = *p.first;
      u = source(e, g);
      v = target(e, g);
    }
    std::pair&lt;edge_iterator,edge_iterator&gt; p;
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor u, v;
    typename boost::graph_traits&lt;G&gt;::edge_descriptor e;
    typename boost::graph_traits&lt;G&gt;::edges_size_type E;
    G g;
  };</pre>
          </section>
        </section>

        <section id="bgl_AdjacencyMatrix">
          <h3>The <code class="interface">AdjacencyMatrix</code> Interface</h3>
          <p>The AdjacencyMatrix concept refines Graph concept and adds the requirement for efficient access to any edge in the graph given the source and target vertices. No Boost Graph Library algorithms currently use this concept. However there are algorithms not yet implemented such as Floyd-Warshall that would require this concept.</p>
          <p>Its associated types:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::traversal_category</code></dt>
              <dd>This tag type must be convertible to adjacency_matrix_tag.</dd>
            </div>
          </dl>
          <p>Valid expressions (global functions) are:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code class="function">edge(u, v, g)</code></dt>
              <dd>
                <p>Returns a pair consisting of a flag saying whether there exists an edge between u and v in graph g, and consisting of the edge descriptor if the edge was found.</p>
                <p>Return type: <code>std::pair&lt;edge_descriptor, bool&gt;</code></p>
              </dd>
            </div>
          </dl>
          <section>
          <h4>Concept Checking Class</h4>
            <pre>template &lt;class G&gt;
  struct AdjacencyMatrix
  {
    typedef typename boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;
    void constraints() {
      p = edge(u, v, g);
    }
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor u, v;
    std::pair&lt;bool, edge_descriptor&gt; p;
    G g;
  };</pre>
          </section>
        </section>

        <section id="bgl_VertexListGraph">
          <h3>The <code class="interface">VertexListGraph</code> Interface</h3>
          <p>The VertexListGraph concept refines the Graph concept, and adds the requirement for efficient traversal of all the vertices in the graph.</p>
          <p>Its associated types:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::traversal_category</code></dt>
              <dd>This tag type must be convertible to vertex_list_graph_tag.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::vertex_iterator</code></dt>
              <dd>A vertex iterator (obtained via vertices(g)) provides access to all of the vertices in a graph. A vertex iterator type must meet the requirements of MultiPassInputIterator. The value type of the vertex iterator must be the vertex descriptor of the graph.</dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code>boost::graph_traits&lt;G&gt;::vertices_size_type</code></dt>
              <dd>The unsigned integer type used to represent the number of vertices in the graph.</dd>
            </div>
          </dl>
          <p>Valid expressions (global functions) are:</p>
          <dl>
            <div class="varlistentry">
              <dt class="term"><code class="function">vertices(g)</code></dt>
              <dd>
                <p>Returns an iterator-range providing access to all the vertices in the graph g.</p>
                <p>Return type: <code>std::pair&lt;vertex_iterator, vertex_iterator&gt;</code></p>
              </dd>
            </div>
            <div class="varlistentry">
              <dt class="term"><code class="function">num_vertices(g)</code></dt>
              <dd>
                <p>Returns the number of vertices in the graph g.</p>
                <p>Return type: <code>vertices_size_type</code></p>
              </dd>
            </div>
          </dl>
          <section>
          <h4>Design Rationale</h4>
            <p>One issue in the design of this concept is whether to include the refinement from the IncidenceGraph and AdjacencyGraph concepts. The ability to traverse the vertices of a graph is orthogonal to traversing out-edges, so it would make sense to have a VertexListGraph concept that only includes vertex traversal. However, such a concept would no longer really be a graph, but would just be a set, and the STL already has concepts for dealing with such things. However, there are many BGL algorithms that need to traverse the vertices and out-edges of a graph, so for convenience a concept is needed that groups these requirements together, hence the VertexListGraph.</p>
          </section>
        </section>

        <section>
          <h3>MutableGraph</h3>
          <p>A MutableGraph is a graph that can be changed via the addition or removal of edges and vertices.</p>
          <h4>Refinement of</h4>
          <p>Graph</p>
          <section>
          <h4>Notation</h4>
            <ul>
              <dd>G 	A type that is a model of Graph.</dd>
              <dd>g 	An object of type G.</dd>
              <dd>e 	An object of type boost::graph_traits&lt;G&gt;::edge_descriptor.</dd>
              <dd>u,v 	are objects of type boost::graph_traits&lt;G&gt;::vertex_descriptor.</dd>
              <dd>iter 	is an object of type boost::graph_traits&lt;G&gt;::out_edge_iterator.</dd>
              <dd>p 	is an object of a type that models Predicate and whose argument type matches the edge_descriptor type.</dd>
            </ul>
          </section>
          <section>
          <h4>Valid Expressions</h4>
            <dl>
              <div class="varlistentry">
                <dt class="term"><pre>add_edge(u, v, g)</pre></dt>
                <dd>
                  <p>Inserts the edge (u,v) into the graph, and returns an edge descriptor pointing to the new edge. If the graph disallows parallel edges, and the edge (u,v) is already in the graph, then the bool flag returned is false and the returned edge descriptor points to the already existing edge. Note that for undirected graphs, (u,v) is the same edge as (v,u), so after a call to the function add_edge(), this implies that edge (u,v) will appear in the out-edges of u and (u,v) (or equivalently (v,u)) will appear in the out-edges of v. Put another way, v will be adjacent to u and u will be adjacent to v.</p>
                  <p>Return type: <code>std::pair&lt;edge_descriptor, bool&gt;</code></p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_edge(u, v, g)</pre></dt>
                <dd>
                  <p>Remove the edge (u,v) from the graph. If the graph allows parallel edges this remove all occurrences of (u,v).</p>
                  <p>Return type: void</p>
                  <p>Precondition: u and v are vertices in the graph.</p>
                  <p>Postcondition: (u,v) is no longer in the edge set for g.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_edge(e, g)</pre></dt>
                <dd>
                  <p>Remove the edge e from the graph.</p>
                  <p>Return type: void</p>
                  <p>Precondition: e is an edge in the graph.</p>
                  <p>Postcondition: e is no longer in the edge set for g.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_edge(iter, g)</pre></dt>
                <dd>
                  <p>Remove the edge pointed to be iter from the graph. This expression is only required when the graph also models IncidenceGraph.</p>
                  <p>Return type: void</p>
                  <p>Precondition: *iter is an edge in the graph.</p>
                  <p>Postcondition: *iter is no longer in the edge set for g.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_edge_if(p, g)</pre></dt>
                <dd>
                  <p>Remove all the edges from graph g for which the predicate p returns true.</p>
                  <p>Return type: void</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_out_edge_if(u, p, g)</pre></dt>
                <dd>
                  <p>Remove all the out-edges of vertex u for which the predicate p returns true. This expression is only required when the graph also models IncidenceGraph.</p>
                  <p>Return type: void</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_in_edge_if(u, p, g)</pre></dt>
                <dd>
                  <p>Remove all the in-edges of vertex u for which the predicate p returns true. This expression is only required when the graph also models BidirectionalGraph.</p>
                  <p>Return type: void</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>add_vertex(g)</pre></dt>
                <dd>
                  <p>Add a new vertex to the graph. The vertex_descriptor for the new vertex is returned.</p>
                  <p>Return type: vertex_descriptor</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>clear_vertex(u, g)</pre></dt>
                <dd>
                  <p>Remove all edges to and from vertex u from the graph.</p>
                  <p>Return type: void</p>
                  <p>Precondition: u is a valid vertex descriptor of g.</p>
                  <p>Postcondition: u does not appear as a source or target of any edge in g.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term"><pre>remove_vertex(u, g)</pre></dt>
                <dd>
                  <p>Remove u from the vertex set of the graph. Note that undefined behavior may result if there are edges remaining in the graph who's target is u. Typically the clear_vertex() function should be called first.</p>
                  <p>Return type: void</p>
                  <p>Precondition: u is a valid vertex descriptor of g.</p>
                  <p>Postcondition: num_vertices(g) is one less, u no longer appears in the vertex set of the graph and it is no longer a valid vertex descriptor.</p>
                </dd>
              </div>
            </dl>
          </section>
          <section>
          <h4>Complexity Guarantees</h4>
            <ul>
              <dd>Edge insertion must be either amortized constant time or it can be O(log(E/V)) if the insertion also checks to prevent the addition of parallel edges (which is a ``feature'' of some graph types).</dd>
              <dd>Edge removal is guaranteed to be O(E).</dd>
              <dd>Vertex insertion is guaranteed to be amortized constant time.</dd>
              <dd>Clearing a vertex is O(E + V).</dd>
              <dd>Vertex removal is O(E + V).</dd>
            </ul>
          </section>
          <section>
          <h4>Models</h4>
            <p><code href="adjacency_list">adjacency_list</code></p>
          </section>
          <section>
          <h4>Concept Checking Class</h4>
            <pre>template &lt;class G&gt;
  struct MutableGraphConcept
  {
    typedef typename boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;
    void constraints() {
      v = add_vertex(g);
      clear_vertex(v, g);
      remove_vertex(v, g);
      e_b = add_edge(u, v, g);
      remove_edge(u, v, g);
      remove_edge(e, g);
    }
    G g;
    edge_descriptor e;
    std::pair&lt;edge_descriptor, bool&gt; e_b;
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor u, v;
    typename boost::graph_traits&lt;G&gt;::out_edge_iterator iter;
  };

  template &lt;class edge_descriptor&gt;
  struct dummy_edge_predicate {
    bool operator()(const edge_descriptor&amp; e) const {
      return false;
    }
  };

  template &lt;class G&gt;
  struct MutableIncidenceGraphConcept
  {
    void constraints() {
      function_requires&lt; MutableGraph&lt;G&gt; &gt;();
      remove_edge(iter, g);
      remove_out_edge_if(u, p, g);
    }
    G g;
    typedef typename boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;
    dummy_edge_predicate&lt;edge_descriptor&gt; p;
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor u;
    typename boost::graph_traits&lt;G&gt;::out_edge_iterator iter;
  };

  template &lt;class G&gt;
  struct MutableBidirectionalGraphConcept
  {
    void constraints() {
      function_requires&lt; MutableIncidenceGraph&lt;G&gt; &gt;();
      remove_in_edge_if(u, p, g);
    }
    G g;
    typedef typename boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;
    dummy_edge_predicate&lt;edge_descriptor&gt; p;
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor u;
  };

  template &lt;class G&gt;
  struct MutableEdgeListGraphConcept
  {
    void constraints() {
      function_requires&lt; MutableGraph&lt;G&gt; &gt;();
      remove_edge_if(p, g);
    }
    G g;
    typedef typename boost::graph_traits&lt;G&gt;::edge_descriptor edge_descriptor;
    dummy_edge_predicate&lt;edge_descriptor&gt; p;
  };
</pre>
          </section>

        </section>

      </section>

      <section id="bgl_concepts">
        <h2>Graph Concepts</h2>
        <p>Just as the STL defines a collection of iterator concepts that provide a generic mechanism for traversing and accessing sequences of objects, BGL defines its own collection of concepts that specify how graphs can be inspected and manipulated.</p>
        <p>In this section we give an overview of these concepts. The examples in this section do not refer to specific graph types; they are written as function templates with the graph as a template parameter. A generic function written using the BGL interface can be applied to any of the BGL graph types&#x2014;or even to new user-defined graph types. Later on, we will discuss the concrete graph classes that are provided in the BGL.</p>
        <section id="bgl_vertex_and_edge_descriptors">
          <h3>Vertex and Edge Descriptors</h3>
          <p>In the BGL, vertices and edges are manipulated through opaque handles called <dfn>vertex descriptors</dfn> and <dfn>edge descriptors</dfn>. Different graph types may use different types for their descriptors. For example, some graph types may use integers, whereas other graphs may use pointers. The descriptor types for a graph type are always accessible through the <a href="bgl_graph_traits">graph traits class</a>.</p>
          <p>Vertex descriptors have very basic functionality. By themselves they can only be default constructed, copied, and compared for equality. <dfn>Edge descriptors</dfn> are similar, although they also provide access to the associated source and target vertex. The following function template shows an implementation a generic function that determines if an edge is a self-loop:</p>
          <pre>template &lt;var class='type'name Graph&gt;
bool is self loop(typename graph traits&lt;Graph&gt;::edge descriptor e, const Graph&amp; g) {
  typename graph traits&lt;Graph&gt;::vertex descriptor u, v;
  u = source(e, g);
  v = target(e, g);
  return u == v;
}</pre>
        </section>

      <section id="bgl_concept_checking">
        <h2>Concept Checking</h2>
        <p>An important aspect of using a generic library is using appropriate classes as template arguments to algorithms (using classes that model the concepts specified by the requirements of the algorithm). If an improper class is used, the compiler will emit error messages, but deciphering these messages can present a significant hurdle to the user of a template library. The compiler may produce literally pages of difficult-to-decipher error messages for even a small error.</p>

        <section>
          <h3>Concept-Checking Classes</h3>
          <p>To overcome the problem of cryptic error messages from code not satisfying a concept the Boost Library has developed a C++ idiom for up-front enforcement of concept compliance, called <dfn>concept checking</dfn>. The supporting code for this idiom is available as the Boost Concept Checking Library (BCCL). For each concept, the BCCL provides a concept-checking class, such as the following concept-checking class for <code>LessThanComparable</code>. The required valid expressions for the concept are exercised in the <code class="function">constraints()</code> member function.</p>
          <pre>template &lt;var class='type'name T&gt;
struct LessThanComparableConcept {
  void constraints() {
    (bool) (a &lt; b);
  };
  T a, b;
};</pre>
          <p>The concept-checking class is instantiated with the user's template arguments at the beginning of the generic algorithm using the BCCL <code class="function">function_requires()</code> function.</p>
          <pre>#include &lt;boost/concept_check.hpp&gt;
template &lt;var class='type'name Iterator&gt;
void safe_sort(Iterator first, Iterator last) {
  typedef typename std::iterator_traits&lt;Iterator&gt;::value_type T;
  function_requires&lt; LessThanComparableConcept&lt;T&gt; &gt;();
  // other requirements . . .
  std::sort(first, last);
};</pre>
          <p>Now when <code class="function">safe_sort()</code> is misused the error message is much more comprehensible: the message is shorter, the point of error is indicated, the violated concept is listed, and the internal functions of the algorithm are not exposed.</p>
          <p>The Boost Graph Library uses concept checks to provide better error messages to users. For each <code>graph_concept</code> there is a corresponding concept-checking class defined in the <cite>boost/graph/graph_concepts.hpp</cite> header file. At the beginning of each BGL algorithm there are concept checks for each of the parameters. Error messages originating from graph <cite>concepts.hpp</cite> are a likely indication that one of the argument types given to an algorithm does not meet the algorithm's requirements for a concept.</p>
        </section>
        <section>
          <h3>Concept Archetypes</h3>
          <p>The complementary problem to concept checking is verifying whether the documented requirements for a generic algorithm actually cover the algorithm's implementation, a problem we refer to as <dfn>concept covering</dfn>. Typically, library implementors check for covering by manual inspection, which of course is error prone. We have also developed a C++ idiom that exploits the C++ compiler's type checker to automate this task. The code for concept covering is also available as part of the Boost Concept Checking Library.</p>
          <p>The BCCL provides an archetype class for each concept used in the Standard Library. An archetype class provides a minimal implementation of a concept. To check whether a concept covers an algorithm, the archetype class for the concept is instantiated and passed to the algorithm.</p>
          <p>The following example program attempts to verify that the requirements of <code class="function">std::sort()</code> are covered by an iterator that models <code>RandomAccessIterator</code> having a value type modeling <code>LessThanComparable</code>.</p>
          <pre>#include &lt;algorithm&gt;
#include &lt;boost/concept_archetype.hpp&gt;
int main() {
  using namespace boost;
  typedef less_than_comparable_archetype&lt;&gt; T;
  random access_iterator_archetype&lt;T&gt; ri;
  std::sort(ri, ri);
}</pre>
          <p>In fact, this program will not successfully compile because those concepts do not cover the requirements that <code class="function">std::sort()</code> makes of its template parameters. The resulting error message indicates that the algorithm also requires that the value type be <code>CopyConstructible</code>.</p>
          <pre>null archetype(const null archetype&lt;int&gt; &amp;) is private</pre>
          <p>Not only is the copy constructor needed, but the assignment operator is needed as well. These requirements are summarized in the <code>Assignable</code> concept. The following code shows the implementation of the archetype class for <code>Assignable</code>. The <code>Base</code> template parameter is provided so that archetypes can be combined. For checking <code class="function">std::sort()</code>, we would need to combine the archetype classes for <code>Assignable</code> and <code>LessThanComparable</code>.</p>
          <pre>template &lt;var class='type'name Base = null_archetype&lt;&gt; &gt;
class assignable_archetype : public Base {
  typedef assignable_archetype self ;
public:
  assignable archetype(const self &amp;) {}
  self &amp; operator=(const self &amp;) { return *this; }
};</pre>
          <p>The Boost Graph Library includes an archetype class for every graph concept in the header file <cite>boost/graph/graph_archetypes.hpp</cite>. Test programs to verify the specification of each BGL algorithm using the graph archetypes are located in the <cite>libs/graph/test/</cite> directory.</p>
        </section>

      </section>  <!-- end of "Concept Checking" -->

      </section>

      <section id="bgl_graph_traits">
        <h2>Graph Traits*</h2>
      </section>

      <section id="bgl_iterators">
        <h2>Graph Iterators for Traversals</h2>
        <p>The graph abstraction consists of several different kinds of collections: the vertices and edges for the graph and the out-edges, in-edges, and adjacent vertices for each vertex. The BGL uses iterators analogous to <a href="iterators">STL iterators</a> to provide access to each of these collections. The value type of these iterators is a vertex or edge <a href="bgl_vertex_and_edge_descriptors">descriptor</a>. There are five kinds of graph iterators, one for each kind of collection:</p>
        <ul>
          <dd>A <dfn>vertex iterator</dfn> is used to traverse all the vertices of a graph. The value type of a vertex iterator is a vertex descriptor.</dd>
          <dd>An <dfn>edge iterator</dfn> is used to traverse all the edges of a graph. The value type of this iterator is an edge descriptor.</dd>
          <dd>An <dfn>out-edge iterator</dfn> is used to access all of the out-edges for a given vertex <var>u</var>. Its value type is an edge descriptor. Each edge descriptor in this iterator range will have <var>u</var> as the source vertex and a vertex adjacent to <var>u</var> as the target vertex (regardless of whether the graph is directed or undirected).</dd>
          <dd>An <dfn>in-edge iterator</dfn> is used to access the in-edges of a vertex <var>v</var>. Its value type is an edge descriptor. Each edge descriptor in this iterator range will have <var>v</var> as the target vertex and a vertex that <var>v</var> is adjacent to as the source.</dd>
          <dd>An <dfn>adjacency iterator</dfn> is used to provide access to the vertices adjacent to a given vertex. The value type of this iterator is a vertex descriptor.</dd>
        </ul>
        <p><!-- Like descriptors. -->Each graph type has its own iterator types that are accessible through the <code href="bgl_graph_traits">graph_traits</code> class. For each of the above iterators, the BGL interface defines a function that returns a <kbd class="userinput">std::pair</kbd> of iterator objects: the first iterator points to the first object in the sequence and the second iterator points past the end of the sequence.</p>
        <p>For example, the following function prints the names of all of the vertices in a graph:</p>
        <pre>template &lt;var class='type'name Graph, typename VertexNameMap&gt;
void print vertex names(const Graph&amp; g, VertexNameMap name map) {
  std::cout &lt;&lt; "vertices(g) = { ";
  typedef typename graph traits&lt;Graph&gt;::vertex_iterator iter_t;
  for (std::pair&lt;iter t, iter t&gt; p = vertices(g); p.first != p.second; ++p.first) {
    print_vertex_name(*p.first, name_map);
    std::cout &lt;&lt; ' ';
  }
  std::cout &lt;&lt; "}" &lt;&lt; std::endl;
}</pre>
        <p>Most algorithms do not need to use all five types of traversal, and some graph types cannot provide efficient versions of all iterator types. Care should be taken not to use concrete graph types with algorithms that require operations not supported by that type. If you attempt to use a graph type that does not provide a required operation, then a compile error will occur. The compile error may even include some information to help you figure out which operation was missing.</p>
        <p>The available operations for a particular graph type is given in the documentation for that type. The <q>Model Of</q> section summarizes the provided operations by listing the concepts satisfied by the graph type. The operations required by each algorithm are given in the documentation for the algorithm by listing the concepts required of each parameter.</p>
      </section>

      <section>
        <h2>Graph Construction and Modification</h2>
        <p>The BGL also defines interfaces for adding and removing vertices and edges from a graph. The <code class="function">add_vertex()</code> function returns a vertex descriptor for the new vertex. We use this vertex descriptor to assign a vertex name to the vertex in a name property map:</p>
        <pre>typename graph traits&lt;Graph&gt;::vertex descriptor a, b, c, d, e;
                                        a = add vertex(g); name map[a] = 'a';
                                        b = add vertex(g); name map[b] = 'b';
                                        c = add vertex(g); name map[c] = 'c';
                                        d = add vertex(g); name map[d] = 'd';
                                        e = add vertex(g); name map[e] = 'e';</pre>
        <p>The <code class="function">add_edge()</code> function returns a <kbd class="userinput">std::pair</kbd>, where the first member of the pair is an edge descriptor for the new edge and the second is a Boolean flag that indicates whether an edge was added (some graph types will not insert an edge if an edge with the same source and target is already in the graph).</p>
        <!--
        <pre><![CDATA[]]></pre>
        <p></p>
               -->





      </section>

      <section id="bgl_visitor">
        <h2>Visitors in the BGL</h2>
        <p>The <dfn>visitor</dfn> concept plays the same role in BGL as functors play in the STL. Functors provide a mechanism for extending an algorithm; for customizing what is done at each step of the algorithm. Visitors allow the user to insert their own operations at various steps within a graph algorithm. Unlike the STL algorithms, graph algorithms typically have multiple <dfn>event points</dfn> where one may want to insert a call-back via a functor. Therefore visitors do not have a single <code class="function">operator()</code> method like a functor, but instead have several methods that correspond to the various event points. Each algorithm has a different set of event points, which are described by the following visitor concepts:</p> <ul>
          <dd><a href="bfs_visitor">BFS Visitor</a></dd>
          <dd><a href="dfs_visitor">DFS Visitor</a></dd>
          <dd><a href="dijkstra_visitor">Dijkstra Visitor</a></dd>
          <dd><a href="bellman_ford_visitor">Bellman Ford Visitor</a></dd>
          <dd><a href="a_star_visitor">A* Visitor</a></dd>
          <dd><a href="event_visitor">Event Visitor</a></dd>
          <dd><a href="planar_face_visitor">Planar Face Visitor</a></dd>
          <dd><a href="tsp_tour_visitor">TSP Tour Visitor</a></dd>
        </ul>
        <p>In the following example we print out the Internet routers in breadth-first order by extending the <code class="function">breadth_first_search()</code> function with a visitor. The visitor prints the vertex name on the discover vertex event. The visitor class is defined according to the interface described by the <a href="bfs_visitor">BFSVisitor</a> concept.</p>
        <pre>template &lt;var class='type'name VertexNameMap&gt;
class bfs_name_printer : public default_bfs_visitor {
// inherit default (empty) event point actions
public:
  bfs_name_printer(VertexNameMap n map) : m_name_map(n_map) { }
  template &lt;var class='type'name Vertex, typename Graph&gt;
  void discover_vertex(Vertex u, const Graph&amp; ) const {
    std::cout &lt;&lt; get(m_name_map, u) &lt;&lt; ' ';
  }
private:
  VertexNameMap m_name_map;
};</pre>
        <p>We then create a visitor object of type <code>bfs_name_printer</code> and pass it to <code class="function">breadth_first_search()</code>.</p>
        <pre>bfs_name_printer&lt;VertexNameMap&gt; vis(name map);
std::cout &lt;&lt; "BFS vertex discover order: ";
breadth first search(g, a, visitor(vis));
std::cout &lt;&lt; std::endl;</pre>

          <section id="bfs_visitor">
          <h4>BFS Visitor</h4>
            <p>This concept defines the visitor interface for <code class="function">breadth_first_search()</code>. Users can define a class with the BFS Visitor interface and pass and object of the class to <code class="function">breadth_first_search()</code>, thereby augmenting the actions taken during the graph search.</p>
            <h4>Refinement of</h4>
            <p>Copy Constructible (copying a visitor should be a lightweight operation).</p>
            <h4>Notation</h4>
            <ul>
              <dd><var>V</var>: 	A type that is a model of BFS Visitor.</dd>
              <dd><var>vis</var>: 	An object of type V.</dd>
              <dd><var>G</var>: 	A type that is a model of Graph.</dd>
              <dd><var>g</var>: 	An object of type G.</dd>
              <dd><var>e</var>: 	An object of type <code>boost::graph_traits&lt;G&gt;::edge_descriptor</code>.</dd>
              <dd><var>s,u</var>: 	An object of type <code>boost::graph_traits&lt;G&gt;::vertex_descriptor</code>.</dd>
            </ul>
            <h4>Valid Expressions</h4>
            <dl>
              <div class="varlistentry">
                <dt class="term">Initialize Vertex</dt>
                <dd>
                  <p><code class="function">vis.initialize_vertex(s, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on every vertex of the graph before the start of the graph search.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Discover Vertex</dt>
                <dd>
                  <p><code class="function">	vis.discover_vertex(u, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked when a vertex is encountered for the first time.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Examine Vertex</dt>
                <dd>
                  <p><code class="function">	vis.examine_vertex(u, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on a vertex as it is popped from the queue. This happens immediately before examine_edge() is invoked on each of the out-edges of vertex u.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Examine Edge</dt>
                <dd>
                  <p><code class="function">	vis.examine_edge(e, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on every out-edge of each vertex after it is discovered.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Tree Edge</dt>
                <dd>
                  <p><code class="function">	vis.tree_edge(e, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on each edge as it becomes a member of the edges that form the search tree.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Non-Tree Edge</dt>
                <dd>
                  <p><code class="function">	vis.non_tree_edge(e, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on back or cross edges for directed graphs and cross edges for undirected graphs.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Gray Target</dt>
                <dd>
                  <p><code class="function">	vis.gray_target(e, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on the subset of non-tree edges whose target vertex is colored gray at the time of examination. The color gray indicates that the vertex is currently in the queue.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Black Target</dt>
                <dd>
                  <p><code class="function">	vis.black_target(e, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This is invoked on the subset of non-tree edges whose target vertex is colored black at the time of examination. The color black indicates that the vertex has been removed from the queue.</p>
                </dd>
              </div>
              <div class="varlistentry">
                <dt class="term">Finish Vertex</dt>
                <dd>
                  <p><code class="function">	vis.finish_vertex(u, g)</code></p>
                  <p><em>return type:</em> void</p>
                  <p>This invoked on a vertex after all of its out edges have been added to the search tree and all of the adjacent vertices have been discovered (but before the out-edges of the adjacent vertices have been examined).</p>
                </dd>
              </div>

            </dl>
          </section>

          <section id="dfs_visitor"> <h2>DFS Visitor*</h2> </section>

          <section id="dijkstra_visitor"> <h2>Dijkstra Visitor*</h2> </section>

          <section id="bellman_ford_visitor"> <h2>Bellman Ford Visitor*</h2> </section>

          <section id="a_star_visitor"> <h2>A* Visitor*</h2> </section>

          <section id="event_visitor"> <h2>Event Visitor*</h2> </section>

          <section id="planar_face_visitor"> <h2>Planar Face Visitor*</h2> </section>

          <section id="tsp_tour_visitor"> <h2>TSP Tour Visitor*</h2> </section>

      </section> <!-- end of "Visitors in the BGL" -->

      <section>
        <h2>Graph Classes and Adaptors</h2>
        <p>The graph types provided by the BGL fall into two categories. The first is the graph classes that are used to store a graph in memory. The second is graph adaptors that create a modified view of a graph or that create a BGL graph interface based on some other type.</p>

        <p>The BGL contains two primary graph classes: <code href="adjacency_list">adjacency_list</code> and <code href="adjacency_matrix">adjacency_matrix</code>.</p>

        <section id="adjacency_list">
          <h3><code>adjacency_list</code></h3>
          <p>The main BGL component for representing graphs is the <code>adjacency_list</code>. This class generalizes the traditional adjacency-list representation for a graph. The graph is represented by a collection of vertices where, with each vertex, there is stored a collection of out-edges. The actual implementation of the collection of vertices and edges can vary to meet particular needs and is set through a <a href="boost_container_selectors">container selector</a>.</p>
          <p>The <code>adjacency_list</code> class has several template parameters: <var class="parameter">EdgeList</var>, <var class="parameter">VertexList</var>, <var>Directed</var>, <var>VertexProperties</var>, <var>EdgeProperties</var>, and <var>GraphProperties</var>.</p>

          <pre>adjacency_list&lt;OutEdgeList = vecS,
               VertexList = vecS,
               Directed = directedS,
               VertexProperties = no_property,
               EdgeProperties = no_property,
               GraphProperties = no_property,
               EdgeList = listS&gt;</pre>

          <p>The <code>adjacency_list</code> class implements a generalized adjacency list graph structure. The template parameters provide many configuration options so that you can pick a version of the class that best meets your needs. An adjacency-list is basically a two-dimensional structure, where each element of the first dimension represents a vertex, and each of the vertices contains a one-dimensional structure that is its edge list.</p>
          <p>The <var class="parameter">VertexList</var> template parameter of the <code>adjacency_list</code> class controls what kind of container is used to represent the outer two-dimensional container. The <var class="parameter">OutEdgeList</var> template parameter controls what kind of container is used to represent the edge lists. The choices for <var class="parameter">OutEdgeList</var> and <var class="parameter">VertexList</var> will determine the space complexity of the graph structure, and will determine the time complexity of the various graph operations. The possible choices and tradeoffs are discussed in <cite class="section" href="choosing_the_edgelist_and_vertexlist">Choosing the Edgelist and VertexList</cite>.</p>

          <p>The <var class="parameter">Directed</var> template parameter controls whether the graph is directed, undirected, or directed with access to both the in-edges and out-edges (which we call bidirectional). The bidirectional graph takes up twice the space (per edge) of a directed graph since each edge will appear in both an out-edge and in-edge list.</p>



          <ul>
            <dd><var class="parameter">EdgeList</var> and <var class="parameter">VertexList</var> specify the classes used to store the vertex list and edge lists for the graph. These parameters allow tradeoffs between traversal speed and insertion/removal speed and tradeoffs in memory consumption. In addition, the <var class="parameter">EdgeList</var> parameter determines whether parallel edges may be inserted into the graph.</dd>
            <dd><var>Directed</var> specifies whether the graph is directed, undirected, or bidirectional. By convention, a directed graph provides access to out-edges only, whereas a bidirectional graph provides access to in-edges as well as out-edges. These options are selected through <kbd class="userinput">directedS</kbd>, <kbd class="userinput">undirectedS</kbd>, and <kbd class="userinput">bidirectionalS</kbd></dd>
            <dd><var>VertexProperties</var>, <var>EdgeProperties</var>, and <var>GraphProperties</var> specify the property types that are attached to the vertices, edges, and to the graph itself. They default to <kbd class="userinput">no_property</kbd>.</dd>
          </ul>

          <section id="choosing_the_edgelist_and_vertexlist">
          <h4>Choosing the <var class="parameter">Edgelist</var> and <var class="parameter">VertexList</var></h4>
            <p>This section focuses on how to decide which version of the <code>adjacency_list</code> class to use in different situations. The <code>adjacency_list</code> is like a swiss-army knife in that it can be configured in many ways. The parameters that we will focus on in this section are <var class="parameter">OutEdgeList</var> and <var class="parameter">VertexList</var>, which control the underlying data structures that will be used to represent the graph. The choice of <var class="parameter">OutEdgeList</var> and <var class="parameter">VertexList</var> affects the time complexity of many of the graph operations and the space complexity of the graph object.</p>
          </section>

          <section>
            <h2/>
            <p><var class="parameter">OutEdgeList</var> is the selector for the container used to represent the edge-list for each of the vertices. It defaults to <kbd class="userinput">vecS</kbd>, that is it selects an <code>std::vector</code>.</p>
            <p><var class="parameter">EdgeList</var>, on the other hand, is the selector for the container used to represent the edge-list for the <em>graph</em>. It defaults to <kbd class="userinput">listS</kbd>, that is it selects an <code>std::list</code>.</p>
          </section>

          <section>
          <h4>Vertex and Edge Properties</h4>
            <p>Properties such as color, distance, weight, and user-defined properties can be attached to the vertices and edges of the graph using properties. The property values can be read from and written to via the property maps provided by the graph. The property maps are obtained via the <code class="function">get(property, g)</code> function. How to use properties is described in <cite class="section" href="BGL_internal_properties">Internal Properties</cite>. The property maps are objects that implement the interface defined in <cite class="section" href="property_map_concepts">Property Map Concepts</cite> or may be bundled properties, which have a more succinct syntax. The types of all property values must be Copy Constructible, Assignable, and Default Constructible. The property maps obtained from the <code>adjacency_list</code> class are models of the Lvalue Property Map concept. If the <code>adjacency_list</code> is const, then the property map is constant, otherwise the property map is mutable.</p>
            <p>If the <var class="parameter">VertexList</var> of the graph is <kbd class="userinput">vecS</kbd>, then the graph has a builtin vertex indices accessed via the property map for the vertex_index_t property. The indices fall in the range [0, num_vertices(g)) and are contiguous. When a vertex is removed the indices are adjusted so that they retain these properties. Some care must be taken when using these indices to access exterior property storage. The property map for vertex index is a model of Readable Property Map.</p>
          </section>

        </section>

        <section id="BGL_internal_properties">
          <h3>Internal Properties*</h3>
        </section>

          <section>
          <h3>Bundled Properties</h3>
          <p>Class templates <code>adjacency_list</code> and <code>adjacency_matrix</code> support the introduction of named properties via <a href="BGL_internal_properties">internal properties</a>. However, this method is cumbersome in many uses, where it would be more intuitive to just specify a structure or class that contains internal properties for edges or vertices. Bundled properties allow one to use adjacency_list and adjacency_matrix in this manner, providing a simple way to introduce and access any number of internal properties for vertices and edges.</p>
          <p>One can introduce bundled properties into an either graph type by providing a user-defined class type for the <var class="parameter">VertexProperties</var> or <var class="parameter">EdgeProperties</var> template arguments. The user-defined class may alternatively be placed at the end of a property list, replacing the (implicit) boost::no_property argument.</p>
          <h4>Example: Route planning</h4>
          <p>Consider the implementation of a simple route planner that should find the shortest directions from one city to another via a set of highways. The vertices of the graph are cities, and we may wish to store several bits of information about the city within each vertex:</p>
          <pre>struct City
{
  string name;
  int population;
  vector&lt;int&gt; zipcodes;
};</pre>
          <p>The edges in the graph represent highways, which also have several interesting attributes:</p>
          <pre>struct Highway
{
  string name;
  double miles;
  int speed_limit;
  int lanes;
  bool divided;
};</pre>
          <p>With bundled properties, we can directly use the <code>City</code> and <code>Highway</code> structures to define the graph:</p>
          <pre>typedef boost::adjacency_list&lt;
    boost::listS, boost::vecS, boost::bidirectionalS,
    City, Highway&gt;
  Map;</pre>
          <p>Without bundled properties, translating this example directly into an instantiation of adjacency_list would involve several custom properties and would result in a type like this:</p>
          <pre>typedef boost::adjacency_list&lt;
    boost::listS, boost::vecS, boost::bidirectionalS,
    // Vertex properties
    boost::property&lt;boost::vertex_name_t, std::string,
    boost::property&lt;population_t, int,
    boost::property&lt;zipcodes_t, std::vector&lt;int&gt; &gt; &gt; &gt;,
    // Edge properties
    boost::property&lt;boost::edge_name_t, std::string,
    boost::property&lt;boost::edge_weight_t, double,
    boost::property&lt;edge_speed_limit_t, int,
    boost::property&lt;edge_lanes_t, int,
    boost::property&lt;edge_divided, bool&gt; &gt; &gt; &gt; &gt; &gt;
  Map;</pre>
          <p>Bundling vertex and edge properties greatly simplifies the declaration of graphs.</p>
          <p>In addition to vertex and edge bundles, we can also bundle properties of the graph itself. Suppopse we extend the application to include a portfolio of route-planning maps for different countries. In addition to the <code>City</code> and <code>Highway</code> bundles above, we can declare a graph bundle, <code>Country</code>.</p>
          <pre>struct Country {
  string name;
  bool use_right;   // Drive on the left or right
  bool use_metric;  // mph or km/h
};</pre>
          <p>The graph type would now be declared as:</p>
          <pre>typedef boost::adjacency_list&lt;
    boost::listS, boost::vecS, boost::bidirectionalS,
    City, Highway, Country&gt;
  Map;</pre>

          <section>
          <h4>Accessing bundled properties</h4>
            <p>To access a bundled property for a particular edge or vertex, subscript your graph with the descriptor of the edge or vertex whose bundled property you wish to access. For instance:</p>
            <pre>Map map; // load the map
Map::vertex_descriptor v = *vertices(map).first;
map[v].name = "Troy";
map[v].population = 49170;
map[v].zipcodes.push_back(12180);
Map::edge_descriptor e = *out_edges(v, map).first;
map[e].name = "I-87";
map[e].miles = 10.;
map[e].speed_limit = 65;
map[e].lanes = 4;
map[e].divided = true;</pre>
            <p>The graph bundle, since it does not correspond to a vertex or edge descripor, is accessed using the graph_bundle object as a key.</p>
            <pre>map[graph_bundle].name = "United States";
map[graph_bundle].use_right = true;
map[graph_bundle].use_metric = false;</pre>
          </section>

          <section>
          <h4>Property maps for a graph bundle</h4>
            <p>There is currently no support for creating property maps from the bundled properties of a graph.</p>
          </section>


          <section>
          <h4>Getting the type of bundled properties</h4>
            <p>To get the type of the vertex or edge bundle for a given graph type Graph, you can use the trait classes <code>vertex_bundle_type</code> and <code>edge_bundle_type</code>. The type <code>vertex_bundle_type&lt;Graph&gt;::type</code> will be the type bundled with vertices (or <code>no_vertex_bundle</code> if the graph supports bundles but no vertex bundle exists). Likewise, <code>edge_bundle_type&lt;Graph&gt;::type</code> will be the type bundled with edges (or <code>no_edge_bundle</code> if no edge bundle exists).</p>
          </section>

          <section>
          <h4>Compatibility</h4>
            <p>Bundled properties will only work properly on compilers that support class template partial specialization.</p>
          </section>

        </section>

        <section id="adjacency_matrix">
          <h3><code>adjacency_matrix</code></h3>
          <p>The <code>adjacency_matrix</code> is the BGL class for representing dense graphs. In an <code>adjacency_matrix</code>, access to an arbitrary edge (u, v) is efficient (constant time). The adjacency matrix can represent both directed and undirected graphs and provides a mechanism for attaching properties to the vertices and edges.</p>
        </section>

        <section id="bgl_graph_adaptors">
          <h3>Graph Adaptors</h3>
          <p>The BGL also includes a large number of graph adaptors. This first group of classes adapts any BGL graph to provide new behavior.</p>
          <ul>
            <dd><code>reverse_graph</code> is an adaptor that reverses the edge directions of a directed graph on the fly, so that in-edges behave like out-edges, and vice versa.</dd>
            <dd><code>filtered_graph</code> is an adaptor that creates a view of a graph where two predicate function objects control whether vertices and edges from the original graph appear in the adapted graph, or whether they are hidden.</dd>
          </ul>
          <p>BGL also provides support for objects and data structures that are not BGL graph classes. This support is provided via adaptor classes and overloaded functions. The following describes these interfaces.</p>
          <ul>
            <dd>edge list is an adaptor that creates a BGL graph out of an iterator range of edges.</dd>
            <dd>Stanford GraphBase is supported by overloaded functions in the header file boost/- graph/stanford graph.hpp . As a result of these overloaded functions, the GraphBase type Graph* satisfies the BGL graph interface.</dd>
            <dd>LEDA is a popular object-oriented package that includes graph data structures and algorithms. Overloaded functions in the header file boost/graph/leda graph.hpp allow the LEDA graph type <kbd class="userinput">GRAPH&lt;vtype, etype&gt;</kbd> to satisfy the BGL graph interface.</dd>
            <dd>The STL composite type <kbd class="userinput">std::vector&lt; std::list&lt;int&gt; &gt;</kbd> is supported as a graph by overloaded functions in the header file <cite>boost/graph/vector_as_graph.hpp</cite>.</dd>
          </ul>
          <p>Each graph class implements some (or all) of these concepts. The <code>adjacency_list</code> class can be considered a canonical implementation (or model) of a BGL graph, as it illustrates all of the basic ideas and interfaces of the BGL graphs.</p>
        </section>

      </section>



      <section id="bgl_algorithms">
        <h2>Boost Generic Graph Algorithms</h2>
        <p>The BGL graph algorithms are generic algorithms. As such, they are highly flexible in terms of the types of graph data structures to which they can be applied and in terms of how the algorithms can be customized to solve a wide range of problems.</p>
        <p>The BGL algorithms consist of a core set of algorithm patterns (implemented as generic algorithms) and a larger set of graph algorithms. The core algorithm patterns are:</p>
        <ul>
          <dd>Breadth First Search</dd>
          <dd>Depth First Search</dd>
          <dd>Uniform Cost Search</dd>
        </ul>
        <p>By themselves, the algorithm patterns do not compute any meaningful quantities over graphs; they are merely building blocks for constructing graph algorithms. The graph algorithms in the BGL currently include:</p>
        <ul>
          <li>Dijkstra's Shortest Paths</li>
          <li>Bellman-Ford Shortest Paths</li>
          <li>Johnson's All-Pairs Shortest Paths</li>
          <li>Kruskal's Minimum Spanning Tree</li>
          <li>Prim's Minimum Spanning Tree</li>
          <li>Connected Components</li>
          <li>Strongly Connected Components</li>
          <li>Dynamic Connected Components (using Disjoint Sets)</li>
          <li>Topological Sort</li>
          <li>Transpose</li>
          <li>Reverse Cuthill Mckee Ordering</li>
          <li>Smallest Last Vertex Ordering</li>
          <li>Sequential Vertex Coloring</li>
        </ul>

        <section>
          <h3>Building the Topological Sort Generic Algorithm from generic <code class="function">depth_first_search()</code></h3>
          <p>First, we shall look at using the <code class="function">topological_sort()</code> function with two different graph types, and then we shall demonstrate the power of the generic <code class="function">depth_first_search()</code> function by showing how it can be used to implement <code class="function">topological sort()</code>.</p>
          <p>A <dfn>topological ordering</dfn> of a directed graph is an ordering of its vertices such that if there is an edge (<var>u</var>, <var>v</var>) in the graph, then vertex <var>u</var> appears before vertex <var>v</var> in the ordering. The BGL <code class="function">topological_sort()</code> function template takes two arguments: the graph to be ordered and an output iterator. The algorithm writes vertices to the output iterator in reverse topological order.</p>
          <p>One use for topological orderings is for scheduling tasks.</p>
          <section>
          <h4>Using Topological Sort with a Vector of Lists</h4>
            <p>First we apply the topological sort to a graph built using <kbd class="userinput">std::vector&lt;std::list&lt;int&gt;&gt;</kbd>. The following is the outline of the program.</p>
            <pre>// "topo-sort1.cpp" 15a
#include &lt;deque&gt; // to store the vertex ordering
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;boost/graph/vector_as_graph.hpp&gt;
#include &lt;boost/graph/topological_sort.hpp&gt;
int main()
{
  using namespace boost;
  // Create labels for each of the tasks 15b
  // Create the graph 15c
  // Perform the topological sort and output the results 16
  return EXIT_SUCCESS;
}</pre>
            <p>The vertices of the graph are represented using the integers from zero to six; storing the vertex labels in an array is therefore a convenient choice.</p>
            <pre>// Create labels for each of the tasks 15b &#x2261;
const char* tasks[ ] =
{
  "pick up kids from school",
  "buy groceries (and snacks)",
  "get cash at ATM",
  "drop off kids at soccer practice",
  "cook dinner",
  "pick up kids from soccer",
  "eat dinner"
};
const int n_tasks = sizeof (tasks) / sizeof (char*);</pre>
            <p>The graph is realized as a vector of lists. Each vertex in the graph is associated with an index location in the vector. The size of the vector is thus the number of vertices in the graph. The list at that index location is used to represent the edges from that vertex to other vertices in the graph. Each edge (u, v) is added to the graph by pushing the integer for <var>v</var> onto the <var>u</var>th list. Due to the functions defined in <cite>boost/graph/vector_as_graph.hpp</cite> the vector of lists satisfies the requirements of the BGL <var class="parameter">VertexList</var>Graph concept, and therefore can be used in the <code class="function">topological_sort()</code> function.</p>
            <pre>// Create the graph 15c &#x2261;
std::vector&lt; std::list&lt;int&gt; &gt; g(n tasks);
g[0].push back(3);
g[1].push back(3);
g[1].push back(4);
g[2].push back(1);
g[3].push back(5);
g[4].push back(6);
g[5].push back(6);</pre>
            <p>Before we call <code class="function">topological_sort()</code> we need to create a place to store the results. The BGL algorithm for topological sort writes its output in reverse topological order (because it is more efficient to implement it that way). Recovering the topological order requires reversing the ordering computed by the algorithm. The following example uses <kbd class="userinput">std::deque</kbd> as its output data structure because it supports constant time insertion at the front, which will reverse the ordering. In addition, calling <code class="function">topological_sort()</code> requires one of two things: (1) supply a color property map so that the algorithm can mark vertices to keep track of its progress through the graph or (2) supply a mapping from vertices to integers so that the algorithm can create its own color map with an array.</p>
            <p>Since in this example the vertices are already integers, we just pass <code class="function">identity_property_map</code> in as the <code class="function">vertex_index_map</code>. The <code class="function">vertex_index_map()</code> function is used to specify a named parameter.</p>
            <pre>// Perform the topological sort and output the results 16 &#x2261;
std::deque&lt;int&gt; topo_order;

topological sort(g, std::front_inserter(topo_order),
 vertex_index_map(identity_property_map()));

int n = 1;
for (std::deque&lt;int&gt;::iterator i = topo_order.begin();
     i != topo order.end();
     ++i, ++n)
  std::cout &lt;&lt; tasks[*i] &lt;&lt; std::endl;</pre>
            <p>The output shows an order in which the tasks could be carried out.</p>
            <pre>get cash at ATM
buy groceries (and snacks)
cook dinner
pick up kids from school
drop off kids at soccer practice
pick up kids from soccer
eat dinner</pre>
          </section>
          <section>
          <h4>Using Topological Sort with the <code>adjacency_list</code> Class</h4>
            <p>To demonstrate the flexibility of the generic algorithm <code class="function">topological_sort()</code> we now change to using an altogether different graph type: the BGL <code>adjacency_list</code> class template. Since the <code class="function">topological_sort()</code> function is a function template, graph structures of arbitrary type can be used. All that is required is that the type satisfies the concepts required by the algorithm.</p>
            <p>The first two template parameters of the adjacency list class determine the particular internal structure that will be used. The first argument <var>listS</var> specifies that <kbd class="userinput">std::list</kbd> is used for each out-edge list. The second argument <var>vecS</var> specifies that std::vector is used as the backbone of the adjacency list. This version of the <code>adjacency_list</code> class is similar in character to the vector of lists used in the previous section.</p>
            <pre>// Create an adjacency list object 17a &#x2261;
adjacency_list&lt;listS, vecS, directedS&gt; g(n_tasks);</pre>
            <p>The function <code class="function">add_edge()</code> provides the interface for inserting edges into an <code>adjacency_list</code> (and all other graphs that support the EdgeMutableGraph concept). The vertex descriptor type for <code>adjacency_list</code> is an integer when <kbd class="userinput">std::vector</kbd> is used for the backbone, which is why we can use integers below to specify vertices. It is not always true for a given graph type that one can use integers to specify vertices.</p>
            <pre>// Add edges to the adjacency list 17b i &#x2261;
  add_edge(0, 3, g);
  add_edge(1, 3, g);
  add_edge(1, 4, g);
  add_edge(2, 1, g);
  add_edge(3, 5, g);
  add_edge(4, 6, g);
  add_edge(5, 6, g);</pre>
            <p>The rest of the program is similar to the previous example, except that the <cite>adjacency_list.hpp</cite> header file is included instead of <cite>vector_as_graph.hpp</cite>. The following is the code for the program, with two of the parts reused from the previous section.</p>
            <pre>// "topo-sort2.cpp" 18 &#x2261;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;boost/graph/topological_sort.hpp&gt;
#include &lt;boost/graph/adjacency_list.hpp&gt;
int main() {
  using namespace boost;
  // Create labels for each of the tasks 15bi
  // Create an adjacency list object 17ai
  // Add edges to the adjacency list 17bi
  // Perform the topological sort and output the results 16i
  return EXIT_SUCCESS;
}</pre>
          </section>
        </section>

        <section id="bgl_depth-first_search">
          <h3>The Depth-First Search Generic Algorithm</h3>
          <p>The BGL implementation of <code class="function">topological_sort()</code> is only a few lines long because it can be implemented using the <code class="function">depth_first_search()</code> function (and, in fact, the topological sort algorithm is typically presented this way in text books). The implementation consists of <code class="function">depth_first_search()</code> used with a visitor that records the order in which vertices pass through the "finish vertex" event of the depth-first search.</p>
          <p>The following code creates an algorithm visitor class that records vertices as they pass through the finish event point of a depth-first search. For added genericity, the vertex ordering is recorded in an output iterator, allowing the user to choose from a variety of output methods.</p>
          <pre>template &lt;var class='type'name OutputIterator&gt;
class topo_sort_visitor : public default_dfs_visitor { // inherit empty actions
public:
  topo_sort_visitor(OutputIterator iter) : m_iter(iter) { }
  template &lt;var class='type'name Vertex, typename Graph&gt;
  void finish_vertex(Vertex u, const Graph&amp;) { *m_iter++ = u; }
private:
  OutputIterator m_iter;
};</pre>
          <p>Thus, <code class="function">topological_sort()</code> is implemented by invoking <code class="function">depth_first_search()</code> using the <code>topo_sort_visitor</code> as a parameter.</p>
          <pre>template &lt;var class='type'name Graph, typename OutputIterator&gt;
void topological sort(Graph&amp; g, OutputIterator result iter) {
  topo_sort_visitor&lt;OutputIterator&gt; vis(result_iter);
  depth_first_search(g, visitor(vis));
}</pre>
        </section>

      </section> <!-- end of "Boost Generic Graph Algorithms" -->

      <section id="bgl_data_structures">
        <h2>BGL Data Structures</h2>
        <p>The BGL provides two graph classes and an edge list adaptor:</p>
        <ul>
          <li href="bgl_adjacency_list"><code>adjacency_list</code></li>
          <li href="bgl_adjacency_matrix"><code>adjacency_matrix</code></li>
          <li href="bgl_edge_list"><code>edge_list</code></li>
        </ul>
        <p>The <code>adjacency_list</code> class is the general purpose <q>swiss army knife</q> of graph classes. It is highly parameterized so that it can be optimized for different situations: the graph is directed or undirected, allow or disallow parallel edges, efficient access to just the out-edges or also to the in-edges, fast vertex insertion and removal at the cost of extra space overhead, etc.</p>
        <p>The <code>adjacency_matrix</code> class stores edges in a <var>n</var> x <var>n</var> matrix (where <var>n</var> is the number of vertices). The elements of this matrix represent edges in the graph. Adjacency matrix representations are especially suitable for very dense graphs, i.e., those where the number of edges approaches <var>n</var><sup>2</sup>.</p>
        <p>The <code>edge_list</code> class is an adaptor that takes any kind of edge iterator and implements an <code href="bgl_edge_list_graph">Edge List Graph</code>.</p>

        <section id="bgl_adjacency_list">
          <h3>BGL <code>adjacency_list</code>*</h3>
        </section>
        <section id="bgl_adjacency_matrix">
          <h3>BGL <code>adjacency_matrix</code>*</h3>
        </section>
        <section id="bgl_edge_list">
          <h3>BGL <code>edge_list</code></h3>
        </section>

        <section id="bgl_edge_list_graph">
          <h3>BGL <code>Edge List Graph</code>*</h3>
        </section>

      </section>

      <section id="bgl_property_map">
        <h2>BGL Property Maps</h2>
        <p>The main link between the abstract mathematical nature of graphs and the concrete problems they are used to solve is the properties that are attached to the vertices and edges of a graph, things like distance, capacity, weight, color, etc. There are many ways to attach properties to a graph in terms of data-structure implementation, but graph algorithms should not have to deal with the implementation details of the properties. The property map interface discussed in section <a href="boost_property_maps">Property Maps</a> provides a generic method for accessing properties from graphs. This is the interface used in the BGL algorithms to access properties.</p>
        <p>In the BGL we refer to attached objects or attached quantities as <dfn>properties</dfn>. There are a wide variety of implementation techniques that can be used to associate a property with a vertex or edge. These include properties as data members of a struct, separate arrays indexed by vertex or edge number, hash tables, and so on. However, to write generic graph algorithms we need a uniform syntax for accessing properties, regardless of how they are stored. This uniform syntax is defined by the property map concepts.</p>
        <p>The following example is a generic function that prints the name of a vertex given a name property map:</p>
        <pre>template &lt;var class='type'name VertexDescriptor, typename VertexNameMap&gt;
void print_vertex name(VertexDescriptor v, VertexNameMap name map) {
  std::cout &lt;&lt; get(name map, v);
}</pre>
        <p>...</p>


        <section id="bgl_property_map_interface">
          <h3>Property Map Interface</h3>
          <p>The property map interface specifies that each property is accessed using a separate property map object. In the following example we show an implementation of the relax() function used inside of Dijkstra's shortest paths algorithm. In this function, we need to access the weight property of an edge, and the distance property of a vertex. We write relax() as a template function so that it can be used in many difference situations. Two of the arguments to the function, weight and distance, are the property map objects. In general, BGL algorithms explicitly pass property map objects for every property that a function will need. The property map interface defines several functions, two of which we use here: get() and put(). The get() function takes a property map object, such as distance and a key object. In the case of the distance property we are using the vertex objects u and v as keys. The get() function then returns the property value for the vertex.</p>
          <pre>template &lt;class Edge, class Graph,
            class WeightPropertyMap,
            class DistancePropertyMap&gt;
  bool relax(Edge e, const Graph&amp; g,
             WeightPropertyMap weight,
             DistancePropertyMap distance)
  {
    typedef typename graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
    Vertex u = source(e,g), v = target(e,g);
    if ( get(distance, u) + get(weight, e) &lt; get(distance, v)) {
      put(distance, v, get(distance, u) + get(weight, e));
      return true;
    } else
      return false;
  }</pre>
<p>The function <code class="function">get()</code> returns a copy of the property value. There is a third function in the property map interface, at(), that returns a reference to the property value (a const reference if the map is not mutable).</p>
<p>Similar to the iterator_traits class of the STL, there is a property_traits class that can be used to deduce the types associated with a property map type: the key and value types, and the property map category (which is used to tell whether the map is readable, writeable, or both). In the relax() function we could have used property_traits to declare local variables of the distance property type.</p>
<pre>  {
    typedef typename graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
    Vertex u = source(e,g), v = target(e,g);
    typename property_traits&lt;DistancePropertyMap&gt;::value_type
      du, dv; // local variables of the distance property type
    du = get(distance, u);
    dv = get(distance, v);
    if (du + get(weight, e) &lt; dv) {
      put(distance, v, du + get(weight, e));
      return true;
    } else
      return false;
  }</pre>
<p>There are two kinds of graph properties: interior and exterior:</p>
<dl>
  <div class="varlistentry">
    <dt class="term">Interior Properties</dt>
    <dd>are stored <em>inside</em> the graph object in some way, and the lifetime of the property value objects is the same as that of the graph object.</dd>
  </div>
  <div class="varlistentry">
    <dt class="term">Exterior Properties</dt>
    <dd>are stored <em>outside</em> of the graph object and the lifetime of the property value objects is independent of the graph. This is useful for properties that are only needed temporarily, perhaps for the duration of a particular algorithm such as the color property used in breadth_first_search(). When using exterior properties with a BGL algorithm a property map object for the exterior property must be passed as an argument to the algorithm.</dd>
  </div>
</dl>
<section>
  <h2>Interior Properties</h2>
  <p>A graph type that supports interior property storage (such as <code>adjacency_list</code>) provides access to its property map objects through the interface defined in <code>PropertyGraph</code>. There is a function get(Property, g) that get property map objects from a graph. The first argument is the property type to specify which property you want to access and the second argument is the graph object. A graph type must document which properties (and therefore tags) it provides access to. The type of the property map depends on the type of graph and the property being mapped. A trait class is defined that provides a generic way to deduce the property map type: property_map. The following code shows how one can obtain the property map for the distance and weight properties of some graph type.</p>
  <pre>  property_map&lt;Graph, vertex_distance_t&gt;::type d
    = get(vertex_distance, g);

  property_map&lt;Graph, edge_weight_t&gt;::type w
    = get(edge_weight, g);</pre>
  <p>In general, the BGL algorithms require all property maps needed by the algorithm to be explicitly passed to the algorithm. For example, the BGL Dijkstra's shortest paths algorithm requires four property maps: distance, weight, color, and vertex ID.</p>
  <p>Often times some or all of the properties will be interior to the graph, so one would call Dijkstra's algorithm in the following way (given some graph g and source vertex src).</p>
  <pre>dijkstra_shortest_paths(g, src, distance_map(get(vertex_distance, g)).
    weight_map(get(edge_weight, g)).
    color_map(get(vertex_color, g)).
    vertex_index_map(get(vertex_index, g)));</pre>
  <p>Since it is somewhat cumbersome to specify all of the property maps, BGL provides defaults that assume some of the properties are interior and can be accessed via get(Property, g) from the graph, or if the property map is only used internally, then the algorithm will create a property map for itself out of an array and using the graph's vertex index map as the offset into the array. Below we show a call to dijkstra_shortest_paths algorithm using all defaults for the named parameters. This call is equivalent to the previous call to Dijkstra's algorithm.</p>
  <pre>dijkstra_shortest_paths(g, src);</pre>
  <p>The next question is: how do interior properties become attached to a graph object in the first place? This depends on the graph class that you are using. The adjacency_list graph class of BGL uses a property mechanism (see Section Internal Properties) to allow an arbitrary number of properties to be stored on the edges and vertices of the graph.</p>
</section> <!-- end of "Interior Properties" -->

<section>
  <h2>Exterior Properties</h2>
  <p>In this section we will describe two methods for constructing exterior property maps, however there is an unlimited number of ways that one could create exterior properties for a graph.</p>
  <p>The first method uses the adaptor class iterator_property_map. This class wraps a random access iterator, creating a property map out of it. The random access iterator must point to the beginning of a range of property values, and the length of the range must be the number of vertices or edges in the graph (depending on whether it is a vertex or edge property map). The adaptor must also be supplied with an ID property map, which will be used to map the vertex or edge descriptor to the offset of the property value (offset from the random access iterator). The ID property map will typically be an interior property map of the graph. The following example shows how the iterator_property_map can be used to create exterior property maps for the capacity and flow properties, which are stored in arrays. The arrays are indexed by edge ID. The edge ID is added to the graph using a property, and the values of the ID's are given when each edge is added to the graph. The complete source code for this example is in example/exterior_edge_properties.cpp. The print_network() function prints out the graph with the flow and capacity values.</p>
  <pre>typedef adjacency_list&lt;vecS, vecS, bidirectionalS,
  no_property, property&lt;edge_index_t, std::size_t&gt; &gt; Graph;

const int num_vertices = 9;
Graph G(num_vertices);

int capacity_array[] = { 10, 20, 20, 20, 40, 40, 20, 20, 20, 10 };
int flow_array[] = { 8, 12, 12, 12, 12, 12, 16, 16, 16, 8 };

// Add edges to the graph, and assign each edge an ID number.
add_edge(0, 1, 0, G);
// ...

typedef graph_traits&lt;Graph&gt;::edge_descriptor Edge;
typedef property_map&lt;Graph, edge_index_t&gt;::type EdgeID_Map;
EdgeID_Map edge_id = get(edge_index, G);

iterator_property_map
  &lt;int*, int, int&amp;, EdgeID_Map&gt;
    capacity(capacity_array, edge_id),
    flow(flow_array, edge_id);

print_network(G, capacity, flow);</pre>

<p>The second method uses a pointer type (a pointer to an array of property values) as a property map. This requires the key type to be an integer so that it can be used as an offset to the pointer. The adjacency_list class with template parameter <var class="parameter">VertexList</var>=vecS uses integers for vertex descriptors (indexed from zero to the number of vertices in the graph), so they are suitable as the key type for a pointer property map. When the <var class="parameter">VertexList</var> is not vecS, then the vertex descriptor is not an integer, and cannot be used with a pointer property map. Instead the method described above of using a iterator_property_map with an ID property must be used. The edge_list class may also use an integer type for the vertex descriptor, depending on how the adapted edge iterator is defined. The example in example/bellman_ford.cpp shows edge_list being used with pointers as vertex property maps.</p>
<p>The reason that pointers can be used as property maps is that there are several overloaded functions and a specialization of property_traits in the header boost/property_map/property_map.hpp that implement the property map interface in terms of pointers. The definition of those functions is listed here.</p>
<pre>namespace boost {
template &lt;class T&gt;
struct property_traits&lt;T*&gt; {
  typedef T value_type;
  typedef ptrdiff_t key_type;
  typedef lvalue_property_map_tag category;
};

template &lt;class T&gt;
void put(T* pa, std::ptrdiff_t key, const T&amp; value) { pa[key] = value;  }

template &lt;class T&gt;
const T&amp; get(const T* pa, std::ptrdiff_t key) { return pa[key]; }

template &lt;class T&gt;
const T&amp; at(const T* pa, std::ptrdiff_t key) { return pa[key]; }

template &lt;class T&gt;
  T&amp; at(T* pa, std::ptrdiff_t key) { return pa[key]; }
}</pre>
<p>In the following example, we use an array to store names of cities for each vertex in the graph, and a std::vector to store vertex colors which will be needed in a call to breadth_first_search(). Since the iterator of a std::vector (obtained with a call to begin()) is a pointer, the pointer property map method also works for std::vector::iterator. The complete source code for this example is in example/city_visitor.cpp.</p>
<pre>// Definition of city_visitor omitted...

int main(int,char*[])
{
  enum { SanJose, SanFran, LA, SanDiego, Fresno, LosVegas, Reno,
         Sacramento, SaltLake, Pheonix, N };

  // An array of vertex name properties
  std::string names[] = { "San Jose", "San Francisco",  "San Jose",
                          "San Francisco", "Los Angeles", "San Diego",
                          "Fresno", "Los Vegas", "Reno", "Sacramento",
                          "Salt Lake City", "Pheonix" };

  // Specify all the connecting roads between cities.
  typedef std::pair&lt;int,int&gt; E;
  E edge_array[] = { E(Sacramento, Reno), ... };

  // Specify the graph type.
  typedef adjacency_list&lt;vecS, vecS, undirectedS&gt; Graph;
  // Create the graph object, based on the edges in edge_array.
  Graph G(N, edge_array, edge_array + sizeof(edge_array)/sizeof(E));

  // DFS and BFS need to "color" the vertices.
  // Here we use std::vector as exterior property storage.
  std::vector&lt;default_color_type&gt; colors(N);

  cout &lt;&lt; "*** Depth First ***" &lt;&lt; endl;
  depth_first_search(G, city_visitor(names), colors.begin());
  cout &lt;&lt; endl;

  // Get the source vertex
  boost::graph_traits&lt;Graph&gt;::vertex_descriptor
    s = vertex(SanJose, G);

  cout &lt;&lt; "*** Breadth First ***" &lt;&lt; endl;
  breadth_first_search(G, s, city_visitor(names), colors.begin());

  return 0;
}</pre>

</section> <!-- end of "Exterior Properties" -->

<section>
  <h2>Constructing an Exterior Property Map</h2>
  <p>Implementing your own exterior property maps is not very difficult. You simply need to overload the functions required by the property map concept that you want your class to model. At most, this means overloading the put() and get() functions and implementing operator[]. Also, your property map class will need to have nested typedefs for all the types defined in property_traits, or you can create a specialization of property_traits for your new property map type.</p>
  <p>The implementation of the iterator_property_map class serves as a good example for how to build and exterior property map. Here we present a simplified implementation of the iterator_property_map class which we will name iterator_pa.</p>
  <p>We start with the definition of the iterator_map class itself. This adaptor class is templated on the adapted Iterator type and the ID property map. The job of the ID property map is to map the key object (which will typically be a vertex or edge descriptor) to an integer offset. The iterator_map class will need the three necessary typedefs for a property map: key_type, value_type, and category. We can use property_traits to find the key type of IDMap, and we can use iterator_traits to determine the value type of Iterator. We choose boost::lvalue_property_map_tag for the category since we plan on implementing the at() function.</p>
  <pre>template &lt;class Iterator, class IDMap&gt;
class iterator_map
{
public:
  typedef typename boost::property_traits&lt;IDMap&gt;::key_type key_type;
  typedef typename std::iterator_traits&lt;Iterator&gt;::value_type value_type;
  typedef boost::lvalue_property_map_tag category;

  iterator_map(Iterator i = Iterator(),
              const IDMap&amp; id = IDMap())
    : m_iter(i), m_id(id) { }
  Iterator m_iter;
  IDMap m_id;
};</pre>

  <p>Next we implement the three property map functions, get(), put(), and at(). In each of the functions, the key object is converted to an integer offset using the m_id property map, and then that is used as an offset to the random access iterator m_iter.</p>
  <pre>template &lt;class Iter, class ID&gt;
typename std::iterator_traits&lt;Iter&gt;::value_type
get(const iterator_map&lt;Iter,ID&gt;&amp; i,
    typename boost::property_traits&lt;ID&gt;::key_type key)
{
  return i.m_iter[i.m_id[key]];
}
template &lt;class Iter, class ID&gt;
void
put(const iterator_map&lt;Iter,ID&gt;&amp; i,
    typename boost::property_traits&lt;ID&gt;::key_type key,
    const typename std::iterator_traits&lt;Iter&gt;::value_type&amp; value)
{
  i.m_iter[i.m_id[key]] = value;
}
template &lt;class Iter, class ID&gt;
typename std::iterator_traits&lt;Iter&gt;::reference
at(const iterator_map&lt;Iter,ID&gt;&amp; i,
    typename boost::property_traits&lt;ID&gt;::key_type key)
{
  return i.m_iter[i.m_id[key]];
}</pre>
<p>That is it. The iterator_map class is complete and could be used just like the iterator_property_map in the previous section.</p>
          </section>
        </section>
      </section>  <!-- end of "BGL Property Maps" -->

      <section id="bgl_external_adaptation">
        <h2>How to Convert Existing Graphs to the BGL*</h2>
      </section> <!-- end of "How to Convert Existing Graphs to the BGL" -->

      <section id="bgl_examples">
        <h2>BGL (Boost Graph Library) Examples</h2>
        <p>This is a list of the files listed in section <cite>/BGL/examples_1_71_0/i</cite>:</p>
        <ul>
          <li><a href="mcgregor_subgraphs_example_cpp"><cite>mcgregor_subgraphs_example.cpp</cite></a></li>
          <li><a href="max_flow2_dat"><cite>max_flow2.dat</cite></a></li>
          <li><a href="Jamfile_v2"><cite>Jamfile.v2</cite></a></li>
          <li><a href="cuthill_mckee_ordering_expected"><cite>cuthill_mckee_ordering.expected</cite></a></li>
          <li><a href="cycle_ratio_example_cpp"><cite>cycle_ratio_example.cpp</cite></a></li>
          <li><a href="filtered_vec_as_graph_cpp"><cite>filtered_vec_as_graph.cpp</cite></a></li>
          <li><a href="sgb-regression_cfg"><cite>sgb-regression.cfg</cite></a></li>
          <li><a href="graph_cpp"><cite>graph.cpp</cite></a></li>
          <li><a href="quick_tour_expected"><cite>quick_tour.expected</cite></a></li>
          <li><a href="knights_tour_expected"><cite>knights_tour.expected</cite></a></li>
          <li><a href="hawick_circuits_cpp"><cite>hawick_circuits.cpp</cite></a></li>
          <li><a href="loops_dfs_cpp"><cite>loops_dfs.cpp</cite></a></li>
          <li><a href="dfs_parenthesis_expected"><cite>dfs_parenthesis.expected</cite></a></li>
          <li><a href="property-map-traits-eg_cpp"><cite>property-map-traits-eg.cpp</cite></a></li>
          <li><a href="family_tree_cpp"><cite>family_tree.cpp</cite></a></li>
          <li><a href="graph-thingie_cpp"><cite>graph-thingie.cpp</cite></a></li>
          <li><a href="kuratowski_subgraph_cpp"><cite>kuratowski_subgraph.cpp</cite></a></li>
          <li><a href="visitor_expected"><cite>visitor.expected</cite></a></li>
          <li><a href="girth_cpp"><cite>girth.cpp</cite></a></li>
          <li><a href="ordered_out_edges_cpp"><cite>ordered_out_edges.cpp</cite></a></li>
          <li><a href="dfs-example_cpp"><cite>dfs-example.cpp</cite></a></li>
          <li><a href="remove_edge_if_dir_cpp"><cite>remove_edge_if_dir.cpp</cite></a></li>
          <li><a href="r_c_shortest_paths_example_cpp"><cite>r_c_shortest_paths_example.cpp</cite></a></li>
          <li><a href="tc_dot"><cite>tc.dot</cite></a></li>
          <li><a href="remove_edge_if_undir_expected"><cite>remove_edge_if_undir.expected</cite></a></li>
    bcsstk01
          <li><a href="bfs_basics_expected"><cite>bfs_basics.expected</cite></a></li>
          <li><a href="remove_edge_if_bidir_cpp"><cite>remove_edge_if_bidir.cpp</cite></a></li>
          <li><a href="incremental-components-eg_cpp"><cite>incremental-components-eg.cpp</cite></a></li>
          <li><a href="degree_centrality_cpp"><cite>degree_centrality.cpp</cite></a></li>
          <li><a href="incremental_components_cpp"><cite>incremental_components.cpp</cite></a></li>
          <li><a href="reachable-loop-tail_cpp"><cite>reachable-loop-tail.cpp</cite></a></li>
          <li><a href="iohb_h"><cite>iohb.h</cite></a></li>
          <li><a href="bfs_cpp"><cite>bfs.cpp</cite></a></li>
          <li><a href="astar-cities_cpp"><cite>astar-cities.cpp</cite></a></li>
          <li><a href="max_flow_expected"><cite>max_flow.expected</cite></a></li>
          <li><a href="data3_txt"><cite>data3.txt</cite></a></li>
          <li><a href="influence_prestige_cpp"><cite>influence_prestige.cpp</cite></a></li>
          <li><a href="remove_edge_if_dir_expected"><cite>remove_edge_if_dir.expected</cite></a></li>
          <li><a href="in_edges_expected"><cite>in_edges.expected</cite></a></li>
          <li><a href="interior_property_map_cpp"><cite>interior_property_map.cpp</cite></a></li>
          <li><a href="cycle-file-dep2_cpp"><cite>cycle-file-dep2.cpp</cite></a></li>
          <li><a href="comm_network_graph"><cite>comm_network.graph</cite></a></li>
          <li><a href="modify_graph_expected"><cite>modify_graph.expected</cite></a></li>
          <li><a href="copy-example_cpp"><cite>copy-example.cpp</cite></a></li>
          <li><a href="interior_pmap_bundled_cpp"><cite>interior_pmap_bundled.cpp</cite></a></li>
          <li><a href="prim_expected"><cite>prim.expected</cite></a></li>
          <li><a href="graph-assoc-types_cpp"><cite>graph-assoc-types.cpp</cite></a></li>
          <li><a href="reverse_graph_cpp"><cite>reverse_graph.cpp</cite></a></li>
          <li><a href="filtered_graph_cpp"><cite>filtered_graph.cpp</cite></a></li>
          <li><a href="johnson_expected"><cite>johnson.expected</cite></a></li>
          <li><a href="edge_iterator_constructor_dat"><cite>edge_iterator_constructor.dat</cite></a></li>
          <li><a href="family_tree_expected"><cite>family_tree.expected</cite></a></li>
          <li><a href="grid_graph_properties_cpp"><cite>grid_graph_properties.cpp</cite></a></li>
          <li><a href="bron_kerbosch_print_cliques_cpp"><cite>bron_kerbosch_print_cliques.cpp</cite></a></li>
          <li><a href="prism_3_2_graph"><cite>prism_3_2.graph</cite></a></li>
          <li><a href="kevin-bacon_cpp"><cite>kevin-bacon.cpp</cite></a></li>
          <li><a href="modify_graph_cpp"><cite>modify_graph.cpp</cite></a></li>
          <li><a href="inclusive_mean_geodesic_cpp"><cite>inclusive_mean_geodesic.cpp</cite></a></li>
          <li><a href="kruskal-example_cpp"><cite>kruskal-example.cpp</cite></a></li>
          <li><a href="topo-sort-file-dep_cpp"><cite>topo-sort-file-dep.cpp</cite></a></li>
          <li><a href="print-in-edges_cpp"><cite>print-in-edges.cpp</cite></a></li>
          <li><a href="make_connected_cpp"><cite>make_connected.cpp</cite></a></li>
          <li><a href="kruskal-telephone_cpp"><cite>kruskal-telephone.cpp</cite></a></li>
          <li><a href="neighbor_bfs_cpp"><cite>neighbor_bfs.cpp</cite></a></li>
          <li><a href="boost_web_graph_cpp"><cite>boost_web_graph.cpp</cite></a></li>
          <li><a href="make_maximal_planar_cpp"><cite>make_maximal_planar.cpp</cite></a></li>
          <li><a href="subgraph_properties_cpp"><cite>subgraph_properties.cpp</cite></a></li>
          <li><a href="helper_hpp"><cite>helper.hpp</cite></a></li>
          <li><a href="in_edges_cpp"><cite>in_edges.cpp</cite></a></li>
          <li><a href="miles_span_cpp"><cite>miles_span.cpp</cite></a></li>
          <li><a href="accum-compile-times_cpp"><cite>accum-compile-times.cpp</cite></a></li>
          <li><a href="cycle_canceling_example_cpp"><cite>cycle_canceling_example.cpp</cite></a></li>
          <li><a href="max_flow6_dat"><cite>max_flow6.dat</cite></a></li>
          <li><a href="components_on_edgelist_cpp"><cite>components_on_edgelist.cpp</cite></a></li>
          <li><a href="edge_iterator_constructor_cpp"><cite>edge_iterator_constructor.cpp</cite></a></li>
          <li><a href="dijkstra-example-listS_cpp"><cite>dijkstra-example-listS.cpp</cite></a></li>
          <li><a href="vertex_basics_cpp"><cite>vertex_basics.cpp</cite></a></li>
          <li><a href="max_flow_cpp"><cite>max_flow.cpp</cite></a></li>
          <li><a href="make_biconnected_planar_cpp"><cite>make_biconnected_planar.cpp</cite></a></li>
          <li><a href="last-mod-time_cpp"><cite>last-mod-time.cpp</cite></a></li>
          <li><a href="subgraph_cpp"><cite>subgraph.cpp</cite></a></li>
          <li><a href="cuthill_mckee_ordering_cpp"><cite>cuthill_mckee_ordering.cpp</cite></a></li>
          <li><a href="iohb_c"><cite>iohb.c</cite></a></li>
          <li><a href="topo-sort-with-sgb_cpp"><cite>topo-sort-with-sgb.cpp</cite></a></li>
          <li><a href="vector_as_graph_cpp"><cite>vector_as_graph.cpp</cite></a></li>
          <li><a href="adj_list_ra_edgelist_cpp"><cite>adj_list_ra_edgelist.cpp</cite></a></li>
          <li><a href="remove_edge_if_bidir_expected"><cite>remove_edge_if_bidir.expected</cite></a></li>
          <li><a href="graph_property_cpp"><cite>graph_property.cpp</cite></a></li>
          <li><a href="tiernan_print_cycles_cpp"><cite>tiernan_print_cycles.cpp</cite></a></li>
          <li><a href="default-constructor2_cpp"><cite>default-constructor2.cpp</cite></a></li>
          <li><a href="exterior_property_map_cpp"><cite>exterior_property_map.cpp</cite></a></li>
          <li><a href="dfs-parenthesis_cpp"><cite>dfs-parenthesis.cpp</cite></a></li>
          <li><a href="dfs_expected"><cite>dfs.expected</cite></a></li>
          <li><a href="city_visitor_cpp"><cite>city_visitor.cpp</cite></a></li>
          <li><a href="labeled_graph_cpp"><cite>labeled_graph.cpp</cite></a></li>
          <li><a href="edge-connectivity_cpp"><cite>edge-connectivity.cpp</cite></a></li>
          <li><a href="undirected_graph_cpp"><cite>undirected_graph.cpp</cite></a></li>
          <li><a href="planar_face_traversal_cpp"><cite>planar_face_traversal.cpp</cite></a></li>
          <li><a href="implicit_graph_cpp"><cite>implicit_graph.cpp</cite></a></li>
          <li><a href="visitor_cpp"><cite>visitor.cpp</cite></a></li>
          <li><a href="boykov_kolmogorov-eg_cpp"><cite>boykov_kolmogorov-eg.cpp</cite></a></li>
          <li><a href="edge-function_cpp"><cite>edge-function.cpp</cite></a></li>
          <li><a href="adjacency_list_io_cpp"><cite>adjacency_list_io.cpp</cite></a></li>
          <li><a href="connected-components_cpp"><cite>connected-components.cpp</cite></a></li>
          <li><a href="leda-regression_cfg"><cite>leda-regression.cfg</cite></a></li>
          <li><a href="bfs-name-printer_cpp"><cite>bfs-name-printer.cpp</cite></a></li>
          <li><a href="vertex-name-property_cpp"><cite>vertex-name-property.cpp</cite></a></li>
          <li><a href="filtered_graph_edge_range_cpp"><cite>filtered_graph_edge_range.cpp</cite></a></li>
          <li><a href="transitive_closure_cpp"><cite>transitive_closure.cpp</cite></a></li>
          <li><a href="max_flow7_dat"><cite>max_flow7.dat</cite></a></li>
          <li><a href="canonical_ordering_cpp"><cite>canonical_ordering.cpp</cite></a></li>
          <li><a href="closeness_centrality_cpp"><cite>closeness_centrality.cpp</cite></a></li>
          <li><a href="fibonacci_heap_expected"><cite>fibonacci_heap.expected</cite></a></li>
          <li><a href="gerdemann_cpp"><cite>gerdemann.cpp</cite></a></li>
          <li><a href="max_flow5_dat"><cite>max_flow5.dat</cite></a></li>
          <li><a href="dijkstra-example_cpp"><cite>dijkstra-example.cpp</cite></a></li>
          <li><a href="connected_components_cpp"><cite>connected_components.cpp</cite></a></li>
          <li><a href="quick_tour_cpp"><cite>quick_tour.cpp</cite></a></li>
          <li><a href="graph-property-iter-eg_cpp"><cite>graph-property-iter-eg.cpp</cite></a></li>
          <li><a href="topo-sort2_cpp"><cite>topo-sort2.cpp</cite></a></li>
          <li><a href="successive_shortest_path_nonnegative_weights_example_cpp"><cite>successive_shortest_path_nonnegative_weights_example.cpp</cite></a></li>
          <li><a href="exterior_property_map_expected"><cite>exterior_property_map.expected</cite></a></li>
          <li><a href="kevin-bacon_dat"><cite>kevin-bacon.dat</cite></a></li>
          <li><a href="adjacency_list_cpp"><cite>adjacency_list.cpp</cite></a></li>
          <li><a href="file_dependencies_expected"><cite>file_dependencies.expected</cite></a></li>
          <li><a href="ospf-example_cpp"><cite>ospf-example.cpp</cite></a></li>
          <li><a href="bellman_ford_expected"><cite>bellman_ford.expected</cite></a></li>
          <li><a href="gerdemann_expected"><cite>gerdemann.expected</cite></a></li>
          <li><a href="undirected_dfs_cpp"><cite>undirected_dfs.cpp</cite></a></li>
          <li><a href="container_gen_cpp"><cite>container_gen.cpp</cite></a></li>
          <li><a href="undirected_adjacency_list_expected"><cite>undirected_adjacency_list.expected</cite></a></li>
          <li><a href="vf2_sub_graph_iso_multi_example_cpp"><cite>vf2_sub_graph_iso_multi_example.cpp</cite></a></li>
          <li><a href="tiernan_girth_circumference_cpp"><cite>tiernan_girth_circumference.cpp</cite></a></li>
          <li><a href="miles_span_expected"><cite>miles_span.expected</cite></a></li>
          <li><a href="dijkstra-no-color-map-example_cpp"><cite>dijkstra-no-color-map-example.cpp</cite></a></li>
          <li><a href="vector_as_graph_expected"><cite>vector_as_graph.expected</cite></a></li>
          <li><a href="johnson-eg_cpp"><cite>johnson-eg.cpp</cite></a></li>
          <li><a href="topo-sort1_cpp"><cite>topo-sort1.cpp</cite></a></li>
          <li><a href="clustering_coefficient_cpp"><cite>clustering_coefficient.cpp</cite></a></li>
          <li><a href="topo-sort-file-dep2_cpp"><cite>topo-sort-file-dep2.cpp</cite></a></li>
          <li><a href="dfs_basics_expected"><cite>dfs_basics.expected</cite></a></li>
          <li><a href="cycle-file-dep_cpp"><cite>cycle-file-dep.cpp</cite></a></li>
          <li><a href="undirected_adjacency_list_cpp"><cite>undirected_adjacency_list.cpp</cite></a></li>
          <li><a href="iterator-property-map-eg_cpp"><cite>iterator-property-map-eg.cpp</cite></a></li>
          <li><a href="vertex_basics_expected"><cite>vertex_basics.expected</cite></a></li>
          <li><a href="graphviz_example_dot"><cite>graphviz_example.dot</cite></a></li>
          <li><a href="regression_cfg"><cite>regression.cfg</cite></a></li>
          <li><a href="reachable-loop-head_cpp"><cite>reachable-loop-head.cpp</cite></a></li>
          <li><a href="info_network_graph"><cite>info_network.graph</cite></a></li>
          <li><a href="write_graphviz_cpp"><cite>write_graphviz.cpp</cite></a></li>
          <li><a href="kevin-bacon2_expected"><cite>kevin-bacon2.expected</cite></a></li>
          <li><a href="container_gen_expected"><cite>container_gen.expected</cite></a></li>
          <li><a href="king_ordering_cpp"><cite>king_ordering.cpp</cite></a></li>
          <li><a href="stoer_wagner_cpp"><cite>stoer_wagner.cpp</cite></a></li>
          <li><a href="edge_basics_cpp"><cite>edge_basics.cpp</cite></a></li>
          <li><a href="dag_shortest_paths_cpp"><cite>dag_shortest_paths.cpp</cite></a></li>
          <li><a href="incremental_components_expected"><cite>incremental_components.expected</cite></a></li>
          <li><a href="remove_edge_if_undir_cpp"><cite>remove_edge_if_undir.cpp</cite></a></li>
          <li><a href="bucket_sorter_cpp"><cite>bucket_sorter.cpp</cite></a></li>
          <li><a href="data2_txt"><cite>data2.txt</cite></a></li>
          <li><a href="target-compile-costs_dat"><cite>target-compile-costs.dat</cite></a></li>
          <li><a href="roget_components_cpp"><cite>roget_components.cpp</cite></a></li>
          <li><a href="dave_cpp"><cite>dave.cpp</cite></a></li>
          <li><a href="topo_sort_expected"><cite>topo_sort.expected</cite></a></li>
          <li><a href="fibonacci_heap_cpp"><cite>fibonacci_heap.cpp</cite></a></li>
          <li><a href="ordered_out_edges_expected"><cite>ordered_out_edges.expected</cite></a></li>
          <li><a href="grid_graph_example_cpp"><cite>grid_graph_example.cpp</cite></a></li>
          <li><a href="print-adjacent-vertices_cpp"><cite>print-adjacent-vertices.cpp</cite></a></li>
          <li><a href="biconnected_components_cpp"><cite>biconnected_components.cpp</cite></a></li>
          <li><a href="eccentricity_cpp"><cite>eccentricity.cpp</cite></a></li>
          <li><a href="edge-iter-constructor_cpp"><cite>edge-iter-constructor.cpp</cite></a></li>
          <li><a href="print-out-edges_cpp"><cite>print-out-edges.cpp</cite></a></li>
          <li><a href="bfs-example2_cpp"><cite>bfs-example2.cpp</cite></a></li>
          <li><a href="parallel-compile-time_cpp"><cite>parallel-compile-time.cpp</cite></a></li>
          <li><a href="strong_components_expected"><cite>strong_components.expected</cite></a></li>
          <li><a href="edge_basics_expected"><cite>edge_basics.expected</cite></a></li>
          <li><a href="graphviz_cpp"><cite>graphviz.cpp</cite></a></li>
          <li><a href="edmonds-karp-eg_cpp"><cite>edmonds-karp-eg.cpp</cite></a></li>
          <li><a href="kevin-bacon2_dat"><cite>kevin-bacon2.dat</cite></a></li>
          <li><a href="test-astar-cities_dot"><cite>test-astar-cities.dot</cite></a></li>
          <li><a href="kruskal_expected"><cite>kruskal.expected</cite></a></li>
          <li><a href="minimum_degree_ordering_cpp"><cite>minimum_degree_ordering.cpp</cite></a></li>
          <li><a href="iteration_macros_cpp"><cite>iteration_macros.cpp</cite></a></li>
          <li><a href="leda-concept-check_cpp"><cite>leda-concept-check.cpp</cite></a></li>
          <li><a href="cc-internet_cpp"><cite>cc-internet.cpp</cite></a></li>
          <li><a href="edge_coloring_cpp"><cite>edge_coloring.cpp</cite></a></li>
          <li><a href="bipartite_example_cpp"><cite>bipartite_example.cpp</cite></a></li>
          <li><a href="dave_expected"><cite>dave.expected</cite></a></li>
          <li><a href="prim-example_cpp"><cite>prim-example.cpp</cite></a></li>
          <li><a href="straight_line_drawing_cpp"><cite>straight_line_drawing.cpp</cite></a></li>
          <li><a href="read_graphviz_cpp"><cite>read_graphviz.cpp</cite></a></li>
          <li><a href="adjacency_matrix_cpp"><cite>adjacency_matrix.cpp</cite></a></li>
          <li><a href="max_flow_dat"><cite>max_flow.dat</cite></a></li>
          <li><a href="kevin_bacon_expected"><cite>kevin_bacon.expected</cite></a></li>
          <li><a href="put-get-helper-eg_cpp"><cite>put-get-helper-eg.cpp</cite></a></li>
          <li><a href="components_on_edgelist_expected"><cite>components_on_edgelist.expected</cite></a></li>
          <li><a href="property_iterator_cpp"><cite>property_iterator.cpp</cite></a></li>
          <li><a href="simple_planarity_test_cpp"><cite>simple_planarity_test.cpp</cite></a></li>
          <li><a href="kevin-bacon2_cpp"><cite>kevin-bacon2.cpp</cite></a></li>
          <li><a href="edge_property_expected"><cite>edge_property.expected</cite></a></li>
          <li><a href="makefile-target-names_dat"><cite>makefile-target-names.dat</cite></a></li>
          <li><a href="quick-tour_cpp"><cite>quick-tour.cpp</cite></a></li>
          <li><a href="mean_geodesic_cpp"><cite>mean_geodesic.cpp</cite></a></li>
          <li><a href="bfs_expected"><cite>bfs.expected</cite></a></li>
          <!-- figs/ -->
          <li><a href="exterior_properties_cpp"><cite>exterior_properties.cpp</cite></a></li>
          <li><a href="exterior_properties_expected"><cite>exterior_properties.expected</cite></a></li>
          <li><a href="bfs-example_cpp"><cite>bfs-example.cpp</cite></a></li>
          <li><a href="topo-sort-with-leda_cpp"><cite>topo-sort-with-leda.cpp</cite></a></li>
          <li><a href="filtered-copy-example_cpp"><cite>filtered-copy-example.cpp</cite></a></li>
          <li><a href="edge_connectivity_cpp"><cite>edge_connectivity.cpp</cite></a></li>
          <li><a href="max_flow8_dat"><cite>max_flow8.dat</cite></a></li>
          <li><a href="strong-components_cpp"><cite>strong-components.cpp</cite></a></li>
          <li><a href="scaled_closeness_centrality_cpp"><cite>scaled_closeness_centrality.cpp</cite></a></li>
          <li><a href="boost_web_dat"><cite>boost_web.dat</cite></a></li>
          <li><a href="bellman-ford-internet_cpp"><cite>bellman-ford-internet.cpp</cite></a></li>
          <li><a href="bron_kerbosch_clique_number_cpp"><cite>bron_kerbosch_clique_number.cpp</cite></a></li>
          <li><a href="max_flow3_dat"><cite>max_flow3.dat</cite></a></li>
          <li><a href="concept_checks_expected"><cite>concept_checks.expected</cite></a></li>
          <li><a href="leda-graph-eg_cpp"><cite>leda-graph-eg.cpp</cite></a></li>
          <li><a href="data1_txt"><cite>data1.txt</cite></a></li>
          <li><a href="connected_components_expected"><cite>connected_components.expected</cite></a></li>
          <li><a href="makefile-dependencies_dat"><cite>makefile-dependencies.dat</cite></a></li>
          <li><a href="file_dependencies_cpp"><cite>file_dependencies.cpp</cite></a></li>
          <li><a href="max_flow4_dat"><cite>max_flow4.dat</cite></a></li>
          <li><a href="reverse_graph_expected"><cite>reverse_graph.expected</cite></a></li>
          <li><a href="bfs_neighbor_cpp"><cite>bfs_neighbor.cpp</cite></a></li>
          <li><a href="sloan_ordering_cpp"><cite>sloan_ordering.cpp</cite></a></li>
          <li><a href="min_max_paths_cpp"><cite>min_max_paths.cpp</cite></a></li>
          <li><a href="vf2_sub_graph_iso_example_cpp"><cite>vf2_sub_graph_iso_example.cpp</cite></a></li>
          <li><a href="graph_as_tree_cpp"><cite>graph_as_tree.cpp</cite></a></li>
          <li><a href="two_graphs_common_spanning_trees_cpp"><cite>two_graphs_common_spanning_trees.cpp</cite></a></li>
          <li><a href="prim-telephone_cpp"><cite>prim-telephone.cpp</cite></a></li>
          <li><a href="boost_web_graph_expected"><cite>boost_web_graph.expected</cite></a></li>
          <li><a href="subgraph_expected"><cite>subgraph.expected</cite></a></li>
          <li><a href="dijkstra_expected"><cite>dijkstra.expected</cite></a></li>
          <li><a href="transpose-example_cpp"><cite>transpose-example.cpp</cite></a></li>
          <li><a href="matching_example_cpp"><cite>matching_example.cpp</cite></a></li>
          <li><a href="interior_property_map_expected"><cite>interior_property_map.expected</cite></a></li>
          <li><a href="strong_components_cpp"><cite>strong_components.cpp</cite></a></li>
          <li><a href="knights_tour_cpp"><cite>knights_tour.cpp</cite></a></li>
          <li><a href="scc_dot"><cite>scc.dot</cite></a></li>
          <li><a href="max_flow9_dat"><cite>max_flow9.dat</cite></a></li>
          <li><a href="weighted_matching_example_cpp"><cite>weighted_matching_example.cpp</cite></a></li>
          <li><a href="default-constructor_cpp"><cite>default-constructor.cpp</cite></a></li>
          <li><a href="edge_property_cpp"><cite>edge_property.cpp</cite></a></li>
          <li><a href="astar_maze_cpp"><cite>astar_maze.cpp</cite></a></li>
          <li><a href="push-relabel-eg_cpp"><cite>push-relabel-eg.cpp</cite></a></li>
          <li><a href="prob_network_graph"><cite>prob_network.graph</cite></a></li>
          <li><a href="graphviz_test_dot"><cite>graphviz_test.dot</cite></a></li>
          <li><a href="read_write_dimacs-eg_cpp"><cite>read_write_dimacs-eg.cpp</cite></a></li>
          <li><a href="topo_sort_cpp"><cite>topo_sort.cpp</cite></a></li>
          <li><a href="filtered_graph_expected"><cite>filtered_graph.expected</cite></a></li>
          <li><a href="social_network_graph"><cite>social_network.graph</cite></a></li>
          <li><a href="dfs_parenthesis_cpp"><cite>dfs_parenthesis.cpp</cite></a></li>
          <li><a href="scc_cpp"><cite>scc.cpp</cite></a></li>
          <li><a href="print-edges_cpp"><cite>print-edges.cpp</cite></a></li>
          <li><a href="dfs_cpp"><cite>dfs.cpp</cite></a></li>
          <li><a href="isomorphism_cpp"><cite>isomorphism.cpp</cite></a></li>
          <li><a href="csr-example_cpp"><cite>csr-example.cpp</cite></a></li>
          <li><a href="bcsstk01_rsa"><cite>bcsstk01.rsa</cite></a></li>
          <li><a href="adjacency_list_expected"><cite>adjacency_list.expected</cite></a></li>
          <li><a href="directed_graph_cpp"><cite>directed_graph.cpp</cite></a></li>
        </ul>



        <section id="bellman-example_cpp">
          <h3><cite>bellman-example.cpp</cite></h3>
          <p>These are the contents of file <cite>bellman-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="actor_clustering_cpp">
          <h3><cite>actor_clustering.cpp</cite></h3>
          <p>These are the contents of file <cite>actor_clustering.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="fr_layout_cpp">
          <h3><cite>fr_layout.cpp</cite></h3>
          <p>These are the contents of file <cite>fr_layout.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="mcgregor_subgraphs_example_cpp">
          <h3><cite>mcgregor_subgraphs_example.cpp</cite></h3>
          <p>These are the contents of file <cite>mcgregor_subgraphs_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow2_dat">
          <h3><cite>max_flow2.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow2.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="Jamfile_v2">
          <h3><cite>Jamfile.v2</cite></h3>
          <p>These are the contents of file <cite>Jamfile.v2</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cuthill_mckee_ordering_expected">
          <h3><cite>cuthill_mckee_ordering.expected</cite></h3>
          <p>These are the contents of file <cite>cuthill_mckee_ordering.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cycle_ratio_example_cpp">
          <h3><cite>cycle_ratio_example.cpp</cite></h3>
          <p>These are the contents of file <cite>cycle_ratio_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="filtered_vec_as_graph_cpp">
          <h3><cite>filtered_vec_as_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>filtered_vec_as_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="sgb-regression_cfg">
          <h3><cite>sgb-regression.cfg</cite></h3>
          <p>These are the contents of file <cite>sgb-regression.cfg</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graph_cpp">
          <h3><cite>graph.cpp</cite></h3>
          <p>These are the contents of file <cite>graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="quick_tour_expected">
          <h3><cite>quick_tour.expected</cite></h3>
          <p>These are the contents of file <cite>quick_tour.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="knights_tour_expected">
          <h3><cite>knights_tour.expected</cite></h3>
          <p>These are the contents of file <cite>knights_tour.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="hawick_circuits_cpp">
          <h3><cite>hawick_circuits.cpp</cite></h3>
          <p>These are the contents of file <cite>hawick_circuits.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="loops_dfs_cpp">
          <h3><cite>loops_dfs.cpp</cite></h3>
          <p>These are the contents of file <cite>loops_dfs.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs_parenthesis_expected">
          <h3><cite>dfs_parenthesis.expected</cite></h3>
          <p>These are the contents of file <cite>dfs_parenthesis.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="property-map-traits-eg_cpp">
          <h3><cite>property-map-traits-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>property-map-traits-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="family_tree_cpp">
          <h3><cite>family_tree.cpp</cite></h3>
          <p>These are the contents of file <cite>family_tree.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graph-thingie_cpp">
          <h3><cite>graph-thingie.cpp</cite></h3>
          <p>These are the contents of file <cite>graph-thingie.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kuratowski_subgraph_cpp">
          <h3><cite>kuratowski_subgraph.cpp</cite></h3>
          <p>These are the contents of file <cite>kuratowski_subgraph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="visitor_expected">
          <h3><cite>visitor.expected</cite></h3>
          <p>These are the contents of file <cite>visitor.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="girth_cpp">
          <h3><cite>girth.cpp</cite></h3>
          <p>These are the contents of file <cite>girth.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="ordered_out_edges_cpp">
          <h3><cite>ordered_out_edges.cpp</cite></h3>
          <p>These are the contents of file <cite>ordered_out_edges.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs-example_cpp">
          <h3><cite>dfs-example.cpp</cite></h3>
          <p>These are the contents of file <cite>dfs-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="remove_edge_if_dir_cpp">
          <h3><cite>remove_edge_if_dir.cpp</cite></h3>
          <p>These are the contents of file <cite>remove_edge_if_dir.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="r_c_shortest_paths_example_cpp">
          <h3><cite>r_c_shortest_paths_example.cpp</cite></h3>
          <p>These are the contents of file <cite>r_c_shortest_paths_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="tc_dot">
          <h3><cite>tc.dot</cite></h3>
          <p>These are the contents of file <cite>tc.dot</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="remove_edge_if_undir_expected">
          <h3><cite>remove_edge_if_undir.expected</cite></h3>
          <p>These are the contents of file <cite>remove_edge_if_undir.expected</cite>, which...</p>
          <pre></pre>
        </section>

    bcsstk01
        <section id="bfs_basics_expected">
          <h3><cite>bfs_basics.expected</cite></h3>
          <p>These are the contents of file <cite>bfs_basics.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="remove_edge_if_bidir_cpp">
          <h3><cite>remove_edge_if_bidir.cpp</cite></h3>
          <p>These are the contents of file <cite>remove_edge_if_bidir.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="incremental-components-eg_cpp">
          <h3><cite>incremental-components-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>incremental-components-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="degree_centrality_cpp">
          <h3><cite>degree_centrality.cpp</cite></h3>
          <p>These are the contents of file <cite>degree_centrality.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="incremental_components_cpp">
          <h3><cite>incremental_components.cpp</cite></h3>
          <p>These are the contents of file <cite>incremental_components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="reachable-loop-tail_cpp">
          <h3><cite>reachable-loop-tail.cpp</cite></h3>
          <p>These are the contents of file <cite>reachable-loop-tail.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="iohb_h">
          <h3><cite>iohb.h</cite></h3>
          <p>These are the contents of file <cite>iohb.h</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bfs_cpp">
          <h3><cite>bfs.cpp</cite></h3>
          <p>These are the contents of file <cite>bfs.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="astar-cities_cpp">
          <h3><cite>astar-cities.cpp</cite></h3>
          <p>These are the contents of file <cite>astar-cities.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow_expected">
          <h3><cite>max_flow.expected</cite></h3>
          <p>These are the contents of file <cite>max_flow.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="data3_txt">
          <h3><cite>data3.txt</cite></h3>
          <p>These are the contents of file <cite>data3.txt</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="influence_prestige_cpp">
          <h3><cite>influence_prestige.cpp</cite></h3>
          <p>These are the contents of file <cite>influence_prestige.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="remove_edge_if_dir_expected">
          <h3><cite>remove_edge_if_dir.expected</cite></h3>
          <p>These are the contents of file <cite>remove_edge_if_dir.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="in_edges_expected">
          <h3><cite>in_edges.expected</cite></h3>
          <p>These are the contents of file <cite>in_edges.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="interior_property_map_cpp">
          <h3><cite>interior_property_map.cpp</cite></h3>
          <p>These are the contents of file <cite>interior_property_map.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cycle-file-dep2_cpp">
          <h3><cite>cycle-file-dep2.cpp</cite></h3>
          <p>These are the contents of file <cite>cycle-file-dep2.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="comm_network_graph">
          <h3><cite>comm_network.graph</cite></h3>
          <p>These are the contents of file <cite>comm_network.graph</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="modify_graph_expected">
          <h3><cite>modify_graph.expected</cite></h3>
          <p>These are the contents of file <cite>modify_graph.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="copy-example_cpp">
          <h3><cite>copy-example.cpp</cite></h3>
          <p>These are the contents of file <cite>copy-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="interior_pmap_bundled_cpp">
          <h3><cite>interior_pmap_bundled.cpp</cite></h3>
          <p>These are the contents of file <cite>interior_pmap_bundled.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="prim_expected">
          <h3><cite>prim.expected</cite></h3>
          <p>These are the contents of file <cite>prim.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graph-assoc-types_cpp">
          <h3><cite>graph-assoc-types.cpp</cite></h3>
          <p>These are the contents of file <cite>graph-assoc-types.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="reverse_graph_cpp">
          <h3><cite>reverse_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>reverse_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="filtered_graph_cpp">
          <h3><cite>filtered_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>filtered_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="johnson_expected">
          <h3><cite>johnson.expected</cite></h3>
          <p>These are the contents of file <cite>johnson.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_iterator_constructor_dat">
          <h3><cite>edge_iterator_constructor.dat</cite></h3>
          <p>These are the contents of file <cite>edge_iterator_constructor.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="family_tree_expected">
          <h3><cite>family_tree.expected</cite></h3>
          <p>These are the contents of file <cite>family_tree.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="grid_graph_properties_cpp">
          <h3><cite>grid_graph_properties.cpp</cite></h3>
          <p>These are the contents of file <cite>grid_graph_properties.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bron_kerbosch_print_cliques_cpp">
          <h3><cite>bron_kerbosch_print_cliques.cpp</cite></h3>
          <p>These are the contents of file <cite>bron_kerbosch_print_cliques.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="prism_3_2_graph">
          <h3><cite>prism_3_2.graph</cite></h3>
          <p>These are the contents of file <cite>prism_3_2.graph</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kevin-bacon_cpp">
          <h3><cite>kevin-bacon.cpp</cite></h3>
          <p>These are the contents of file <cite>kevin-bacon.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="modify_graph_cpp">
          <h3><cite>modify_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>modify_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="inclusive_mean_geodesic_cpp">
          <h3><cite>inclusive_mean_geodesic.cpp</cite></h3>
          <p>These are the contents of file <cite>inclusive_mean_geodesic.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kruskal-example_cpp">
          <h3><cite>kruskal-example.cpp</cite></h3>
          <p>These are the contents of file <cite>kruskal-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo-sort-file-dep_cpp">
          <h3><cite>topo-sort-file-dep.cpp</cite></h3>
          <p>These are the contents of file <cite>topo-sort-file-dep.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="print-in-edges_cpp">
          <h3><cite>print-in-edges.cpp</cite></h3>
          <p>These are the contents of file <cite>print-in-edges.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="make_connected_cpp">
          <h3><cite>make_connected.cpp</cite></h3>
          <p>These are the contents of file <cite>make_connected.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kruskal-telephone_cpp">
          <h3><cite>kruskal-telephone.cpp</cite></h3>
          <p>These are the contents of file <cite>kruskal-telephone.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="neighbor_bfs_cpp">
          <h3><cite>neighbor_bfs.cpp</cite></h3>
          <p>These are the contents of file <cite>neighbor_bfs.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="boost_web_graph_cpp">
          <h3><cite>boost_web_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>boost_web_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="make_maximal_planar_cpp">
          <h3><cite>make_maximal_planar.cpp</cite></h3>
          <p>These are the contents of file <cite>make_maximal_planar.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="subgraph_properties_cpp">
          <h3><cite>subgraph_properties.cpp</cite></h3>
          <p>These are the contents of file <cite>subgraph_properties.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="helper_hpp">
          <h3><cite>helper.hpp</cite></h3>
          <p>These are the contents of file <cite>helper.hpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="in_edges_cpp">
          <h3><cite>in_edges.cpp</cite></h3>
          <p>These are the contents of file <cite>in_edges.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="miles_span_cpp">
          <h3><cite>miles_span.cpp</cite></h3>
          <p>These are the contents of file <cite>miles_span.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="accum-compile-times_cpp">
          <h3><cite>accum-compile-times.cpp</cite></h3>
          <p>These are the contents of file <cite>accum-compile-times.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cycle_canceling_example_cpp">
          <h3><cite>cycle_canceling_example.cpp</cite></h3>
          <p>These are the contents of file <cite>cycle_canceling_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow6_dat">
          <h3><cite>max_flow6.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow6.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="components_on_edgelist_cpp">
          <h3><cite>components_on_edgelist.cpp</cite></h3>
          <p>These are the contents of file <cite>components_on_edgelist.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_iterator_constructor_cpp">
          <h3><cite>edge_iterator_constructor.cpp</cite></h3>
          <p>These are the contents of file <cite>edge_iterator_constructor.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dijkstra-example-listS_cpp">
          <h3><cite>dijkstra-example-listS.cpp</cite></h3>
          <p>These are the contents of file <cite>dijkstra-example-listS.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vertex_basics_cpp">
          <h3><cite>vertex_basics.cpp</cite></h3>
          <p>These are the contents of file <cite>vertex_basics.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow_cpp">
          <h3><cite>max_flow.cpp</cite></h3>
          <p>These are the contents of file <cite>max_flow.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="make_biconnected_planar_cpp">
          <h3><cite>make_biconnected_planar.cpp</cite></h3>
          <p>These are the contents of file <cite>make_biconnected_planar.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="last-mod-time_cpp">
          <h3><cite>last-mod-time.cpp</cite></h3>
          <p>These are the contents of file <cite>last-mod-time.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="subgraph_cpp">
          <h3><cite>subgraph.cpp</cite></h3>
          <p>These are the contents of file <cite>subgraph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cuthill_mckee_ordering_cpp">
          <h3><cite>cuthill_mckee_ordering.cpp</cite></h3>
          <p>These are the contents of file <cite>cuthill_mckee_ordering.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="iohb_c">
          <h3><cite>iohb.c</cite></h3>
          <p>These are the contents of file <cite>iohb.c</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo-sort-with-sgb_cpp">
          <h3><cite>topo-sort-with-sgb.cpp</cite></h3>
          <p>These are the contents of file <cite>topo-sort-with-sgb.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vector_as_graph_cpp">
          <h3><cite>vector_as_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>vector_as_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="adj_list_ra_edgelist_cpp">
          <h3><cite>adj_list_ra_edgelist.cpp</cite></h3>
          <p>These are the contents of file <cite>adj_list_ra_edgelist.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="remove_edge_if_bidir_expected">
          <h3><cite>remove_edge_if_bidir.expected</cite></h3>
          <p>These are the contents of file <cite>remove_edge_if_bidir.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graph_property_cpp">
          <h3><cite>graph_property.cpp</cite></h3>
          <p>These are the contents of file <cite>graph_property.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="tiernan_print_cycles_cpp">
          <h3><cite>tiernan_print_cycles.cpp</cite></h3>
          <p>These are the contents of file <cite>tiernan_print_cycles.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="default-constructor2_cpp">
          <h3><cite>default-constructor2.cpp</cite></h3>
          <p>These are the contents of file <cite>default-constructor2.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="exterior_property_map_cpp">
          <h3><cite>exterior_property_map.cpp</cite></h3>
          <p>These are the contents of file <cite>exterior_property_map.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs-parenthesis_cpp">
          <h3><cite>dfs-parenthesis.cpp</cite></h3>
          <p>These are the contents of file <cite>dfs-parenthesis.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs_expected">
          <h3><cite>dfs.expected</cite></h3>
          <p>These are the contents of file <cite>dfs.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="city_visitor_cpp">
          <h3><cite>city_visitor.cpp</cite></h3>
          <p>These are the contents of file <cite>city_visitor.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="labeled_graph_cpp">
          <h3><cite>labeled_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>labeled_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge-connectivity_cpp">
          <h3><cite>edge-connectivity.cpp</cite></h3>
          <p>These are the contents of file <cite>edge-connectivity.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="undirected_graph_cpp">
          <h3><cite>undirected_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>undirected_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="planar_face_traversal_cpp">
          <h3><cite>planar_face_traversal.cpp</cite></h3>
          <p>These are the contents of file <cite>planar_face_traversal.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="implicit_graph_cpp">
          <h3><cite>implicit_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>implicit_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="visitor_cpp">
          <h3><cite>visitor.cpp</cite></h3>
          <p>These are the contents of file <cite>visitor.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="boykov_kolmogorov-eg_cpp">
          <h3><cite>boykov_kolmogorov-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>boykov_kolmogorov-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge-function_cpp">
          <h3><cite>edge-function.cpp</cite></h3>
          <p>These are the contents of file <cite>edge-function.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="adjacency_list_io_cpp">
          <h3><cite>adjacency_list_io.cpp</cite></h3>
          <p>These are the contents of file <cite>adjacency_list_io.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="connected-components_cpp">
          <h3><cite>connected-components.cpp</cite></h3>
          <p>These are the contents of file <cite>connected-components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="leda-regression_cfg">
          <h3><cite>leda-regression.cfg</cite></h3>
          <p>These are the contents of file <cite>leda-regression.cfg</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bfs-name-printer_cpp">
          <h3><cite>bfs-name-printer.cpp</cite></h3>
          <p>These are the contents of file <cite>bfs-name-printer.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vertex-name-property_cpp">
          <h3><cite>vertex-name-property.cpp</cite></h3>
          <p>These are the contents of file <cite>vertex-name-property.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="filtered_graph_edge_range_cpp">
          <h3><cite>filtered_graph_edge_range.cpp</cite></h3>
          <p>These are the contents of file <cite>filtered_graph_edge_range.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="transitive_closure_cpp">
          <h3><cite>transitive_closure.cpp</cite></h3>
          <p>These are the contents of file <cite>transitive_closure.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow7_dat">
          <h3><cite>max_flow7.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow7.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="canonical_ordering_cpp">
          <h3><cite>canonical_ordering.cpp</cite></h3>
          <p>These are the contents of file <cite>canonical_ordering.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="closeness_centrality_cpp">
          <h3><cite>closeness_centrality.cpp</cite></h3>
          <p>These are the contents of file <cite>closeness_centrality.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="fibonacci_heap_expected">
          <h3><cite>fibonacci_heap.expected</cite></h3>
          <p>These are the contents of file <cite>fibonacci_heap.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="gerdemann_cpp">
          <h3><cite>gerdemann.cpp</cite></h3>
          <p>These are the contents of file <cite>gerdemann.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow5_dat">
          <h3><cite>max_flow5.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow5.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dijkstra-example_cpp">
          <h3><cite>dijkstra-example.cpp</cite></h3>
          <p>These are the contents of file <cite>dijkstra-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="connected_components_cpp">
          <h3><cite>connected_components.cpp</cite></h3>
          <p>These are the contents of file <cite>connected_components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="quick_tour_cpp">
          <h3><cite>quick_tour.cpp</cite></h3>
          <p>These are the contents of file <cite>quick_tour.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graph-property-iter-eg_cpp">
          <h3><cite>graph-property-iter-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>graph-property-iter-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo-sort2_cpp">
          <h3><cite>topo-sort2.cpp</cite></h3>
          <p>These are the contents of file <cite>topo-sort2.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="successive_shortest_path_nonnegative_weights_example_cpp">
          <h3><cite>successive_shortest_path_nonnegative_weights_example.cpp</cite></h3>
          <p>These are the contents of file <cite>successive_shortest_path_nonnegative_weights_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="exterior_property_map_expected">
          <h3><cite>exterior_property_map.expected</cite></h3>
          <p>These are the contents of file <cite>exterior_property_map.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kevin-bacon_dat">
          <h3><cite>kevin-bacon.dat</cite></h3>
          <p>These are the contents of file <cite>kevin-bacon.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="adjacency_list_cpp">
          <h3><cite>adjacency_list.cpp</cite></h3>
          <p>These are the contents of file <cite>adjacency_list.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="file_dependencies_expected">
          <h3><cite>file_dependencies.expected</cite></h3>
          <p>These are the contents of file <cite>file_dependencies.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="ospf-example_cpp">
          <h3><cite>ospf-example.cpp</cite></h3>
          <p>These are the contents of file <cite>ospf-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bellman_ford_expected">
          <h3><cite>bellman_ford.expected</cite></h3>
          <p>These are the contents of file <cite>bellman_ford.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="gerdemann_expected">
          <h3><cite>gerdemann.expected</cite></h3>
          <p>These are the contents of file <cite>gerdemann.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="undirected_dfs_cpp">
          <h3><cite>undirected_dfs.cpp</cite></h3>
          <p>These are the contents of file <cite>undirected_dfs.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="container_gen_cpp">
          <h3><cite>container_gen.cpp</cite></h3>
          <p>These are the contents of file <cite>container_gen.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="undirected_adjacency_list_expected">
          <h3><cite>undirected_adjacency_list.expected</cite></h3>
          <p>These are the contents of file <cite>undirected_adjacency_list.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vf2_sub_graph_iso_multi_example_cpp">
          <h3><cite>vf2_sub_graph_iso_multi_example.cpp</cite></h3>
          <p>These are the contents of file <cite>vf2_sub_graph_iso_multi_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="tiernan_girth_circumference_cpp">
          <h3><cite>tiernan_girth_circumference.cpp</cite></h3>
          <p>These are the contents of file <cite>tiernan_girth_circumference.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="miles_span_expected">
          <h3><cite>miles_span.expected</cite></h3>
          <p>These are the contents of file <cite>miles_span.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dijkstra-no-color-map-example_cpp">
          <h3><cite>dijkstra-no-color-map-example.cpp</cite></h3>
          <p>These are the contents of file <cite>dijkstra-no-color-map-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vector_as_graph_expected">
          <h3><cite>vector_as_graph.expected</cite></h3>
          <p>These are the contents of file <cite>vector_as_graph.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="johnson-eg_cpp">
          <h3><cite>johnson-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>johnson-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo-sort1_cpp">
          <h3><cite>topo-sort1.cpp</cite></h3>
          <p>These are the contents of file <cite>topo-sort1.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="clustering_coefficient_cpp">
          <h3><cite>clustering_coefficient.cpp</cite></h3>
          <p>These are the contents of file <cite>clustering_coefficient.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo-sort-file-dep2_cpp">
          <h3><cite>topo-sort-file-dep2.cpp</cite></h3>
          <p>These are the contents of file <cite>topo-sort-file-dep2.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs_basics_expected">
          <h3><cite>dfs_basics.expected</cite></h3>
          <p>These are the contents of file <cite>dfs_basics.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cycle-file-dep_cpp">
          <h3><cite>cycle-file-dep.cpp</cite></h3>
          <p>These are the contents of file <cite>cycle-file-dep.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="undirected_adjacency_list_cpp">
          <h3><cite>undirected_adjacency_list.cpp</cite></h3>
          <p>These are the contents of file <cite>undirected_adjacency_list.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="iterator-property-map-eg_cpp">
          <h3><cite>iterator-property-map-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>iterator-property-map-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vertex_basics_expected">
          <h3><cite>vertex_basics.expected</cite></h3>
          <p>These are the contents of file <cite>vertex_basics.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graphviz_example_dot">
          <h3><cite>graphviz_example.dot</cite></h3>
          <p>These are the contents of file <cite>graphviz_example.dot</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="regression_cfg">
          <h3><cite>regression.cfg</cite></h3>
          <p>These are the contents of file <cite>regression.cfg</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="reachable-loop-head_cpp">
          <h3><cite>reachable-loop-head.cpp</cite></h3>
          <p>These are the contents of file <cite>reachable-loop-head.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="info_network_graph">
          <h3><cite>info_network.graph</cite></h3>
          <p>These are the contents of file <cite>info_network.graph</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="write_graphviz_cpp">
          <h3><cite>write_graphviz.cpp</cite></h3>
          <p>These are the contents of file <cite>write_graphviz.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kevin-bacon2_expected">
          <h3><cite>kevin-bacon2.expected</cite></h3>
          <p>These are the contents of file <cite>kevin-bacon2.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="container_gen_expected">
          <h3><cite>container_gen.expected</cite></h3>
          <p>These are the contents of file <cite>container_gen.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="king_ordering_cpp">
          <h3><cite>king_ordering.cpp</cite></h3>
          <p>These are the contents of file <cite>king_ordering.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="stoer_wagner_cpp">
          <h3><cite>stoer_wagner.cpp</cite></h3>
          <p>These are the contents of file <cite>stoer_wagner.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_basics_cpp">
          <h3><cite>edge_basics.cpp</cite></h3>
          <p>These are the contents of file <cite>edge_basics.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dag_shortest_paths_cpp">
          <h3><cite>dag_shortest_paths.cpp</cite></h3>
          <p>These are the contents of file <cite>dag_shortest_paths.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="incremental_components_expected">
          <h3><cite>incremental_components.expected</cite></h3>
          <p>These are the contents of file <cite>incremental_components.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="remove_edge_if_undir_cpp">
          <h3><cite>remove_edge_if_undir.cpp</cite></h3>
          <p>These are the contents of file <cite>remove_edge_if_undir.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bucket_sorter_cpp">
          <h3><cite>bucket_sorter.cpp</cite></h3>
          <p>These are the contents of file <cite>bucket_sorter.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="data2_txt">
          <h3><cite>data2.txt</cite></h3>
          <p>These are the contents of file <cite>data2.txt</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="target-compile-costs_dat">
          <h3><cite>target-compile-costs.dat</cite></h3>
          <p>These are the contents of file <cite>target-compile-costs.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="roget_components_cpp">
          <h3><cite>roget_components.cpp</cite></h3>
          <p>These are the contents of file <cite>roget_components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dave_cpp">
          <h3><cite>dave.cpp</cite></h3>
          <p>These are the contents of file <cite>dave.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo_sort_expected">
          <h3><cite>topo_sort.expected</cite></h3>
          <p>These are the contents of file <cite>topo_sort.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="fibonacci_heap_cpp">
          <h3><cite>fibonacci_heap.cpp</cite></h3>
          <p>These are the contents of file <cite>fibonacci_heap.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="ordered_out_edges_expected">
          <h3><cite>ordered_out_edges.expected</cite></h3>
          <p>These are the contents of file <cite>ordered_out_edges.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="grid_graph_example_cpp">
          <h3><cite>grid_graph_example.cpp</cite></h3>
          <p>These are the contents of file <cite>grid_graph_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="print-adjacent-vertices_cpp">
          <h3><cite>print-adjacent-vertices.cpp</cite></h3>
          <p>These are the contents of file <cite>print-adjacent-vertices.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="biconnected_components_cpp">
          <h3><cite>biconnected_components.cpp</cite></h3>
          <p>These are the contents of file <cite>biconnected_components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="eccentricity_cpp">
          <h3><cite>eccentricity.cpp</cite></h3>
          <p>These are the contents of file <cite>eccentricity.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge-iter-constructor_cpp">
          <h3><cite>edge-iter-constructor.cpp</cite></h3>
          <p>These are the contents of file <cite>edge-iter-constructor.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="print-out-edges_cpp">
          <h3><cite>print-out-edges.cpp</cite></h3>
          <p>These are the contents of file <cite>print-out-edges.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bfs-example2_cpp">
          <h3><cite>bfs-example2.cpp</cite></h3>
          <p>These are the contents of file <cite>bfs-example2.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="parallel-compile-time_cpp">
          <h3><cite>parallel-compile-time.cpp</cite></h3>
          <p>These are the contents of file <cite>parallel-compile-time.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="strong_components_expected">
          <h3><cite>strong_components.expected</cite></h3>
          <p>These are the contents of file <cite>strong_components.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_basics_expected">
          <h3><cite>edge_basics.expected</cite></h3>
          <p>These are the contents of file <cite>edge_basics.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graphviz_cpp">
          <h3><cite>graphviz.cpp</cite></h3>
          <p>These are the contents of file <cite>graphviz.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edmonds-karp-eg_cpp">
          <h3><cite>edmonds-karp-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>edmonds-karp-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kevin-bacon2_dat">
          <h3><cite>kevin-bacon2.dat</cite></h3>
          <p>These are the contents of file <cite>kevin-bacon2.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="test-astar-cities_dot">
          <h3><cite>test-astar-cities.dot</cite></h3>
          <p>These are the contents of file <cite>test-astar-cities.dot</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kruskal_expected">
          <h3><cite>kruskal.expected</cite></h3>
          <p>These are the contents of file <cite>kruskal.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="minimum_degree_ordering_cpp">
          <h3><cite>minimum_degree_ordering.cpp</cite></h3>
          <p>These are the contents of file <cite>minimum_degree_ordering.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="iteration_macros_cpp">
          <h3><cite>iteration_macros.cpp</cite></h3>
          <p>These are the contents of file <cite>iteration_macros.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="leda-concept-check_cpp">
          <h3><cite>leda-concept-check.cpp</cite></h3>
          <p>These are the contents of file <cite>leda-concept-check.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="cc-internet_cpp">
          <h3><cite>cc-internet.cpp</cite></h3>
          <p>These are the contents of file <cite>cc-internet.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_coloring_cpp">
          <h3><cite>edge_coloring.cpp</cite></h3>
          <p>These are the contents of file <cite>edge_coloring.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bipartite_example_cpp">
          <h3><cite>bipartite_example.cpp</cite></h3>
          <p>These are the contents of file <cite>bipartite_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dave_expected">
          <h3><cite>dave.expected</cite></h3>
          <p>These are the contents of file <cite>dave.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="prim-example_cpp">
          <h3><cite>prim-example.cpp</cite></h3>
          <p>These are the contents of file <cite>prim-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="straight_line_drawing_cpp">
          <h3><cite>straight_line_drawing.cpp</cite></h3>
          <p>These are the contents of file <cite>straight_line_drawing.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="read_graphviz_cpp">
          <h3><cite>read_graphviz.cpp</cite></h3>
          <p>These are the contents of file <cite>read_graphviz.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="adjacency_matrix_cpp">
          <h3><cite>adjacency_matrix.cpp</cite></h3>
          <p>These are the contents of file <cite>adjacency_matrix.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow_dat">
          <h3><cite>max_flow.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kevin_bacon_expected">
          <h3><cite>kevin_bacon.expected</cite></h3>
          <p>These are the contents of file <cite>kevin_bacon.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="put-get-helper-eg_cpp">
          <h3><cite>put-get-helper-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>put-get-helper-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="components_on_edgelist_expected">
          <h3><cite>components_on_edgelist.expected</cite></h3>
          <p>These are the contents of file <cite>components_on_edgelist.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="property_iterator_cpp">
          <h3><cite>property_iterator.cpp</cite></h3>
          <p>These are the contents of file <cite>property_iterator.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="simple_planarity_test_cpp">
          <h3><cite>simple_planarity_test.cpp</cite></h3>
          <p>These are the contents of file <cite>simple_planarity_test.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="kevin-bacon2_cpp">
          <h3><cite>kevin-bacon2.cpp</cite></h3>
          <p>These are the contents of file <cite>kevin-bacon2.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_property_expected">
          <h3><cite>edge_property.expected</cite></h3>
          <p>These are the contents of file <cite>edge_property.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="makefile-target-names_dat">
          <h3><cite>makefile-target-names.dat</cite></h3>
          <p>These are the contents of file <cite>makefile-target-names.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="quick-tour_cpp">
          <h3><cite>quick-tour.cpp</cite></h3>
          <p>These are the contents of file <cite>quick-tour.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="mean_geodesic_cpp">
          <h3><cite>mean_geodesic.cpp</cite></h3>
          <p>These are the contents of file <cite>mean_geodesic.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bfs_expected">
          <h3><cite>bfs.expected</cite></h3>
          <p>These are the contents of file <cite>bfs.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <!-- figs/ -->

        <section id="exterior_properties_cpp">
          <h3><cite>exterior_properties.cpp</cite></h3>
          <p>These are the contents of file <cite>exterior_properties.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="exterior_properties_expected">
          <h3><cite>exterior_properties.expected</cite></h3>
          <p>These are the contents of file <cite>exterior_properties.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bfs-example_cpp">
          <h3><cite>bfs-example.cpp</cite></h3>
          <p>These are the contents of file <cite>bfs-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo-sort-with-leda_cpp">
          <h3><cite>topo-sort-with-leda.cpp</cite></h3>
          <p>These are the contents of file <cite>topo-sort-with-leda.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="filtered-copy-example_cpp">
          <h3><cite>filtered-copy-example.cpp</cite></h3>
          <p>These are the contents of file <cite>filtered-copy-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_connectivity_cpp">
          <h3><cite>edge_connectivity.cpp</cite></h3>
          <p>These are the contents of file <cite>edge_connectivity.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow8_dat">
          <h3><cite>max_flow8.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow8.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="strong-components_cpp">
          <h3><cite>strong-components.cpp</cite></h3>
          <p>These are the contents of file <cite>strong-components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="scaled_closeness_centrality_cpp">
          <h3><cite>scaled_closeness_centrality.cpp</cite></h3>
          <p>These are the contents of file <cite>scaled_closeness_centrality.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="boost_web_dat">
          <h3><cite>boost_web.dat</cite></h3>
          <p>These are the contents of file <cite>boost_web.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bellman-ford-internet_cpp">
          <h3><cite>bellman-ford-internet.cpp</cite></h3>
          <p>These are the contents of file <cite>bellman-ford-internet.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bron_kerbosch_clique_number_cpp">
          <h3><cite>bron_kerbosch_clique_number.cpp</cite></h3>
          <p>These are the contents of file <cite>bron_kerbosch_clique_number.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow3_dat">
          <h3><cite>max_flow3.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow3.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="concept_checks_expected">
          <h3><cite>concept_checks.expected</cite></h3>
          <p>These are the contents of file <cite>concept_checks.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="leda-graph-eg_cpp">
          <h3><cite>leda-graph-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>leda-graph-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="data1_txt">
          <h3><cite>data1.txt</cite></h3>
          <p>These are the contents of file <cite>data1.txt</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="connected_components_expected">
          <h3><cite>connected_components.expected</cite></h3>
          <p>These are the contents of file <cite>connected_components.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="makefile-dependencies_dat">
          <h3><cite>makefile-dependencies.dat</cite></h3>
          <p>These are the contents of file <cite>makefile-dependencies.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="file_dependencies_cpp">
          <h3><cite>file_dependencies.cpp</cite></h3>
          <p>These are the contents of file <cite>file_dependencies.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow4_dat">
          <h3><cite>max_flow4.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow4.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="reverse_graph_expected">
          <h3><cite>reverse_graph.expected</cite></h3>
          <p>These are the contents of file <cite>reverse_graph.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bfs_neighbor_cpp">
          <h3><cite>bfs_neighbor.cpp</cite></h3>
          <p>These are the contents of file <cite>bfs_neighbor.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="sloan_ordering_cpp">
          <h3><cite>sloan_ordering.cpp</cite></h3>
          <p>These are the contents of file <cite>sloan_ordering.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="min_max_paths_cpp">
          <h3><cite>min_max_paths.cpp</cite></h3>
          <p>These are the contents of file <cite>min_max_paths.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="vf2_sub_graph_iso_example_cpp">
          <h3><cite>vf2_sub_graph_iso_example.cpp</cite></h3>
          <p>These are the contents of file <cite>vf2_sub_graph_iso_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graph_as_tree_cpp">
          <h3><cite>graph_as_tree.cpp</cite></h3>
          <p>These are the contents of file <cite>graph_as_tree.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="two_graphs_common_spanning_trees_cpp">
          <h3><cite>two_graphs_common_spanning_trees.cpp</cite></h3>
          <p>These are the contents of file <cite>two_graphs_common_spanning_trees.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="prim-telephone_cpp">
          <h3><cite>prim-telephone.cpp</cite></h3>
          <p>These are the contents of file <cite>prim-telephone.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="boost_web_graph_expected">
          <h3><cite>boost_web_graph.expected</cite></h3>
          <p>These are the contents of file <cite>boost_web_graph.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="subgraph_expected">
          <h3><cite>subgraph.expected</cite></h3>
          <p>These are the contents of file <cite>subgraph.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dijkstra_expected">
          <h3><cite>dijkstra.expected</cite></h3>
          <p>These are the contents of file <cite>dijkstra.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="transpose-example_cpp">
          <h3><cite>transpose-example.cpp</cite></h3>
          <p>These are the contents of file <cite>transpose-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="matching_example_cpp">
          <h3><cite>matching_example.cpp</cite></h3>
          <p>These are the contents of file <cite>matching_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="interior_property_map_expected">
          <h3><cite>interior_property_map.expected</cite></h3>
          <p>These are the contents of file <cite>interior_property_map.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="strong_components_cpp">
          <h3><cite>strong_components.cpp</cite></h3>
          <p>These are the contents of file <cite>strong_components.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="knights_tour_cpp">
          <h3><cite>knights_tour.cpp</cite></h3>
          <p>These are the contents of file <cite>knights_tour.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="scc_dot">
          <h3><cite>scc.dot</cite></h3>
          <p>These are the contents of file <cite>scc.dot</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="max_flow9_dat">
          <h3><cite>max_flow9.dat</cite></h3>
          <p>These are the contents of file <cite>max_flow9.dat</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="weighted_matching_example_cpp">
          <h3><cite>weighted_matching_example.cpp</cite></h3>
          <p>These are the contents of file <cite>weighted_matching_example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="default-constructor_cpp">
          <h3><cite>default-constructor.cpp</cite></h3>
          <p>These are the contents of file <cite>default-constructor.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="edge_property_cpp">
          <h3><cite>edge_property.cpp</cite></h3>
          <p>These are the contents of file <cite>edge_property.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="astar_maze_cpp">
          <h3><cite>astar_maze.cpp</cite></h3>
          <p>These are the contents of file <cite>astar_maze.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="push-relabel-eg_cpp">
          <h3><cite>push-relabel-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>push-relabel-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="prob_network_graph">
          <h3><cite>prob_network.graph</cite></h3>
          <p>These are the contents of file <cite>prob_network.graph</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="graphviz_test_dot">
          <h3><cite>graphviz_test.dot</cite></h3>
          <p>These are the contents of file <cite>graphviz_test.dot</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="read_write_dimacs-eg_cpp">
          <h3><cite>read_write_dimacs-eg.cpp</cite></h3>
          <p>These are the contents of file <cite>read_write_dimacs-eg.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="topo_sort_cpp">
          <h3><cite>topo_sort.cpp</cite></h3>
          <p>These are the contents of file <cite>topo_sort.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="filtered_graph_expected">
          <h3><cite>filtered_graph.expected</cite></h3>
          <p>These are the contents of file <cite>filtered_graph.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="social_network_graph">
          <h3><cite>social_network.graph</cite></h3>
          <p>These are the contents of file <cite>social_network.graph</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs_parenthesis_cpp">
          <h3><cite>dfs_parenthesis.cpp</cite></h3>
          <p>These are the contents of file <cite>dfs_parenthesis.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="scc_cpp">
          <h3><cite>scc.cpp</cite></h3>
          <p>These are the contents of file <cite>scc.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="print-edges_cpp">
          <h3><cite>print-edges.cpp</cite></h3>
          <p>These are the contents of file <cite>print-edges.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="dfs_cpp">
          <h3><cite>dfs.cpp</cite></h3>
          <p>These are the contents of file <cite>dfs.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="isomorphism_cpp">
          <h3><cite>isomorphism.cpp</cite></h3>
          <p>These are the contents of file <cite>isomorphism.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="csr-example_cpp">
          <h3><cite>csr-example.cpp</cite></h3>
          <p>These are the contents of file <cite>csr-example.cpp</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="bcsstk01_rsa">
          <h3><cite>bcsstk01.rsa</cite></h3>
          <p>These are the contents of file <cite>bcsstk01.rsa</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="adjacency_list_expected">
          <h3><cite>adjacency_list.expected</cite></h3>
          <p>These are the contents of file <cite>adjacency_list.expected</cite>, which...</p>
          <pre></pre>
        </section>

        <section id="directed_graph_cpp">
          <h3><cite>directed_graph.cpp</cite></h3>
          <p>These are the contents of file <cite>directed_graph.cpp</cite>, which...</p>
          <pre></pre>
        </section>

      </section>

    </main>

  </body>

</html>
